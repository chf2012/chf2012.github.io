<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jimmy那些事儿</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-08T13:54:11.033Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jimmy_Cai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《乌合之众》读书笔记</title>
    <link href="http://yoursite.com/2018/08/08/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95&amp;%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86/30_%E8%A1%8C%E4%B8%BA%E5%BF%83%E7%90%86%E5%AD%A6/%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%5B%E6%B3%95%5D%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB.%E5%8B%92%E5%BA%9E_201807/"/>
    <id>http://yoursite.com/2018/08/08/阅读书籍/60_社会发展&amp;行为与心理/30_行为心理学/《乌合之众》读书笔记_[法]古斯塔夫.勒庞_201807/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2018-08-08T13:54:11.033Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《乌合之众》 - [法] 古斯塔夫.勒庞 | 《The Crowd》 Gustave Le Bon | 1895</strong></p>
<p><strong>01 【初始疑问与目的】</strong></p>
<ol>
<li>S：阅读《人生定位》之后，认识到他人的重要性。故了解他人在社会中的力量是如何产生影响的。</li>
<li>W：他人如何在社会/群体中产生影响</li>
</ol>
<p><strong>02 【作者关注的问题】</strong></p>
<ol>
<li>what：<u>个人在群体中会发生什么样的变化</u></li>
<li>作者的原文回答：<ul>
<li>群体的无意识行为代替了个人的有意识行为。</li>
</ul>
</li>
</ol>
<p><strong>03 【文章展开的方式】</strong></p>
<ol>
<li>文章脉络如何展开：</li>
<li>其他人的观点：</li>
<li>作为读者，你怎么看：</li>
</ol>
<p><strong>04 【对我的指导意义与行动】</strong></p>
<ol>
<li>对我生活与工作的指导意义：</li>
<li>准备具体怎么去做：</li>
</ol>
<p><strong>05 【总结回顾】</strong></p>
<ol>
<li>回答自己的问题：</li>
<li>作者简介与著作背景：</li>
<li>一句话概括：</li>
</ol>
<blockquote>
<p>总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。所以，做完读书笔记之后，重新再次思考；回答一下所有的问题。</p>
</blockquote>
<a id="more"></a>
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>群体的无意识行为代替了个人的有意识行为。</p>
<p>社会事实如此复杂，根本不可能全盘掌握或预见到它们的相互影响带来的后果。此外，可见的事实背后，有时还隐藏着成千种看不见的原因。可见的社会现象可能是某种巨大的无意识机制的结果，而这一机制通常超出了我们的分析范围。</p>
<blockquote>
<p>【解读】表述出真实社会/世界是非常复杂的，以致于我们根本无法系统、全面地去分析</p>
</blockquote>
<p>考虑事物虚幻的形状，</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《乌合之众》 - [法] 古斯塔夫.勒庞 | 《The Crowd》 Gustave Le Bon | 1895&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;01 【初始疑问与目的】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S：阅读《人生定位》之后，认识到他人的重要性。故了解他人在社会中的力量是如何产生影响的。&lt;/li&gt;
&lt;li&gt;W：他人如何在社会/群体中产生影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;02 【作者关注的问题】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;what：&lt;u&gt;个人在群体中会发生什么样的变化&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;作者的原文回答：&lt;ul&gt;
&lt;li&gt;群体的无意识行为代替了个人的有意识行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;03 【文章展开的方式】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文章脉络如何展开：&lt;/li&gt;
&lt;li&gt;其他人的观点：&lt;/li&gt;
&lt;li&gt;作为读者，你怎么看：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;04 【对我的指导意义与行动】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对我生活与工作的指导意义：&lt;/li&gt;
&lt;li&gt;准备具体怎么去做：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;05 【总结回顾】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回答自己的问题：&lt;/li&gt;
&lt;li&gt;作者简介与著作背景：&lt;/li&gt;
&lt;li&gt;一句话概括：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。所以，做完读书笔记之后，重新再次思考；回答一下所有的问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>快速阅读</title>
    <link href="http://yoursite.com/2018/07/08/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/40_%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB_%E6%95%B4%E7%90%86_20180708/"/>
    <id>http://yoursite.com/2018/07/08/阅读书籍/10_思维意识/40_学习方法/快速阅读_整理_20180708/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-10T02:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>S：在知乎上看到关于 “ 快速阅读 “ 的问题，然后提到说要 &lt; 消除内语 &gt;，即脑中的声音。让眼睛去读，而不是发声去读；但尝试几次之后，依然失败；同时，在《精进》一本书中提到关于学习，应该以 &lt; 自己的初始疑问为中心 &gt;，去阅读。<br>    另外，认识到快速阅读的重要性以及对今后的帮助，所有准备重新整理，并落实到行动</p>
<p>W：知晓快速阅读的核心观念，具体执行的方法，并落实到可执行的行为</p>
<p>整理快速阅读的核心与方法</p>
<a id="more"></a>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li></li>
</ol>
<p>去结合《精进》中提到的学习方法</p>
<blockquote>
<p>知乎问题：<a href="https://www.zhihu.com/question/24716960" target="_blank" rel="external">快速阅读该怎么学</a></p>
</blockquote>
<p><br></p>
<h2 id="观点一：确定作者关注的问题，并寻找答案"><a href="#观点一：确定作者关注的问题，并寻找答案" class="headerlink" title="观点一：确定作者关注的问题，并寻找答案"></a>观点一：确定作者关注的问题，并寻找答案</h2><blockquote>
<p>【思考】这个观点，是从作者为中心的角度去思考，旨在剖析文章；    </p>
<p>知乎 From 核聚</p>
</blockquote>
<h4 id="读书就是探索。"><a href="#读书就是探索。" class="headerlink" title="读书就是探索。"></a>读书就是探索。</h4><ol>
<li><p>目标1：<strong>确定作者在关注什么问题？</strong></p>
<ul>
<li><p>如果一本专著没有讨论任何问题，或者讨论了各种问题而没有突出的问题，那就算不上专著，只能是文集之类</p>
</li>
<li><p>很多情况下，&lt; 书名 &gt; 就是说明了关注的问题</p>
</li>
</ul>
</li>
<li><p>目标2：<strong>找出书中最关键的问题来回答这个问题</strong>，而且必须要找到书中的原话。而不是自己模糊的感觉。</p>
</li>
<li><p>目标3：针对这个问题，<strong>找出书中有没有提到其他不一样的、别人的观点？</strong></p>
</li>
<li><p>目标4：两者相比较，哪一方的观点更有道理？为什么？</p>
</li>
<li><p>目标5：自我思考；<strong>作为读者，你怎么看？</strong></p>
</li>
</ol>
<blockquote>
<p>这样读一本书，你未必会读得很快。但读书会变成福尔摩斯探案，<strong>围绕着核心问题，不断找线索、找证据，最终发现答案。</strong></p>
</blockquote>
<p>​    效果，完全可以用来写个书评，或者做个读书报告。细节部分，再根据主题内容做补充即可。若有其他需要，可以回头再查阅。这个方法可以用来速读，也可以精读。所谓精读，是对书的某一个章节，甚至一个段落，都可以用这种方式提问，挖掘到深刻的部分，并将问题、事实与概念在大脑中串起来。如果经常这么做，读书就会很快。因为同一领域的书，大部分内容都是重复的。</p>
<p>不适用的场景与书籍：</p>
<ol>
<li><p>太经典的书籍</p>
<ul>
<li>例如《道德经》；处处都是重点，处处都是核心；因为智慧已经被浓缩的不能再浓缩了。</li>
</ul>
</li>
<li><p>太专业的书籍</p>
<ul>
<li>例如《童年的秘密》、《纯粹理性批判》；有的书太深奥，一环扣一环；或者太专业，太深刻</li>
</ul>
</li>
<li><p>例如充斥着图表和公式的书，适合做工具书；或者深究</p>
</li>
</ol>
<p><br></p>
<h3 id="《如何阅读一本书》"><a href="#《如何阅读一本书》" class="headerlink" title="《如何阅读一本书》"></a>《如何阅读一本书》</h3><ol>
<li><strong>明确自己的阅读目的</strong>；消遣、获取信息、形成观点 <ul>
<li>“ 形成观点 “，你需要知道作者的想法和观点，并形成自己的观点，而且还要能够批判他人提出的观点，时刻注意想法的差异；这是训练批判性思维的一种方法，有利于形成自己的价值观；</li>
</ul>
</li>
<li><strong>基于你具体的初始问题，筛选有用的信息</strong>；本田直之先生所著的《杠杆阅读术》一书中，做过如下解释  “一本书里的重要内容占20%，再从其中抽取80%后，所提炼的要点只占16%。如果是200页的书，就只有32页是关键内容” 、</li>
<li><strong>找主题句。</strong><ul>
<li>主题句为段落第一句。</li>
<li>主题句为段落第二句。</li>
<li>主题句为段落最后一句。</li>
</ul>
</li>
</ol>
<blockquote>
<p>但我还是要请求你，假如读了之后觉得它们不合口味，那就把它们搁到一边吧，因为除非你能真正享受它们，否则读来也无用。<br>没有人有义务一定阅读诗歌、小说或其他可以归入纯文学类的作品。人一定是为了寻求乐趣而阅读，然而谁又能保证使某个人快乐的事物也一定会使其他人快乐呢！  From 毛姆</p>
</blockquote>
<p><br></p>
<h2 id="观点二：具体的阅读方法"><a href="#观点二：具体的阅读方法" class="headerlink" title="观点二：具体的阅读方法"></a>观点二：具体的阅读方法</h2><ol>
<li><p><strong>避免发声。出声阅读是影响阅读速度的重要因素。</strong>   <em>实验统计表明，朗读的速度最快每分钟只能达到200字，而默读每分钟可达800字左右，是朗读的4倍。因此，提高阅读首先要学会默读。默读的关键在于避免出声，有的人在读时虽然听不到有明显的出声现象，但是仔细观察会发现他的唇或舌在动，说明其阅读仍有不易觉察的潜在发声现象，这仍会影响到阅读的速度。在实际阅读训练中，要有意识地克服唇动、舌动的现象。</em></p>
<blockquote>
<p>即使有内语，也可以加快速度，快速阅读。</p>
<p>实际发现，还是很有帮助的。</p>
</blockquote>
</li>
<li><p><strong>减少注视点。</strong>   <em>阅读过程中，眼睛是以<u>快速眼跳运动</u>  的方式进行的。而眼跳运动的时间只占10%，而眼睛停留在各个注视点上停留的时间占90%。可见，眼睛不是靠眼跳的运动，而是通过眼跳过程中的 <u>注意停顿</u> 来获取信息的；这样，减少一行乃至一页文字中的注视点，也就相应使得视觉幅度扩大，每次眼停获得的信息增多，从而可以节省阅读时间，提高阅读的效率。</em></p>
</li>
<li><p>缩短眼停时间。</p>
</li>
<li><p><strong>避免回视；</strong>    <em>回视是指眼跳经过某一注视点后又重新返回。回视的次数越多，阅读的速度就会越慢。因此，必须努力克服回视的毛病。一般来说，回视的出现是由于注意力不够集中、阅读缺乏自信，总担心没有完全看清楚。要避免回视，就应从这些方面多加注意。</em></p>
</li>
</ol>
<blockquote>
<p>《博赞脑力训练手册》当中，作者已经做过大量研究。</p>
<p>阅读速度的提高并不会影响理解力，你不理解某个内容是因为你过去的知识储备不够。</p>
<p>你反复回读、复读是不会增强你的理解力的，反而会阻碍你对整篇文章的理解。 </p>
<p>文章是一个整体，中间出现一些不太明白的词，只要不影响你对主题的理解，你不理解也没有关系，直接顺下去读就可以了。 </p>
<p>只有<strong>当你的阅读速度影响了你对作品主旨的理解，降低了阅读的快感时，才需要调整</strong> </p>
</blockquote>
<p><br></p>
<blockquote>
<p>麦田星空    的回答</p>
</blockquote>
<ol>
<li><p><strong>用视觉输入代替逐字输入。</strong> </p>
<ul>
<li><em>很多人的阅读习惯是从左往右、从上往下，逐字逐行地读，这其实是效率最低下的阅读方式。</em> </li>
<li>阅读本身分为 <strong>阅和读</strong> 两个部分。阅，对应的动作是看，读对应的是听；<ul>
<li><strong>阅是视觉输入，就像你看一幅画一样，你不会从上往下从左往右按着顺序来看，你一眼瞄过去就能知道这是幅人物画还是风景画。</strong> </li>
<li>读，是听觉输入；你得按照一定的顺序描述才能把它还原成一幅画，既然看一段文字就像看一幅画，你一眼瞄过去就应该知道一幅画的内容，那就没必要逐字去读。 </li>
</ul>
</li>
</ul>
<blockquote>
<p>理解这一点很重要，所谓快速阅读，就是指快速地找出一段话的关键信息，直接跳过和忽略那些不重要的辅助信息。 </p>
</blockquote>
</li>
<li><p><strong>抓概念。</strong></p>
<ul>
<li><strong>没接触过的新概念</strong>；方法论也可以归为新概念；</li>
<li><strong>不够重视的旧概念</strong>；就是作者试图用自己的论证来说服你，让你了解自己以前的观念是错的，是具有片面性的，是可以重新解释的。 </li>
</ul>
</li>
<li></li>
</ol>
<h2 id="观点三：反对意见"><a href="#观点三：反对意见" class="headerlink" title="观点三：反对意见"></a>观点三：反对意见</h2><blockquote>
<p> Pierre  </p>
</blockquote>
<p>​    不要自学，因为关于快速阅读的训练基本都是骗人的；你的阅读速度取决于 <strong>1) 大脑的理解速度；  2) 你的专注程度</strong></p>
<p>​    前者基本由你对文字和概念的处理速度决定，可以通过多阅读和多了解阅读材料的相关知识来提到；后者可通过手指或笔 指引自己阅读来避免走神；</p>
<p>​    </p>
<blockquote>
<p><a href="http://daily.zhihu.com/story/8847840" target="_blank" rel="external">如何做到看英文不用在内心读出来？</a></p>
</blockquote>
<p>关于默读的形成机制和深层原理直到现在都还有争论，总的来说，它是人类大脑在阅读文字时的自然过程，学术界对默读一般有以下三种认识：</p>
<ol>
<li><strong>对看到的文字进行语音化处理（phonological coding，即默读）是在阅读行为最开始就会发生的，很有可能是在大脑获取单词含义这一过程中产生</strong>。</li>
<li><strong>默读是「大脑用来理解词汇」或者「理解词汇之后增强短期记忆、帮助理解、还原音韵和语调」的</strong>。这个或者代表学术界对此还有争议。</li>
<li><strong>默读是阅读过程的副产品，在高水平的阅读者中，默读是普遍存在的</strong>。</li>
</ol>
<p>一个有意思的知识：天生的聋哑人在阅读时也会进行默读这一过程。 </p>
<p>目前为止，还没发现有哪篇论文含有「默读会降低阅读速度」这一结果的。 </p>
<p>正常人英语母语阅读速度为每分钟 200~400 单词（对内容完全理解的前提下），而速读布道者则宣称可以通过<strong>消除默读</strong>的方式来通过<strong>视读</strong>（visual reading）来达到 700 单词每分钟以上的阅读速度。 </p>
<p>总的来说，教授得出了结论：<strong>所谓速读，不过是略读（skimming）罢了。</strong>略读谁都会，略得越多，读得越快，懂得越少罢了。 200~400 单词每分钟是<strong>充分理解全文</strong>的正常阅读速度。高于这个速度是完全可以做到的，只不过需要通过牺牲阅读效果 / 质量来达成罢了：读得越快，所能够理解的部分就越少。脱离对材料的实际理解程度（阅读效果）来一味追求阅读速度没有意义。 </p>
<blockquote>
<p>【总结】</p>
<ol>
<li>默读是正常现象，且不存在任何科学研究来表明，默认会降低阅读速度；</li>
<li>所谓速读，不过是略读；略读越多，读得越快，但懂得也越少</li>
<li>通过 手指或笔 指引来避免走神，只是帮助那些原本阅读速度低下的人回到正常水平；</li>
</ol>
<p>1460 </p>
</blockquote>
<p>看到有的人说，第一步要抑制脑中发音。这是完全错误的。说这话的人，严重怀疑他没练过！！！千万不要主动抑制发音！！！重要的事，说一遍！！！否则将完成严重的后果！！！ </p>
<h2 id="观点四：对于快速阅读的理解"><a href="#观点四：对于快速阅读的理解" class="headerlink" title="观点四：对于快速阅读的理解"></a>观点四：对于快速阅读的理解</h2><blockquote>
<p>Rainbow清浅</p>
</blockquote>
<p>快速阅读的概念应该分为2种：</p>
<ol>
<li>一种是阅读速度（理解速度），即每分钟阅读多少字</li>
<li>另一种是通过科学的方法用较少的时间掌握书中大部分的重点。 </li>
</ol>
<p>关于文字的阅读速度<strong>本质上是理解速度的问题，这取决于阅读对象的难易、逻辑结构、语言、对这类内容的认知度等。</strong>有很多快速阅读文字的训练方法，比如抑制默读则阅读记忆速度会更快、眼球跟着一个物体移动、甚至于说将文字像拍照一样摄入大脑，颇受人追捧，但是我之前看过不少分析<u>这些方法并不科学的文章，深以为然</u>。  <strong>要提升文字阅读速度还是要多看多练，自然就会提升了，无捷径。</strong></p>
<blockquote>
<p>不用轻信一些快速阅读的方法，要有自己的判断是否科学；</p>
</blockquote>
<p>个人是采用SQ3R阅读法，<strong>用较少的时间理解一本书中60%-80%的内容。</strong>这个方法也不是适用所有书籍的，像散文之类的还是仔细品味吧，这个快速阅读法比较适用于商业类、个人提升类的书籍。 </p>
<p><strong>01 | 纵览全局</strong></p>
<ol>
<li>书名和副标题、目录、作者介绍、推荐、自序，第一页和最后一页，先快速看一遍这些内容，对整本书的结构内容、作者精通的领域、整本书最大的特色和价值所在有个直观的了解。 </li>
<li>之后拿一张纸写下问题，比如通过这本书来解答什么疑惑，书中的知识能解决什么问题等，带着问题找答案总是会更容易集中精神。 </li>
</ol>
<blockquote>
<p>通过纵览全局，<strong>确定几个问题；例如作者写作的背景、作者关注的问题，等（这些问题后续总结）</strong></p>
</blockquote>
<p><strong>02 | 关键点扫读</strong> </p>
<p>浏览粗体字、段落开头、段落结尾，<strong>并将重点内容标记出来。</strong> </p>
<p><strong>03 | 建立框架</strong> </p>
<p>完成关键点扫读后将还能记得的内容建成一个框架（我是手绘逻辑图的，觉得顺手的方法就好），这时候会有很多东西不记得，没关系，这是很正常的情况，将记得的内容梳理完后，再通过快速浏览一遍关键点将框架补全即可。</p>
<p><strong>04 | 重新阅读</strong></p>
<p><strong>采用何种方式，阅读哪些内容，我一般根据时间和目的来决定的。</strong></p>
<p>比如说，我在做关于定位概念的主题阅读，那我在建立出框架后，就只阅读关于定位的内容，其余都忽略，留待之后有需求的时候再阅读。</p>
<p>如果我是想完整地阅读这本书，那我会从关键点中挑选我不明白和感兴趣的内容来精读，其余的则扫读带过。</p>
<p><strong>不管采用何种方式，重点都需要标记出来。</strong></p>
<p> <strong>05 | 回忆&amp;记录</strong></p>
<p>在阅读完一个关键点或者章节后，用自己的语言将关键信息填充到框架中。填充完成后再回顾一下标注的重点，查漏补缺。方法根据自己的习惯，思维导图、手写、手绘、大纲都可以。</p>
<p><strong>06 | 回顾</strong></p>
<p>在完善框架之后，其实一份读书笔记就已经完成了，之后隔一段时间把读书笔记拿出来温故一下，有利于记忆及运用。</p>
<p>————————–分割线——————————–</p>
<blockquote>
<p>sting</p>
</blockquote>
<p>很多人在说，干嘛要快速阅读？应该找一本好书精读。</p>
<p>我的理解，<strong>快速阅读就是根据自己的需要来找信息和读书的一个策略。</strong>为了从海量的知识库中能够迅速找到自己想要的知识，我们往往使用搜索引擎找文章。</p>
<p>在此过程中，找到值得精读和练习的书，还是需要精读。 </p>
<blockquote>
<p>对于快速阅读，他的理解也是为了快速定位所需的内容，而不是增加阅读速度；是基于一定目的的阅读；</p>
</blockquote>
<p><strong>正确的速读方法：眼睛每一次停顿时，尽量同时多看几个字。不要逐字阅读，不要回读，不要复读。</strong> </p>
<p><strong>初期训练时候，可以用手指指示</strong>，实验表明，跟着手指运动，眼睛更加放松、更加高效。 </p>
<p>大脑中一定要有目的性，这样才能快速扫描和迅速记忆。 </p>
<h2 id="观点五：不同的阅读速度"><a href="#观点五：不同的阅读速度" class="headerlink" title="观点五：不同的阅读速度"></a>观点五：不同的阅读速度</h2><p>我把读书分为<strong>悟读、精读和泛读</strong>。</p>
<ol>
<li><strong>所谓悟读，就是认真领悟，一句一句认真理解和阅读，最后甚至通过反复阅读背诵出来。这样阅读的范围一定是顶级经典著作，是对人类文明和智慧带来重大价值的著作。</strong> <em>今天我们已经不一定非要把四书五经都背出来，但像《论语》《中庸》《孟子》这样的内容依然值得深度理解，并把极好的内容背下来。这一类著作有很多，像《老子》《庄子》《孙子兵法》，以及一些宗教经典，都可以列入这类。读这样的书，一天只要读一段就行，要反复咀嚼反复朗读，直到有所领悟方可罢休。拿起这样的书，先必须凝神屏息，心态保持宁静，不能有杂念和烦恼留在心里。</em></li>
</ol>
<ol>
<li><strong>所谓精读，就是碰到你特别喜爱的书，在文笔上、知识上、思想上、高度上都有启示的图书，就可以多读几遍。 </strong>   <em>比如我把马尔克斯的《百年孤独》读了四到五遍，书中魔幻现实主义的描写、文笔的流畅、人物命运的描述，都让我有爱不释手的感觉。阿来的《尘埃落定》我也读了三遍，文笔铺陈上和《百年孤独》有类似的手法。岳南的《南渡北归》厚厚三本书百万字，我也阅读了两遍，对于一代知识分子的命运总是心有戚戚然，久久不能释怀，拿起了放下，放下了再拿起来。一个人一生，总应该有十本左右的书是反复阅读的，通过深度阅读，提升自己的情感度和智慧度。在我前面一个月介绍的几十本书里，《通向常识之路》就是值得大家读第二遍的书。</em></li>
</ol>
<ol>
<li><p><strong>所谓泛读，就是泛泛阅读。我认为世界上大部分的书，泛泛阅读就可以了，主要是为了增加自己知识的广度和思维的宽度。</strong> 我拿到一本新书，一般都会先随意从中抽取几页阅读，如果读出点感觉，就会从头往后顺序翻阅，<strong>凡是觉得罗嗦不值得花时间的地方，眼睛就扫过去，凡是需要认真阅读的段落，就放慢速度仔细阅读。</strong>有的时候读到好的地方，也会用笔做标志，这样读完了可以把重点再读一遍。这样的阅读，我的速度大概每分钟一页左右，一半300页左右的书4个小时左右读完。这次读书活动我为大家介绍的书，大部分都在泛读之列。这也是为什么我能够每天给大家介绍一本书的原因。但泛泛阅读也不是读过就算，书中如果有给你灵感和思考的地方，依然要重点标注出来，或者扫描存档，以备以后学习和引用。</p>
<blockquote>
<p>根据不同的内容，进行选择；凡是觉得不重要的地方直接扫过去就行；凡是需要认真阅读的段落，就一定要放慢速度仔细阅读。</p>
</blockquote>
</li>
</ol>
<h2 id="观点六：读书目的"><a href="#观点六：读书目的" class="headerlink" title="观点六：读书目的"></a>观点六：读书目的</h2><p><strong>一、要确定读书的目的，根据读书目的的不同要有不同的方法。</strong> </p>
<p> <em>曾看过一篇网上的文章，说林志颖带Kimi参加法国图书节最终被劝退。为什么呢？不是因为Kimi不认真，而是因为他太认真了。认真到废寝忘食专注读书，读得还很快，难道这不好吗？是的，组委会认为一点都不好，他们认为这种一心只为得奖的做法有违读书节的初衷。读书是为了让自己沉浸于书中的世界充分享受读书的乐趣，而不是为了任何别的功利的目的。</em></p>
<p>但如果我们读的是商务类书籍，那么请一定带着目的去阅读。<strong>因为如果你读书是有目的的，你告诉自己的大脑要练习什么，寻找什么，那么在读书的时候你会更快地找到答案，从而使读书显得更高效。</strong> </p>
<p> <strong>二、阅读一本书不必头读到尾。</strong> </p>
<p>当我们第一次去一个陌生的很大的地方，比如公园，我们要做的第一件事是什么？对，找地图，地图能指引我们找到目标。同理，去一个新公司上任，首要的就是了解这个公司的组织架构，这一定是一个最好的开始。 </p>
<blockquote>
<p>有启发的对比与比喻；找地图是自己的习惯，但对于读书，却没有，需要反思；</p>
</blockquote>
<p>读书，也是如此。<strong>一本书的序言、目录、后记有助于我们最快地掌握全文概要</strong>，这样我们可以在有限地时间里抓住书的重点，在有限的生命里多读几本书。因为受各种因素的影响，就像二八定律所说，一本书中的重要内容不会超过20% </p>
<p><strong>三、一定要想办法将书弄脏。</strong> </p>
<p>建议用各种方式，<strong>如划线、记号、括号、折页、便利贴等自己独特的方式做标记来<u>打造一个自己专属的书籍</u>。</strong>这样的方式有助于我们对书的理解和记忆，是一笔很大的财富。 </p>
<p><strong>五、一年读多少本书不是关键，重要地是学以致用</strong> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S：在知乎上看到关于 “ 快速阅读 “ 的问题，然后提到说要 &amp;lt; 消除内语 &amp;gt;，即脑中的声音。让眼睛去读，而不是发声去读；但尝试几次之后，依然失败；同时，在《精进》一本书中提到关于学习，应该以 &amp;lt; 自己的初始疑问为中心 &amp;gt;，去阅读。&lt;br&gt;    另外，认识到快速阅读的重要性以及对今后的帮助，所有准备重新整理，并落实到行动&lt;/p&gt;
&lt;p&gt;W：知晓快速阅读的核心观念，具体执行的方法，并落实到可执行的行为&lt;/p&gt;
&lt;p&gt;整理快速阅读的核心与方法&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《人生定位》读书笔记_杰克.特劳特</title>
    <link href="http://yoursite.com/2018/07/01/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/10_%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/%E3%80%8A%E4%BA%BA%E7%94%9F%E5%AE%9A%E4%BD%8D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%9D%B0%E5%85%8B.%E7%89%B9%E5%8A%B3%E7%89%B9/"/>
    <id>http://yoursite.com/2018/07/01/阅读书籍/10_思维意识/10_思维方式/《人生定位》读书笔记_杰克.特劳特/</id>
    <published>2018-06-30T16:00:00.000Z</published>
    <updated>2018-08-08T13:44:26.076Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《人生定位》 - [美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 AI Ries &amp; Jack Trout | 2011.09</strong></p>
<p><strong>01 【初始疑问与目的】</strong></p>
<ol>
<li>S：近期比较焦虑，于是在知乎上翻看 “ 为什么越努力，越焦虑 “ 的讨论；其中看到一个观点说的是，&lt; 个人努力只是成功很小的一个要素，更大的成分在于外界 &gt;；并且提到了一本书《人生定位》；于是乎，就买了阅读；</li>
<li>W：真正去理解 &lt; 个人努力只是成功很小的一个要素，更大的成分在于外界  &gt; 这样的一个观点；做独立判断后，尝试改变自己的固有思维；把眼界向外看，而不是像之前一样一直向内看；</li>
</ol>
<p><strong>02 【作者关注的问题】</strong></p>
<ol>
<li>what：如何借助外力取得成功。不要一味地把重心放在自己的身上。</li>
</ol>
<p><strong>03 【文章展开的方式】</strong></p>
<ol>
<li>文章脉络如何展开：通过表达个人努力并不那么重要，引入外界因素的重要性，并进而引出几种不同风险的外界因素进行阐述。风险的高低，根据依赖自身的程度进行区分；越是依赖自身，风险就越高。</li>
<li>作者的原文回答：<strong>成功根本不是某种你能自发产生的结果，成功的关键是你能从别人那里获得什么。想要获得巨大的成功，你必须找到一匹可以驾驭的好马。</strong></li>
<li>其他人的观点：</li>
<li>作为读者，你怎么看：</li>
</ol>
<p><strong>04 【对我的指导意义与行动】</strong></p>
<ol>
<li>对我生活与工作的指导意义：<ul>
<li><strong><u>更加客观、全面地看待自己的努力所带来的成果，以及会更加注意外界的因素；</u></strong></li>
<li>观念的改变；不会说一定靠自己的能力去获取成功，而是更加全面、客观地看待所谓成功的这件事中其他因素的重要性。</li>
<li>对于今后孩子的教育，会让他明白倚靠他人是正常并且正确的行为，不要以此而感到羞愧</li>
</ul>
</li>
<li>准备具体怎么去做：</li>
</ol>
<p><strong>05 【总结回顾】</strong></p>
<ol>
<li>回答自己的问题：</li>
<li>作者简介与著作背景：</li>
<li>一句话概括：</li>
</ol>
<blockquote>
<p>总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。</p>
</blockquote>
<a id="more"></a>
<p><strong>成功根本不是某种你能自发产生的结果，成功的关键是你能从别人那里获得什么。</strong></p>
<h1 id="引言与伏笔"><a href="#引言与伏笔" class="headerlink" title="引言与伏笔"></a>引言与伏笔</h1><p>很多人认为努力工作、设定目标、相信自己才是成功之道。</p>
<blockquote>
<p>因为那些外在的因素太复杂，也难以把握，是脱离自身的；也没有人喜欢会说自己成功是因为靠外界因素，但可能真相恰恰如此。</p>
</blockquote>
<p>不要只盯着自己，你要看着外面。找到一匹好马，你的人生将会精彩纷呈。</p>
<p>我要做自己。” 我想去闯一闯，我要向自己证明，向外界证明，我可以成为一个大人物。我不要老爸的钱，也不需要他的贷款。 “ 这很正常，你每天都会听到有人这么说，尤其是孩子和青少年。有些人永远长不大，他们力争获取外在的成功，总想以此来证明自己的聪明与能干。</p>
<blockquote>
<p>现状：中国青少年也是如此，包括年轻人。突然觉得我们只是 &lt; 过度强化 &gt; 了自身的力量。</p>
<p>原因：1) 可能也是由于外界的因素本身不可控，2) 其次没有人喜欢把成功归因于外界。</p>
</blockquote>
<p>人在本应借助外力的时候，却要自己做。但是只靠自己是不可能获得成功的，<strong>是其他人使你成功。</strong></p>
<p><strong>如果你能把成功看做别人为你所做的事，而不是你为自己所做的事，你就不太可能陷入追逐成功的不安之中。</strong> 【态度】</p>
<h1 id="三种不同风险的赛马"><a href="#三种不同风险的赛马" class="headerlink" title="三种不同风险的赛马"></a>三种不同风险的赛马</h1><h2 id="高风险赛马"><a href="#高风险赛马" class="headerlink" title="高风险赛马"></a>高风险赛马</h2><blockquote>
<p>成功完全依靠自己。</p>
</blockquote>
<h3 id="努力型赛马-100：1"><a href="#努力型赛马-100：1" class="headerlink" title="努力型赛马 | 100：1"></a>努力型赛马 | 100：1</h3><p>最大的高风险赛马就是 &lt; 你自己 &gt;</p>
<p>成功人士往往努力工作，但并不等于说努力工作的人就能获得成功。</p>
<p>时刻记住，努力工作只是一个选项而已。</p>
<h4 id="智商型赛马-75：1"><a href="#智商型赛马-75：1" class="headerlink" title="智商型赛马 | 75：1"></a>智商型赛马 | 75：1</h4><p>智商与成功并无太大的关联。越聪明的人，越会依靠自己。</p>
<h4 id="教育型赛马-60：1"><a href="#教育型赛马-60：1" class="headerlink" title="教育型赛马 | 60：1"></a>教育型赛马 | 60：1</h4><p>记住，教育的作用只是让你进入比赛。凭学历不大可能让你的马跑得更快；[ 并不是说学历没有帮助 ] </p>
<h3 id="企业型赛马-50：1"><a href="#企业型赛马-50：1" class="headerlink" title="企业型赛马 | 50：1"></a><u>企业型赛马 | 50：1</u></h3><p><strong>著名的大企业是你职业生涯非常好的起点，只要它是一家合适的大企业。</strong> </p>
<p><strong>不要问你能为企业做什么，要为企业能为你做什么。</strong> </p>
<p>不管你多么聪明，<strong>把注压在一个输家身上是永远得不到回报的</strong>；如果有人竭力推荐你加盟一个输家，那么一定要给你实权职务，而且公司董事会要做出明确的变革来进行变革。（输家，指的是那些发展并不良好的企业）</p>
<p>那些最后在大企业工作的人发现，通往事业巅峰的道路很辛苦。有一个叫做 “99%法则”，即 因为拥有合适的品质，看上去也很杰出，而受雇的100人中，只有10个人能够升至中间管理层的职位，只有1个人能达到主管的层次；</p>
<p>残酷的现实是，<strong>对于成功来说，能力不是最重要的因素。</strong>企业并不是理性实体，<strong>不会为个人的最佳发展提供无尽的帮助。</strong>企业是那些试图超过他们竞争对手的各类人的组合。</p>
<blockquote>
<p>【思考】所以，不要 <strong>只</strong> 关注能力的提升；另外，让企业匹配你的发展阶段，而不是你去匹配企业；在这之前，必须要明白自己的道路以及所处的阶段；</p>
</blockquote>
<p>骑上企业型赛马的最佳时机是要趁早，而最好的企业型赛马就是<strong>领先行业里的领先企业</strong>；我们要去识别，尤其是对于下一个领先的行业。那下一个领先的行业是什么呢？在事实没有出现之前，没有人知道。这使得驾驭企业型赛马成为一场赌博。</p>
<p>为了增加你个人成功的概率，需要做的是从潜在企业清单上划掉那些绝对不是领先行业的候选机构。</p>
<blockquote>
<p>【共鸣】芒格的 反过来思考：想要成功，要首先知道哪些是不该做的事。</p>
</blockquote>
<p>大企业里，你不能太直率，你必须委婉、间接。你必须学会当一个政治家。<strong>你不能依靠自己的努力达到企业的高层，你必须依靠提拔。</strong> 谁来提拔你？<strong>别人。</strong> 这就是你想要在大企业有所成就就必须成为一个政治家的原因。<br><strong>把工作做好只是第一步，你必须找到一种方法，让别人知道你能够把工作做好。你的工作技能没有你的政治技能重要。</strong></p>
<blockquote>
<p>对于 &lt; 你的工作技能没有你的政治技能重要 &gt; 赞同一半；正常情况下，赞同一半；</p>
<p>但仔细思考，想的确如此；那些领导人并不一定是最能有能力的；一开始不赞同，只是不愿意接受这样的事实。、</p>
</blockquote>
<p>导师与保人；<br>导师通常年纪比你大，对你的事业有着个人的兴趣，给你提供免费的建议；<br>保人比导师更近一步，保人会提拔你，或者至少会利用他的影响力影响那些可以提拔你的人。</p>
<p>如果你在一家大企业工作，要问自己最重要的问题，不是” 我做得怎么样 “， 而是 “ 我的保人是谁 “ ;没有保人，你将停滞不前；</p>
<p>很多企业都有保密的 “ 高潜力 “ 员工名单。你在这名单里面吗，尽可能证实它。如果你不在这个名单上，那你需要继续跳槽；</p>
<blockquote>
<p>但有个悖论是，可能在一段时间之后，你才能成为 “ 高潜力 “ 名单中的人；所以，需要的是了解这个时间的周期，然后给自己一个时限</p>
</blockquote>
<p>所以，有两个选择 1) 进入” 高潜力 “名单 2) 离开该企业</p>
<p>企业的规模越大，缺乏合作精神的员工越可能在远没有达到高层之前就被清理出局。当你在一个大企业工作时，你必须不断展示<strong>你的忠诚</strong>，而不是你的才智。</p>
<blockquote>
<p>到了一定时间，企业更钟爱忠诚的员工，其次才会才智</p>
<p>认清现实与事实 “ 是什么 “，而不是 “ 应该是什么样子 “</p>
</blockquote>
<p><strong>【做一个耀眼的人】</strong><br>如果想觉得进步，就必须找到一种方法把自己展现给高级管理者；<strong>个人关系</strong>是你努力攀登企业阶梯的关键。 <em>加入你在通用电气工作了20年，韦尔奇本人并不认识你，那在该企业工作的你将不会有前景</em><br>你的老板知道你，你的老板的老板也很可能知道那你。但是你职位之上的第三人呢？你怎么才能引起这个人的注意？</p>
<blockquote>
<p>【行动】你可以不用特意去做这些事，但至少你要有这个意识；也认同这样的观念，接受这样的事实。</p>
</blockquote>
<p><strong>【做一名英雄】</strong></p>
<p>最简单、最直接的方法是<strong>让自己与你的企业推出的最耀眼、最激动人心的新产品或新服务联系在一起</strong>。</p>
<p>如果你获得了一个大露脸的机会，谨慎的开始这个工作，摸索两三个月，直到站稳脚跟。<strong>这种方法是错误的。</strong><br><strong>确保尽快采取强硬、大胆的行动才是正确的。</strong>在开始的100天内，你是 “ 防弹型 “ 。确保自己用正确的方法做正确的事情，特别是一些令人讨厌的事情 (例如关闭一家工厂、停产一系列产品或解雇员工) 给你委派工作的人在前两三个月里是不会解雇你的。这样的话，会给那个人带来不利影响。你可以自由行动，要了利用这点。</p>
<p>不要接受首席执行官视线之外的任何工作，这种任务都是死路一条。（例如，海外职务）</p>
<blockquote>
<p>关键是你是否想在这个企业长久地担任下去；若不是，这种经历对于以后的工作或许也不错。</p>
</blockquote>
<p><strong>当企业经营良好的时候，常常回从内部提拔人才，这个就是那些政治家或英雄接手的时候</strong>；但当经营不善时，内部人士是没有机会的，这时候需要新鲜血液。</p>
<p><br></p>
<h2 id="中风险赛马"><a href="#中风险赛马" class="headerlink" title="中风险赛马"></a>中风险赛马</h2><blockquote>
<p>成功部分依靠自己奋斗，部分借助外力；</p>
</blockquote>
<h3 id="才华型赛马-25：1"><a href="#才华型赛马-25：1" class="headerlink" title="才华型赛马 | 25：1"></a>才华型赛马 | 25：1</h3><p>想要成为创意达人，你需要的不仅仅是才华，<strong>还需要人们的认可。</strong> （后者才是真正的关键部分；那如何获取人们的认可呢？）</p>
<p><strong>创造性人才必须学会如何聆听观众的心声。观众希望他们怎样，他们就得去适应，而不是让观众来适应你。</strong><br>失败的人通常只关注自身内部的因素，他们不会倾听。</p>
<p>他们想当然地认为 “ 才华会得到施展 “，那那种才能给你的不过是一张彩票而已。才华型赛马要获得成功，几乎比其他任何类型的赛马都更需要外界的认可。</p>
<p><strong>你的问题的实质是外界的认可。</strong> 无论你是作家、画家、歌手、演员等角色，<strong>你都要把大部分时间用来寻找能够证明你创造力的外部专家。</strong></p>
<blockquote>
<p>全新的一个视角与概念；</p>
<p>【共鸣】想起之前看过的内容：畅销书的作家，并不一定是写文章做好的作家，但一定是懂得包装与倾听市场的作家；</p>
</blockquote>
<p>如果你只想做一个有才华的人，那就像 梵.高 那样，自顾自地把全部时间都用在你的艺术创作上；如果你想拥有才华并取得成功，那就需要花一点时间用于艺术创作，再花一点时间向他人推销自己。</p>
<p><strong>自我膨胀十有八九会成为你成功路上的绊脚石。人们都希望别人认可自己的创造力而不是推销能力。不妨问问自己，这真的有那么重要吗？</strong></p>
<blockquote>
<p>思维：关注结果；明白你真正想要的是什么。</p>
</blockquote>
<p>产品的外包装与产品一样重要，有时还比产品本身更重要。</p>
<h4 id="爱好型赛马-20：1"><a href="#爱好型赛马-20：1" class="headerlink" title="爱好型赛马 | 20：1"></a>爱好型赛马 | 20：1</h4><p>只有单纯地将其视作爱好而不是成功的方法。很明显，当你关注外在目标时，你的动机就不一样了。</p>
<h4 id="地利型赛马-15：1"><a href="#地利型赛马-15：1" class="headerlink" title="地利型赛马 | 15：1"></a>地利型赛马 | 15：1</h4><p>环境的选择。</p>
<h4 id="宣传型赛马-10：1"><a href="#宣传型赛马-10：1" class="headerlink" title="宣传型赛马 | 10：1"></a>宣传型赛马 | 10：1</h4><p>90%的人都不会独立思考，所以你完全可以骑着宣传型赛马一路登顶。</p>
<p>如果你打算骑上宣传型赛马，首先要给自己一个称号或主意。你必须下决心丢下各种资料，这样才能将焦点集中在一个主意或概念上。</p>
<h2 id="低风险赛马"><a href="#低风险赛马" class="headerlink" title="低风险赛马"></a>低风险赛马</h2><blockquote>
<p>成功完全取决于外力。</p>
</blockquote>
<h3 id="产品型赛马-5：1"><a href="#产品型赛马-5：1" class="headerlink" title="产品型赛马 | 5：1"></a><u>产品型赛马 | 5：1</u></h3><p><strong>认可他人的天赋几乎总是让人获得成功的关键。</strong> </p>
<blockquote>
<p>发现好的产品，关键是认可对方的产品/天赋；做一个能够识别机会的人。</p>
</blockquote>
<p>发明者 VS. 识别者  迄今发明的最成功的产品都没有给发明者带来足够的利益，但却让识别者发了大财。</p>
<p>你是否具有创新能力并没有那重要。即使你没有什么创新的天分，也同样可以跨上产品型赛马。关键在于你<strong>判别他人天分的能力。</strong></p>
<p>很多发明都是巧合，它们很大程度上取决于你是否能从发生的事情中领悟到什么。</p>
<p><strong>【警惕市场调研】</strong></p>
<blockquote>
<p>因为调研是基于过去&amp;现在的认知与经验，而新的产品是未来的。</p>
</blockquote>
<p>要留心，重要的产品创意的检验结果通常不会很好。有过一次调研，说到2000年计算机的应用数量只有1000台。那为什么要发明一种市场潜在规模如此之小的产品呢？</p>
<p>别小看了形象的重要性。等你有了钱，你或许仍然会为了声誉而工作。</p>
<p><strong>简单概念好于复杂概念。</strong></p>
<p><strong>【学会说：就这样了】</strong></p>
<p>有一个常态：通常人们在看到一个创意时，会说” 这个尝试很不；我来提几点建议吧 “ ；其实他们是在说，在跳上这匹马之前，先让我看看能否介入这个产品；<br><strong>这是个错误。</strong>当你找到一匹出色的产品型赛马时，先别急着让自己介入，把别人逼走。何不干脆先跳上去。为什么不说，” 就这样了，我们去骑一圈吧 “</p>
<p>你要改变的一切原因在于你试图让自己介入那个产品。忘记自己，要<strong>仅仅根据那是不是一匹骏马来评估产品。</strong></p>
<p><strong>【如果找不到产品，那就找出问题来】</strong>愤怒这一因素的占比越大，就越有可能带来某种可以赚钱的产品创意。不要抵御这种感觉，要让愤怒因素带领你走向解决自身问题的道路。</p>
<p>【你永远不会太年轻】<strong>要认识到，机遇永远比努力更稀缺。</strong></p>
<blockquote>
<p>若有机遇来临，不要说自己还没准备好；去尝试抓住他，因为努力这件事可以从这一刻开始，若失去了机遇，那是无法挽回的。</p>
</blockquote>
<p>【你永远不会太老】怀着一颗开放的心态看待生活，你就永远不会太老。</p>
<p>【媒体炒作】<strong>你要明白媒体大肆宣传的并不是新产品的潜力，而是宣传者的声望。</strong> （通用公司推出Saturn汽车被媒体大肆报道，仅仅只是因为是通用公司推出的）</p>
<p><br></p>
<h3 id="创意型赛马-4：1"><a href="#创意型赛马-4：1" class="headerlink" title="创意型赛马 | 4：1"></a>创意型赛马 | 4：1</h3><p>你必须愿意面可笑的、有争议的创意，你也必须乐意逆潮流而行。</p>
<p><em>没有证据表明，人们普遍持有的观点就是正确的。</em></p>
<p>如果你无法把一个创意推销给自己，那么你就不大可能把它推销给其他人。并且，如果你不愿意把一生中大部分时间和资源用在这个想法上，那么其他人不大可能这么做。<strong>你不能用业余时间来骑创意型赛马。</strong></p>
<p>如果有一个好的创意来解决某个问题的一半，而不是思考一个周全的创意来解决整个问题，那么你的境况会好很多。</p>
<p><strong>千万不要把你的想法往你的上司桌上一丢，然后让他来决定是否实施。那样的话，就等于放弃了你的所有权。</strong> 你要对这个想法做出承诺，不管以哪种形式（备忘录、演示、非公开的会议），重要的是让企业管理层知道你才是这个想法的提出者。<br>若遇到反对意见，要表现得友好，要感谢他们的帮助，并且请他们<strong>以书面形式提交反对意见</strong>。（这一做法通常会阻止掉那些更加愚蠢的反对意见）<br>如有一些与你没有竞争关系的伙伴赞同你的想法，要确保他们提供相关的证明，<strong>让他们给个人给你写一份备忘录。</strong></p>
<h3 id="他人型赛马-3：1"><a href="#他人型赛马-3：1" class="headerlink" title="他人型赛马 | 3：1"></a><u>他人型赛马 | 3：1</u></h3><p>成功的关键总是依靠他人。即使你驾驭着一个可以让你走向巅峰的创意或产品，还是要依靠他人识别该创意或该产品的价值。</p>
<p><strong>你个人不能完成销售，要靠他人来购买。</strong></p>
<p><strong>你应该更多地审度你为之工作的那个人，而不是你为之共的那家公司。</strong> 他是否有前途？如果没有，那么谁有？要始终尝试为你所能找到最聪明的、最有能力的人工作。如果你的老板前途光明，那么很可能你也一样。<br>无论你相信与否，有些人喜欢为无能之人工作。原因是他们觉得，如果老板是个庸才的话，那他们就能鹤立鸡群，更能脱颖而出。但实际情况恰恰相反，<strong>高级管理层往往会认为整个团队都能力欠缺</strong>。 如果他们对某项工作有所不满，他们会把相关的每个人都剔除出局。</p>
<p>当你为一家大企业工作时，引起他人注意就意味着你已经成功了一半。</p>
<h4 id="伙伴型赛马-5：2"><a href="#伙伴型赛马-5：2" class="headerlink" title="伙伴型赛马 | 5：2"></a>伙伴型赛马 | 5：2</h4><h4 id="配偶型赛马-2：1"><a href="#配偶型赛马-2：1" class="headerlink" title="配偶型赛马 | 2：1"></a>配偶型赛马 | 2：1</h4><p>“ 我想做自己 “ 几乎是年轻一族的箴言（当你老一些的时候，你会意识自己可能错过了一个重要的机遇）</p>
<p><strong>不要让你的自我意识阻碍了你。</strong> 要记住，每个人都需要一匹马。</p>
<h3 id="家族型赛马-3：2"><a href="#家族型赛马-3：2" class="headerlink" title="家族型赛马 | 3：2"></a>家族型赛马 | 3：2</h3><p>只要对情况稍加分析，<strong>就不难看出能力之间的差异远小于所取得的成就方面的差异。</strong> 从实际情况来看，看不出家族出身的管理者和非家族出身的管理者之间在能力上有什么差异。</p>
<blockquote>
<p>【认知】对于成功来说，能力的差异可能是最微不足道的；虽然很让人寒心，但现实可能就是如此。</p>
</blockquote>
<p>然后，大多数的豪门子弟都希望凭借自己的能力开创一番天地，也许是处于自负心理，也许是因为公平意识。你需要知道的是，” 没有哪个人是独自一人取得成功的，每个人都需要一匹坐骑。 “ 反正你永远也不可能理直气壮地说，所有的一切都是单凭我自己完成的。所以不妨骑上那匹坐骑。<strong>真正的悲剧不在于孩子没有这种意识，而在于父母缺乏这种意识。 如果你是父母，请不要在家族企业里仅给孩子一个底层工作，而是要鼓励他们，理解他们。</strong></p>
<p><em>我想凭借自己的能力取得成功，而不是仅凭老板的儿子这一身份</em> ，这是一种健康的心理态度。但你要知道，没有人可以单凭自己取得成功。</p>
<p><strong>家族型赛马能帮你占据一个良好的起点，而良好的起点至少是成功的一半。</strong></p>
<p><br></p>
<h1 id="更换赛马"><a href="#更换赛马" class="headerlink" title="更换赛马"></a>更换赛马</h1><p>事实上，人人都安于现状。当然，每个人也都希望境况能更好一些，赚的钱更多一些，买更好的房子。<strong>我们都希望人生的曲线能够 &lt; 平稳地 &gt; 按照我的期望向上延伸。</strong></p>
<p><strong>但是 &lt; 变化 &gt;（而且常常是意外的变化） 才是人生取得极大成功的必要条件。</strong> 如果你稍有野心，那还不够。大多数人不曾接近过自己的真实潜力，这并不是因为努力不够，有时候甚至不是因为没有能力找到一匹坐骑，<strong>而是因为他们害怕变化</strong>。还是那句话，<strong>如果你总是做过去一直在做的事情，那么你就只能得到你惯常所得到的的东西。</strong></p>
<p>导致人们不肯更换坐骑的主要原因在于对未知事物的恐惧。人们抓住原有的不放，在于他们不能很好地应对新的尝试中所包含的不确定性。【但是，必须明白，你目前正在做的事，并没有给你带来想要的生活】</p>
<blockquote>
<p>【共鸣】《The Millionair Fastlane》 中提到停止你现在正在做的事情，因为它们并没有给那你带来成功。可能是时间不够，但更可能是这并不是正确的行为。</p>
</blockquote>
<p><strong>当你拥有工作的时候，你会停止搜索。你会专心于自己的职位、企业和晋升机会。</strong>你此时的策略是努力工作，这样也许他们会注意到。但你也就成了一匹被蒙上双眼的马，一门心思放在赢得比赛上。有些人在同样的赛道上奔跑了二十年，但成就甚微。那么他们会怎么做呢？他们会更努力。我们称之为 “ 掉队心理 “。 努力工作蒙蔽了你的头脑，它使你一直重复过去的老路。</p>
<p><strong>你可以变换策略，更改坐骑。但最难的一点往往在做出更换坐骑这个决定，而找到另一匹赛马反倒并不会很困难。</strong></p>
<p>When：何时更换？ 当你原来的工作不再充满乐趣的时候，你就应该寻找另一份工作。 你应该远在你的工作给你造成困扰之前，就应该抬腿走人。因为如果在目前境况还算乐观的时候这么做，那你就处于主动而非被动的地位。</p>
<p>问自己，” 从现在起，我打算在这家公司干5年吗？ “ 如果答案是，” 绝对如此 “，那么你已经找到自己的坐骑了，你应该全力以赴骑上它。但如果不是，你就应该着手去寻找另一匹坐骑。慢慢弄来，不要仓促行事。你现在的工作尚有乐趣可言，所以你还有一段缓冲时间，可以慢慢选择，而不是饥不择食地接受第一个上门的机会。</p>
<p>然后，<strong>你要记住，你要的不是一份工作，而是一匹赛马，</strong>这两者之间很很大的不同。<br>工作指的是一份职责、薪水、福利等相关的职位，而赛马指的是一种创意、产品或某个人。<br>当你接受某个工作岗位时，你就等于置自己于流水线之上，要求自己提供具体的服务。<br>当你骑上一匹赛马时，你等于是要<strong>与自身之外的某人或某事共命运。</strong> 你最终所做的事可能与你最初的期待完全不同。</p>
<p>当一个新兴行业兴起之时，大多数人都唯恐不及，因为他们在这个行业里毫无经验。但是不要忘了，其他人也一样。</p>
<p>在某人决定不把某份你想要的工作给你之后，如果你在旁边等待，你就给了他们再次拒绝你的机会。</p>
<p><br></p>
<h2 id="第二幕"><a href="#第二幕" class="headerlink" title="第二幕"></a>第二幕</h2><p>今天就是今天，今日的机遇不会出现在昨日的成功之中；</p>
<p>无论你多么聪明机智，你也不可能缔造成功，你只能寻找成功。</p>
<blockquote>
<p>【思考】如果你真正明白努力只是成功中微不足道的一个因素，那你就不会大胆到说要去再次创造成功。</p>
</blockquote>
<p>在首次成功的这片土壤上，唯一生长出来的是你个人的自大意识。</p>
<p>自负是一切 “ 第二幕 “ 公司灾难的根源。你也许必须向自己证明你确实能再次成功，但必须在向其他人证明。因为你曾经做到过一次，就已经证明了你的实力。</p>
<p><br></p>
<h2 id="借口，还是借口"><a href="#借口，还是借口" class="headerlink" title="借口，还是借口"></a>借口，还是借口</h2><p>事情的真相是，外面是一个广阔世界，而就机遇而言，它总会越来越大。</p>
<p>智力往往使人们把注意力集中在自己以及自己的世界观上。智力超群的人往往会对整个世界抱有不切实际的幻想</p>
<p>当你发现那匹可以带你到达顶峰的赛马时，不要犹豫。放弃你正在做的一切，因为你可能在也没有这样的机会了。</p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《人生定位》 - [美] 艾.里斯 &amp;amp; 杰克.特劳特 | 《Horse Sense》 AI Ries &amp;amp; Jack Trout | 2011.09&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;01 【初始疑问与目的】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S：近期比较焦虑，于是在知乎上翻看 “ 为什么越努力，越焦虑 “ 的讨论；其中看到一个观点说的是，&amp;lt; 个人努力只是成功很小的一个要素，更大的成分在于外界 &amp;gt;；并且提到了一本书《人生定位》；于是乎，就买了阅读；&lt;/li&gt;
&lt;li&gt;W：真正去理解 &amp;lt; 个人努力只是成功很小的一个要素，更大的成分在于外界  &amp;gt; 这样的一个观点；做独立判断后，尝试改变自己的固有思维；把眼界向外看，而不是像之前一样一直向内看；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;02 【作者关注的问题】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;what：如何借助外力取得成功。不要一味地把重心放在自己的身上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;03 【文章展开的方式】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文章脉络如何展开：通过表达个人努力并不那么重要，引入外界因素的重要性，并进而引出几种不同风险的外界因素进行阐述。风险的高低，根据依赖自身的程度进行区分；越是依赖自身，风险就越高。&lt;/li&gt;
&lt;li&gt;作者的原文回答：&lt;strong&gt;成功根本不是某种你能自发产生的结果，成功的关键是你能从别人那里获得什么。想要获得巨大的成功，你必须找到一匹可以驾驭的好马。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其他人的观点：&lt;/li&gt;
&lt;li&gt;作为读者，你怎么看：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;04 【对我的指导意义与行动】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对我生活与工作的指导意义：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;u&gt;更加客观、全面地看待自己的努力所带来的成果，以及会更加注意外界的因素；&lt;/u&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;观念的改变；不会说一定靠自己的能力去获取成功，而是更加全面、客观地看待所谓成功的这件事中其他因素的重要性。&lt;/li&gt;
&lt;li&gt;对于今后孩子的教育，会让他明白倚靠他人是正常并且正确的行为，不要以此而感到羞愧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;准备具体怎么去做：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;05 【总结回顾】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回答自己的问题：&lt;/li&gt;
&lt;li&gt;作者简介与著作背景：&lt;/li&gt;
&lt;li&gt;一句话概括：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>The Millionaire Fastlane</title>
    <link href="http://yoursite.com/2018/06/30/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/%E3%80%8AThe%20Millionaire%20Fastlane%E3%80%8B/%E3%80%8AThe%20Millionaire%20Fastlane%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_MJ.DeMarco/"/>
    <id>http://yoursite.com/2018/06/30/阅读书籍/10_思维意识/50_投资理财/《The Millionaire Fastlane》/《The Millionaire Fastlane》读书笔记_MJ.DeMarco/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2018-06-28T01:02:09.535Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《The Millionaire Fastlane》 - MJ.Demacro</strong></p>
<ol>
<li>S：目前正在焦虑，对于未来。此时需要重新思考，如何才能致富；所有，重新来回顾这篇文章；</li>
<li>W：力图改变一些自己的思维定势，然后列出一些具体的行为清单，去执行；</li>
<li>用一句话概括</li>
<li>启发</li>
</ol>
<a id="more"></a>
<p>## </p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《The Millionaire Fastlane》 - MJ.Demacro&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S：目前正在焦虑，对于未来。此时需要重新思考，如何才能致富；所有，重新来回顾这篇文章；&lt;/li&gt;
&lt;li&gt;W：力图改变一些自己的思维定势，然后列出一些具体的行为清单，去执行；&lt;/li&gt;
&lt;li&gt;用一句话概括&lt;/li&gt;
&lt;li&gt;启发&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《精进》读书笔记_采铜</title>
    <link href="http://yoursite.com/2018/05/19/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89/%E3%80%8A%E7%B2%BE%E8%BF%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%87%87%E9%93%9C/"/>
    <id>http://yoursite.com/2018/05/19/阅读书籍/10_思维意识/20_精要主义/《精进》读书笔记_采铜/</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2018-07-07T03:10:03.706Z</updated>
    
    <content type="html"><![CDATA[<p>《精进》_采铜</p>
<p>S：2018年初专研&lt; 精要主义 &gt;时一起购买的书籍</p>
<p>哪些有意义的启发</p>
<blockquote>
</blockquote>
<a id="more"></a>
<h2 id="时间之尺"><a href="#时间之尺" class="headerlink" title="时间之尺"></a>时间之尺</h2><blockquote>
<p>对待时间：收益半衰期 + 快工作慢生活；</p>
</blockquote>
<ol>
<li><p>一个人如何对待时间：茫然 VS. 焦虑 ； 过去 VS. 未来</p>
<blockquote>
<p>利用图形将这个概念画出来：用矩阵 、 用象限 去描述；</p>
</blockquote>
</li>
<li><p>认真对待对方；当你的孩子/朋友用真诚或严肃的态度向你提问时，无论该问题是否幼稚（该问题越是幼稚，你越应该打精神，由其是面对孩子的很多”幼稚”的问题时）；这个时候，放下你的轻浮。认真去对待；</p>
<blockquote>
<p>孩子：尊重</p>
</blockquote>
</li>
<li><p>向五年后的自己提问；解决远期、近期的冲突</p>
<ul>
<li>远期未来的视角：倾向于抽象、概括的方式去思考；所以，远期视角下的想法更多的是考虑这件事的价值和意义，而常常缺乏细节；</li>
<li>近期未来的视角：倾向于到具体的情景中去考虑；而同时人们倾向于做可行性高、容易实现的事情；</li>
</ul>
</li>
<li><p>【<strong>启发</strong>】<strong>当你想要不做一件事时，尽量提高完成它的难度，主动增加障碍；反之，若想要去改变一件事/完成一件事，就尽量排除触发的障碍；</strong></p>
<ul>
<li><em>比如删除电脑里所有的电影、游戏；剪断网线，把手机换成非智能机等；可能有的人会说，电影删了可以再下，等等；这个而方法有用吗？  <strong><u>有用</u></strong> 。因为虽然可能会反复出现，但这种反复会使得原来简单且惯常的行为变得更麻烦了，逃避的便利性减少了；</em></li>
</ul>
</li>
<li><p><strong>【新观点】收益半衰期</strong> （用矩阵、坐标轴来描述与记忆）[ 如同：真理都是简单的 ] </p>
<ul>
<li>收益值：这件事 <u>当下</u> 带给我的收益大小，可以是物质，也可以是精神层面的</li>
<li><strong>半衰期：这昂收益岁时间衰减的速度；</strong></li>
</ul>
<p><u>我们常常只关注到一件事情在发生时带给我们的即刻的好处，而忽略了这一好处是否可以持续下去，产生长期的效果；</u>只要不是短半衰期的事情，只要这个收益可以被累加，尽管去做；很多时间，我们难以选择，往往是并没有全面考虑的结果；</p>
<blockquote>
<p>【行动】可以用该概念来衡量一件事情</p>
</blockquote>
</li>
<li><p>时间管理，很多时候并没有真正解决问题；我们原本就因为快而痛苦，可时间管理却教我们如何更快；（想起《80/20法则》or《每周工作4小时》中提到，“我们不是时间不够用，而是对待时间的方式错了；” ）</p>
</li>
<li><p>我们无法预估未来发生的意外事件，而意外事件却恰恰频繁发生，扰乱人们的原定计划；但你必须意识到，我们所处的社会是”液态的”，是一个流动的世界，在这个世界里，一切都处于不确定性中；当一个原本预定的计划并没有完成时，我们往往会陷入自责之中；其实，更令人担心的是陷入这种自责之中无法自拔；</p>
</li>
<li><p><strong>工作要快，但生活要慢</strong></p>
<ul>
<li>尽可能慢的事情：与朋友共度闲暇时光、欣赏作品、<strong>自我反思（写总结时，往往太过仓促）</strong>、散步，不要方向、在完全安静的环境看一本书、</li>
<li>尽可能快的事情：完成常规的事务性工作</li>
</ul>
<blockquote>
<p>【共鸣】曾在其他书籍中也看到过这样的观点；</p>
<p>回想自己经常去外滩吹风发呆，其实就是一种慢生活的体验；</p>
</blockquote>
</li>
<li><p><strong>提升时间的使用深度</strong>；（同样是安排休闲时间，坐在电视机前来电视的&lt; 被动式休闲 &gt;所带给人的满足感，远不如从事一项自己喜欢的业务爱好所带来的满足感；所以，从闲暇中获得满足的程度取决于质量，而不是时间；）</p>
</li>
</ol>
<p><br></p>
<h2 id="寻找心中的“巴拿马”"><a href="#寻找心中的“巴拿马”" class="headerlink" title="寻找心中的“巴拿马”"></a>寻找心中的“巴拿马”</h2><blockquote>
<p>做出更好的选择：<strong>从终极目标出发：以人生最高目标作为第一原则；</strong></p>
</blockquote>
<ol>
<li>从终极目标出发：以人生最高目标作为第一原则；</li>
</ol>
<blockquote>
<p>【思考】你想要成为一个什么样的人，这是你必须想清楚的问题；人生中到底想要什么，追求什么。</p>
<p>做一个多维度的人，科学&amp;文学；（但显然，自己对文学著作不感兴趣）</p>
</blockquote>
<ol>
<li>隐含假设：<strong>[ 很多人痛苦不堪，可能就是因为陷在了他们置身认知范围内的某种假设；在你分析事物（自身或他人）时，试着问自己，对应这个情景它的隐含假设是什么，很可能就会豁然开朗。 ]</strong>  <ul>
<li>错误、狭隘的隐含假设往往会缩小你的备选；我们往往在做选择/做计划的时候，往往是站在当下，（潜意识中）某种假设的前提下进行的，但我们并没有觉察到。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【启发】对于隐含假设，是一个新的概念；</p>
<p>【行动】</p>
<ol>
<li>分析时，<strong>试着去找你的隐含假设</strong>；</li>
<li>请求他人/第三方的建议，往往能给出不同范围的选择（因为第三方的角度、经历与经验，与你完全是不同的，包括他的成长背景，所有必然会给你带来新的视角）</li>
</ol>
</blockquote>
<ol>
<li>目标悬置。斯坦福大学在2015年10月宣布开启了一项学制改革，将传统的集中在18-22岁区间的连续四年制改为终身多次进出学校的六年制学习。称之为 “开环大学”。</li>
</ol>
<blockquote>
<p>【思考】这样的方式，让你接触新的东西后，在回来；视角、态度会完全不一样。</p>
</blockquote>
<ol>
<li>人生是持续而反复的构造。</li>
<li>涉及情感、喜好等主观性特别强的选择时，最好的方法是聆听内心的声音。</li>
</ol>
<p><br></p>
<h2 id="即可行动"><a href="#即可行动" class="headerlink" title="即可行动"></a>即可行动</h2><blockquote>
<p>最有效的，是即可行动。</p>
<p>开始并完成一件事，比做好它更重要。因为只有开始了，才有机会把它做得更好。</p>
</blockquote>
<ol>
<li>“精益创业” 中提到 “最小化可行性产品”，指的是使用最少的资源、被最快制作出来的、可执行基本功能的、能被用户使用的试验性产品，创业者应该尽快把最小化可行性产品发布出去，然后根据用户使用它的反馈来进行优化。</li>
</ol>
<blockquote>
<p>【唤起】想起之前的文章提过的概念，这一方式最重要的是 &lt; 将其置于真实场景 &gt; 中；</p>
</blockquote>
<ol>
<li><p>一个人的 “最小可行性产品” 是什么？</p>
<ul>
<li>产品不是过程，而是结果</li>
<li>产品不是对原料、素材的简单堆积，而是对它们结构性的整合和组织</li>
<li>产品不是创造者锁在自己保险箱里的东西，而是能被其他人使用和体验的</li>
<li>产品能独立对世界产品影响</li>
<li>产品也是一种媒介</li>
</ul>
<p>​        比如在某家公司的工作经历不是产品，但基于工作经历写成的系统性<strong>总结报告</strong>可以算作产品；阅读一本书的经历不是产品，但对一本书深入、透彻分析的<strong>文章</strong>可以算作产品；拥有绘画技能不是产品，但使用这项技能创作的绘画作品可以算是产品；</p>
</li>
<li><p><strong>我们永远无法完全准备好。</strong> </p>
</li>
</ol>
<blockquote>
<p>事情一步一步来，不要总想着一步到位；包括工作、成家、旅行等</p>
</blockquote>
<ol>
<li>提前对要完成的任务进行有效的剖析，区分出 &lt; 容忍中断 &gt; 与 &lt; 无法容忍中断 &gt; 的部分，然后用可保证的<strong>相对完整的时间去进行那些 &lt; 无法容忍中断 &gt;</strong> 的部分；<strong>因为对于一些操作性的事情时，你并不会太介意被打断。</strong> （例如，你在寻找配图或调整字体时）</li>
<li>对不同认知类型的工作分层处理；<strong>即不要在不同认知类型的事情上来回切换。</strong>因为当在不同类型进行切换时，人需要重新进行调整，这样任务的转换损耗会比较大。<em>例如在本书的写作中，很多章节是配图的，如果按照一般顺序的写作手法，在写到需要用配图的地方，把文字停下来着手寻找配图，这样的方式其实是很损耗精力的。</em> 同时，<strong>集中处理同性质的工作。</strong> </li>
</ol>
<p><br></p>
<h2 id="怎样的学习，才能够直面现实-Key"><a href="#怎样的学习，才能够直面现实-Key" class="headerlink" title="怎样的学习，才能够直面现实 - Key"></a>怎样的学习，才能够直面现实 - Key</h2><blockquote>
<p>成为一个高段位的学习者</p>
<p>只有最后能够作用于现实的学习，才是唯一有效的学习。</p>
</blockquote>
<h3 id="找到一切学习的导向"><a href="#找到一切学习的导向" class="headerlink" title="找到一切学习的导向"></a>找到一切学习的导向</h3><ol>
<li><p>对问题的好奇、对答案的渴望，是驱动自我学习和探索的主要动力。</p>
<blockquote>
<p>学习，应该以学习者心中的问题为中心，让问题引导着我们去探求答案；</p>
</blockquote>
</li>
<li><p>不经提问的学习，一直存在于生活当中：</p>
<ul>
<li>订立计划；例如接下来两个星期看完《XXX》</li>
<li>实施学习；从头至尾观看一本书/一门课程，把其中认为重要的点摘取出来，并记成笔记</li>
<li>回顾和整理；对笔记进行整理，或者画一张思维导图，把书中的知识要点以整体的形式体现出来</li>
</ul>
<p>​        做到以上三点已经是比较优秀的学习者，但是在这个过程中<strong>占据 &lt; 中心位置 &gt; 的是编织好的教程/课程，是既成的已有知识，而不是你心中的困惑——那些待解的难题。</strong></p>
<p>​    以既成知识为核心的学习，学习者扮演的是 &lt; 吸纳者 &gt; 或 &lt; 搬运工 &gt; 的角色，<strong>他们把外部的知识经过消化后搬运到头脑内部，知识在传递过程中的精确性、完整性被认为是至关重要的，而学习者自身的心智，包括他原有的知识体系、方法、观点乃至困惑，却可以被搁置起来，不闻不问。</strong> </p>
<p>​    很多人没有思考过，”为什么要看这本书？” 因为大家都在推荐，因为它很热门，还是根本没有考虑过为什么，只是隐约觉得对自己有用？ 我在<strong>标注重点及记笔记的时候，是依据什么来判断哪些值得记、哪些不值得记？</strong>有没有有一个特定的标准还是只是凭借感觉？我在学完之后积累下来的知识，是不是还是不知道怎么用，<strong>而只是增加了一点点掌握知识的满足感？</strong></p>
</li>
</ol>
<blockquote>
<p>【反思】这也是自己的现状；</p>
<p>【行动】<strong>写下</strong>自己为什么看一本书/学习一门课，做一件是的<strong>触发场景，所要达到的目的</strong>，以及之后该有的<strong>可落实的行动</strong>（这一步很关键，能让你去反馈/检验 前面的整个过程，也能让你时刻牢记自己做这件事的原因与目的）。</p>
</blockquote>
<ol>
<li>打破新旧知识之前的通道；常思考的问题<ul>
<li>针对当前的材料，已经具备了哪些相关的知识？</li>
<li>针对当前的材料，学到了哪些新知识？这些新知识对缘由知识构成了何种补充与挑战？</li>
<li>针对当前的材料，还有哪些是未知的，并且通过简单探索就可以了解的？</li>
<li>针对当前的材料，哪些是未知的，且无法轻易获得，同时又有价值成为我长期去探索的问题？</li>
</ul>
</li>
<li>在没有问题引导时，可能我们常常只是零散的、随性地去涉猎学习材料，去捕获一些不相干的知识。这种学习结果是得到已按知识的砂砾。而在问题的牵引下的学习，则是连续地构筑着知识之网，使它们以一种有意义的方式连接在一起。</li>
</ol>
<blockquote>
<p>【共鸣】如同《地头力》中提到的，目标是一块磁铁，能够让你将力量往一个方向作用；</p>
</blockquote>
<h3 id="不只做信息的搬运工"><a href="#不只做信息的搬运工" class="headerlink" title="不只做信息的搬运工"></a>不只做信息的搬运工</h3><ol>
<li><p>通过解码，才能深入事物的深层。解码不等同于一般所说的理解。理解通常只涉及对字面意义的解读，常以自动化的方式进行，无需做太深入的思考，并且理解应遵从客体本身，不可擅自演化；而解码是一个更为主动和主观的过程，不同的解读对同一材料的解码可能是完全不一样的，就如果看一部电影不同的人看出不同的意味。</p>
</li>
<li><p>解码的基本规律<strong>（不同的人看待同一事物的角度是完全不同的）</strong></p>
<pre><code>在玩具店里看到 &quot;会说话的小黄鸭&quot;。
</code></pre><ol>
<li>在孩子眼中，他关心的是 “小黄鸭说了什么”，于是他听到的是儿歌、故事。即孩子关心的是<strong>最直接的信息。</strong></li>
<li>在家长眼中，他关心的是 “小黄鸭是什么”，首先会将其定义为一个玩具，然后对它的娱乐性、教育性、安全性进行评估；即家长关心的是<strong>价值和意义</strong></li>
<li>在玩具工程师眼中，他关心的是 “小黄鸭是怎么做出来的”，他会思考和设计小黄鸭有哪些功能，会想它的电路结构和声光效果；即工程师关心的是<strong>结构和实现</strong></li>
</ol>
<blockquote>
<p>不同的人，对于同一事物的关注点是完全不同的；而对于现在的我来说，要做的是不能只关注最直接的信息，而且要去关注背后的价值和意义。</p>
</blockquote>
</li>
<li><p>关于解码的入口</p>
<ul>
<li>不只要寻找结论，还要寻找过程；即我们不仅要知道结果是什么，还应该知道这个结果是如何得来的</li>
<li>不只要去做归纳，还要去做延伸；</li>
<li>不知要去比较相似，还要去比较不同</li>
</ul>
</li>
</ol>
<h3 id="技能，才是学习的终点"><a href="#技能，才是学习的终点" class="headerlink" title="技能，才是学习的终点"></a>技能，才是学习的终点</h3><blockquote>
<p>你能够调用的知识有多少？</p>
</blockquote>
<ol>
<li><p>基本的学习理念：你掌握了多少知识，并不取决于你记忆了多少知识，而是<strong>取决于你能调用多少知识</strong>。</p>
<ul>
<li><p>认知心理学研究表明，记忆提取的操作起到了 “记忆修改器” 的作用：一个曾经被调用过的知识，和从未调用过的知识相比，在今后更有可能被调用。”构成学习者思维独特性的并非是他所录入的观点序列，而是他有能力启动和调用的关联。”</p>
<ul>
<li>教育界中，发现以 <strong>&lt; 练习 &gt;</strong> 为主导的方法是有效性最高的。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因此，要做的是主动的知识点的回想与调起，而不是被动的去看之前记录的东西。</p>
<p>正如之前自己做过的  Anki</p>
</blockquote>
</li>
<li><p>求知分为三个层级：信息、知识、技能</p>
<ul>
<li>最差的学习者：接受信息</li>
<li>好一点的学习者：看重知识，以记忆为目标</li>
<li>更高层次的学习者：磨炼技能</li>
</ul>
<blockquote>
<p>技能是终点，信息与知识只是迈向这个终点的路与桥</p>
</blockquote>
</li>
<li><p>分离的知识，难以解答真正的现实。因为显示是各种复杂的集合体。</p>
</li>
</ol>
<p><br></p>
<h2 id="修炼思维，向未知逼近"><a href="#修炼思维，向未知逼近" class="headerlink" title="修炼思维，向未知逼近"></a>修炼思维，向未知逼近</h2><blockquote>
<p>修炼思维</p>
</blockquote>
<ol>
<li><p>定期闭关，屏蔽外界干扰；说的是，<strong>每隔一段时间，给自己一个仪式，让自己去思考与回顾。</strong></p>
<ul>
<li>比尔盖茨每年都会抽出两个星期的时间闭关，也就是一个人呆在个地方，只看书和思考，不允许任何人去打扰他</li>
</ul>
</li>
<li><p>培养<strong>简洁表达</strong>的能力。 “好的写作的秘诀就是剥离每一句话中的杂物，只存留其最洁净的部分。每一个无用之词、每一个动词中已经表示其相同意思的副词、每一个使读者不知道谁在干什么的被动语态结构 —— 这些都是削弱句子力度的掺杂物。”</p>
</li>
<li><p><strong>一次只做一件事。</strong>  关于发散思维 和 收敛思维，重点在于它们两个是独立的阶段，而不应该把两者混在一起。</p>
<ul>
<li>发散思考的时候不要收敛思考，反之同理；</li>
</ul>
</li>
<li><p>图解思考。越是抽象的研究，图解思考所能发挥的作用可能越大。</p>
</li>
<li><p>文档创建不同的版本与副本是个好习惯</p>
<blockquote>
<p>【行动】：<strong>之后更重要的是去回顾各个版本，去回顾自己的思考过程。</strong></p>
</blockquote>
</li>
</ol>
<p><br></p>
<h2 id="努力，是一种最需要学习的才能"><a href="#努力，是一种最需要学习的才能" class="headerlink" title="努力，是一种最需要学习的才能"></a>努力，是一种最需要学习的才能</h2><blockquote>
<p>不断优化你的&lt; 努力 &gt;方式；努力本身就是一冲才能，努力需要有效的策略</p>
</blockquote>
<ol>
<li><p>努力本身就是一种才能。在努力这件事情上，除了自我激励，更应该思考：<strong>到底应该怎么努力，应该采取什么样的策略来投入自己的时间和精力，应该怎样有效的启动、维持和优化对一件事情的投入。</strong></p>
<blockquote>
<p>对于努力，去思考，去做计划；</p>
</blockquote>
</li>
<li><p>转变心智的方法：改变自己的语言习惯，把封闭的、绝对性的总结评价改为开放式的启发提问。 比如说，”我不擅长做这件事，” 改为 “要做成这件事，我还有哪些地方需要提高”； 不要说 “这件事我做不好”，而是说 “怎样才能把搞定”</p>
</li>
</ol>
<h3 id="发展自己的长项"><a href="#发展自己的长项" class="headerlink" title="发展自己的长项"></a>发展自己的长项</h3><ol>
<li><p>对于 “木桶理论”  的误区：”木桶理论” 最早是用来类比团队管理的。对一个团队来说，决定其绩效的是组织中最弱的那个成员。因为团队中每个人都有自己的分工，这些分工构成了结构紧密的整体，所以一旦哪个环节出了问题会影响整个团队的表现。</p>
<pre><code>但仔细思考，适用于团队的木桶理论正好推导出它并不适用于个人。因为如果一家公司笃信木桶理论，那么它就会要求所属的每一块木板就尽可能的长，而不会允许特别短的木板存在。也就是说，公司中的每个岗位都不容许能力平平的人，而是要求每个岗位都聘用能完全胜任的人。又由于现代社会分工的特点，大多数的岗位需要的技能一定是某一个领域的专长。（大企业如此，但对于小企业，可能未必）
很多人倾诉关于自己未来的职业迷茫，大部分并没有意识到**专注发展个人才能**的重要性。
</code></pre><blockquote>
<p>【启发】对于事件的触发场景，很重要；对于一些观点、知识及理论更是如此。</p>
</blockquote>
</li>
<li><p>通过与人合作来平衡自己的劣势，回避在很多不同方向上空耗精力。</p>
<blockquote>
<p>让专业的人去做专业的事情；不同的领域，可以去尝试了解，但目标不是精通；</p>
<p>T型人才，依然适用。</p>
</blockquote>
</li>
<li><p>学习的策略；<strong>花大部分时间专注于某个领域学习，拿出较小一部分时间做积极大胆的探索和尝试</strong>，以博取迎接”黑天鹅”事件的机会。例如，每天有10个小时的时间，根据20/80法则，其中8个小时专注于你的主业上，剩余2小时可以进行完全自由的学习，接触不同领域的知识，学习一些小而美的技能。</p>
</li>
</ol>
<p><br></p>
<h2 id="每一个成功者都是唯一的"><a href="#每一个成功者都是唯一的" class="headerlink" title="每一个成功者都是唯一的"></a>每一个成功者都是唯一的</h2><blockquote>
<p>创造成功，而不是复制成功</p>
</blockquote>
<ol>
<li><p>费曼给我的启示是，抽象的理论和生动的现实是可以没有边界的，如果有人觉得存在边界的话，恰是因为他的知识和思考尚不足以洞见两者深处的关联。</p>
</li>
<li><p>独特性是最好的竞争力。迈克尔波特说，<strong>“战略的意义是让你远离竞争，战略不是要你做得更好，而是让你做得不同。”</strong></p>
<blockquote>
<p>【共鸣】战略是让你远离竞争，而不是让你在竞争中胜出。后者，是策略要思考的事情。</p>
</blockquote>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《精进》_采铜&lt;/p&gt;
&lt;p&gt;S：2018年初专研&amp;lt; 精要主义 &amp;gt;时一起购买的书籍&lt;/p&gt;
&lt;p&gt;哪些有意义的启发&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《运营之光》读书笔记_黄有璨_201802</title>
    <link href="http://yoursite.com/2018/03/26/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/120_%E4%BA%92%E8%81%94%E7%BD%91%E8%BF%90%E8%90%A5/%E3%80%8A%E8%BF%90%E8%90%A5%E4%B9%8B%E5%85%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%BB%84%E6%9C%89%E7%92%A8_20180206/"/>
    <id>http://yoursite.com/2018/03/26/阅读书籍/120_互联网运营/《运营之光》读书笔记_黄有璨_20180206/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-04-01T10:46:05.671Z</updated>
    
    <content type="html"><![CDATA[<p><em>主题</em></p>
<p>阅于2018年2月6日</p>
<a id="more"></a>
<blockquote>
<p>S：当时一次产品会议以及之后对APP用户的课题分析，促使对运营的兴趣</p>
<p>W：了解产品运营是怎么样的；关注点是什么；</p>
</blockquote>
<p><br></p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ol>
<li><p>行业发展初期是产品为王，因为并没有对手；行业发展过程中是渠道为王，因为谁占领了渠道，谁就赢得了用户；但是在充分竞争的互联网领域，是运营决胜的；</p>
</li>
<li><p>如果产品不一样，”运营” 作为于产品的方式，肯定是不一样的；</p>
</li>
<li><p>三种同维度和层次的运用</p>
<ul>
<li>微观的运营：具体的运营手段；<em>比如如何做好一个活动，如何写好一篇推广文案；</em> 抽象一点看，一切运营的手段其实就是两个导向：<strong>1) 拉新、引流和转化； 2) 用户维系</strong></li>
<li>宏观的运营：<strong>N多具体的运营手段到底该如何被组织和串联起来，以便更好地作用于一款产品</strong>；关注运营的策略、规划和资源分配；</li>
<li>作为一种艺术而存在的运用</li>
</ul>
</li>
<li><p><strong>管理者的工作不是让大家去工作，而是去创造环境，让大家可以用顺利开展工作。——《人件》</strong>；其实运营也是在做类似的事情，运营或许不是非要把用户拉过来，<strong>而是要搭建和创造一个环境，让用户们可以更愿意来与你发生互动和玩耍。</strong></p>
<blockquote>
<p>【启发】管理的核心是创造环境，这个环境是能够发挥人的主观能动性的；</p>
</blockquote>
</li>
</ol>
<p><br></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol>
<li><p>国内互联网发展的3个阶段</p>
<ul>
<li>概念驱动时代；1995 ~2004；互联网刚刚起步，线上世界一片空白，大家对于什么是 “好产品” ，甚至怎么做产品都还没有什么认知；</li>
<li>产品驱动时代；2004 ~ 至今（2017年）；各类互联网产品更加重视 “用户体验” </li>
<li>运营驱动时代</li>
</ul>
</li>
<li><p><strong>整个行业的发展阶段和需求决定了现阶段整个行业对于研发和产品的刚性需求</strong>是更大的，整个互联网行业现在正处于一种爆发式增长和发展的阶段；但是你想干互联网或者做个网站和APP，第一步一定是先把产品做出来；如果产品都看不到，谈何运营？</p>
<blockquote>
<p>【启发】思考&amp;回顾 数据分析的历史、当前行业所处的阶段</p>
</blockquote>
<p>​</p>
</li>
</ol>
<p><br></p>
<h2 id="第1章-运营是什么"><a href="#第1章-运营是什么" class="headerlink" title="第1章 运营是什么"></a>第1章 运营是什么</h2><h3 id="运营的四大模块"><a href="#运营的四大模块" class="headerlink" title="运营的四大模块"></a>运营的四大模块</h3><blockquote>
<p>内容运营、用户运营、活动运营、产品运营、其他</p>
</blockquote>
<ol>
<li><p>内容运营；核心：<strong>围绕着内容的生产和消费搭建起来一个良性循环</strong>，持续提升各类跟内容相关的数据；如内容数量、内容浏览量、内容互动数、内容传播数；</p>
<ul>
<li><em>内容基础属性是什么（文字？图片？视频？）需要那种调性（搞笑？深度评论？）内容从哪里来（UGC？PGC？）</em></li>
<li><em>如何组织与呈现？如何更容易、更高频地被客户消费（标题怎么写？推送？频率？）</em></li>
</ul>
</li>
<li><p>用户运营；核心：<strong>围绕着用户的新增—留存—活跃—传播以及用户之间的价值供给关系建立起一个良性的循环</strong>，持续提升各类与用户有关的数据；如用户数、精英用户数、用户停留时间；</p>
<ul>
<li><em>用户从哪里来？（微博？豆瓣？地推？）如何落实（付费？渠道建设？销售？）</em></li>
<li><em>如何建立和维护与用户的关系（互动？反馈？礼物？）</em></li>
<li><em>如何让更多的用户愿意留下来玩（分析数据？关注留存？关注活动？激励体系设计？）</em></li>
<li><em>用户规模庞大时，如何对整个用户生态的影响与掌控（如何分类？不同用户如何服务和管理？不同类型用户之间的如何产生价值关系？）</em></li>
</ul>
</li>
<li><p>活动运营；核心：<strong>围绕着一个或一系列活动的策划、资源确认、宣传推广、效果评估等一系列流程做好全流程的项目推进、进度管理和执行落地。</strong>一个活动运营，必须先确定活动的目标，并持续跟踪活动过程中的相关数据，做好效果评估。</p>
</li>
<li><p>产品运营；核心：<strong>通过一系列不同的运营手段，去拉升某个产品的特定数据</strong>；如装机量、注册量、用户访问深度、访问频次、用户关系对数量、发帖量；</p>
</li>
<li><p>其他的集中运营：新媒体运营、APP商店推广运营、SEO/SEM运营、广告投放运营/流量运营、淘宝店铺运营、编辑、QQ群、小组运营；</p>
</li>
<li><p>不同业务类型的产品和公司</p>
<ul>
<li>工具类产品；注重效率和体验</li>
<li>社交/社区类产品；注重社交氛围、话题和玩法</li>
<li>内容类产品；持续做出独特、高质量的内容，并把这些内容包装好，让用户更易于消费</li>
<li>电商类产品；1) 商品和品类的运营，选择什么样的商品； 2) 促销活动的策划与落地； 3) 推广和流量建设； 4) 用户关怀和维系</li>
<li>平台类产品；特别注意 “节奏” ；即在不同的阶段，一定要确定合适的目标；</li>
<li>游戏类产品； 1) 推广； 2) 收入；</li>
</ul>
<blockquote>
<p>【意义】帮你去囊括已有的产品类型</p>
</blockquote>
</li>
</ol>
<p><br></p>
<h3 id="运营的职能"><a href="#运营的职能" class="headerlink" title="运营的职能"></a>运营的职能</h3><ol>
<li><p>用户参与构成了互联网产品核心价值的重要组成部分。</p>
<ul>
<li>传统价值产品 = 功能 + 体验</li>
<li><strong>互联网产品价值 = 功能 + 体验 + 用户参与价值</strong></li>
</ul>
</li>
<li><p>首先，任何一项业务，都存在三个不可或缺的要素：产品、用户、运营；其次，<strong>任何一个产品，只有在与用户发生关系之后，才具备价值；</strong> 再次，基于业务类型的不同，一款产品与用户间的关系类型会有很大的差异；（例如一次性关系、高频次等）</p>
</li>
<li><p>所谓运营，其实就是为了帮助产品与用户之间更好的<strong>建立关系</strong>，以及更好地<strong>维系住</strong>这种关系；最大的区别在于关系类型不同，运营的导向性也是完全不同的；因此，运营应当是大于&lt;营销、策划、文案、编辑、传播、用户管理&gt; 这些概念的总和。实际意义上的运营工作，应该更侧重于使用哪种运营手段，<strong>事实上取决于你的业务类型，以及你的产品和用户之间的关系。</strong></p>
<blockquote>
<p>【启发】因此，你必须明确你的业务类型、你的用户与你的产品之间的关系是什么 </p>
</blockquote>
</li>
</ol>
<h3 id="运营-VS-市场"><a href="#运营-VS-市场" class="headerlink" title="运营 VS. 市场"></a>运营 VS. 市场</h3><ol>
<li>市场部：创造和管理消费者<strong>无形价值</strong>的部门；市场所做的一切，都应该瞄准着扩大品牌、产品的用户认知和提升产品的无形价值；</li>
<li>运营，在做的事，<strong>是一定要落实到响应产品数据上</strong>，比如流量、注册量、留存率、活跃率等</li>
</ol>
<h3 id="运营-VS-产品"><a href="#运营-VS-产品" class="headerlink" title="运营 VS. 产品"></a>运营 VS. 产品</h3><ol>
<li><strong>产品方向和产品形态决定运营的思路</strong>；反过来，<strong>又需要运营根据用户反馈和运营需求来决定产品的调整和迭代；</strong>产品负责界定和提供长期长期用户价值，运营负责创造短期用户价值 + 协助产品完善长期价值；</li>
<li>如果你们公司的产品很烂，做为运用，需要做的是：<ul>
<li>对任何一个早期产品， “烂” 是正常的现象；这个阶段，需要运营维护好早期核心用户；</li>
<li>若从用户层面感受到了问题，你需要有能力<strong>回归到具体真实的用户使用场景中</strong>去向大家说明这个需求和功能可能是有问题的，或者用数据证明它。</li>
<li>最好还可以提出一些解决方案，并通过一些验证和数据去证明它是可行的；</li>
<li><strong>产品烂其实一点也不可怕；真正可怕的是：产品很烂，但提不出解决方案，或者压根不想去解决和优化；</strong></li>
</ul>
</li>
</ol>
<h3 id="运营的简史"><a href="#运营的简史" class="headerlink" title="运营的简史"></a>运营的简史</h3><ol>
<li><p><strong>在某种意义上，我相信，一个事物，如果你并不足够了解它的过去，那你一定很难真正去理解它的现在和未来。</strong></p>
<blockquote>
<p>【启发】去了解数据分析的过去</p>
</blockquote>
</li>
<li><p>运营的最终目的时候为了 <strong>&lt;更好地连接产品和用户&gt;</strong>。</p>
<ul>
<li><strong>能顾获取用户，并实现用户付费</strong> （需要关注<strong>信息分发和传播</strong>的逻辑变化，以及<strong>流量获取的成本</strong>）</li>
<li><strong>能够更好地维系住这些用户，令之愿意与你持续发生关系</strong> （需要结合产品形态来关注<strong>随着用户体量呈不同变化时</strong>，该如何更好地作为一个群体的用户进行沟通与互动，较好地控制用户的预期、甚至构成体验）</li>
</ul>
</li>
<li><p>运营的工作内容从来都不是固定的，往往会随着主流产品形态和整个互联网中<strong>信息分发和传播</strong>的逻辑而改变。<strong>&lt;流量&gt; 和 &lt;用户&gt; 在哪里，运营的关注就在哪里。</strong></p>
</li>
</ol>
<blockquote>
<p>互联网运营的7个阶段</p>
</blockquote>
<ol>
<li><p>1984 - 1993：互联网的萌芽</p>
</li>
<li><p>1994 - 1997：互联网是什么</p>
<ul>
<li>用户体量不足30万；</li>
<li>代表产品：门户、早期BBS；两者最大的区别，门户（PGC）、BBS（UGC）</li>
<li>代表性运营工作：网站编辑、BBS管理员</li>
</ul>
</li>
<li><p>1998 - 2001：第一波潮流</p>
<ul>
<li>用户体量：100 ~ 2000万</li>
<li>代表产品：聊天室、更成熟的BBS、QQ、联众、下载类站点</li>
<li>代表性运营工作：在线推广、社区管理</li>
</ul>
</li>
<li><p>2001 - 2005：流量为王的时代与运营的出现</p>
<ul>
<li>用户体量：2200万~ 1.03亿</li>
<li>代表产品：百度、hao123、淘宝、网游、各种安装插件</li>
<li>代表性运营工作：SEO/SEM、流量分发、QQ群管理、电商运营</li>
</ul>
</li>
<li><p>2005 - 2009：Web2.0时代的运营 —— 用户的崛起</p>
<ul>
<li>用户体量：1.03亿~ 3.84亿</li>
<li>代表产品：博客、wiki、视频网站、P2P下载、论坛、SNS</li>
<li>代表性运营工作：网络推手、论坛营销、事件营销与传播</li>
</ul>
<blockquote>
<p>所谓Web2.0 可以简单地理解为是 &lt;由用户主导而生成内容的互联网产品模式&gt;</p>
</blockquote>
</li>
<li><p>2009 - 2013：微博时代与移动互联网大局下的运营</p>
<ul>
<li>用户体量：3.84亿~ 6.18亿</li>
<li>代表产品：各类APP、微博、知乎、微信、团购</li>
<li>代表性运营工作：微博运营、社会化媒体营销、APP推广</li>
</ul>
</li>
<li><p>2013 - 至今：连接一切的互联网与运营</p>
<ul>
<li>用户体量：6.18亿~ 7.10亿</li>
<li>代表产品：微信、O2O产品、滴滴出行、今日头条、罗辑思维等自媒体</li>
<li>代表性运营工作：新媒体运营、社群运营、微博运营、社会化媒体运营、APP推广</li>
</ul>
<p>​</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h2 id="第2章-运营之”光”"><a href="#第2章-运营之”光”" class="headerlink" title="第2章 运营之”光”"></a>第2章 运营之”光”</h2><blockquote>
<p>两种思维意识：目标导向意识、效率意识</p>
</blockquote>
<ol>
<li><p>目标导向意识；</p>
<ul>
<li>纯粹的职能支持类工作</li>
<li>目标导向类工作</li>
</ul>
<blockquote>
<p>【启发】不仅仅是运营，数据分析更是如此；牢记你的目标，最好的方式是写下你的目标</p>
</blockquote>
</li>
<li><p>效率意识；在效率意识的观念下，你的所有时间及所有在做的工作，可能都是成本。所以，在相同的成本投入下，你如何让自己的产出变得更强大？如何持续去优化自己的投入产出比</p>
<ul>
<li>我这周都做了哪些事？哪些事情是有产出的？哪些事情的产出不够？哪些事情的产出效率尤其地高，值得我花更多时间投入？而哪些事情产出明显不足，可能应该去忽略它？</li>
</ul>
<blockquote>
<p>【共鸣】精要主义；这种反思要经常做</p>
</blockquote>
</li>
</ol>
<ol>
<li>传统运营讲<strong>转化</strong>，需要以<strong>交易达成</strong>为中心；互联网运营讲<strong>用户</strong>，需要以<strong>用户价值</strong>为核心；</li>
</ol>
<h3 id="精益运营"><a href="#精益运营" class="headerlink" title="精益运营"></a>精益运营</h3><blockquote>
<p>面对不确定环境下的工作方法：</p>
<ul>
<li><strong>找出最核心的不确定要素</strong></li>
<li><strong>先以最小成本去搭建一个真实的应用场景</strong></li>
</ul>
</blockquote>
<ol>
<li>当在一个具体项目中面临N多不确定因素的时候，往往存在一个最重要的因素，它可能会成为整件事情顺畅发生的核心前提；在互联网世界里，这个最重要的因素往往是 <strong>&lt;一个基于某种假设的产品或服务，能否得到用户真实、自发的认可&gt;</strong>。</li>
<li><strong>用最低的成本去搭建一个真实的用户应用场景</strong>，并去<strong>验证</strong>这个场景下，用户是否真的会产生你所预期的行为；要注意，你所搭建的场景一定是无限接近于真实的；</li>
</ol>
<h3 id="做运营的三个底层方法"><a href="#做运营的三个底层方法" class="headerlink" title="做运营的三个底层方法"></a>做运营的三个底层方法</h3><ol>
<li><p>让自己拥有对新鲜事物的高度敏感</p>
</li>
<li><p><strong>让自己拥有对于用户的洞察（自己成为用户）</strong></p>
<ul>
<li><strong>尽可能把自己变成一个真正的典型用户，让自己大量置身于真实用户的真实体验场景下</strong>；久而久之，你自然会慢慢拥有一种对于你的用户们的洞察力；而这样的洞察力，很多时候会成为一个优秀运营的核心价值；</li>
</ul>
</li>
<li><p>学会更具有打动力和说服力的表达</p>
<ul>
<li><strong>获取注意力：需要抛出一个可以让对方大吃一惊或十分好奇的观点和结论，瞬间击中对方，然后再去逐一论证你的观点是否可以成立</strong><ul>
<li><em>前天我去参加了一个会议，那会议上有好多人；有XX公司、XX公司；然后，有一个著名的基金合伙人，在会议上做了一个演讲，他结合了自己对于教育行业的观察，从20世纪90年代的教育行业发展讲起，具体讲了新东方、学而思等公司的成长路径，还有在线教育的一些趋势。</em></li>
<li><em>前天我参加了一个会议，有个著名基金的合伙人聊了一个特别有意思的颠覆性观点，叫做：教育将死，学习永生</em> （激发倾听的欲望）</li>
</ul>
</li>
<li><strong>说服对方：需要先从大量事实和一些细节的刻画出发，通过事实和细节引发出对方的感知、共鸣和认同，再逐步引申出你的结论。</strong><ul>
<li><em>这部电影超级好，我推荐你一定要去看看</em></li>
<li><em>我昨天刚刚看了一部电影，这部电影播放的过程中，我先后4次被感动到落泪；另外，在电影结束播放时，我们那个全场爆满的影厅里，有超过一半的人自发地为这部电影鼓掌</em>  （大量事实和细节的刻画）</li>
</ul>
</li>
</ul>
<blockquote>
<p>【启发】表达之前，你要明白你的目的是什么，然后基于你的目的选择应该的表达方式；（记录到沟通中）</p>
</blockquote>
</li>
</ol>
<h3 id="运营需要懂产品"><a href="#运营需要懂产品" class="headerlink" title="运营需要懂产品"></a>运营需要懂产品</h3><ol>
<li><p>对于一个合格的产品经理，<strong>&lt;用户、需求、场景&gt;</strong> 永远是在其产品设计和需求分析时必不可少的3要素；</p>
<blockquote>
<p>【反思】场景与目的，是需要分别做充分挖掘的；不仅仅是界定场景，还需要分析现有的结构、资源等</p>
</blockquote>
</li>
</ol>
<p><br></p>
<h2 id="第3章-运营的核心技能-amp-工作方法"><a href="#第3章-运营的核心技能-amp-工作方法" class="headerlink" title="第3章 运营的核心技能&amp;工作方法"></a>第3章 运营的核心技能&amp;工作方法</h2><ol>
<li>基于目标的拆解 VS. 基于场景的拆解<ul>
<li>基于目标：咨询思维<ul>
<li>销售额 = 活动流量 <em> 付费率 </em> ARPU值</li>
</ul>
</li>
<li>基于场景：运营思维</li>
</ul>
</li>
<li>思考的几个步骤<ul>
<li>界定这个指标是由哪些要素构成；需要把这些要素的关系界定出来，最好变成一个公式/图解/矩阵的样子</li>
<li>这些要素是否要有可以提升的空间</li>
<li>思考如果要提升具体某个指标，需要将其拆分和落实为哪些具体的运营手段？</li>
</ul>
</li>
</ol>
<h3 id="数据分析方法和意识"><a href="#数据分析方法和意识" class="headerlink" title="数据分析方法和意识"></a>数据分析方法和意识</h3><ol>
<li>框架不是为了束缚思维，而是用来整理思路的；</li>
</ol>
<blockquote>
<p>数据在运营中的作用</p>
</blockquote>
<ol>
<li><p>数据可以客观反映出一款产品当前的状态好坏和所处阶段</p>
</li>
<li><p>假如做了一件事但效果不好，数据可以告诉你，问题出在哪里</p>
</li>
<li><p>如果要实现某个目标，数据可以帮助你找到最佳路径</p>
</li>
<li><p>极度精细的数据分析可以帮助你通过层层拆分，对用户更了解，也对整个站内的生态更有掌控力；</p>
<ul>
<li>数据分析中的基本概念：<strong>度量、维度</strong><ul>
<li>度量：具体的数据指标（具体指标、具体用户行为数据）</li>
<li>维度：看待指标的不同角度（层次差异[不同用户类型]、角度差异[不同时间、地区]）</li>
</ul>
</li>
<li><strong>所谓数据分析，其实就是界定清楚了评估的度量有哪些，然后需要知道你可能有哪些维度去看待这些度量；之后还需要在不同维度和度量间做交叉分析和对比，最后产出结论，把结果用图表等方式呈现出来。</strong></li>
</ul>
<blockquote>
<p>【启发】先确定具体的度量值，然后在思考可能的维度；之后对需要的部分做交叉分析和对比；在思考的时候，这两个步骤分开来做；例如才子提到的方式：第一阶段就只做列度量值，不去思考整体之间的关系和结构；做完第一步之后，再做内容的归类与可能的交叉分析（矩阵）</p>
</blockquote>
</li>
<li><p>数据中可能隐藏着一些潜在的让你把一件事情变得更好的线索和彩蛋，有待你去发现和挖掘</p>
</li>
</ol>
<h3 id="内容的运营"><a href="#内容的运营" class="headerlink" title="内容的运营"></a>内容的运营</h3><blockquote>
<p>内容运营要做的事，是持续关注内容从生产到消费再到流通和传播的全过程，并通过自己撰写、编辑、组织加工、外部渠道等一系列手段去促进这个过程的发生。</p>
<p>在整个过程中，需要持续关注并提升各类跟内容相关的数据，如内容数量、内容浏览量、内容互动数、内容传播数等</p>
<p>内容的定位、调性和基本原则</p>
</blockquote>
<ol>
<li><p>做内容，永远都关注长、短两条线；</p>
<ul>
<li>短线，是尽一切努力促进内容被消费</li>
<li>长线，是以一系列长期、持续的内容为载体，面向用户建立起一种识别度和信任感<ul>
<li>为了做好这一点，必须明确你的<strong>内容边界</strong>（什么能写，什么不能写），并给你的内容<strong>打上某种风格化的标签</strong> ；即定位和调性</li>
<li>重要性在于，一旦这个调性被成功树立起来，就可以在用户心中牢牢占据一个位置，进而大大降低以后要去建立用户认知的成本</li>
</ul>
</li>
</ul>
</li>
<li><p>关于定位和调性的难点并不在于想清楚的调性是什么，而是在于</p>
<ul>
<li>必须给自己的内容找到显著的不同和差异所在</li>
<li>要落地到实处找到具体的发力点</li>
</ul>
</li>
<li><p>内容运营过程中关注的点</p>
<ul>
<li><p>内容的生产；</p>
<ul>
<li>对于UGC型的内容生态来说，从&lt;优质内容如何被生产出来&gt; 到 &lt;优质内容如何可以持续地被生产出来&gt; 是两个重要的问题</li>
</ul>
</li>
<li><p>内容的组织和包装</p>
<ul>
<li><p>单篇内容的组建和标准</p>
</li>
<li><p>相关内容的聚合</p>
</li>
<li><p>整体内容的导览和索引</p>
<ul>
<li><strong>界定用户的访问模式</strong>，是你在负责一款内容型产品时，首先就要回答的问题<ul>
<li><strong>闲逛式：用户在访问时可能没有什么特定的目的</strong></li>
<li><strong>目的导向式：用户在访问时是为了解决某个特定的问题，或为了查询某个特定的资料</strong></li>
</ul>
</li>
<li>围绕闲逛式的行为方式，内容的组织解决方案可能比较适合<strong>通过信息流这种可以随意刷新、随机获取信息的方式，或者比较突出热门话题、官方推荐、最新最热等内容的方式；</strong>这样的方式，<u>重在可以让用户以较小的成本获取到一些能够给自己带来刺激或价值的内容</u></li>
<li>围绕目的导向式的行为方式，内容的组织解决方案可能更适合<strong>通过分类、加强搜索体验和引导等方式</strong>；<u>重在给予客户一条明确的路径和查询线索，帮助用户更高效地找到自己想要的内容；</u></li>
</ul>
<blockquote>
<p>【思考】今日头条，用户的访问模式本质上是闲逛式的；只是对于大类的做了划分而已；</p>
</blockquote>
</li>
<li><p>核心拳头内容的呈现</p>
</li>
</ul>
</li>
<li><p>内容的流通</p>
<ul>
<li>内容的流通：当你已经有了一定数量的内容后，<strong>需要考虑以某种方式让你已有的内容可以流动起来，通过流动令之展现在用户面前，从而让用户可以发现和消费它。</strong> <u>假如不存在这样的流通形式和流通机制，很容易出现就是老的内容被大量堆在深谷，很难被用户找到或看到，又或者内容和用户间的匹配效率始终不高；</u></li>
<li>需要关注的维度：如何通过一些机制或手段促进内容的流同，以及促进流通中的内容与用户的匹配效率</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="转化型文案的写作方法"><a href="#转化型文案的写作方法" class="headerlink" title="转化型文案的写作方法"></a>转化型文案的写作方法</h3><ol>
<li>转化型文案，就是这个文案的目的是特定的，它被写出来的唯一意义就是<strong>引导用户去完成某个特定的行为</strong>； <ul>
<li>标题的最大意义，就是吸引读者去阅读正文；</li>
<li>商品详情页最大的意义，促成用户下单购买</li>
</ul>
</li>
<li>你只有先帮用建立起认知，才有机会激发用户的兴趣。即就是你的文案要先确保用户能够看得懂，在这个基础上才能进一步激发用户的转化。</li>
</ol>
<h3 id="成为内容领域的高手"><a href="#成为内容领域的高手" class="headerlink" title="成为内容领域的高手"></a>成为内容领域的高手</h3><ol>
<li><p>内容本身的价值、打动力，与内容的传播、用户消费几率等，已经越来越合一（之前内容只是为了如何简单粗暴地获取流量而服务，至于内容本身的价值并不重要），用户在内容面前的话语权越来越大，而不再是渠道。一个内容能不能火，本质上越来越取决于用户是否认可它，传播它，而不再是核心渠道是否能够推荐它。</p>
</li>
<li><p>如果做内容，<strong>尽量不要只做一维的资讯。或者说，即便做资讯，背后也应该包含了某种既定的思想与价值主张。</strong>因为如果你提供的是思想、知识、价值主张等，可能会更容易得到用户的认可，而这种认可如果长期积累下来，可能会为你构建起来一种穿透性的用户信任感，且这个信任感可以沉淀转化到任何东西上。<em>比如罗辑思维建立起来的影响力，完全可以转化到卖月饼、卖桃子事情上。</em></p>
</li>
<li><p><strong>我觉得，人活着，总是需要先能够打破边界，然后再找到边界。前一个边界是外界给自己设定的限制和束缚；后一个边界，则指的是自己的能力、野心和欲望可及和应及的范围。打破前者，为的是找到这个世界的丰富和可能性，打开眼界和格局。找到后者，则为的是找到个人的局限和使命，获得谦卑、专注于平静。</strong></p>
<blockquote>
<p>【思考】两个边界：外部、自我</p>
</blockquote>
</li>
<li><p>我相信，你应该把你的内容当做一种 &lt;与读者交朋友&gt; 的形式。若想要获得用户持续给予的发自内心的信任，你们之间的关系，必是无限接近于&lt;朋友&gt;的关系。因而，你必须要思考，在一个你最好的朋友面前，你会如何表现？如何表达？然后带着类似的立场去做你的内容；就我来说， 在最好的朋友面前，往往是性格鲜明、情感丰富的；在他们面前，我不会中庸，不会高大上。而是该骂时骂，该哭时哭，该逗乐开心时逗乐开心，该义正言辞时义正言辞，偶尔不靠谱时就自黑调侃地聊聊自己的不靠谱。</p>
<blockquote>
<p>【反思】这是真实。真实的你是什么样的呢？矛盾、简单又复杂。</p>
</blockquote>
</li>
<li><p>所谓伦理，核心只有一点：跟你从认识一个朋友到愿意毫无保留地相信他是漫长的过程一样，也要相信通过内容来与用户建立信任是一件长期的事情，所以在内容面前，凡是不妨都往长远看一点。</p>
</li>
<li><p>我喜欢的工作方法是：</p>
<ul>
<li><strong>先找到一个你长期愿意相信的东西，坚守住它，确定一个不可逾越的底线</strong></li>
<li>在此基础上再考虑向一些短期的诱惑去妥协</li>
<li>否则，若无长期坚守，哪怕你短线战绩再辉煌，你在用户眼中很可能只能车呢各位一个过眼云烟式的枪手</li>
</ul>
</li>
<li><p>以我为例，可能很多人都发现了，我喜欢写长篇大论式的认真表达，不太喜欢短平快的段子，这在今天的互联网上其实有点非主流。尤其是好久以前就不断有人跟我说，现在已经是读图的时代了，已经是短视频的时代了，已经是表情秀、冷笑话，你那种长篇大论的东西没人看，你要跟上时代。</p>
<blockquote>
<p>【反思&amp;行动】慢慢写字，这么舒服的纸张，要让你的字配得上它。慢慢写字，慢慢说话，把东西写清楚，把话说清楚；</p>
</blockquote>
</li>
<li><p>我觉得，他们的状态其实很惨。因为他们的内容背后展现的，已经不是真实的自己。就像我们说的，一个做内容的人，其实是让自己的内容代表自己去与用户交朋友。但，如果你的内容所展现的都不是一个真实的、诚恳的、性格鲜明的你，用户如何能够相信你？</p>
<blockquote>
<p>【反思】一直就有的观点，你的作品就代表了你的人；其实生活中，勇敢去做自己，不要中庸，不要敷衍，更不要奉承；做一个性格鲜明的你，坦诚一点，真实一点；活出自己，才会是最大的坦荡；那一刻的你，就会像是拥有了一颗坚定的信念，毫无畏惧。</p>
</blockquote>
</li>
</ol>
<h3 id="用户运营的逻辑、策略于工作方法"><a href="#用户运营的逻辑、策略于工作方法" class="headerlink" title="用户运营的逻辑、策略于工作方法"></a>用户运营的逻辑、策略于工作方法</h3><p><br></p>
<h2 id="第4章-运营的宏观规律和逻辑"><a href="#第4章-运营的宏观规律和逻辑" class="headerlink" title="第4章 运营的宏观规律和逻辑"></a>第4章 运营的宏观规律和逻辑</h2><p><br></p>
<h2 id="第5章-运营的职业发展与成长"><a href="#第5章-运营的职业发展与成长" class="headerlink" title="第5章 运营的职业发展与成长"></a>第5章 运营的职业发展与成长</h2><p><br></p>
<h2 id="第6章-运营人的思考"><a href="#第6章-运营人的思考" class="headerlink" title="第6章 运营人的思考"></a>第6章 运营人的思考</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;主题&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;阅于2018年2月6日&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>SyncToy使用说明</title>
    <link href="http://yoursite.com/2018/02/12/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/SyncToy/SyncToy%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/02/12/软件应用_办公软件/SyncToy/SyncToy使用说明/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-02-13T13:18:57.494Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="SyncToy使用说明"><a href="#SyncToy使用说明" class="headerlink" title="SyncToy使用说明"></a>SyncToy使用说明</h2><ul>
<li>synchronize ：在这个模式下，SyncToy会使得两个文件夹<strong>完全一致</strong>，无论在哪一个文件夹中操作，对应的操作相当于都在另一个文件夹中执行了一次。（也就是我们所说的“同步”）。</li>
<li>echo：echo模式的效果是，使得在左边文件夹中新增加的和被改变的内容会被备份到右边的文件夹中。在左侧被重命名的文件以及被删除了的文件，将也会在右侧的文件夹中删除。（这种模式与synchronize 很像，<strong>差别就在于这里只会从左边同步到右边，右边的操作对左边的文件夹无效~）</strong>。</li>
<li>Contribute ：也就是我们常说的“增量备份”，相当于在echo的基础上，把所有的删除操作都屏蔽掉了，只要在左边文件夹中存在过的文件都会在右侧文件夹中存在。</li>
</ul>
<blockquote>
<p>博客文档，选用echo模式；因为并不是所有的文章都要发表</p>
<p><strong>并且，在右侧删除的内容，对同一个 &lt;同步设置&gt; 再次执行时，右侧被删除的文档不会被再次增加。</strong></p>
</blockquote>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;SyncToy使用说明&quot;&gt;&lt;a href=&quot;#SyncToy使用说明&quot; class=&quot;headerlink&quot; title=&quot;SyncToy使用说明&quot;&gt;&lt;/a&gt;SyncToy使用说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;synchroniz
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="办公软件" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Sync" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/Sync/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="办公软件" scheme="http://yoursite.com/tags/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Sync" scheme="http://yoursite.com/tags/Sync/"/>
    
  </entry>
  
  <entry>
    <title>Python_数据处理_pandas</title>
    <link href="http://yoursite.com/2018/02/06/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_pandas/"/>
    <id>http://yoursite.com/2018/02/06/软件应用_程序编程/Python/Python_专题总结/Python_数据处理_pandas/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-02-13T13:12:22.596Z</updated>
    
    <content type="html"><![CDATA[<p>pandas 指引 : <a href="http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window" target="_blank" rel="external">http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window</a></p>
<ul>
<li><strong>DataFrame 单独取出一列是 Series 格式</strong></li>
</ul>
<blockquote>
<p>根据pandas的官方文档，重新调整结构</p>
</blockquote>
<a id="more"></a>
<p>[TOC]</p>
<p><br></p>
<p><strong>笔记方法：</strong></p>
<ol>
<li>列出关键的参数</li>
<li>示例部分一定要是自己的代码</li>
<li>其他均可以上网找</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div></pre></td></tr></table></figure>
<blockquote>
<p>官方文档：<a href="http://pandas.pydata.org/pandas-docs/stable/api.html" target="_blank" rel="external">http://pandas.pydata.org/pandas-docs/stable/api.html</a></p>
</blockquote>
<!--more-->
<p><br></p>
<h1 id="Input-Output-输入-输出"><a href="#Input-Output-输入-输出" class="headerlink" title="Input/Output - 输入/输出"></a>Input/Output - 输入/输出</h1><p><br></p>
<h1 id="General-func-一般功能"><a href="#General-func-一般功能" class="headerlink" title="General func - 一般功能"></a>General func - 一般功能</h1><p><br></p>
<h2 id="datetimelike-顶层处理"><a href="#datetimelike-顶层处理" class="headerlink" title="datetimelike 顶层处理"></a>datetimelike 顶层处理</h2><h4 id="pd-to-datetime"><a href="#pd-to-datetime" class="headerlink" title="pd.to_datetime"></a>pd.to_datetime</h4><blockquote>
<p><strong>Convert argument to datetime.</strong></p>
</blockquote>
<p>pandas<strong>.to_datetime(</strong>arg, errors=’raise’, <strong>dayfirst=False,</strong> yearfirst=False, utc=None, <strong>box=True,</strong> <strong>format=None</strong>, exact=True, unit=None, infer_datetime_format=False, origin=’unix’)</p>
<blockquote>
<p><strong>arg</strong> : <u>integer, float, string, datetime, list, tuple, 1-d array, Series</u></p>
<p><strong>errors</strong> : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’</p>
<blockquote>
<ul>
<li>If ‘raise’, then invalid parsing will raise an exception (唤起异常)</li>
<li>If ‘coerce’, then invalid parsing will be set as NaT </li>
<li>If ‘ignore’, then invalid parsing will return the input</li>
</ul>
</blockquote>
<p><strong>dayfirst</strong> : boolean, default False</p>
<blockquote>
<p>If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10.</p>
</blockquote>
<p><strong>box</strong> : boolean, default True</p>
<blockquote>
<ul>
<li>If True returns a <u>DatetimeIndex</u></li>
<li>If False returns <u>ndarray of values.</u></li>
</ul>
</blockquote>
<p><strong>format</strong> : string, default None</p>
<blockquote>
<p>strftime to parse time, eg “%d/%m/%Y”, note that “%f” will parse all the way up to nanoseconds (纳秒).</p>
</blockquote>
<p><strong>unit</strong> : string, default ‘ns’  (默认为纳秒)</p>
<blockquote>
<p>unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number.</p>
</blockquote>
<hr>
<p>Return type depends on input:</p>
<ul>
<li>list-like: DatetimeIndex</li>
<li>Series: Series of datetime64 dtype</li>
<li>scalar: Timestamp</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'year'</span>: [<span class="number">2015</span>, <span class="number">2016</span>],</div><div class="line">                       <span class="string">'month'</span>: [<span class="number">2</span>, <span class="number">3</span>],</div><div class="line">                       <span class="string">'day'</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</div><div class="line">day	month	year</div><div class="line"><span class="number">0</span>	<span class="number">4</span>	<span class="number">2</span>	<span class="number">2015</span></div><div class="line"><span class="number">1</span>	<span class="number">5</span>	<span class="number">3</span>	<span class="number">2016</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_datetime(df)</div><div class="line"><span class="number">0</span>   <span class="number">2015</span><span class="number">-02</span><span class="number">-04</span></div><div class="line"><span class="number">1</span>   <span class="number">2016</span><span class="number">-03</span><span class="number">-05</span></div><div class="line">dtype: datetime64[ns]  <span class="comment"># 对于一列的DataFrame其实就是一个Series，返回的对象类型为 datetime64 dtype</span></div><div class="line">  </div><div class="line"><span class="comment">#-----------------</span></div></pre></td></tr></table></figure>
<h5 id="pd-to-timedelta"><a href="#pd-to-timedelta" class="headerlink" title="pd.to_timedelta"></a>pd.to_timedelta</h5><h5 id="pd-date-range"><a href="#pd-date-range" class="headerlink" title="pd.date_range"></a>pd.date_range</h5><blockquote>
<p><strong>Return a fixed frequency DatetimeIndex, with day (calendar) as the default frequency</strong></p>
</blockquote>
<p>pandas.<strong>date_range</strong>(start=None, end=None, periods=None, freq=’D’, tz=None, normalize=False, name=None, closed=None, **kwargs)</p>
<p><br></p>
<h5 id="pd-bdate-range"><a href="#pd-bdate-range" class="headerlink" title="pd.bdate_range"></a>pd.bdate_range</h5><h5 id="pd-period-range"><a href="#pd-period-range" class="headerlink" title="pd.period_range"></a>pd.period_range</h5><h5 id="pd-timedelta-range"><a href="#pd-timedelta-range" class="headerlink" title="pd.timedelta_range"></a>pd.timedelta_range</h5><h5 id="pd-infer-freq"><a href="#pd-infer-freq" class="headerlink" title="pd.infer_freq"></a>pd.infer_freq</h5><p><br></p>
<p>#Series</p>
<p><br></p>
<p>#DataFrame</p>
<p><br></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h4 id="pd-DataFrame"><a href="#pd-DataFrame" class="headerlink" title="pd.DataFrame"></a>pd.DataFrame</h4><p> pandas.<strong>DataFrame</strong>(data=None, index=None, columns=None, dtype=None, copy=False)</p>
<blockquote>
<p><strong>data</strong> : numpy ndarray (structured or homogeneous), dict, or DataFrame</p>
<blockquote>
<p>Dict can contain Series, arrays, constants, or list-like objects</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'col1'</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="string">'col2'</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(data=d)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">   col1  col2</div><div class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">3</span></div><div class="line"><span class="number">1</span>     <span class="number">2</span>     <span class="number">4</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>##重编索引/选择/标签操作</p>
<h4 id="pd-DataFrame-reindex"><a href="#pd-DataFrame-reindex" class="headerlink" title="pd.DataFrame.reindex"></a>pd.DataFrame.reindex</h4><blockquote>
<p><strong>Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index. /   Retrun  reindexed : DataFrame</strong></p>
</blockquote>
<p>DataFrame.<strong>reindex</strong>(labels=None, index=None, columns=None, <strong>axis</strong>=None, <strong>method</strong>=None, copy=True, level=None, <strong>fill_value</strong>=nan, limit=None, tolerance=None)</p>
<blockquote>
<p><strong>labels</strong> : array-like, optional</p>
<blockquote>
<p>New labels / index to conform the axis specified by ‘axis’ to.</p>
</blockquote>
<p><strong>index, columns</strong> : array-like, optional (should be specified using keywords)</p>
<p><strong>axis</strong> : int or str, optional ; <strong>(axis=1, 表示对列进行重排)</strong></p>
<blockquote>
<p>Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1).</p>
</blockquote>
<p><strong>method</strong> : {None, ‘backfill’/’bfill’, ‘pad’/’ffill’, ‘nearest’}, optional  <strong>（仅对调单递增/递减的空位处进行填充 - 向前/向后等）</strong></p>
<blockquote>
<p>method to use for filling holes in reindexed DataFrame. Please note: this is only applicable to DataFrames/Series with a monotonically increasing/decreasing index. </p>
<ul>
<li>default: don’t fill gaps</li>
<li>pad / ffill: propagate last valid observation forward to next valid</li>
<li>backfill / bfill: use next valid observation to fill gap</li>
<li>nearest: use nearest valid observations to fill gap</li>
</ul>
</blockquote>
<p><strong>fill_value</strong> : scalar, default np.NaN</p>
<blockquote>
<p>Value to use for missing values. Defaults to NaN, but can be any “compatible” value</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#--------------- reindex the columns.</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(columns=[<span class="string">'http_status'</span>, <span class="string">'user_agent'</span>])  <span class="comment"># 通过columns 来重排</span></div><div class="line">           http_status  user_agent</div><div class="line">Firefox            <span class="number">200</span>         NaN</div><div class="line">Chrome             <span class="number">200</span>         NaN</div><div class="line">Safari             <span class="number">404</span>         NaN</div><div class="line">IE10               <span class="number">404</span>         NaN</div><div class="line">Konqueror          <span class="number">301</span>         NaN</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex([<span class="string">'http_status'</span>, <span class="string">'user_agent'</span>], axis=<span class="string">"columns"</span>)  <span class="comment"># 通过axis 指定来重排 / axis=1 类同</span></div><div class="line">           http_status  user_agent</div><div class="line">Firefox            <span class="number">200</span>         NaN</div><div class="line">Chrome             <span class="number">200</span>         NaN</div><div class="line">Safari             <span class="number">404</span>         NaN</div><div class="line">IE10               <span class="number">404</span>         NaN</div><div class="line">Konqueror          <span class="number">301</span>         NaN</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--------------- reindex the index.</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>index = [<span class="string">'Firefox'</span>, <span class="string">'Chrome'</span>, <span class="string">'Safari'</span>, <span class="string">'IE10'</span>, <span class="string">'Konqueror'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;</div><div class="line"><span class="meta">... </span>     <span class="string">'http_status'</span>: [<span class="number">200</span>,<span class="number">200</span>,<span class="number">404</span>,<span class="number">404</span>,<span class="number">301</span>],</div><div class="line"><span class="meta">... </span>     <span class="string">'response_time'</span>: [<span class="number">0.04</span>, <span class="number">0.02</span>, <span class="number">0.07</span>, <span class="number">0.08</span>, <span class="number">1.0</span>]&#125;,</div><div class="line"><span class="meta">... </span>      index=index)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">           http_status  response_time</div><div class="line">Firefox            <span class="number">200</span>           <span class="number">0.04</span></div><div class="line">Chrome             <span class="number">200</span>           <span class="number">0.02</span></div><div class="line">Safari             <span class="number">404</span>           <span class="number">0.07</span></div><div class="line">IE10               <span class="number">404</span>           <span class="number">0.08</span></div><div class="line">Konqueror          <span class="number">301</span>           <span class="number">1.00</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -------------Create a new index and reindex the dataframe. </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>new_index= [<span class="string">'Safari'</span>, <span class="string">'Iceweasel'</span>, <span class="string">'Comodo Dragon'</span>, <span class="string">'IE10'</span>,</div><div class="line"><span class="meta">... </span>            <span class="string">'Chrome'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(new_index)</div><div class="line">               http_status  response_time</div><div class="line">Safari               <span class="number">404.0</span>           <span class="number">0.07</span></div><div class="line">Iceweasel              NaN            NaN  <span class="comment">## 无法匹配的索引默认填充 NaN</span></div><div class="line">Comodo Dragon          NaN            NaN</div><div class="line">IE10                 <span class="number">404.0</span>           <span class="number">0.08</span></div><div class="line">Chrome               <span class="number">200.0</span>           <span class="number">0.02</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(new_index, fill_value=<span class="number">0</span>)  <span class="comment"># NaN 用0来填充</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(new_index, fill_value=<span class="string">'missing'</span>)  <span class="comment"># NaN 用‘missing’来填充</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>#panel - 面板</p>
<p><br></p>
<p>#Index - 索引</p>
<p><br></p>
<p>#Numeric Index - 数字化索引</p>
<p><br></p>
<p>#CategoricalIndex - 分类索引</p>
<p><br></p>
<p>#IntervalIndex - 交互索引</p>
<p><br></p>
<p>#MultiIndex </p>
<p><br></p>
<p>#DatetimeIndex - 日期时间索引</p>
<p><br></p>
<p>#TimedeltaIndex - 时间间隔索引</p>
<p><br></p>
<p>#PeriodIndex - 间隔索引</p>
<p><br></p>
<p>#Scales - 标量</p>
<p><br></p>
<p><br></p>
<p>#Windows  - 窗口</p>
<p><br></p>
<h1 id="Groupby-分组"><a href="#Groupby-分组" class="headerlink" title="Groupby - 分组"></a>Groupby - 分组</h1><p><br></p>
<p>#Resampling  - 重新取样</p>
<p><br></p>
<p>#Style- 样式</p>
<p><br></p>
<p>#General utility func - 通用效用函数</p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h1 id="old"><a href="#old" class="headerlink" title="old"></a>old</h1><p><br></p>
<h2 id="创建与变更格式"><a href="#创建与变更格式" class="headerlink" title="创建与变更格式"></a>创建与变更格式</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li><strong>pd.Series( [], index=[], name=’’ )</strong>：创建Series</li>
</ul>
<ul>
<li><strong>pd.DataFrame</strong>(np.random.rand(20,5) , index=[], columns=[] )：创建20行5列的随机数组成的DataFrame对象</li>
</ul>
<blockquote>
<p>DataFrame会<strong>自动创建索引，且会被有序排列</strong>； <strong>Index索引对象是不可修改的</strong>。除非在第一次写入时缺少索引列，可进行定义。</p>
<p>传入等长的列表或NumPy数组组成的 <strong>字典</strong>。</p>
<p>若传入的列在数据中查询不到，就会产生NA</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">DataFrame(obj, colums=[], index=[])</div><div class="line"><span class="comment"># columns  按照指定的列进行显示</span></div><div class="line"><span class="comment"># index  指定索引的名称，但并不改变行的顺序; 	若对已存在的索引（eg:嵌套字典），若index中的索引不存在，则不显示</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建对象：运用字典--------------------</span></div><div class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohi'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>], <span class="string">'year'</span>: [<span class="number">2000</span>,</div><div class="line">        <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</div><div class="line">frame = DataFrame(data, columns = [<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>])  <span class="comment"># 按照指定列进行排序</span></div><div class="line"></div><div class="line"><span class="comment"># 创建对象：运用列表</span></div><div class="line">pd.DataFrame([[<span class="number">4</span>,<span class="number">7</span>],[<span class="number">5</span>,<span class="number">10</span>]],columns=[<span class="string">'a'</span>,<span class="string">'b'</span>],index=[<span class="number">1</span>,<span class="number">2</span>])</div><div class="line"></div><div class="line"><span class="comment"># ------嵌套字典-----------</span></div><div class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, </div><div class="line">       <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</div><div class="line">frame3 = DataFrame(pop)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><ul>
<li><strong>df.shape()</strong>：查看行数和列数</li>
<li><strong>df.head(n)</strong>：查看DataFrame对象的前n行</li>
<li><strong>df.tail(n)</strong>：查看DataFrame对象的最后n行</li>
<li><strong>df.describe()</strong>：查看数值型列的汇总统计</li>
<li><strong>df.columns</strong> ：查看列名</li>
<li>s.value_counts(dropna=False)：查看Series对象的唯一值和计数</li>
<li>df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</li>
<li><a href="http://link.zhihu.com/?target=http%3A//df.info%28%29" target="_blank" rel="external">http://df.info()</a>：查看索引、数据类型和内存信息</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h2><h3 id="重命名-rename"><a href="#重命名-rename" class="headerlink" title="重命名 - rename"></a>重命名 - rename</h3><ul>
<li><strong>df.set_index(‘column_one’)</strong>：更改<strong>索引列</strong></li>
<li><strong>df.columns</strong>：获取当前列名</li>
<li><strong>df.columns = [‘a’,’b’,’c’]</strong>：重命名列名</li>
<li><strong>df.rename( columns = {‘a’ : ‘A’} , inplace = True )</strong>：只修改特定的列；将’a’ 改为 ‘A’<ul>
<li><strong>df.rename(columns=lambda x: x + 1)</strong>：批量更改列名</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df.rename(columns=&#123;<span class="string">'old_name'</span>: <span class="string">'new_ name'</span>&#125;) <span class="comment"># 选择性更改列名</span></div><div class="line"></div><div class="line">df.rename(columns=<span class="keyword">lambda</span> x: x + <span class="number">1</span>) <span class="comment"># 批量更改列名</span></div><div class="line">df.rename(index=<span class="keyword">lambda</span> x: x + <span class="number">1</span>) <span class="comment"># 批量重命名索引</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="批量重命名-前缀-后缀"><a href="#批量重命名-前缀-后缀" class="headerlink" title="批量重命名  - 前缀/后缀"></a>批量重命名  - 前缀/后缀</h3><ul>
<li><strong>DataFrame.add_prefix(prefix)</strong> ：将<strong>前缀字符串</strong>与面板项名称串联在一起。</li>
<li>DataFrame.add_suffix(suffix)：将<strong>后缀字符串</strong>与面板项名称串联在一起。、</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 分组运算并合并数据</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).transform(<span class="string">'mean'</span>).add_prefix(<span class="string">'mean_'</span>)  <span class="comment"># DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。</span></div><div class="line"></div><div class="line">mean_data1	mean_data2</div><div class="line"><span class="number">0</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">1</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">2</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">3</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">4</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="排序-sort-valuese"><a href="#排序-sort-valuese" class="headerlink" title="排序 - sort_valuese"></a>排序 - sort_valuese</h3><blockquote>
<p>根据列的值进行排序</p>
</blockquote>
<ul>
<li><strong>df.sort_values(col1)</strong>：按照列col1排序数据，<strong>默认升序</strong>排列</li>
<li><strong>df.sort_values([col1,col2], ascending=[True,False])</strong>：先按列col1升序排列，后按col2降序排列数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.sort_value(col1, ascendding=<span class="keyword">False</span>)</div><div class="line"><span class="comment">## ascendding=False，按照列col1降序排列数据；默认按升序排列</span></div></pre></td></tr></table></figure>
<blockquote>
<p>根据索引调整</p>
</blockquote>
<ul>
<li><strong>df.sort_index(asix=1, ascending=False)</strong> ：根据<strong>索引/列名标签</strong>对数据结构进行调整</li>
</ul>
<blockquote>
<p>若axis=1，则根据<strong>列名的顺序</strong>进行调整结构，行不变。</p>
</blockquote>
<ul>
<li><strong>df.reset_index()</strong>：重新设置行的索引</li>
</ul>
<ul>
<li>s.sort_index() ：根据索引进行排序</li>
</ul>
<ul>
<li>s.order()</li>
</ul>
<p><br></p>
<h3 id="列-行索引重排"><a href="#列-行索引重排" class="headerlink" title="列/行索引重排"></a>列/行索引重排</h3><ul>
<li>DataFrame.<strong>reindex(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)</strong>：根据新索引进行重新排序<ul>
<li>只显示符合当前索引的值。可加入新的索引值，若不存在则显示为NaN</li>
<li><strong>axsi = 1 ，则表示对 [列 Columns ] 进行重排</strong></li>
<li>支持两种形式（建议采用第二种）<ul>
<li><code>(index=index_labels, columns=column_labels, ...)</code></li>
<li><code>(labels, axis={&#39;index&#39;, &#39;columns&#39;}, ...)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>labels</strong> : array-like, optional. New labels / index to conform the axis specified by ‘axis’ to.</p>
<p>index： 用作索引的新序列</p>
<p><strong>axis</strong> : int or str, optional. Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1).</p>
<p>fill_value ：缺失值NaN的替代值</p>
<p>method： = ffill /bfill；向前填充/向后填充；<strong>只适用于单调增长/减少的索引</strong></p>
<p>limit： 向前或向后填充的最大填充量； 向前，即正向填充，向后一位数字（数值2位于1的前面）</p>
<p>level ：</p>
<p>copy： 默认为True，无论如何都复制；若为False，则新旧不相等时复制</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">           http_status  response_time</div><div class="line">Firefox            <span class="number">200</span>           <span class="number">0.04</span></div><div class="line">Chrome             <span class="number">200</span>           <span class="number">0.02</span></div><div class="line">Safari             <span class="number">404</span>           <span class="number">0.07</span></div><div class="line">IE10               <span class="number">404</span>           <span class="number">0.08</span></div><div class="line">Konqueror          <span class="number">301</span>           <span class="number">1.00</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex([<span class="string">'http_status'</span>, <span class="string">'user_agent'</span>], axis=<span class="string">"columns"</span>)</div><div class="line">           http_status  user_agent</div><div class="line">Firefox            <span class="number">200</span>         NaN</div><div class="line">Chrome             <span class="number">200</span>         NaN</div><div class="line">Safari             <span class="number">404</span>         NaN</div><div class="line">IE10               <span class="number">404</span>         NaN</div><div class="line">Konqueror          <span class="number">301</span>         NaN</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将制定的列提到最前面</span></div><div class="line">df.reindex([<span class="string">'mean'</span>] + list(df.columns[:<span class="number">-1</span>]), axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li><strong>df.index.is_unique()</strong>：判断<strong>索引值是否唯一</strong>，若某个索引对应多个值，则返回一个Series，否则返回单个值</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="排名-rank"><a href="#排名-rank" class="headerlink" title="排名 - rank"></a>排名 - rank</h3><ul>
<li><strong>df.rank(method = ‘’)</strong>：会把对象的 values <strong>替换成名次</strong> <ul>
<li>排名作用与排序的不同之处在于，它会<strong>把对象的 values 替换成名次</strong>。 这时唯一的问题在于如何处理<strong>平级项</strong>，方法里的 method 参数就是起这个作用的</li>
</ul>
</li>
</ul>
<blockquote>
<p>method 排名时处理平级值的方式。</p>
<p>average ：默认，为各个值分配平均排名</p>
<p>min：使用整个分组的 [最小] 排名</p>
<p>max：使用整个分组的 [最大] 排名</p>
<p>first：按值在原始数据中的出现顺序分配排名</p>
<ul>
<li>max 与 min的区别：相等时，显示的排名按最大/最小排名来显示</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ------------示例-------------</span></div><div class="line">obj = Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]) </div><div class="line">obj.rank(method=<span class="string">'max'</span>)  <span class="comment"># 对于3这个值，最大排序为4，所以显示4</span></div><div class="line"><span class="number">0</span>    <span class="number">1.0</span></div><div class="line"><span class="number">1</span>    <span class="number">2.0</span></div><div class="line"><span class="number">2</span>    <span class="number">4.0</span></div><div class="line"><span class="number">3</span>    <span class="number">4.0</span></div><div class="line"><span class="number">4</span>    <span class="number">7.0</span></div><div class="line"><span class="number">5</span>    <span class="number">7.0</span></div><div class="line"><span class="number">6</span>    <span class="number">7.0</span></div><div class="line"></div><div class="line">obj.rank(method=<span class="string">'min'</span>)  <span class="comment"># 对于3这个值，最下排序为3，所以显示3</span></div><div class="line"><span class="number">0</span>    <span class="number">1.0</span></div><div class="line"><span class="number">1</span>    <span class="number">2.0</span></div><div class="line"><span class="number">2</span>    <span class="number">3.0</span></div><div class="line"><span class="number">3</span>    <span class="number">3.0</span></div><div class="line"><span class="number">4</span>    <span class="number">5.0</span></div><div class="line"><span class="number">5</span>    <span class="number">5.0</span></div><div class="line"><span class="number">6</span>    <span class="number">5.0</span></div></pre></td></tr></table></figure>
<br>

<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ul>
<li>​</li>
</ul>
<p><br></p>
<h3 id="布局转换-长宽格式"><a href="#布局转换-长宽格式" class="headerlink" title="布局转换 - 长宽格式"></a>布局转换 - 长宽格式</h3><blockquote>
<p><strong>宽格式 $\to$  长格式</strong></p>
</blockquote>
<ul>
<li><strong>df.melt(id_vars=[‘A’], value_vars=[‘B’, ‘C’])</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">df.melt(id_ars=[], value_vars=[], var_name=<span class="string">''</span>, value_name=<span class="string">''</span>)</div><div class="line"><span class="comment">## id_vars，以该变量为基准进行重构</span></div><div class="line"><span class="comment">## vaule_vars，需要将哪些变量组合进id列的变量，其值自动填充</span></div><div class="line"></div><div class="line"><span class="comment"># 示例-------------------</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">   A  B  C</div><div class="line"><span class="number">0</span>  a  <span class="number">1</span>  <span class="number">2</span></div><div class="line"><span class="number">1</span>  b  <span class="number">3</span>  <span class="number">4</span></div><div class="line"><span class="number">2</span>  c  <span class="number">5</span>  <span class="number">6</span></div><div class="line"></div><div class="line">df.melt(id_vars=[<span class="string">'A'</span>], value_vars=[<span class="string">'B'</span>, <span class="string">'C'</span>])</div><div class="line"></div><div class="line">   A variable  value</div><div class="line"><span class="number">0</span>  a        B      <span class="number">1</span></div><div class="line"><span class="number">1</span>  b        B      <span class="number">3</span></div><div class="line"><span class="number">2</span>  c        B      <span class="number">5</span></div><div class="line"><span class="number">3</span>  a        C      <span class="number">2</span></div><div class="line"><span class="number">4</span>  b        C      <span class="number">4</span></div><div class="line"><span class="number">5</span>  c        C      <span class="number">6</span></div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p><strong>长格式 $\to$ 宽格式</strong></p>
</blockquote>
<ul>
<li><strong>df.pivot(val1, val2, val3)</strong>：将df的val1作为<strong>[行]</strong>索引的列名，val2为用作<strong>[列]</strong>索引的列名，val3作为用于<strong>[填列值]</strong>的列名</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="层次化索引的重塑-stack"><a href="#层次化索引的重塑-stack" class="headerlink" title="层次化索引的重塑 - stack"></a>层次化索引的重塑 - stack</h3><ul>
<li>stack()：列转行；将数据的列 “旋转” 为行</li>
<li>unstack()：列转行；将数据的行 “旋转” 为列</li>
</ul>
<blockquote>
<p>stack操作的是对<strong>最内层的索引</strong>进行操作。</p>
<blockquote>
<p>若用字符串表示，则直接输入该索引的名称 .stack(‘number’)</p>
<p>若用数字表示，0 - 第一层索引； 1 - 第二层索引</p>
</blockquote>
</blockquote>
<p><br></p>
<h3 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h3><ul>
<li><strong>df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)</strong>：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表</li>
</ul>
<p><br></p>
<h2 id="格式：数字、时间与日期"><a href="#格式：数字、时间与日期" class="headerlink" title="格式：数字、时间与日期"></a>格式：数字、时间与日期</h2><blockquote>
<p><strong>pandas库是基于整列的操作</strong></p>
</blockquote>
<h3 id="格式转换-通用"><a href="#格式转换-通用" class="headerlink" title="格式转换 - 通用"></a>格式转换 - 通用</h3><ul>
<li>DataFrame<strong>.astype</strong>(dtype, copy=True, errors=’raise’, **kwargs) ：Cast a pandas object to a specified dtype <code>dtype</code></li>
</ul>
<blockquote>
<p><strong>dtype</strong> : data type, or dict of column name</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ser = pd.Series([<span class="number">1</span>, <span class="number">2</span>], dtype=<span class="string">'int32'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ser</div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line">dtype: int32</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ser.astype(<span class="string">'int64'</span>)</div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line">dtype: int64  <span class="comment"># dtype 注意此处</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="数字操作"><a href="#数字操作" class="headerlink" title="数字操作"></a>数字操作</h3><h4 id="格式转换-1"><a href="#格式转换-1" class="headerlink" title="格式转换"></a>格式转换</h4><ul>
<li>pandas.<strong>to_numeric</strong>(arg, errors=’raise’, downcast=None) ：将变量<strong>转为数值类型</strong></li>
</ul>
<blockquote>
<p><strong>arg</strong> : list, tuple, 1-d array, or Series</p>
<p><strong>downcast</strong> : {‘integer’, ‘signed’, ‘unsigned’, ‘float’} , default None</p>
<ul>
<li>‘integer’ or ‘signed’: smallest signed int dtype (min.: np.int8)</li>
<li>‘unsigned’: smallest unsigned int dtype (min.: np.uint8)</li>
<li>‘float’: smallest float dtype (min.: np.float32)</li>
</ul>
</blockquote>
<p><br></p>
<p><br></p>
<h4 id="数字格式定义"><a href="#数字格式定义" class="headerlink" title="数字格式定义"></a>数字格式定义</h4><ul>
<li><strong>str.format( { : } )</strong>  ：格式化输出字符串使用<strong>format()</strong>函数, 字符串即<strong>类</strong>, 可以使用方法。可使用 <code>print(&quot;FORMAT&quot;.format(NUMBER));</code> 来运行示例  <a href="http://blog.xiayf.cn/2013/01/26/python-string-format/" target="_blank" rel="external">http://blog.xiayf.cn/2013/01/26/python-string-format/</a><ul>
<li><strong>语法是{ }中带 : 号</strong>   <code>&#39;{:,}&#39;.format(&#39;str&#39;)</code></li>
<li>符号 <code>{}</code> 是替换变量的占位符</li>
<li>转义大括号：若你需要使用大括号，只要写两次就可以了</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串的参数使用 <strong>{ num }</strong> 进行表示 ,<strong>0, 表示第一个参数</strong>,<strong>1, 表示第二个参数</strong> </p>
<p>使用<strong>“:”</strong>, 指定代表元素需要的<strong>操作</strong>  , 如”:.3”小数点三位, “:8”占8个字符空间等;</p>
<p>添加特定的<strong>字母</strong></p>
<blockquote>
<p><strong>‘b’</strong> - 二进制. 将数字以2为基数进行输出.</p>
<p>‘c’ - 字符. 在打印之前将整数转换成对应的Unicode字符串.</p>
<p><strong>‘d’</strong> - 十进制整数. 将数字以10为基数进行输出.</p>
<p>‘o’ - 八进制. 将数字以8为基数进行输出. </p>
<p>‘x’ - 十六进制. 将数字以16为基数进行输出, 9以上的位数用小写字母.</p>
<p><strong>‘e’</strong> - 幂符号. 用科学计数法打印数字, 用’e’表示幂. </p>
<p>‘g’ - 一般格式. 将数值以fixed-point格式输出. 当数值特别大的时候, 用幂形式打印. </p>
<p>‘n’ - 数字. 当值为整数时和’d’相同, 值为浮点数时和’g’相同. 不同的是它会根据区域设置插入数字分隔符. </p>
<p><strong>‘%’</strong> - 百分数. 将数值乘以100然后以fixed-point(‘f’)格式打印, 值后面会有一个百分号. </p>
</blockquote>
<p><strong>对齐方式</strong></p>
<blockquote>
<p>&lt; （默认）左对齐</p>
<p>> 右对齐</p>
<p>^ 中间对齐</p>
<p>= （只用于数字）在小数点后进行补齐</p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># 主要用法 </div><div class="line">'&#123;:,&#125;'.format('str')</div><div class="line"></div><div class="line"></div><div class="line"># 符号 &#123;&#125; 是替换变量的占位符。若没有指定格式，则直接将变量值作为字符串插入。 </div><div class="line">"glazed with &#123;&#125; water beside the &#123;&#125; chickens".format("rain", "white")</div><div class="line"></div><div class="line"></div><div class="line"># 可以使用变量的位置数值，在字符串中改变它们，进行格式化时。如果搞错了顺序，你可以轻易地修正而不需要打乱所有的变量。</div><div class="line">s1 = " &#123;0&#125; is better than &#123;1&#125; ".format("emacs", "vim")</div><div class="line">s2 = " &#123;1&#125; is better than &#123;0&#125; ".format("emacs", "vim")</div><div class="line"></div><div class="line"># 默认顺序为0</div><div class="line">str = "Oh &#123;0&#125;, &#123;0&#125;! wherefore art thou &#123;0&#125;?".format("Romeo")</div><div class="line">&gt;&gt;&gt; Oh Romeo, Romeo! wherefore art thou Romeo?</div><div class="line"></div><div class="line"># 命名参数：将新的格式字符串用作模板引擎，使用命名参数，这样就不要求有严格的顺序。</div><div class="line">madlib = " I &#123;verb&#125; the &#123;object&#125; off the &#123;place&#125; ".format(verb="took", object="cheese", place="table")</div><div class="line">&gt;&gt;&gt; I took the cheese off the table</div><div class="line"></div><div class="line"># 转义大括号：若你需要使用大括号，只要写两次就可以了</div><div class="line">print(" The &#123;&#125; set is often represented as &#123; &#123;0&#125; &#125; ".format("empty"))</div></pre></td></tr></table></figure>
<p><br></p>
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>+3.14</td>
<td><strong>带符号</strong>保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td>{:+.2f}</td>
<td>-1.00</td>
<td><strong>带符号</strong>保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:, }</td>
<td>1,000,000</td>
<td>以<strong>逗号分隔</strong>的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td><strong>百分比</strong>格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为10)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<p>【应用到列】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义函数</span></div><div class="line">de format_qian(a):</div><div class="line">  b = <span class="string">'&#123;:,&#125;'</span>.format(a)</div><div class="line">  retrun(b)</div><div class="line">  </div><div class="line">qian_all_data[<span class="string">'参与人次'</span>].apply(format_qian)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h3><h4 id="格式转换-2"><a href="#格式转换-2" class="headerlink" title="格式转换"></a>格式转换</h4><p>#####转为日期格式</p>
<ul>
<li>pandas.<strong>to_datetime</strong>( arg, errors=’raise’, dayfirst=False, yearfirst=False, utc=None, box=True, format=None, exact=True, unit=None, infer_datetime_format=False, origin=’unix’ )：将字符类型转化成<strong>时间格式</strong></li>
</ul>
<blockquote>
<p><strong>dayfirst</strong> : boolean, default False ;  If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10.</p>
<p><strong>box</strong> : boolean, default True</p>
<ul>
<li>If True returns a DatetimeIndex</li>
<li>If False returns ndarray of values.</li>
</ul>
<p><strong>format</strong> : string, default None</p>
<p><strong>errors</strong> : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’</p>
<ul>
<li>If ‘raise’, then invalid parsing will raise an exception <strong>引发异常</strong></li>
<li>If ‘coerce’, then invalid parsing will be set as NaT </li>
<li>If ‘ignore’, then invalid parsing will return the input</li>
</ul>
<p><strong>unit</strong> : string, default ‘ns’</p>
<blockquote>
<p>unit of the arg (D,s,ms,us,ns) denote the unit</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'year'</span>: [<span class="number">2015</span>, <span class="number">2016</span>],</div><div class="line">                       <span class="string">'month'</span>: [<span class="number">2</span>, <span class="number">3</span>],</div><div class="line">                       <span class="string">'day'</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_datetime(df)</div><div class="line"><span class="number">0</span>   <span class="number">2015</span><span class="number">-02</span><span class="number">-04</span></div><div class="line"><span class="number">1</span>   <span class="number">2016</span><span class="number">-03</span><span class="number">-05</span></div><div class="line">dtype: datetime64[ns]</div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment"># 指定格式  </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_datetime(<span class="string">'13000101'</span>, format=<span class="string">'%Y%m%d'</span>, errors=<span class="string">'ignore'</span>)</div><div class="line">datetime.datetime(<span class="number">1300</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p>#####转为日期差值</p>
<ul>
<li>pandas.<strong>to_timedelta</strong>(arg, unit=’ns’, box=True, errors=’raise’) ：Convert argument to timedelta<ul>
<li>timedelta <strong>表示两个datetime之间的时间差。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_timedelta([<span class="string">'1 days 06:05:01.00003'</span>, <span class="string">'15.5us'</span>, <span class="string">'nan'</span>])</div><div class="line">TimedeltaIndex([<span class="string">'1 days 06:05:01.000030'</span>, <span class="string">'0 days 00:00:00.000015'</span>, NaT],</div><div class="line">               dtype=<span class="string">'timedelta64[ns]'</span>, freq=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<ul>
<li>DatetimeIndex<strong>.strftime(date_format)</strong> ：返回指定格式的<strong>字符串格式</strong></li>
</ul>
<p><br></p>
<ul>
<li>Series<strong>.dt.strftime</strong>(*args, **kwargs) ：<strong>单列</strong>转为字符串格式，<strong>格式化输出</strong></li>
</ul>
<blockquote>
<p><strong>date_format</strong> : str ;      date format string (e.g. “%Y-%m-%d”)</p>
</blockquote>
<ul>
<li><p>Timestamp<strong>.strptime()</strong> ：string, format -&gt; new datetime parsed from a string (like time.strptime()).</p>
<p>​</p>
</li>
</ul>
<p><br></p>
<p>####基本操作</p>
<p><strong>【选取】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 过滤某个时间片的数据&amp;取某个时间片的数据</span></div><div class="line">df[df[<span class="string">'date'</span>]&lt;=pd.datetime(<span class="number">2016</span>,<span class="number">6</span>,<span class="number">10</span>)]</div></pre></td></tr></table></figure>
<p><strong>【返回】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 返回某个日期是周几</span></div><div class="line">pd.to_datetime(df[<span class="string">'date'</span>]).dt.weekday_name   <span class="comment"># 返回星期名；</span></div><div class="line"></div><div class="line">pd.to_datetime(df[<span class="string">'date'</span>]).dt.weekday  <span class="comment"># 返回数字；</span></div></pre></td></tr></table></figure>
<p><strong>【判断】</strong></p>
<ul>
<li><strong>dt.is_month_start</strong> ：判断是否为一个月的第一天</li>
<li><strong>dt.is_month_end</strong>：判断是否为一个月的最后一天</li>
</ul>
<p><br></p>
<p><br></p>
<h4 id="日期格式定义"><a href="#日期格式定义" class="headerlink" title="日期格式定义"></a>日期格式定义</h4><p><strong>【datetime格式定义】</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>4位数的年</td>
</tr>
<tr>
<td>%y</td>
<td>2位数的年</td>
</tr>
<tr>
<td>%m</td>
<td>2位数的月 [01, 12]</td>
</tr>
<tr>
<td>%d</td>
<td>2位数的日 [01, 31]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%F</td>
<td>%Y-%m-%d 简写形式；2012-04-18</td>
</tr>
<tr>
<td>%D</td>
<td>%m/%d/%y 简写形式；04/18/12</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>时间（24小时制） [00, 23]</td>
</tr>
<tr>
<td>%I</td>
<td>时间（12小时制） [00, 12]</td>
</tr>
<tr>
<td>%M</td>
<td>2位数的分钟 [00, 59]</td>
</tr>
<tr>
<td>%S</td>
<td>秒 [00, 61] (秒60和61用于闰秒)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%w</td>
<td>用整数表示的星期几 （星期天为第0天） [0, 6]</td>
</tr>
<tr>
<td>%U</td>
<td>每年的第几周 [00, 53]。<strong>星期天被认为是每周的第一天</strong>，每年第一个星期天之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td>%W</td>
<td>每年的第几周 [00, 53]。<strong>星期一被认为是每周的第一天</strong>，每年第一个星期一之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%z</td>
<td>以+HHMM 或-HHMM 表示的UTC时区偏移量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>【特定于当前环境的日期格式】</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a</td>
<td>星期几的简写</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的全称</td>
</tr>
<tr>
<td>%b</td>
<td>月份的简写</td>
</tr>
<tr>
<td>%B</td>
<td>月份的全称</td>
</tr>
<tr>
<td>%c</td>
<td>完成的日期和时间；Tue 01 May 2012 04:20:57 pm</td>
</tr>
<tr>
<td>%p</td>
<td>不同环境中的AM 或PM</td>
</tr>
<tr>
<td>%x</td>
<td>适用于当前环境的日期格式  ；若在美国， “May 1 2012” 会产生 “05/01/2012”</td>
</tr>
<tr>
<td>%X</td>
<td>适用于当前环境的时间格式； “04:24:12 PM”</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><br></p>
<p><br></p>
<p>##合并数据</p>
<h3 id="横向合并-类同-join"><a href="#横向合并-类同-join" class="headerlink" title="横向合并 - 类同 join"></a>横向合并 - 类同 join</h3><ul>
<li><p><strong>DataFrame</strong>.<strong>join(other, <em>on=None</em>, <em>how=’left’</em>, <em>lsuffix=’’</em>, <em>rsuffix=’’</em>, <em>sort=False</em>)</strong> </p>
<blockquote>
<p><strong>other : DataFrame, Series with name field set, or list of DataFrame</strong></p>
<ul>
<li>方法对象必须是DataFrame，但join的对象可以是多个类型的；通用性比 <code>pd.merge</code> 更加好</li>
</ul>
<p><strong>on</strong> ：若不指定，按照索引来进行join； column name, tuple/list of column names, or array-like Column(s) in the caller to join on the index in other.</p>
<p><strong>lsuffix</strong> / <strong>rsuffix</strong>  : string. Suffix to use from left /right frame’s overlapping columns； 均在已有列名之后跟字符串</p>
<p><strong>sort</strong> : boolean, default False</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用索引进行连接</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>caller.join(other, lsuffix=<span class="string">'_caller'</span>, rsuffix=<span class="string">'_other'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>    A key_caller    B key_other</div><div class="line">    <span class="number">0</span>  A0         K0   B0        K0</div><div class="line">    <span class="number">1</span>  A1         K1   B1        K1</div><div class="line">    <span class="number">2</span>  A2         K2   B2        K2</div><div class="line">    <span class="number">3</span>  A3         K3  NaN       NaN</div><div class="line">    <span class="number">4</span>  A4         K4  NaN       NaN</div><div class="line">    <span class="number">5</span>  A5         K5  NaN       NaN</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># 使用关键列进行连接；需要指定连接的列名</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>caller.join(other.set_index(<span class="string">'key'</span>), on=<span class="string">'key'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>pd.merge(df1,df2, on =’val’, how=’inner’)</strong>：将df1，df2根据val列进行内联接<ul>
<li><strong>pd.merge(df1, df2, on = ,[left_on=] how = , [left_index=False, srot=True, copy=True, suffixes=(‘_x’,’_y’)])</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>df1, df2 ：必须都是DataFrame</strong></p>
<p>on = ‘val’  用于连接的列名；若不指定则以列名的交集作为连接列</p>
<ul>
<li>当涉及左右两个表单列名不相同时，需使用left_on / right_on</li>
<li>left_on = ‘val1’   左侧表中用作连接的列</li>
<li>right_on = ‘val2’  右侧表中用作连接的列</li>
</ul>
<p>left_index / right_index =True ,将索引列作为 [连接列]</p>
<p>how = ‘inner’ / ‘left’ / ‘right’ / ‘outer’   （outer为求并集）</p>
<p>sort = True/False ，根据连接列对合并的数据进行排序，默认为True</p>
<p>suffixs，字符串元组，在两个表中有重复的列名时，可用将字符串追加到重叠列名的末尾，默认为(‘_x’,’_y’)</p>
<p>copy = True，默认为True，即将结果复制到数据结构中</p>
</blockquote>
<p><br></p>
<blockquote>
<p>对于层次化索引，以 <strong>[列表的形式]</strong> 指名作用合并键的多个列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; pd.merge(lefth, righth, left_on = [<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="keyword">True</span>)</div><div class="line">&gt;    data   key1  key2  event1  event2</div><div class="line">&gt; <span class="number">0</span>     <span class="number">0</span>   Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></div><div class="line">&gt; <span class="number">0</span>     <span class="number">0</span>   Ohio  <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></div><div class="line">&gt; <span class="number">1</span>     <span class="number">1</span>   Ohio  <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></div><div class="line">&gt; <span class="number">2</span>     <span class="number">2</span>   Ohio  <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></div><div class="line">&gt; <span class="number">3</span>     <span class="number">3</span>  Nevda  <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></div><div class="line">&gt;</div><div class="line">&gt; lefth</div><div class="line">&gt;    data   key1  key2</div><div class="line">&gt; <span class="number">0</span>     <span class="number">0</span>   Ohio  <span class="number">2000</span></div><div class="line">&gt; <span class="number">1</span>     <span class="number">1</span>   Ohio  <span class="number">2001</span></div><div class="line">&gt; <span class="number">2</span>     <span class="number">2</span>   Ohio  <span class="number">2002</span></div><div class="line">&gt; <span class="number">3</span>     <span class="number">3</span>  Nevda  <span class="number">2001</span></div><div class="line">&gt; <span class="number">4</span>     <span class="number">4</span>  Nevda  <span class="number">2002</span></div><div class="line">&gt;</div><div class="line">&gt; righth</div><div class="line">&gt;             event1  event2</div><div class="line">&gt; Nevda <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></div><div class="line">&gt;       <span class="number">2000</span>       <span class="number">2</span>       <span class="number">3</span></div><div class="line">&gt; Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></div><div class="line">&gt;       <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></div><div class="line">&gt;       <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></div><div class="line">&gt;       <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<h3 id="纵向合并-增加行"><a href="#纵向合并-增加行" class="headerlink" title="纵向合并 - 增加行"></a>纵向合并 - 增加行</h3><ul>
<li><strong>df1.append(df2)</strong>：将df2中的 <strong>[行]</strong> 添加到df1的尾部</li>
</ul>
<ul>
<li><strong>df.concat([df1,df2], ignore_index = True)</strong> ：纵向合并，将df2中的 <strong>[所有行] 添加到df1的尾部</strong></li>
</ul>
<blockquote>
<p>ignore_index = True，表示进行纵向合并，不保留轴上的索引，产生一组新的索引 </p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="数据选取与删除"><a href="#数据选取与删除" class="headerlink" title="数据选取与删除"></a>数据选取与删除</h2><h3 id="行列选取"><a href="#行列选取" class="headerlink" title="行列选取"></a>行列选取</h3><blockquote>
<p>涉及<strong>布尔判断</strong>时，默认的对象为<strong>所有观测行的所有列</strong></p>
<p>选取的内容会包含<strong>索引</strong>与<strong>数值</strong></p>
<p>通过索引方式返回的列只是相应数据的视图。对此所做的任何修改，<strong>会直接反映到源数据。</strong></p>
</blockquote>
<ul>
<li><strong>df[col]</strong>：根据列名，并以<strong>Series的形式</strong>返回 [列]</li>
<li><strong>df[ [col1, col2] ]</strong>：以<strong>DataFrame形式</strong>返回 [多列]</li>
<li><strong>df[ df[col] &gt; 0.5 ]</strong>：选择col列的值大于0.5的所有行<ul>
<li>先对 df[col] &gt;0.5 进行布尔判断，返回True 和 False，再选取所有True的值</li>
<li><strong><u>对具体的观测行进行条件选取</u></strong> ；等价于 <code>Select * From table where col &gt; 0.5</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>也可为布尔型数组(过滤行)、切片（行切片）、布尔型DataFrame</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 指定列中的特定值，并返回所有的行</span></div><div class="line">data[data[<span class="string">'three'</span>]&gt;<span class="number">5</span>]</div><div class="line">          one  two  three  four</div><div class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></div><div class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></div><div class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></div><div class="line"></div><div class="line"><span class="comment"># 返回布尔值</span></div><div class="line">data &gt; <span class="number">5</span></div><div class="line">            one    two  three   four</div><div class="line">Ohio      <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span></div><div class="line">Colorado  <span class="keyword">False</span>  <span class="keyword">False</span>   <span class="keyword">True</span>   <span class="keyword">True</span></div><div class="line">Utah       <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span></div><div class="line">New York   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>df.loc[ n [, m] ]</strong> ：通过 <strong>[ 行标签 ] </strong>索引<strong>行数据</strong> 。 主要基于<strong><u>标签</u></strong>的, 但也可以与<strong><u>布尔数组</u></strong>一起使用。<ul>
<li>n 为行标签；若行标签为字符串，则也需要用字符串表示。loc[‘d’] 表示索引的是第’d’行（index 是字符）</li>
<li>若出现m，则表示可以索引行与列</li>
<li><strong>起始索引值为0；</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>df.iloc[ n [,m] ]</strong>：通过 <strong>[ 行号 ] </strong> 索引<strong>行数据</strong> 。 主要基于<strong><u>整数位置</u></strong> (从0到 length-1 轴), 但也可以与<strong><u>布尔数组</u></strong>一起使用。<ul>
<li>n 为行号；</li>
<li>若出现m，则表示可以索引行与列</li>
</ul>
</li>
</ul>
<blockquote>
<p>loc 在index的标签上进行索引,<strong>范围包括start和end.</strong> </p>
<p>iloc 在index的位置上进行索引,<strong>不包括end.</strong> </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ---- loc -------</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </div><div class="line">index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]  </div><div class="line">columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]  </div><div class="line">df = pd.DataFrame(data=data, index=index, columns=columns)  </div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df </div><div class="line">a	b	c</div><div class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line"><span class="number">1</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></div><div class="line"><span class="number">2</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">9</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span> df[<span class="number">0</span>:<span class="number">1</span>]</div><div class="line">a	b	c</div><div class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line"><span class="number">1</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></div><div class="line"></div><div class="line"><span class="comment"># 索引某行某列</span></div><div class="line">df.loc[<span class="string">'d'</span>,[<span class="string">'b'</span>,<span class="string">'c'</span>]]  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ---- iloc -------</span></div><div class="line"><span class="comment">## 索引第一列的所有数据</span></div><div class="line">df.iloc[:,[<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="多条件选取"><a href="#多条件选取" class="headerlink" title="多条件选取"></a>多条件选取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </div><div class="line">index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]  </div><div class="line">columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]  </div><div class="line">df = pd.DataFrame(data=data, index=index, columns=columns)  </div><div class="line"></div><div class="line"><span class="comment"># 所有列的多条件选取</span></div><div class="line">df[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>)]</div><div class="line"></div><div class="line">    a	b	c</div><div class="line"><span class="number">1</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></div><div class="line"><span class="number">2</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">9</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 指定列的多条件选取</span></div><div class="line">df[<span class="string">'c'</span>][(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>)]</div><div class="line"><span class="number">1</span>    <span class="number">6</span></div><div class="line"><span class="number">2</span>    <span class="number">9</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 指定列的多条件选取</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>),<span class="string">'c'</span>]</div><div class="line"><span class="number">1</span>    <span class="number">6</span></div><div class="line"><span class="number">2</span>    <span class="number">9</span></div><div class="line">Name: c, dtype: int64</div><div class="line"><span class="comment"># 指定多列的 多条件选择</span></div><div class="line">df.loc[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>),<span class="string">'b'</span>:<span class="string">'c'</span>]</div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line"><span class="comment"># 获取值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>),<span class="string">'c'</span>].values</div><div class="line">array([<span class="number">6</span>, <span class="number">9</span>], dtype=int64)</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>df.ix[1, val ] 因为容易混淆，建议不使用。</p>
</blockquote>
<ul>
<li><strong>df.ix[1, val ]</strong>：<strong>既能通过行号，也可以通过索引位置来进行选取</strong>，但ix中的索引<strong>右端为包含</strong>； 因为容易混淆，建议不要使用。<ul>
<li><strong>若行的索引名为数字时，在进行选中时，选择的为行索引的数值名称，而非位置</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 因行索引不为数字，故代表位置，右端不包含</span></div><div class="line">data.ix[<span class="number">0</span>:<span class="number">2</span>]</div><div class="line">          one  two  three  four</div><div class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></div><div class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></div><div class="line"></div><div class="line"><span class="comment"># 因行索引为数字，故代表的为行索引的名称</span></div><div class="line">data.ix[<span class="number">0</span>:<span class="number">2</span>]</div><div class="line">	Id	Survived</div><div class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">0</span></div><div class="line"><span class="number">1</span>	<span class="number">2</span>	<span class="number">1</span></div><div class="line"><span class="number">2</span>	<span class="number">3</span>	<span class="number">1</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###条件选取 - filter</p>
<ul>
<li><strong>df.filter(item=[val], like= , regex=’’, axis=1)</strong>：选择DataFrame中满足条件的子集<ul>
<li><strong><u>filter的条件判断是对 行索引/ 列名 进行的匹配，而非具体的观测值</u></strong></li>
</ul>
</li>
</ul>
<blockquote>
<p> item：指定的列名；若不指定，则表示全体</p>
<p> regex：满足正则表达式的<strong>列名</strong> ，此时axis=1</p>
<p> like ：满足like的行索引的<strong>所有行</strong>，此时axis=0  （该功能是SQL中没有的）</p>
<p> axis = 1 ：基于列； </p>
<p> axis = 0 ：基于行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">one  two  three</div><div class="line">mouse     <span class="number">1</span>    <span class="number">2</span>      <span class="number">3</span></div><div class="line">rabbit    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># select columns by name</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.filter(items=[<span class="string">'one'</span>, <span class="string">'three'</span>])</div><div class="line">         one  three</div><div class="line">mouse     <span class="number">1</span>      <span class="number">3</span></div><div class="line">rabbit    <span class="number">4</span>      <span class="number">6</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># select columns by regular expression</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.filter(regex=<span class="string">'e$'</span>, axis=<span class="number">1</span>)</div><div class="line">         one  three</div><div class="line">mouse     <span class="number">1</span>      <span class="number">3</span></div><div class="line">rabbit    <span class="number">4</span>      <span class="number">6</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># select rows containing 'bbi'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.filter(like=<span class="string">'bbi'</span>, axis=<span class="number">0</span>)</div><div class="line">one  two  three</div><div class="line">rabbit    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###随机与排序选取</p>
<ul>
<li><strong>df.sample(frac=0.5)</strong>：随机选取所有数据中的50%的观测行</li>
<li><strong>df.sample(n=10)</strong>：随机选取10行</li>
<li><strong>df.nlargest(n, ‘value’)</strong>：根据’value’进行排列，并选取最前面的n个值</li>
<li><strong>df.nsmallest(n, ‘value’)</strong>:根据n进行排序，并选取最后面的n个值</li>
</ul>
<ul>
<li>s.iloc[0]：按位置选取数据</li>
<li>s.loc[‘index_one’]：按索引选取数据</li>
</ul>
<br>



<h3 id="重复值-duplicated"><a href="#重复值-duplicated" class="headerlink" title="重复值 - duplicated"></a>重复值 - duplicated</h3><ul>
<li><strong>df.duplicated()</strong>：<strong>判断</strong>是否有重复行</li>
<li><strong>df.duplicates()</strong>：<strong>移除</strong>重复行，默认<strong>保留第一个出现的值</strong>组合<ul>
<li><strong>df.duplicates([val1, val2], take_last=True)</strong>：指定部分列进行重复项判断； take_last=True 指定保留最后一个</li>
</ul>
</li>
</ul>
<ul>
<li>s.dropna()：将Series中删除所有包含空值的行</li>
<li>s.astype(float)：将Series中的数据类型更改为float类型</li>
<li>s.replace(1,’one’)：用‘one’代替所有等于1的值</li>
<li>s.replace([1,3],[‘one’,’three’])：用’one’代替1，用’three’代替3</li>
</ul>
<p><br></p>
<h3 id="唯一值-unique"><a href="#唯一值-unique" class="headerlink" title="唯一值 - unique"></a>唯一值 - unique</h3><ul>
<li><strong>df[‘val’].unique</strong>：返回某一列的唯一值</li>
<li><strong>df.[‘val’].value_conuts</strong>：计算列中每个值出现的次数</li>
</ul>
<p><br></p>
<h3 id="数据删除-drop"><a href="#数据删除-drop" class="headerlink" title="数据删除 - drop"></a>数据删除 - drop</h3><ul>
<li><strong>df.drop(val, axis=0 )</strong>：删除<strong>索引行/变量列</strong>，并返回一个<strong>新的对象</strong></li>
</ul>
<blockquote>
<p><strong>axis默认为0</strong>，删除索引为val1,val2的<strong>观测 [行]</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.drop([val1,val2], axis=<span class="number">1</span>)  <span class="comment"># 删除列名为val1,val2的 [列]，并返回一个新的对象；</span></div></pre></td></tr></table></figure>
<ul>
<li>s.drop()</li>
</ul>
<p><br></p>
<h3 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h3><h3 id="返回某列中不为NUll的所有行"><a href="#返回某列中不为NUll的所有行" class="headerlink" title="返回某列中不为NUll的所有行"></a>返回某列中不为NUll的所有行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data1 = data0[data0[<span class="string">'column'</span>].notnull()]</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="创建新变量"><a href="#创建新变量" class="headerlink" title="创建新变量"></a>创建新变量</h2><blockquote>
<p><strong>往往需要用到apply函数，然后用 merge 或者 join 来进行合并</strong></p>
</blockquote>
<p><br></p>
<h3 id="增加列"><a href="#增加列" class="headerlink" title="增加列"></a>增加列</h3><ul>
<li><strong>df[‘Volumn’]</strong> = df.Length * df.Height</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">219</span>]: df[<span class="string">'b'</span>]=<span class="number">1</span>  </div><div class="line">  </div><div class="line">In [<span class="number">220</span>]: df  </div><div class="line">Out[<span class="number">220</span>]:   </div><div class="line">   c  a  b  </div><div class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">5</span>  <span class="number">1</span>  </div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>pd.Series</strong>(my_list)：从可迭代对象my_list创建一个Series对象</li>
</ul>
<blockquote>
<p>若不指定索引 index = [‘’, ‘’ ] ，则会自动创建从0开始的索引列</p>
<p>通过索引返回/赋值的数据，是对应数据的视图；<strong>所做的修改都会直接反映在源数据上；</strong></p>
<p>算术运算中，会<strong>自动对齐不同索引的数据</strong>，若<strong>对应索引不存在，则填充为NaN</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">obj2 = Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index = [<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])  <span class="comment"># 指定索引</span></div><div class="line"></div><div class="line"><span class="comment"># 字典创建：字典中的 键 = 索引</span></div><div class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Orgen'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</div><div class="line">obj3 = Series(sdata)</div></pre></td></tr></table></figure>
<ul>
<li><strong>df.index = pd.date_range</strong>(‘1900/1/30’, periods=df.shape[0])：增加一个日期索引</li>
</ul>
<p><br></p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul>
<li><strong>DataFrame.apply</strong>(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)<ul>
<li><strong>若提前定义了函数，默认将之前的才变量传入为第一个参数</strong>； 例如 apply(sum)，其实是将变量传递给sum()的第一个变量</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>func</strong> : Function to apply to <strong>each column/row</strong></p>
<ul>
<li>np.mean / np.sum  ：常规统计函数均可用np.xxx 表示对每一列使用该函数</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.apply(numpy.sum, axis=<span class="number">0</span>) <span class="comment"># equiv to df.sum(0)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义链接的函数；为apply做准备；</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(a)</span>:</span></div><div class="line">    a = str(a)  <span class="comment"># 必须是字符串格式</span></div><div class="line">    link = <span class="string">'http://xinyitong.gensee.com/webcast/site/entry/join-5c9543e2905146aa9a6f2b16bd1f6de0'</span></div><div class="line">    c = <span class="string">'?nickName=visitor'</span></div><div class="line">    <span class="keyword">return</span> (link + c + a)</div><div class="line">  </div><div class="line">  </div><div class="line">link_add = tb0[<span class="string">'员工编号'</span>].apply(link);</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="重编码-字符串"><a href="#重编码-字符串" class="headerlink" title="重编码 - 字符串"></a>重编码 - 字符串</h2><blockquote>
<p>字符串操作：Python内置、Re模块、矢量化操作</p>
<p>Re模块的函数主要分三个大类：匹配模式、替换、拆分</p>
<p><strong>矢量化”(简化)是重写循环的过程，使得不是将阵列的单个元素处理N次，而是将阵列的4个元素同时N / 4次处理。</strong></p>
<ul>
<li><strong>使用 str.func</strong> </li>
<li><strong>在str属性上使用索引</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># 使用str.func</span></div><div class="line">&gt; matches = df.str.match(pattern)</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment"># 在str属性上使用索引</span></div><div class="line">&gt; matches.str[<span class="number">0</span>]</div><div class="line">&gt;</div><div class="line">&gt; matches.str.get(<span class="number">1</span>)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<ul>
<li><strong>常常需要结合 apply 函数进行批量操作</strong></li>
</ul>
<p><br></p>
<h3 id="匹配-find-amp-match-amp-search"><a href="#匹配-find-amp-match-amp-search" class="headerlink" title="匹配 - find &amp; match &amp; search"></a>匹配 - find &amp; match &amp; search</h3><blockquote>
<p>Python 内置</p>
</blockquote>
<ul>
<li><strong>find()</strong>：返回<strong>第一个发现的子串的第一个字符</strong>所在的位置；否则返回 -1</li>
<li><strong>rfind()</strong>：返回<strong>最后一个发现的子串的第一个字符</strong>所在的位置；否则返回 -1</li>
<li><strong>index()</strong>：返回子串第一个字符所在的<strong>位置</strong>；若没有找到返回ValueError</li>
<li><strong>startswith() / endswith()</strong> ：判断字符是否以<strong>某个前缀/后缀 开始或结尾</strong>，返回True</li>
<li><strong>count</strong>：返回子串在字符串中出现的次数<strong>（非重复）</strong></li>
</ul>
<p><br></p>
<blockquote>
<p>Re模块</p>
</blockquote>
<ul>
<li><strong>match(pattern, string, flags=0)</strong>：字符串string的<strong>开头 开始搜索</strong>正则表达式模式pattern；若匹配成功，则返回一个匹配对象<u>（仅返回匹配的部分）</u>；否则返回None</li>
<li><strong>search(pattern,string, flags=0)</strong>：从字符串string中<strong>（任意位置）</strong>搜索正则表达式模式pattern <strong>第一次出现的地方</strong>； 如果匹配成功，则返回一个匹配对象；否则返回None</li>
<li><strong>findall(pattern, string [,flags])</strong> ：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，并返回一个匹配对象的 <strong>[列表 list]</strong></li>
<li><strong>finditer(pattern, string [, flags])</strong>：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，返回一个<strong>迭代器</strong>，该迭代器返回一个匹配对象</li>
</ul>
<p><br></p>
<blockquote>
<p>矢量化的字符串方法</p>
<p><strong>df.str.func</strong></p>
</blockquote>
<ul>
<li><p>match() ：根据指定的正则表达式<strong>对各个元素执行</strong>re.match</p>
</li>
<li><p>findall()</p>
</li>
<li><p>startswith / endswith </p>
</li>
<li><p><strong>contains()</strong> ：返回各字符串是<strong>否含有指定模式的布尔型数组</strong></p>
</li>
<li><p>count：模式出现的次数</p>
<p>​</p>
</li>
</ul>
<p><br></p>
<h3 id="替换-replace-amp-sub"><a href="#替换-replace-amp-sub" class="headerlink" title="替换 - replace &amp; sub"></a>替换 - replace &amp; sub</h3><blockquote>
<p>python内置</p>
</blockquote>
<ul>
<li><strong>strip / lstrip / rstrip</strong>：去除空格（包括换行符）。相当于对各个元素执行x.strip()</li>
<li><strong>ljust /rjust</strong> ：<strong>用空格（或其他字符）填充</strong>字符串的空白侧以返回符合最低宽度的字符串</li>
</ul>
<ul>
<li><p><strong>df.replace(1,’one’)</strong>：用‘one’代替所有等于1的值</p>
<ul>
<li><strong>df.replcae([1,2], [‘one’, ‘two’])</strong> ：多个值之间替换</li>
<li><strong>df.replace({-999:na.nan, -1000:0})</strong>： 传入的参数也可以是字典</li>
</ul>
<blockquote>
<p>replace - 替换； 此处的替换为<strong>对整个值进行查找</strong>，而非值中的部分值</p>
<p>eg: 第3个观测行daf\n ，无法用 data.replace(’\n‘, ‘’) 进行替换</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.replace(old, new [,max])  <span class="comment"># 将old值替换为new</span></div><div class="line"><span class="comment"># max，可选字符串, 替换不超过 max 次</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>lower / upper ()</strong> ：转化为小写/大写</li>
</ul>
<p><br></p>
<blockquote>
<p>Re模块</p>
</blockquote>
<ul>
<li><p><strong>re.sub(pattern, repl ,string, max = 0)</strong> : 把字符串string中所有匹配正则表达式pattern的地方 <strong>替换</strong>成 字符串 repl </p>
<ul>
<li>如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。</li>
</ul>
<blockquote>
<p>若max 的值没有给出，则对所有匹配的地方进行替换</p>
</blockquote>
</li>
<li><p><strong>subn()</strong> ：该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数</p>
</li>
</ul>
<p><br></p>
<blockquote>
<p>矢量化的字符串</p>
</blockquote>
<ul>
<li><strong>strip / lstrip / rstrip</strong>：去除空格（包括换行符）。相当于对各个元素执行x.strip()</li>
<li><strong>pad()</strong>：在字符串左边、右边或两侧添加空白符</li>
<li><strong>center()</strong>：相当于pad(side=’both’)</li>
<li><strong>replace()</strong>：用指定字符串替换找到的模式</li>
<li><strong>repeat()</strong>：重复值； s.str.repeat(3) 相当于对各个字符串执行 x *3 </li>
<li><strong>get()</strong>：获取各元素的第i个元素</li>
<li><strong>len()</strong>：计算各字符串长度</li>
<li><strong>lower / upper ()</strong> ：转化为小写/大写</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="分隔与连接"><a href="#分隔与连接" class="headerlink" title="分隔与连接"></a>分隔与连接</h3><blockquote>
<p>Python内置</p>
</blockquote>
<ul>
<li><p><strong>split</strong>：通过指定的分隔符将字符串拆分为一组子串</p>
</li>
<li><p><strong>‘sep’.join(seq)</strong> ：将字符串用作<strong>连接</strong>其他字符串序列的<strong>分隔符</strong></p>
<blockquote>
<p>sep：分隔符；可以为空</p>
<p>seq：要连接的元素序列、字符串、元组、字典</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq1 = [<span class="string">'hello'</span>,<span class="string">'good'</span>,<span class="string">'boy'</span>,<span class="string">'doiido'</span>]  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">':'</span>.join(seq1)  </div><div class="line">hello:good:boy:doiido</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>Re模块</p>
</blockquote>
<ul>
<li><strong>split</strong>：根据找到的模式将字符串<strong>拆分为数段</strong></li>
</ul>
<p><br></p>
<blockquote>
<p>矢量化字符串函数</p>
</blockquote>
<ul>
<li><strong>split()</strong></li>
<li><strong>slice()</strong>：对Series中的各个字符串进行子串截取；</li>
<li><strong>cat()</strong>：实现元素级的字符串连接操作，可指定分隔符</li>
</ul>
<p><br></p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><ol>
<li><strong>dir()</strong>：获得对象的所有属性与类型 </li>
<li><strong>type()</strong>  - 判断对象类型</li>
<li><strong>instance()</strong>  - 判断一个对象<strong>是否为某种类型：返回布尔值Ture/Falses</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 指定判断类型</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'a'</span>, str)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, int)</div><div class="line"><span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="comment"># 先创建判断的对象</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = Animal()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h = Husky()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(h, Husky)</div><div class="line"><span class="keyword">True</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 还可以判断一个变量是否是某些类型中的一种</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<blockquote>
<p>能用type()判断的基本类型也可以用isinstance()判断</p>
</blockquote>
<p><br></p>
<h3 id="常规格式转化"><a href="#常规格式转化" class="headerlink" title="常规格式转化"></a>常规格式转化</h3><ul>
<li>int(x [,base ]) ：将x转换为一个<strong>整数</strong></li>
<li>long(x [,base ]) ：将x转换为一个长整数    </li>
<li><strong>float(x)</strong>：将x转换到一个浮点数    </li>
<li><strong>str(x)</strong>：将对象 x 转换为<strong>字符串</strong>    </li>
<li>repr(x)：将对象 x 转换为表达式字符串    </li>
<li>eval(str) ：用来计算在字符串中的有效Python表达式,并返回一个对象    </li>
<li>tuple(s)：将序列 s 转换为一个元组    </li>
<li>list(s)：将序列 s 转换为一个列表    </li>
<li><strong>chr(x)</strong> ：将一个整数转换为一个<strong>字符</strong>    </li>
<li>unichr(x) ：将一个整数转换为<strong>Unicode字符</strong>    </li>
<li>ord(x)：将一个字符转换为它的<strong>整数值</strong></li>
<li>hex(x)：将一个整数转换为一个十六进制字符串 </li>
<li>oct(x)：将一个整数转换为一个八进制字符串   </li>
<li>complex(real [,imag ])：创建一个复数</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>###判断</p>
<ul>
<li><strong>df.isnull()</strong>：检查DataFrame对象中的空值，并返回一个Boolean数组</li>
<li><strong>df.notnull()</strong>：检查DataFrame对象中的非空值，并返回一个Boolean数组</li>
</ul>
<blockquote>
<p>Python中内置的<code>None</code>会被当做NA处理</p>
<p>pandas用浮点值NaN (Not a Number) 表示浮点和非浮点数据中的缺失数据；其类型为 float</p>
</blockquote>
<p><br></p>
<p>###移除</p>
<ul>
<li><strong>df.dropna()</strong>：删除所有包含空值的行，返回为剔除后的对象（<strong>一行中只要有一个值为NaN，就删除整行</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df.dropna(how=<span class="string">'all'</span>, axis=<span class="number">1</span>, thresh=n)</div><div class="line"></div><div class="line"><span class="comment">## how='all', 指定排除一行中 [所有值均NA] 行/列</span></div><div class="line"><span class="comment">## axis=1, 删除所有包含空值的 [列]; 默认axis=0, 即删除所有包含空置的[行]</span></div><div class="line"><span class="comment">## axis=1,thresh=n, 删除所有 [小于n个非空值] 的 [行]</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###重编码</p>
<ul>
<li><strong>df.fillna(x, inplace=True)</strong>：用x替换DataFrame对象中所有的空值，inplace表示在源数据中修改</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fillna(value [, method = <span class="string">'ffill'</span>,limit =n, axis=<span class="number">0</span>, inplace=<span class="keyword">False</span>])</div><div class="line"><span class="comment"># value 填充值</span></div><div class="line"><span class="comment"># method 差值方式，默认为ffill；也可为bfill</span></div><div class="line"><span class="comment"># limit  可以连续填充的最大数量</span></div><div class="line"><span class="comment"># axis 待填充的轴，默认为0</span></div><div class="line"><span class="comment"># inplace 默认为False，表示返回新对象；若为True，则对原始数据进行修改</span></div><div class="line"></div><div class="line">df.fillna(<span class="number">0</span>)  <span class="comment"># 将缺失值替换为0</span></div><div class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">3</span>: <span class="number">-1</span>&#125;)  <span class="comment"># 对位置值为1的 [列]，缺失值替换为0.5；即对第二列，将NaN值替换为0.5</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="汇总与描述统计"><a href="#汇总与描述统计" class="headerlink" title="汇总与描述统计"></a>汇总与描述统计</h2><blockquote>
<p>常规情况下，axis=1 代表列； axis=0 代表行；</p>
<p><strong>计算情况下</strong>，axis=1 代表<strong>沿着每一行遍历所有的列，并向下执行方法</strong></p>
</blockquote>
<p><br></p>
<h3 id="常规统计值"><a href="#常规统计值" class="headerlink" title="常规统计值"></a>常规统计值</h3><ul>
<li>count()：非NA的数量</li>
<li>describe()：计算统计汇总</li>
<li>sum()</li>
<li>mean() / median() </li>
<li>quantile()</li>
<li>min() / max()</li>
<li>var()：方差 / std()：标准差</li>
<li>mad() :根据平均值计算平均绝对离差</li>
<li>argmin() / argmax()：计算能够获取到最小值/最大值的<strong>索引位置（整数）</strong>  （对应 iloc）</li>
<li>idxmin() / idxmax()：计算能过获取到最小值/最大值的所<strong>索引值</strong>  （对应loc）</li>
</ul>
<p><br></p>
<h3 id="常规统计值-高阶"><a href="#常规统计值-高阶" class="headerlink" title="常规统计值 - 高阶"></a>常规统计值 - 高阶</h3><ul>
<li>cumsum()：累计和</li>
<li>cummin() /cummax() ：累计最小值/累计最大值</li>
<li>cumprod()：累计积</li>
<li>skew()：偏度（三阶矩）</li>
<li>kurt()：峰度（四阶矩）</li>
<li>diff()：一阶差分（对时间序列很有用）</li>
<li>pct_change()：百分数变化</li>
<li>corr()：相关系数</li>
<li>ocv()：协方差</li>
</ul>
<p><br></p>
<h2 id="数据聚合与分组"><a href="#数据聚合与分组" class="headerlink" title="数据聚合与分组"></a>数据聚合与分组</h2><p>分组聚合是由三个过程来组成的：拆分Split - 应用Apply - 合并Combine</p>
<ol>
<li>数据根据所提供的<strong>一个或多个键被拆分 (Split) 为多组</strong>。并且拆分操作是在<strong>对象的特定轴 (axis=1 列； 或 axis=0 - 行)上执行的</strong></li>
<li>将一个函数Apply应用到各个分组并产生一个新的值</li>
<li>将所有的结果合并Combine到最终结果的对象中</li>
</ol>
<blockquote>
<p><strong>grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df[‘key1’]的中间数据而已。该对象已经有了所需的一切信息</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">df = pd.DataFrame(&#123;<span class="string">'key1'</span>:[<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>],</div><div class="line">               <span class="string">'key2'</span>:[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'one'</span>],</div><div class="line">               <span class="string">'data1'</span>:np.random.randn(<span class="number">5</span>),</div><div class="line">               <span class="string">'data2'</span>:np.random.randn(<span class="number">5</span>)&#125;)</div><div class="line"></div><div class="line"><span class="comment"># grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已</span></div><div class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">grouped</div><div class="line">&lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x000000000876EBA8</span>&gt;</div><div class="line"></div><div class="line"><span class="comment"># 调用GroupBy的方法进行聚合计算</span></div><div class="line">grouped.mean()</div><div class="line">       key1</div><div class="line">a    <span class="number">0.486419</span></div><div class="line">b   <span class="number">-0.771562</span></div><div class="line">Name: data1, dtype: float64</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><blockquote>
<p>groupby：在分组的基础上，计算<strong>非NA</strong>的值统计量；</p>
<p>并且对<strong>所有的数值数据</strong>进行统计计算，而对非数据数据列则会排除。</p>
<p><strong>默认对axis=0上进行分组；该场景应认为是计算的场景，axis=0  表示以列为单位，遍历每一行；即对该列中的各个值进行分组</strong>；效果等同于SQL中的groupby </p>
</blockquote>
<ul>
<li><strong>df.groupby(‘ col’ )</strong>：返回一个按列col进行分组的Groupby对象</li>
<li><strong>df.groupby( [‘col1’,’col2’] )</strong>：<strong><u>多条件分组</u></strong>； （ 等价于SQL中<code>Group by key1, key2</code> ）</li>
<li><strong>df.groupby().size()</strong>：返回一个包含<strong>分组大小</strong>的Series</li>
</ul>
<blockquote>
<p>as_index = False ：以 <strong>“无索引”</strong> 的形式返回聚合数据</p>
<p>group_keys = False ：禁止分组键。分组键会跟原始对象的索引共同构成结果对象中的层次化索引。该函数可禁止该效果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已</span></div><div class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">grouped</div><div class="line">&lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x000000000876EBA8</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 调用GroupBy的方法进行聚合计算</span></div><div class="line">grouped.mean()</div><div class="line">       key1</div><div class="line">a    <span class="number">0.486419</span></div><div class="line">b   <span class="number">-0.771562</span></div><div class="line">Name: data1, dtype: float64</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># 对所有的数值数据进行统计计算，而对非数据数据列则会排除。 'key2'列自动被排除在外</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).mean()</div><div class="line">      data1	data2</div><div class="line">key1		</div><div class="line">a	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line">b	<span class="number">-0.771562</span>	<span class="number">-0.562044</span>    </div><div class="line">    </div><div class="line">  </div><div class="line"><span class="comment"># -----------df.groupby(['col1', 'col2'])-----------------</span></div><div class="line"><span class="comment"># 一次传入多个数组，表示多条件分组 </span></div><div class="line">df.loc[:,<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>],df[<span class="string">'key2'</span>]]).mean()  <span class="comment"># 等价于SQL中 Group by key1, key2</span></div><div class="line">           key1  key2</div><div class="line">a     one     <span class="number">0.882282</span></div><div class="line">      two    <span class="number">-0.305308</span></div><div class="line">b     one    <span class="number">-1.010323</span></div><div class="line">      two    <span class="number">-0.532800</span></div><div class="line">Name: data1, dtype: float64</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># ---------------Size--------------------</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).size()</div><div class="line">    key1</div><div class="line">a    <span class="number">3</span></div><div class="line">b    <span class="number">2</span></div><div class="line">dtype: int64</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="层次化索引的重塑-stack-1"><a href="#层次化索引的重塑-stack-1" class="headerlink" title="层次化索引的重塑 - stack"></a>层次化索引的重塑 - stack</h4><blockquote>
<p>可构建类似数据透视表的结构</p>
</blockquote>
<ul>
<li><strong>stack()</strong>：列转行；将数据的列 “旋转” 为行</li>
<li><strong>unstack()</strong>：<strong><u>列转行</u></strong>；将数据的行 “旋转” 为列</li>
</ul>
<blockquote>
<p>stack操作的是对<strong>最内层的索引</strong>进行操作。</p>
<blockquote>
<p>若用字符串表示，则直接输入该索引的名称 .stack(‘number’)</p>
<p>若用数字表示，0 - 第一层索引； 1 - 第二层索引</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.loc[:,<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>],df[<span class="string">'key2'</span>]]).mean().unstack()</div><div class="line"></div><div class="line">key2	one	two</div><div class="line">key1		</div><div class="line">a	<span class="number">0.882282</span>	<span class="number">-0.305308</span></div><div class="line">b	<span class="number">-1.010323</span>	<span class="number">-0.532800</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="选取部分列-分组"><a href="#选取部分列-分组" class="headerlink" title="选取部分列 分组"></a>选取部分列 分组</h4><ul>
<li><strong>df[‘data1’].groupby(df[‘key1’])</strong>：返回的一个已分组的数据框对象（语法糖：<strong>df.groupby(‘key1’)[‘data1’]</strong> ）</li>
<li><strong>df[[‘data1’]].groupby(df[‘key1’])</strong> ： 语法糖为<strong>df.groupby(‘key1’)[[‘data1’]]</strong> </li>
</ul>
<p><br></p>
<h4 id="通过函数-分组"><a href="#通过函数-分组" class="headerlink" title="通过函数 - 分组"></a>通过函数 - 分组</h4><ul>
<li><p>任何被当做分组键的函数都会在<strong>各个索引值 （行的索引值，而非列名）</strong>上被调用一次，其返回值就会被用作分组名称。</p>
<ul>
<li>若索引为人的名字；假设你希望<strong>根据人名的长度进行分组</strong>，虽然可以求取一个字符串长度数组，但其实仅需 传入len函数即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(len).sum()</div></pre></td></tr></table></figure>
<p><br></p>
</li>
</ul>
<p>####通过索引级别 - 分组</p>
<blockquote>
<p>针对层次化索引数据集，可以根据索引级别进行分组；通过level 关键字传入 级别编码 或者 名称 即可。</p>
</blockquote>
<ul>
<li><strong>df.groupby(level=’cty’, axis=1)</strong>.mean()  对层次化索引的数据，根据索引级别进行聚合.通过level关键字传入<strong>级别编号或名称</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hier_df.groupby(level=<span class="string">'cty'</span>, axis=<span class="number">1</span>).count()</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h4 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h4><h4 id="通过字典或Series-分组"><a href="#通过字典或Series-分组" class="headerlink" title="通过字典或Series 分组"></a>通过字典或Series 分组</h4><blockquote>
<p>传入一个 字典或Series 根据其值的内容分别分组</p>
</blockquote>
<p><br></p>
<h3 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h3><blockquote>
<p>聚合：从数组产生标量值的数据转换过程</p>
<p>GroupBy会高效地对Series进行切片，然后对各片调用Piece，最后将这些结果组装为最终结果</p>
</blockquote>
<p><br></p>
<h4 id="自定义聚合函数"><a href="#自定义聚合函数" class="headerlink" title="自定义聚合函数"></a>自定义聚合函数</h4><blockquote>
<p>将自定义的函数<strong>传入aggregate 或 agg方法</strong>即可</p>
<p><strong>aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby(col1).agg(np.mean)</strong>：返回按列col1分组的<strong>所有列的均值</strong>df </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">return</span> arr.max() - arr.min()</div><div class="line"></div><div class="line">df.groupby(<span class="string">'key1'</span>).agg(peak_to_peak)</div></pre></td></tr></table></figure>
<blockquote>
<p>优化过的GroupBy 方法</p>
<p>.count() ： 非NA值的数量<br>.sum() ： 非NA值的和<br>.mean()<br>.mdian()： 非NA值的算术中位数<br>.std / .var： 无偏（分母为n-1）标准差和方差<br>.min / .max<br>.prod()： 非NA值的积<br>.first / .last ：第一个和最后一个非NA的值</p>
</blockquote>
<p><br></p>
<h4 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h4><blockquote>
<p><strong>一次应用多个函数</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby( [‘sum’, ‘mean’]) ：一次应用多个函数</strong>：对于描述统计，可以将函数名以 <strong>字符串str</strong> 的形式传入，并作为一个 <strong>列表list</strong> 传入，得到一个<strong>以相应的函数命名的列</strong></li>
<li><strong>df.groupby( [ (‘foo’, ‘mean’), (‘bar’, ‘sum’) ]) ：传入多个函数，并重命名列名</strong>。<ul>
<li>当传入的是一个由 <strong>(name, function)元组组成的列表list</strong> ，则各元组的第一个元素会被用作DataFrame的列名（可以将这种二元元组看做一个有序映射） </li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>).agg([<span class="string">'sum'</span>,<span class="string">'mean'</span>])</div><div class="line">	       data1	data2</div><div class="line">       sum	mean	sum	mean</div><div class="line">key1				</div><div class="line">a	<span class="number">1.459256</span>	<span class="number">0.486419</span>	<span class="number">-1.138960</span>	<span class="number">-0.379653</span></div><div class="line">b	<span class="number">-1.543123</span>	<span class="number">-0.771562</span>	<span class="number">-1.124087</span>	<span class="number">-0.562044</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ---- 先定义要传入的多个函数为对象A；也可以运行</span></div><div class="line">fc = [<span class="string">'count'</span>, <span class="string">'mean'</span>, <span class="string">'max'</span>]    </div><div class="line">df.groupby(<span class="string">'key1'</span>).agg(fc)</div><div class="line"></div><div class="line">			data1		data2</div><div class="line">	count	mean	max	count	mean	max</div><div class="line">key1						</div><div class="line">a	<span class="number">3</span>	<span class="number">0.486419</span>	<span class="number">1.041325</span>	<span class="number">3</span>	<span class="number">-0.379653</span>	<span class="number">0.010709</span></div><div class="line">b	<span class="number">2</span>	<span class="number">-0.771562</span>	<span class="number">-0.532800</span>	<span class="number">2</span>	<span class="number">-0.562044</span>	<span class="number">0.038084</span></div><div class="line"></div><div class="line"><span class="comment"># 传入带有自定义名称的元组列表</span></div><div class="line">fc_name = [(<span class="string">'计数'</span>,<span class="string">'count'</span>),(<span class="string">'最大值'</span>,<span class="string">'max'</span>)]</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>对不同的列使用不同的聚合函数</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby(‘key1’).agg( { ‘tip’: np.max, ‘size’: ‘sum’} )</strong> ：向 agg 传入一个<strong><u>列名映射到函数的 字典dict</u></strong><ul>
<li><strong>df.groupby(‘key1’).agg( { ‘tip_pct’ : [‘min’, ‘,max’], ‘size’: ‘sum’})</strong> ：对不同列完成不同数量的聚合</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="分组运算transform-amp-apply"><a href="#分组运算transform-amp-apply" class="headerlink" title="分组运算transform &amp; apply"></a>分组运算transform &amp; apply</h3><blockquote>
<p>transform &amp; apply 只能产生两种结果：</p>
<ol>
<li>一个可以广播出去的标量值</li>
<li>一个相同大小的结果数组</li>
</ol>
<p><strong>aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby(‘val’).transform( func )</strong>：将一个函数应用到各个分组，<strong>返回该结果的值</strong>； 若产生的是一个标量值，则该值会被<strong>广播</strong>出去。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>).transform(<span class="string">'mean'</span>)</div><div class="line">	data1	data2</div><div class="line"><span class="number">0</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">1</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">2</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">3</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">4</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 对比 df.groupby('key1').mean()</span></div><div class="line">	   data1	data2</div><div class="line">key1		</div><div class="line">a	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line">b	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 分组运算并合并数据</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).transform(<span class="string">'mean'</span>).add_prefix(<span class="string">'mean_'</span>)  <span class="comment"># DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<blockquote>
<p>apply 是更一般性的 “拆分-应用-合并”；</p>
<p><strong>传入的函数一般都是需要提前定义的；而无法直接调用已有的函数（sum/mean等）</strong></p>
</blockquote>
<ul>
<li><strong>GroupBy.apply(func)</strong>：<ul>
<li><strong>data.apply(np.mean)</strong>：对DataFrame中的每一 <strong>[列]</strong> 应用函数np.mean</li>
</ul>
</li>
</ul>
<blockquote>
<p>axis = 0 默认：以行为单位，遍历列的所以行；可以理解为  SQL中指定某列的Group by </p>
<p>axis = 1 ：以列为单位，遍历行的所有列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义函数：根据分组选出最高的5个tip_pct值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(df, n=<span class="number">5</span>, column = <span class="string">'tip_pct'</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> df.sort_index(by=column)[-n:]</div><div class="line">  </div><div class="line"><span class="comment"># 将该函数应用</span></div><div class="line">tips.groupby(<span class="string">'smoker'</span>).apply(top)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -----------------------------------------------</span></div><div class="line"><span class="comment"># 如果传入的函数能够接受其他参数或关键字，可以将这些内容直接放在函数名后面一并传入apply</span></div><div class="line">tips.groupby([<span class="string">'smoker'</span>, <span class="string">'day'</span>]).apply(top, n=<span class="number">1</span>, column = <span class="string">'totoal_bill'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="样式输出-style"><a href="#样式输出-style" class="headerlink" title="样式输出 - style"></a>样式输出 - style</h2><blockquote>
<p><strong>【提醒】</strong></p>
<ul>
<li>采用格式化函数之后，整个对象类型则变更为 <code>styler</code> ，此时不应该赋值给原对象。因为赋值后，无法应用任何 <code>DataFrame</code>的函数；</li>
<li>格式输出并不改变原对象的值</li>
</ul>
<ul>
<li><strong>在最后阶段应用格式化输出的函数</strong></li>
</ul>
</blockquote>
<h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><ul>
<li>Styler<strong>.format</strong>(formatter, subset=None)：格式化单元格的文本显示值<ul>
<li>pandas.io.formats.style.Styler.format</li>
<li><strong>对象必须是 DataFrame；对于Series无效；即若只取 DataFrame的一列，则会报错</strong>；</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>formatter: str, callable, or dict</strong></p>
<blockquote>
<p><strong>&lt; formatter是 a  或 dict {column name： a}  &gt;； a 是如下之一</strong></p>
<ul>
<li>str: this will be wrapped in: <code>a.format(x)</code>   ； 这将包装在：<code>a.format(x)</code></li>
<li>callable:  called with the value of an individual cell 使用单个单元格的值调用</li>
</ul>
</blockquote>
<p><strong>subset: IndexSlice</strong></p>
<blockquote>
<p>An argument to <code>DataFrame.loc</code> that restricts which elements <code>formatter</code> is applied to</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">2</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 对所有对象调用格式化函数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.style.format(<span class="string">'&#123;:.2%&#125;'</span>)  <span class="comment"># 注意&#123;&#125;是用引号 括起来的</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'c'</span>] = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 通过字典的方式来指定特定列的输出格式   </span></div><div class="line"><span class="comment">## 对于数值类型，直接调用format函数； 对于文本，直接调用str.func</span></div><div class="line">df.style.format(&#123;<span class="string">'a'</span>:format(<span class="string">'&#123;:.2%&#125;'</span>),<span class="string">'b'</span>:format(<span class="string">'&#123;:.2%&#125;'</span>),<span class="string">'c'</span>:str.upper&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>对于数值类型，直接调用format函数； 对于文本，直接调用str.func</strong></p>
</blockquote>
<p>格式化单元格的文本显示值。</p>
<p><br></p>
<h2 id="参考说明"><a href="#参考说明" class="headerlink" title="参考说明"></a>参考说明</h2><h3 id="axis的含义"><a href="#axis的含义" class="headerlink" title="axis的含义"></a>axis的含义</h3><p><strong>【结论】</strong></p>
<ol>
<li><strong>常规情况下，axis=1 代表列； axis=0 代表行；</strong></li>
<li><strong>计算情况下，axis=1 代表沿着每一行遍历所有的列，并向下执行对一个的方法</strong></li>
</ol>
<blockquote>
<p>如果我们调用df.mean(axis=1),我们将得到按行计算的均值</p>
<p>如果我们调用 df.drop((name, axis=1),我们实际上删掉了一列，而不是一行</p>
</blockquote>
<p>df.mean其实是在每一行上取所有列的均值，而不是保留每一列的均值。也许简单的来记就是axis=0代表往<strong>跨行（down)</strong>，而axis=1代表<strong>跨列（across)</strong>，作为方法动作的副词（译者注）</p>
<p>换句话说：</p>
<ul>
<li>使用0值 表示沿着每一列或行标签\索引值向下执行方法</li>
<li>使用1值 表示沿着每一行或者列标签模向执行对应的方法</li>
</ul>
<p>下图代表在DataFrame当中axis为0和1时分别代表的含义:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2233157-b77105789e36c847.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>axis参数作用方向图示</p>
<p>另外，记住，Pandas保持了Numpy对关键字axis的用法，用法在Numpy库的词汇表当中有过解释：</p>
<p><strong>轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。</strong></p>
<p>所以问题当中第一个列子 df.mean(axis=1)代表沿着列水平方向计算均值，而第二个列子df.drop(name, axis=1) 代表将name对应的列标签（们）沿着水平的方向依次删掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;df = pd.DataFrame([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]], \</div><div class="line">columns=[<span class="string">"col1"</span>, <span class="string">"col2"</span>, <span class="string">"col3"</span>, <span class="string">"col4"</span>])</div><div class="line">&gt;&gt;&gt;df</div><div class="line">   col1  col2  col3  col4</div><div class="line">    <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></div><div class="line">    <span class="number">1</span>     <span class="number">2</span>     <span class="number">2</span>     <span class="number">2</span>     <span class="number">2</span></div><div class="line">    <span class="number">2</span>     <span class="number">3</span>     <span class="number">3</span>     <span class="number">3</span>     <span class="number">3</span></div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.mean(axis=<span class="number">1</span>)</div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line"><span class="number">2</span>    <span class="number">3</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.drop(<span class="string">"col4"</span>, axis=<span class="number">1</span>)</div><div class="line">   col1  col2  col3</div><div class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></div><div class="line"><span class="number">1</span>     <span class="number">2</span>     <span class="number">2</span>     <span class="number">2</span></div><div class="line"><span class="number">2</span>     <span class="number">3</span>     <span class="number">3</span>     <span class="number">3</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="两行相减-amp-环比"><a href="#两行相减-amp-环比" class="headerlink" title="两行相减 &amp; 环比"></a>两行相减 &amp; 环比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pandas 指引 : &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window&quot;&gt;http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DataFrame 单独取出一列是 Series 格式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;根据pandas的官方文档，重新调整结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>阅读书籍_2018年度</title>
    <link href="http://yoursite.com/2018/02/05/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB_2018%E5%B9%B4%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/02/05/阅读书籍/阅读书籍汇总/阅读书籍汇总_2018年度/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-07-10T14:55:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>记录2018年度阅读的书籍。</p>
<a id="more"></a>
<p>[TOC]</p>
<p><br></p>
<blockquote>
<p>类别</p>
<p>《书名》_作者 | 出版时间/ 购买时间 / 阅读时间 - 网址链接 （若时间点只有一个，表示阅读与购买时间为同一时段）</p>
<p>《book name》_author | 2011.09 / 2017-02 （注意两个时间的格式不一样）</p>
<p>一句话概括整本书的核心内容，最多不超过三句话。这个是原则。</p>
</blockquote>
<p><br></p>
<h2 id="互联网运营"><a href="#互联网运营" class="headerlink" title="互联网运营"></a>互联网运营</h2><p><br></p>
<ol>
<li><p><strong>《运营之光：我的互联网运营方法论与自白 2.0》_黄有璨 / 2017-12 / 2018-02</strong> </p>
</li>
<li><p><strong>《小群效应》_徐志斌 / 2018-02</strong></p>
</li>
</ol>
<p><br></p>
<h2 id="思维意识与生活态度"><a href="#思维意识与生活态度" class="headerlink" title="思维意识与生活态度"></a>思维意识与生活态度</h2><ol>
<li><strong>《精进》_采铜 / 2018-01 /2018-05</strong></li>
<li><strong>《人生定位》_[美] 艾.里斯 &amp; 杰克.特劳特 (AI Ries &amp; Jack Trout) |2011.09 / 2018-07</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录2018年度阅读的书籍。&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/tags/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python_日期处理</title>
    <link href="http://yoursite.com/2018/02/05/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/02/05/软件应用_程序编程/Python/Python_专题总结/Python_日期处理/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-02-17T13:10:09.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h1><blockquote>
<p><strong><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</strong></p>
<p><strong>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</strong></p>
</blockquote>
<a id="more"></a>
<p>Python中关于时间、日期的处理库有三个：time、datetime和Calendar。</p>
<ul>
<li>datetime又有datetime.date、datetime.time、datetime.datetime三个类</li>
<li>时间又可以分为时间戳、本地时间和UTC时间（世界标准时间）</li>
</ul>
<p><code>from time import time</code></p>
<p><code>from datetime import datetime</code></p>
<p><br></p>
<p>时间序列的几种内容</p>
<ul>
<li>时间戳 (timestamp)，特定的时刻</li>
<li>固定时期 (period)，如2017年1月或2017年全年</li>
<li>时间间隔 (internal) ，由起始时间和结束时间戳表示。时期 (period) 可以看做间隔的一个特例</li>
</ul>
<p><br></p>
<h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><blockquote>
<p>datetime是Python处理日期和时间的标准库。</p>
<p><code>from datetime import datetime</code></p>
</blockquote>
<p>datetime模块。该模块中包含4个主要的类：</p>
<ul>
<li>datetime.date：日期类，只包含年、月、日、星期等日期信息。</li>
<li>datetime.time：时间类，只包含时、分、秒、微秒等时间信息。</li>
<li>datetime.datetime：日期时间类，包含以上两者的全部信息。</li>
<li>datetime.timedelta：时间日期差值类，用来表示两个datetime之间的差值（日、秒、毫秒）。</li>
</ul>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; # 获取当前时间</div><div class="line">&gt; &gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt; &gt;&gt;&gt; now = datetime.now() # 获取当前datetime</div><div class="line">&gt; &gt;&gt;&gt; print(now)</div><div class="line">&gt; 2015-05-18 16:28:07.198690</div><div class="line">&gt; &gt;&gt;&gt; print(type(now))</div><div class="line">&gt; &lt;class 'datetime.datetime'&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p>
<p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p>
<p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p>
</blockquote>
<p><br></p>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><ul>
<li><strong>datetime.datetime.now()</strong>：获取当前日期与时间</li>
<li><strong>datetime.datetime(2012, 1, 12)</strong>：获取<strong>指定</strong>日期与时间</li>
</ul>
<p><br></p>
<p>####指定部分</p>
<ul>
<li><p><strong>datetime.year</strong> : 获取日期与时间的<strong>指定部分</strong></p>
<ul>
<li><p><code>datetime.year</code></p>
</li>
<li><p><code>datetime.month</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>datetime.day</code></li>
</ul>
<ul>
<li><code>datetime.hour</code></li>
</ul>
<ul>
<li><code>datetime.minute</code></li>
</ul>
<ul>
<li><code>datetime.second</code></li>
</ul>
<ul>
<li><code>datetime.microsecond</code>   In range(1000000) </li>
</ul>
<ul>
<li><p>datetime.date()：获得日期部分</p>
<ul>
<li>datetime.time()</li>
<li><strong>datetime.weekday()</strong>：将星期几作为整数返回，<strong>其中星期一为0，星期日为6</strong></li>
<li><strong>datetime.isoweek()</strong>：将星期几作为整数返回，<strong>星期一为1，星期日为7</strong></li>
</ul>
</li>
</ul>
<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><ul>
<li><strong>datetime.strftime( format )</strong> ：时间<strong>转为字符串</strong>    <em>f：表示from</em><ul>
<li>strftime() 用来<strong>格式化</strong>  datetime对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>format : ‘%Y-%M-%D %H:%M:%S’</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># datetime.datetime类型转字符串</span></div><div class="line">print(a_datetime_local.strftime(<span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>))  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 字符串转datetime.datetime格式</span></div><div class="line">a_datetime = datetime.datetime.strptime(<span class="string">"2016-11-15, 15:32:12, 2"</span>, <span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>)</div></pre></td></tr></table></figure>
<ul>
<li><strong>datetime.strptime( ‘date_string’, ‘%Y-%M-%D’)</strong>：字符串<strong>转为时间格式</strong><ul>
<li>datetime.strptime 是通过已知的格式进行日期解析的方式。但每次都必须要编写格式定义。</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>parser.parse(‘str’ ,dayfirst =True)</strong>：可以解析几乎所有人类能够理解的日期表示形式（中文除外）<ul>
<li>对于常见的日期格式，可以使用<code>dateutil</code> 第三方包中的 <code>parser.parse</code> 方法</li>
<li>注意：它并不是一个完美的工具；因为会把一些原本不是日期的字符串认作是日期（比如 “42”会被解析为2042年的今天）</li>
</ul>
</li>
</ul>
<blockquote>
<p>dayfirst =True ，将日期显示在最前面；因为国际通用格式中，日通常排在月的前面。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</div><div class="line">parse(<span class="string">'2011-03-11'</span>)</div><div class="line"></div><div class="line">[out]:datetime.datetime(<span class="number">2011</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="timedelta对象-加减"><a href="#timedelta对象-加减" class="headerlink" title="timedelta对象 + 加减"></a>timedelta对象 + 加减</h3><p>datetime.timedelta <strong>表示两个datetime之间的时间差。</strong></p>
<p>给datetime对象加上一个或多个 timedelta，会产生一个新的对象；</p>
<ul>
<li><p><strong>now + timedelta(days=n, hours=m)</strong>：在原有基础上加减日期</p>
<ul>
<li>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</li>
</ul>
</li>
</ul>
<blockquote>
<p>years<br>months<br>days<br>hours<br>minutes<br>seconds </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 日期加减</span></div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</div><div class="line">start = datetime(<span class="number">2011</span>,<span class="number">1</span>,<span class="number">7</span>)</div><div class="line"></div><div class="line">start + timedelta(<span class="number">12</span>)</div><div class="line">[out]:datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment"># 返回间隔</span></div><div class="line">delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>)</div><div class="line">delta</div><div class="line">[out]:datetime.timedelta(<span class="number">927</span>)</div><div class="line"></div><div class="line">delta.days</div><div class="line">[out]:<span class="number">927</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>在time模块中，时间有三种表现形式：</p>
<ul>
<li>时间戳，一般指Unix时间戳，是从1970年开始到现在的秒数。<ul>
<li>1970年以前的时间timestamp为负数</li>
</ul>
</li>
<li>本地时间的struct_time形式：一个长度为11的命名元组，第一位为年，第二位为月….</li>
<li>UTC时间的struct_time形式：一个长度为11的命名元组，类似于上个，只不过为UTC时间</li>
</ul>
<blockquote>
<p>其中后两者的类型一致，区别在于一个是本地时间（localtime），一个是utc时间。</p>
</blockquote>
<p><br></p>
<h3 id="时间获取-1"><a href="#时间获取-1" class="headerlink" title="时间获取"></a>时间获取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 时间戳：1479193181.829338</span></div><div class="line">print(<span class="string">"time stamp:"</span>, time.time())         </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的本地时间</span></div><div class="line">print(<span class="string">"local time:"</span>, time.localtime())    </div><div class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">15</span>, tm_hour=<span class="number">14</span>, tm_min=<span class="number">59</span>, tm_sec=<span class="number">41</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">320</span>, tm_isdst=<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的utc时间</span></div><div class="line">print(<span class="string">"utc time:"</span>, time.gmtime())         </div><div class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">15</span>, tm_hour=<span class="number">6</span>, tm_min=<span class="number">59</span>, tm_sec=<span class="number">41</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">320</span>, tm_isdst=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="字符串转换-1"><a href="#字符串转换-1" class="headerlink" title="字符串转换"></a>字符串转换</h3><ul>
<li><strong>time.strptime()：</strong>字符串<strong>转为时间格式</strong></li>
<li><strong>time.strftime()</strong>：时间格式<strong>转为字符串</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 时间戳转字符串(本地时间字符串)</span></div><div class="line">print(time.ctime(time_stamp))       </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的本地时间转字符串</span></div><div class="line">print(time.asctime(local_time))   </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的utc时间转字符串</span></div><div class="line">print(time.asctime(utc_time))       </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的本地时间转字符串：自定义格式</span></div><div class="line">print(time.strftime(<span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>, local_time))</div><div class="line"><span class="comment"># struct_time类型的utc时间转字符串：自定义格式</span></div><div class="line">print(time.strftime(<span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>, utc_time))</div><div class="line"></div><div class="line">struct_time = time.strptime(<span class="string">"2016-11-15, 15:32:12, 2"</span>, <span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p><img src="https://pic3.zhimg.com/80/v2-69d0c2ed958b802e9902c8e3815c19e9_hd.jpg" alt="img"></p>
<p><br></p>
<p><br></p>
<h2 id="datetime-与-timestamp转换"><a href="#datetime-与-timestamp转换" class="headerlink" title="datetime 与 timestamp转换"></a>datetime 与 timestamp转换</h2><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 可以认为</span></div><div class="line">timestamp = <span class="number">0</span> = <span class="number">1970</span><span class="number">-1</span><span class="number">-1</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC+<span class="number">0</span>:<span class="number">00</span></div><div class="line"></div><div class="line"><span class="comment"># 对应的北京时间是：</span></div><div class="line">timestamp = <span class="number">0</span> = <span class="number">1970</span><span class="number">-1</span><span class="number">-1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> UTC+<span class="number">8</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p>
</blockquote>
<p><br></p>
<h3 id="datetime-转-timestamp"><a href="#datetime-转-timestamp" class="headerlink" title="datetime 转 timestamp"></a>datetime 转 timestamp</h3><ul>
<li><strong>dt.timestamp()</strong>：把datetime对象转化为timestamp</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></div><div class="line"><span class="number">1429417200.0</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="timestamp-转-datetime"><a href="#timestamp-转-datetime" class="headerlink" title="timestamp 转 datetime"></a>timestamp 转 datetime</h3><ul>
<li><strong>datetime.fromtimestamp(t)</strong>：从timestamp 转为datetime<strong>（本地时间）</strong><ul>
<li>注意到timestamp是一个浮点数，<strong>它没有时区的概念</strong>，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</li>
</ul>
</li>
<li><strong>datetime. utcfromstimestamp(t)</strong>：从timestamp 转为datetime<strong>（UTC时间）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t)) <span class="comment"># 本地时间</span></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.utcfromtimestamp(t)) <span class="comment"># UTC时间</span></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">04</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>类型和时间戳、struct_time类型的相互转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment"># datetime类型转时间戳</span></div><div class="line">time_stamp = a_datetime_local.timestamp()   </div><div class="line">print(time_stamp)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 时间戳转datetime.datetime类型的本地时间</span></div><div class="line">a_datetime_local = datetime.datetime.fromtimestamp(time.time())     </div><div class="line">a_datetime_utc = datetime.datetime.utcfromtimestamp(time.time())    <span class="comment"># 时间戳转datetime.datetime类型的utc时间</span></div><div class="line">print(a_datetime_local, a_datetime_utc)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># datetime类型转struct_time类型</span></div><div class="line">print(a_datetime_local.timetuple())    </div><div class="line">print(a_datetime_utc.utctimetuple())    <span class="comment"># datetime类型转struct_time类型</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><img src="https://pic1.zhimg.com/80/v2-e623f9c109960af3805ec3eadfeaaa11_hd.jpg" alt="img"></p>
<p><br></p>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="本地时间转UTC时间"><a href="#本地时间转UTC时间" class="headerlink" title="本地时间转UTC时间"></a>本地时间转UTC时间</h3><blockquote>
<p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
</blockquote>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tz_utc_8 = timezone(timedelta(hours=<span class="number">8</span>)) <span class="comment"># 创建时区UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.replace(tzinfo=tz_utc_8) <span class="comment"># 强制设置为UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>, tzinfo=datetime.timezone(datetime.timedelta(<span class="number">0</span>, <span class="number">28800</span>)))</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><ul>
<li><strong>utcnow()</strong>：获取当前的UTC时间</li>
<li>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</li>
<li>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(utc_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">09</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line">      </div><div class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(bj_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line">      </div><div class="line"><span class="comment"># astimezone()将转换时区为东京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></div><div class="line">      </div><div class="line"><span class="comment"># astimezone()将bj_dt转换时区为东京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt2)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的<code>datetime</code>都可以正确转换，例如上述<code>bj_dt</code>到<code>tokyo_dt</code>的转换。</p>
</blockquote>
<p><br></p>
<h2 id="格式定义"><a href="#格式定义" class="headerlink" title="格式定义"></a>格式定义</h2><h3 id="datetime格式定义"><a href="#datetime格式定义" class="headerlink" title="datetime格式定义"></a>datetime格式定义</h3><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>4位数的年</td>
</tr>
<tr>
<td>%y</td>
<td>2位数的年</td>
</tr>
<tr>
<td>%m</td>
<td>2位数的月 [01, 12]</td>
</tr>
<tr>
<td>%d</td>
<td>2位数的日 [01, 31]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%F</td>
<td>%Y-%m-%d 简写形式；2012-04-18</td>
</tr>
<tr>
<td>%D</td>
<td>%m/%d/%y 简写形式；04/18/12</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>时间（24小时制） [00, 23]</td>
</tr>
<tr>
<td>%I</td>
<td>时间（12小时制） [00, 12]</td>
</tr>
<tr>
<td>%M</td>
<td>2位数的分钟 [00, 59]</td>
</tr>
<tr>
<td>%S</td>
<td>秒 [00, 61] (秒60和61用于闰秒)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%w</td>
<td>用整数表示的星期几 （星期天为第0天） [0, 6]</td>
</tr>
<tr>
<td>%U</td>
<td>每年的第几周 [00, 53]。<strong>星期天被认为是每周的第一天</strong>，每年第一个星期天之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td>%W</td>
<td>每年的第几周 [00, 53]。<strong>星期一被认为是每周的第一天</strong>，每年第一个星期一之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%z</td>
<td>以+HHMM 或-HHMM 表示的UTC时区偏移量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="特定于当前环境的日期格式"><a href="#特定于当前环境的日期格式" class="headerlink" title="特定于当前环境的日期格式"></a>特定于当前环境的日期格式</h3><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a</td>
<td>星期几的简写</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的全称</td>
</tr>
<tr>
<td>%b</td>
<td>月份的简写</td>
</tr>
<tr>
<td>%B</td>
<td>月份的全称</td>
</tr>
<tr>
<td>%c</td>
<td>完成的日期和时间；Tue 01 May 2012 04:20:57 pm</td>
</tr>
<tr>
<td>%p</td>
<td>不同环境中的AM 或PM</td>
</tr>
<tr>
<td>%x</td>
<td>适用于当前环境的日期格式  ；若在美国， “May 1 2012” 会产生 “05/01/2012”</td>
</tr>
<tr>
<td>%X</td>
<td>适用于当前环境的时间格式； “04:24:12 PM”</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h2><h4 id="输出为-月-日格式"><a href="#输出为-月-日格式" class="headerlink" title="输出为 月-日格式"></a>输出为 月-日格式</h4><p><br></p>
<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><p>pandas最基本的时间序列类型就是<strong>以时间戳为索引</strong>的Series；</p>
<p>当创建一个<strong>带有DatatimeIndex</strong> 的Series时，pandas就会知道该对象是一个<strong>时间序列</strong></p>
<blockquote>
<p>索引是 时间格式的字段；</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;日期与时间&quot;&gt;&lt;a href=&quot;#日期与时间&quot; class=&quot;headerlink&quot; title=&quot;日期与时间&quot;&gt;&lt;/a&gt;日期与时间&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;datetime&lt;/code&gt;表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果要存储&lt;code&gt;datetime&lt;/code&gt;，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>阅读书籍汇总</title>
    <link href="http://yoursite.com/2018/02/05/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/02/05/阅读书籍/阅读书籍汇总/阅读书籍汇总/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-07-10T14:53:01.699Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2008-2017年度共阅读13个大类（不完全统计），共计161本，读书笔记98篇，罗辑思维音频若干（含2场时间的朋友）。</strong></p>
<a id="more"></a>
<p>[TOC]</p>
<blockquote>
<p>类别</p>
<p>《书名》_作者 |出版时间 / 购买时间 / 阅读时间 - 网址链接 （若只有一个时间点，则购买时间与阅读时间为同一时间段）</p>
<blockquote>
<p>《原名》 - 原作者</p>
</blockquote>
<p>一句话概括整本书的核心内容，最多不超过三句话。这个是原则。</p>
</blockquote>
<p>关于一本书的概括，暂未做补充。</p>
<p><br></p>
<h2 id="心理学、社会认知与发展史-21本"><a href="#心理学、社会认知与发展史-21本" class="headerlink" title="心理学、社会认知与发展史 - 21本"></a>心理学、社会认知与发展史 - 21本</h2><ol>
<li><p><strong>《社会心理学》_周晓虹 / 2009-09</strong></p>
</li>
<li><p><strong>《天下大道》_奥修 / 2009-11</strong></p>
</li>
<li><p><strong>《道德的理由》_詹姆斯.雷切尔斯 / 2009-12</strong></p>
</li>
<li><p><strong>《世界简史》_中山大学历史系 / 2009-12</strong></p>
</li>
<li><p><strong>《101个道德难题》_马丁.科恩 / 2010-01</strong></p>
</li>
<li><p><strong>《汤普森谈判学》_利·汤普森 / 2010-07</strong></p>
</li>
<li><p><strong>《潜规则：中国历史中的真实游戏》_吴思 / 2010-07</strong></p>
</li>
<li><p><strong>《中国大历史》_黄仁宇 / 2010-09</strong></p>
</li>
<li><p><strong>《赫逊河畔谈中国历史》_黄仁宇 / 2010-09</strong></p>
</li>
<li><p><strong>《社会学的想象力》_赖特.米尔斯 / 2010-10</strong></p>
</li>
<li><p><strong>《意识形态与乌托邦》_卡尔.曼海姆 / 2010-10</strong></p>
</li>
<li><p><strong>《影响力》_[美] 罗伯特.西奥迪尼 / 2015-03</strong></p>
</li>
<li><p><strong>《意志力》_[美] 罗伊.鲍迈斯特 / 2015-04</strong></p>
</li>
<li><p><strong>《沟通的艺术》_[美] 罗纳德.B.阿德勒 / 2015-12</strong></p>
</li>
<li><p><strong>《少有人走的路1：心智成熟的旅程》_ M.斯科特.派克(M.Scott Peck) / 2016-07</strong></p>
</li>
<li><p><strong>《稀缺：我们是如何陷入贫穷与忙碌的》_塞德希尔·穆来纳森(Sendhil Mullainathan) / 2016-10</strong></p>
</li>
<li><p><strong>《理性乐观派》_[英]马特.里德利(Matt.Ridley) / 2017-04</strong></p>
<p>从经济学的角度解释了整个社会的发展。</p>
</li>
<li><p><strong>《未来简史》_[以色列]尤瓦尔•赫拉丽(Yuval Noah Harari) / 2017-04</strong></p>
</li>
<li><p><strong>《文明是副产物》_郑也夫 / 2017-05</strong></p>
</li>
<li><p><strong>《代价论》_郑也夫 / 2017-06</strong></p>
</li>
<li><p><strong>《信任论》_郑也夫 / 2017-06</strong></p>
</li>
</ol>
<p><br></p>
<h2 id="思维意识与生活态度-20本"><a href="#思维意识与生活态度-20本" class="headerlink" title="思维意识与生活态度 - 20本"></a>思维意识与生活态度 - 20本</h2><ol>
<li><p><strong>《做人有学问》_李镇 / 2009-01</strong></p>
</li>
<li><p><strong>《开放你的人生》_王辉耀 /2010-03</strong></p>
</li>
<li><p><strong>《杠杆思考术》_[日] 本田直之 / 2011-3</strong></p>
</li>
<li><p><strong>《秘密》_朗达·拜恩(Rhonda Byrne) / 2012-03</strong></p>
</li>
<li><p><strong>《地头力：从结果出发思考问题》_[日] 细谷功 / 2014-05</strong></p>
</li>
<li><p><strong>《锻炼“地头力”：打造你的黄金自考力》_[日] 细谷功 / 2014-07</strong></p>
</li>
<li><p><strong>《高效能人士的七个习惯》_[美]史蒂芬·柯维 / 2014-11</strong></p>
</li>
<li><p><strong>《思考的艺术》_[美]文森特·赖安·拉吉罗(Vincent Ryan Ruggiero) / 2015-03</strong></p>
</li>
<li><p><strong>《每周工作4小时》_蒂莫西.费里斯 / 2016-07</strong></p>
</li>
<li><p><strong>《80/20法则》_[英] 理查德.科克 / 2016-08</strong></p>
</li>
<li><p><strong>《断舍离》_[日] 山下英子 / 2017-10</strong></p>
</li>
<li><p><strong>《怦然心动的人生整理魔法》_[日] 近藤麻理惠 / 2017-10</strong></p>
</li>
<li><p><strong>《人活到极致一定是素与简》_[日] 山口势子 / 2017-12</strong></p>
</li>
<li><p><strong>《麦肯锡教我的思考武器》_[日] 安宅和人 / 2017-12</strong></p>
</li>
<li><p><strong>《最重要的事只有一件》_[美] 加里.凯勒 &amp;杰伊.帕帕森(Gray Keller &amp; Jay Papasan) / 2017-12</strong>  </p>
</li>
<li><p><strong>《精要主义》_[英] 格雷戈.麦吉沃恩(Grey Mckeown) / 2017-12</strong></p>
</li>
<li><p><strong>《专注力：化简为繁的惊人力量》_[英] 于尔根.沃尔夫(Jurgen Wolff) / 2017-12</strong></p>
</li>
<li><p><strong>《每天最重要的2小时》_[美] 乔西.戴维斯(Josh Davis) / 2017-12</strong></p>
</li>
<li><p><strong>《精进》_采铜 / 2018-05</strong></p>
</li>
<li><p><strong>《人生定位》_[美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 (AI Ries &amp; Jack Trout) | 2011.09 / 2018-07</strong></p>
</li>
<li></li>
</ol>
<p><br></p>
<h2 id="工作与学习方法-16本"><a href="#工作与学习方法-16本" class="headerlink" title="工作与学习方法 - 16本"></a>工作与学习方法 - 16本</h2><ol>
<li><p><strong>《像咨询顾问一样思考》_王佑 / 2010-06</strong></p>
</li>
<li><p><strong>《金字塔原理》_巴巴拉·明托 / 2010-09</strong></p>
</li>
<li><p><strong>《用图表说话》_[美]基恩·泽拉兹尼(Gene Zelazny) / 2013-05</strong></p>
</li>
<li><p><strong>《餐巾纸的背面》_丹·罗姆 / 2014-12</strong></p>
</li>
<li><p><strong>《如何阅读一本书》_莫提默·J.艾德勒 &amp; 查尔斯·范多伦 / 2015-03</strong></p>
</li>
<li><p><strong>《读书经验分享 - 知乎Live》_李笑来 / 2017-04</strong></p>
</li>
<li><p><strong>《如何自学计算机专业课程 - 知乎Live》 / 2017-06</strong></p>
<p>虽然标题是关于自学计算机课程，但很大部分内容是关于大脑对记忆与学习的机理。包括工作记忆与长期记忆，包括学习的过程是建立新知识与已有知识网络的连接，是重组神经元的过程。知识，必须形成网状结构的知识，才是有效的知识。这一部分对于更好地利用大脑特性学习新知识有很大帮助。</p>
</li>
<li><p><strong>《麦肯锡方法》_艾森.拉塞尔 / 2017-07 （二刷）</strong></p>
</li>
<li><p><strong>《金字塔原理》_巴巴拉·明托 / 2017-06 （二刷）</strong></p>
</li>
<li><p><strong>《学习之道》_芭芭拉•奥克利(Barbara Oakley) / 2017-06</strong></p>
</li>
<li><p><strong>《刻意练习》_[美] 安德斯.艾利克森 &amp; 罗伯特.普尔(Anders Ericsson &amp; Robert Pool) / 2017-07</strong></p>
</li>
<li><p><strong>《练习的心态》_[美] 托马斯 M. 斯特纳 / 2017-07</strong></p>
<blockquote>
<p>《The Practicing Mind》_ Thomas M. Sterner</p>
</blockquote>
</li>
<li><p><strong>《麦肯锡精英的48个工作习惯》_[日] 户塚隆将 / 2017-07</strong></p>
</li>
<li><p><strong>《麦肯锡精英的39个工作习惯》_[日] 大岛祥誉 / 2017-07</strong></p>
</li>
<li><p><strong>《习惯的力量》_[美] 查尔斯.杜希格 / 2017-11</strong></p>
<blockquote>
<p>《The Power of Habit》_ Charles Duhigg </p>
</blockquote>
</li>
<li><p><strong>《思考，快与慢》_丹尼尔.卡尼曼 / 2017-10</strong></p>
</li>
</ol>
<p><br></p>
<h2 id="个人与团队管理-19本"><a href="#个人与团队管理-19本" class="headerlink" title="个人与团队管理 - 19本"></a>个人与团队管理 - 19本</h2><ol>
<li><strong>《卓有成效的管理者》_[美] 彼得·德鲁克  / 2008-12</strong></li>
<li><strong>《卡耐基精英之道》_[美] 戴尔.卡耐基 / 2009-01</strong></li>
<li><strong>《卡耐基沟通与人际关系》_[美] 戴尔.卡耐基 / 2009-05</strong></li>
<li><strong>《一分钟自我表现术》_杰夫 / 2009-06</strong></li>
<li><strong>《团队管理》_[美]马蒂·布隆斯坦 / 2009-07</strong></li>
<li><strong>《铁军：如何打造一支过得硬的团队》_程冲 / 2009-07</strong></li>
<li><strong>《有效沟通》_桑德拉黑.贝尔斯 / 2009-09</strong></li>
<li><strong>《有效沟通：管理者的沟通艺术》_余世维 / 2009-09</strong></li>
<li><strong>《他们为什么效忠希特勒》_英克.布罗德森 / 2009-10</strong></li>
<li><strong>《时间管理》_[美]波利·伯德 / 2009-12</strong></li>
<li><strong>《时间管理：高效人士的成功利器》_朱信凯 / 2009-12</strong></li>
<li><strong>《个人效率提升系统》_赵明 / 2009-12</strong></li>
<li><strong>《培训培训师：TTT全案》_刘永中 / 2010-01</strong></li>
<li><strong>《打造无敌团队》_[英] 莱斯利.雷 / 2010-02</strong></li>
<li><strong>《培训学习手册》_[美] 大卫.梅尔 / 2010-02</strong></li>
<li><strong>《高效团队24法则》_小文斯.隆巴迪 / 2010-06</strong></li>
<li><strong>《打造高绩效团队》_余世维 / 2010-06</strong></li>
<li><strong>《哈佛团队》_向洪 / 2010-06</strong></li>
<li><strong>《忠仆：领导就是服务》_詹姆斯.C.亨特 / 2010-06</strong></li>
</ol>
<p><br></p>
<h2 id="企业发展与管理"><a href="#企业发展与管理" class="headerlink" title="企业发展与管理"></a>企业发展与管理</h2><ol>
<li><p><strong>《影响世界的西方管理思想》_斯图尔特.克雷纳 / 2009-02</strong></p>
</li>
<li><p><strong>《IBM营销革命》_保罗.甘布尔 / 2009-03</strong></p>
</li>
<li><p><strong>《门槛：创业，从准备到行动》_赵延忱 / 2009-09</strong></p>
</li>
<li><p><strong>《营销：来自世界一流企业的4C营销方案》_方全 / 2009-10</strong></p>
</li>
<li><p><strong>《新直销营销》_李野新 / 2009-10</strong></p>
</li>
<li><p><strong>《与成功签约：CCTV赢在中国创业自问》_CCTV赢在中国项目组 / 2009-10</strong></p>
</li>
<li><p><strong>《史玉柱点评创业》_CCTV赢在中国项目组 / 2009-10</strong></p>
</li>
<li><p><strong>《只有CEO才能做的事》_雷福礼 / 2009-11</strong></p>
</li>
<li><p><strong>《马云点评创业》_CCTV赢在中国项目组 / 2009-11</strong></p>
</li>
<li><p><strong>《牛根生创业人生》_CCTV赢在中国项目组 / 2009-11</strong></p>
</li>
<li><p><strong>《创业企业融资》_杰弗里.蒂蒙斯 / 2009-12</strong></p>
</li>
<li><p><strong>《战略与竞争分析：商业竞争分析的方法与技巧》_[加]弗莱舍 / 2010-03</strong></p>
</li>
<li><p><strong>《麦肯锡传奇》_伊丽莎白·哈斯·埃德莎姆 / 2010-04</strong></p>
</li>
<li><p><strong>《麦肯锡意识》_艾森·拉塞尔 / 2010-04</strong></p>
</li>
<li><p><strong>《麦肯锡方法》_艾森·拉塞尔 / 2010-04</strong></p>
</li>
<li><p><strong>《咨询学》_余明阳 / 2010-06</strong></p>
</li>
<li><p><strong>《顶级咨询》_卡尔弗特.马克汉姆 / 2010-07</strong></p>
</li>
<li><p><strong>《管理咨询行业指南》_苏格塔.比斯沃斯 / 2010-07</strong></p>
</li>
<li><p><strong>《打败麦肯锡》_王瑶 / 2010-07</strong></p>
</li>
<li><p><strong>《从优秀到卓越》_[美] 吉姆.柯林斯 / 2010-09</strong></p>
</li>
<li><p><strong>《追求卓越》_[美] 汤姆.彼得斯 / 2010-09</strong></p>
</li>
<li><p><strong>《咨询的谎言》_[美] 马丁.基恩 / 2012-03</strong></p>
</li>
<li><p><strong>《商业模式新生代》_亚历山大·奥斯特瓦德 / 2013-11</strong></p>
</li>
<li><p><strong>《竞争战略》_迈克尔·波特 (Michael E. Porter)  / 2013-12</strong></p>
</li>
<li><p><strong>《市场营销原理》_菲利普·科特勒 &amp; 加里·阿姆斯特朗 / 2014-02</strong></p>
</li>
<li><p><strong>《领导梯队：全面打造领导力驱动型公司》_[美] 拉姆·查兰 / 2014-07</strong></p>
</li>
<li><p><strong>《从0到1》_[美] 彼得.蒂尔 / 2015-07</strong></p>
</li>
<li><p><strong>《参与感：小米口碑营销内部手册》_黎万强 / 2015-09</strong></p>
</li>
<li><p><strong>《星巴克：关于咖啡、商业和文化的传奇》_泰勒.克拉克(Taylor Clark)  / 2016-06</strong></p>
</li>
<li><p><strong>《浪潮之巅》_吴军 / 2017-11</strong></p>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="数据分析-16本"><a href="#数据分析-16本" class="headerlink" title="数据分析 - 16本"></a>数据分析 - 16本</h2><ol>
<li><p><strong>《深入浅出数据分析》_迈克尔.米尔顿 / 2016-09</strong></p>
</li>
<li><p><strong>《深入浅出SQL》_[美] 贝里(Beighley L.)  / 2016-09</strong></p>
</li>
<li><p><strong>《商务与经济统计学》_詹姆斯·麦克拉夫(James T.McClave) / 2016-10</strong></p>
</li>
<li><p><strong>《R语言实战》_卡巴科弗(Robert I.Kabacoff) / 2016-10</strong></p>
</li>
<li><p><strong>《ggplot2：数据分析与图形艺术》_哈德利·威克姆(Hadley Wickham)  / 2016-11</strong></p>
</li>
<li><p><strong>《精通Web Analytics 2.0》 / 2016-11</strong></p>
</li>
<li><p><strong>《数据挖掘导论》 / 2016-11 （未完）</strong></p>
</li>
<li><p><strong>《Python编程：从入门到实践》_[美] Eric Matthes / 2017-05</strong></p>
</li>
<li><p><strong>《利用Python进行数据分析》_Wes McKinney / 2017-05</strong></p>
</li>
<li><p><strong>《Python核心编程》_[美] Wesley J. Chun / 2017-12</strong></p>
</li>
<li><p><strong>《统计学习导论：基于R应用》_[美] 加雷斯.詹姆斯 &amp; 丹妮拉.威滕 / 2017-09</strong></p>
<blockquote>
<p>《An Introduction to Statistical Learning : with Application in R》_Gareth James  &amp; Daniela Witten</p>
</blockquote>
</li>
<li><p><strong>《数据的本质》_车品觉 / 2017-10</strong></p>
</li>
<li><p><strong>《数学之美》_吴军 / 2017-11</strong></p>
</li>
<li><p><strong>《大数据时代》_维克托.迈尔.舍恩伯格 &amp; 肯尼斯.库克耶(Viktor.Mayer.Schonberger &amp; Kenneth.Cukier) / 2017-11</strong></p>
</li>
<li><p><strong>《智能时代》_吴军 / 2017-11</strong></p>
</li>
<li><p><strong>《精益数据分析》_[加] 阿利斯泰尔.克罗尔 &amp; 本杰明.尤科维奇(Croll, A. &amp; Yoskovitz, B) / 2017-11</strong></p>
<p>从商业运作的角度阐述了不同行业运作的规则，并针对性地给出不同行业中所关注的核心指标。</p>
</li>
</ol>
<p><br></p>
<h2 id="经济学-6本"><a href="#经济学-6本" class="headerlink" title="经济学 - 6本"></a>经济学 - 6本</h2><ol>
<li><p><strong>《世纪末金融风暴》_韩文高 / 2009-11</strong></p>
</li>
<li><p><strong>《小的是美好的》_E.F.舒马赫 / 2009-11</strong></p>
</li>
<li><p><strong>《经济学原理：微观经济学分册》_N.格里高利·曼昆 / 2010-04</strong></p>
</li>
<li><p><strong>《经济学原理：宏观经济学分册》_N.格里高利·曼昆 / 2010-04</strong></p>
</li>
<li><p><strong>《增长的困惑》_[英] 理查德.杜韦斯特 / 2012-02</strong></p>
</li>
<li><p><strong>《货币金融学》_费雷德里克.S.米什金(Frederic S. Mishkin ) / 2017-07</strong> （未完）</p>
</li>
</ol>
<p><br></p>
<h2 id="投资理财-7本"><a href="#投资理财-7本" class="headerlink" title="投资理财 - 7本"></a>投资理财 - 7本</h2><ol>
<li><p><strong>《彼得·林奇的成功投资》_彼得·林奇 / 2009-11</strong></p>
</li>
<li><p><strong>《投资者的未来》_[美]杰里米.J.西格尔 / 2009-12</strong></p>
</li>
<li><p><strong>《漫步华尔街》_伯顿 G·马尔基尔 / 2009-12</strong></p>
</li>
<li><p><strong>《巴比伦富翁的理财课》_乔治·克拉森 / 2014-12</strong></p>
</li>
<li><p><strong>《富爸爸穷爸爸》_罗伯特·清崎 &amp; 莎伦·莱希特 / 2015-01</strong></p>
</li>
<li><p><strong>《小狗钱钱》_[德] 博多.舍费尔 / 2015-01</strong></p>
</li>
<li><p><strong>《The Millionaire Fastlane》_MJ.DeMarco / 2016-06</strong></p>
<p>虽然是一本全英文书籍，但内容很好。</p>
</li>
</ol>
<p><br></p>
<h2 id="人物传记-7本"><a href="#人物传记-7本" class="headerlink" title="人物传记 - 7本"></a>人物传记 - 7本</h2><ol>
<li><p><strong>《马云创造：颠覆传统的草根创业者传奇》_杨艾祥 / 2008-12</strong></p>
</li>
<li><p><strong>《林肯》_[德] 艾密尔.鲁特维克 / 2009-01</strong></p>
</li>
<li><p><strong>《105亿传奇：黄光裕和他的国美帝国》_吴阿仑 / 2009-11</strong></p>
</li>
<li><p><strong>《杰克.韦尔奇自传》_[美]杰克.韦尔奇 / 2010-11</strong></p>
</li>
<li><p><strong>《史蒂夫.乔布斯传》_[美] 沃尔特.艾萨克森 / 2012-03</strong></p>
</li>
<li><p><strong>《你好，我是费曼》_[美]理查德.费曼(Richard P. Feynman) / 2017-07</strong> </p>
</li>
<li><p><strong>《向死而生：我修的死亡学分》_李开复 / 2017-11</strong></p>
<p>讲述的是李开复在诊断出患有癌症后，在治疗中关于对待人生的感悟，对于在事业、家人与生活之间的关系有了新的认识。</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h2 id="文学小说-12本"><a href="#文学小说-12本" class="headerlink" title="文学小说 - 12本"></a>文学小说 - 12本</h2><ol>
<li><p><strong>《莎士比亚四大悲剧》_[英] 威廉.莎士比亚 / 2010-02</strong></p>
<blockquote>
<p>《哈姆雷特》《奥赛罗》《李尔王》《麦克白斯》</p>
</blockquote>
</li>
<li><p><strong>《围城》_钱钟书 / 2010-03</strong></p>
</li>
<li><p><strong>《狼图腾》_姜戎 / 2010-10</strong></p>
</li>
<li><p><strong>《不能承受的生命之轻》_米兰·昆德拉(Milan Kundera)  / 2011-03</strong></p>
</li>
<li><p><strong>《假如给我三天光明》_[美] 凯勒 / 2014-08</strong> </p>
</li>
<li><p><strong>《何以笙箫默》_顾漫 / 2014-11</strong></p>
</li>
<li><p><strong>《活出生命的意义》_[美] 维克多.弗兰克尔 / 2015-03</strong></p>
</li>
<li><p><strong>《小王子》_[法] 圣埃克苏佩里 / 2015-05</strong></p>
</li>
<li><p><strong>《皮囊》_蔡崇达 / 2016-04</strong></p>
</li>
<li><p><strong>《离开前请叫醒我》_卢思浩 / 2017-03</strong></p>
</li>
<li><p><strong>《局外人》_[法] 加缪 / 2017-12</strong></p>
</li>
<li><p><strong>《看见》_柴静 / 2017-10 （未完）</strong></p>
</li>
</ol>
<p><br></p>
<h2 id="哲学-4本"><a href="#哲学-4本" class="headerlink" title="哲学 - 4本"></a>哲学 - 4本</h2><ol>
<li><strong>《超越神话：古希腊人的哲学智慧》_曹兴 / 2008-12</strong></li>
<li><strong>《逻辑学》_[德] 黑格尔 / 2009-02</strong></li>
<li><strong>《逻辑学基础教程》_南开大学哲学系 / 2009-02</strong></li>
<li><strong>《逻辑》_雍琦 / 2009-07</strong></li>
</ol>
<p><br></p>
<h2 id="军事-4本"><a href="#军事-4本" class="headerlink" title="军事 - 4本"></a>军事 - 4本</h2><ol>
<li><strong>《二战十六大战役故事秘档全公开》_侯鲁梁 / 2009-03</strong></li>
<li><strong>《孙子兵法全集》_陈才俊 / 2012-03</strong></li>
<li><strong>《三十六计全集》_陈才俊 / 2012-03</strong></li>
<li><strong>《三十六计全鉴》_东篱子 / 2012-03</strong></li>
</ol>
<p><br></p>
<h2 id="自然科学-1本"><a href="#自然科学-1本" class="headerlink" title="自然科学 - 1本"></a>自然科学 - 1本</h2><ol>
<li><strong>《狭义与广义相对论浅说》_[美] 阿尔伯特·爱因斯坦 / 2015-01</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2008-2017年度共阅读13个大类（不完全统计），共计161本，读书笔记98篇，罗辑思维音频若干（含2场时间的朋友）。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/tags/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据分析_组织架构</title>
    <link href="http://yoursite.com/2018/02/04/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E9%83%A8%E9%97%A8_%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84_20180204/"/>
    <id>http://yoursite.com/2018/02/04/数据分析/数据部门_组织架构_20180204/</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-02-12T12:49:27.928Z</updated>
    
    <content type="html"><![CDATA[<p>S：对数据工作做了总结之后（分为两大模块：数据平台、数据使用），想了解当前社会对数据分析工作的定位是如何的；引发通过了解 数据分析部门所处的组织架构去认识</p>
<p>W：通过对组织架构的研究，去定义/剖析不同组织架构下数据分析部门当前所处的阶段与机制；</p>
<p>B：达到状态：能够去辨别一家公司对数据分析工作的定位与重视度</p>
<blockquote>
<p>在一个企业中，可能数据部门在一个公司中组织架构中的位置，决定了部门的定位和一些做的事情，数据部门所处的组织架构对数据价值实现是一个很重要因素。</p>
</blockquote>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="数据部门发展的阶段"><a href="#数据部门发展的阶段" class="headerlink" title="数据部门发展的阶段"></a>数据部门发展的阶段</h2><p>这是一个必须要经历的过程。</p>
<p><img src="http://s3.51cto.com/wyfs02/M00/7A/57/wKioL1aoLliAi5sUAAGtpVWm3FI986.jpg-wh_651x-s_895689990.jpg" alt="img"></p>
<p><br></p>
<h2 id="数据工作的两大模块"><a href="#数据工作的两大模块" class="headerlink" title="数据工作的两大模块"></a>数据工作的两大模块</h2><p>数据部门分成二个部门：</p>
<ol>
<li>后端：数据仓库，大数据平台等；</li>
<li>前端，例如：数据分析，数据挖掘，数据产品等;</li>
</ol>
<p><br></p>
<h2 id="常见的部门架构"><a href="#常见的部门架构" class="headerlink" title="常见的部门架构"></a>常见的部门架构</h2><h3 id="分散式"><a href="#分散式" class="headerlink" title="分散式"></a>分散式</h3><p><strong>数据平台由技术部建设，技术没有数据分析/业务分析人员</strong>；这部分人员都分到各个业务块中。</p>
<p><strong>技术部负责搭建大数据平台</strong>(在传统主要叫数据仓库)。目前大数据平台，如果比较大型的公司基本上会包括几块内容：</p>
<ol>
<li>分布式：hadoop 平台;</li>
<li>实时计算: storm平台</li>
<li>内存计算：spark 平台</li>
<li>传统关系数据库</li>
</ol>
<p><strong>业务分析人员获取数据</strong></p>
<ol>
<li>向数据平台接口人提需求，最终<strong>以报表的形式获取数据。</strong>把业务方的进行转化，转为PRD文档，让ETL开发工程师，报表开发工程师实现 。<u>【业务人员是没有访问数据仓库的权限的】</u></li>
<li>开放所有给业务人员进行去访问，业务可以自己访问部分数据，去写SQL去取数据。</li>
</ol>
<p><strong>适合情况</strong>： 在一些业务变化不快，或者业务相对不那么复杂的公司可能比较好。</p>
<p>对一些业务复杂，业务变化非常快的可能就不适合：</p>
<ul>
<li>数据平台/仓库建议跟不上业务变化。造成数据仓库效率低，数据口径混乱。因为数据仓库架构离业务比较远，对业务理解不深。</li>
<li>业务数据分析师很多人的知识不能很有效沉淀下来。</li>
</ul>
<p>这会<strong>导致业务要求为各个业务建议自己 “数据集市”，当这种数据集市我的时候，又会造成数据仓库负担中，各个业务方的数据“各大自为政”。</strong>最终公司数据混乱，后面大家对数据都摇头。</p>
<p>对于不把数据分析独立存在的公司，数据分析只是个数据展现工具，根本谈不上分析，而形成不了整体的营销能力.</p>
<p><img src="http://s3.51cto.com/wyfs02/M02/7A/57/wKioL1aoLqnwrtsiAAG1g9SgjmQ970.jpg-s_1537300888.jpg" alt="img"></p>
<p><br></p>
<h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p><strong>公司所有的数据相关都归到一个部门中。</strong>业务方有任何需要都会向数据部门提出，数据部门会在内部对这些需求和报表进行沟通，避免重复开发，也便于对需求进行总结。</p>
<p>优势：所有的数据都是一个部门出，相对来说数据的口径会比较统一;</p>
<p>劣势：如果部门组织的不好。会造成数据部门离业务比较远 ;有时候对于数据的思考不够深入，造成与业务部门的沟通成本上升。</p>
<p><img src="http://s4.51cto.com/wyfs02/M02/7A/58/wKiom1aoLq7RFdXFAAGqOo9TwXo720.jpg-s_3999238439.jpg" alt="img"></p>
<p><br></p>
<h3 id="混合式"><a href="#混合式" class="headerlink" title="混合式"></a>混合式</h3><p><strong>大数据平台建设由技术负责，他们核心是把数据平台建设的足够强大。</strong></p>
<ul>
<li>有一个比较大的数据部门，负责数据分析，挖掘，数据统一工作。一般来说这个部门会直接像管理层汇报，主要服务公司管理层;同时也会和业务方的数据分析师合作一起解决某个具体问题。</li>
</ul>
<p><strong>在业务方也会有自己的小数据分析团队。</strong></p>
<ul>
<li>这个数据团队主要服务由自己这个业务团队，同时也会和公司的数据部门有沟通和合作。</li>
</ul>
<p><img src="http://s4.51cto.com/wyfs02/M01/7A/57/wKioL1aoL6rRKA2WAAGwX7e22cA183.jpg-s_519638876.jpg" alt="img"></p>
<p><br></p>
<p><br></p>
<h2 id="传统BI"><a href="#传统BI" class="headerlink" title="传统BI"></a>传统BI</h2><blockquote>
<p><strong>问题：为什么传统BI没有达到今天互联网数据应用的高度呢?</strong></p>
</blockquote>
<p>在传统的BI中，<strong>更多只实现最底层价值。</strong> </p>
<p>$$ &lt; 数据存储技术与成本 \to 数据运算效率 \to 公司数据价值意识 \to 数据相关部门架构 &gt; $$</p>
<ul>
<li>传统的BI，更多是<strong>偏重数据仓库的架构</strong>，根据需求来帮报表。</li>
<li>在数据部门没有一批主动去思考业务，思考业务与数据关系的人。<strong>这种人很可能都是在业务方，他们更多把业务问题转为要看的报表，然后与数据部门沟通报表开发</strong>，数据部门收集需求沟通后，进行排期</li>
</ul>
<p><br></p>
<h2 id="对当前公司架构的思考"><a href="#对当前公司架构的思考" class="headerlink" title="对当前公司架构的思考"></a>对当前公司架构的思考</h2><p>组织架构：<strong>混合式的优化版</strong></p>
<ol>
<li>大数据平台、数据仓库由技术部门统一负责</li>
<li>各个业务团队成立独立的数据分析部门，进行数据分析、挖掘、数据统一工作。也是由专业的数据分析人员构成，而非业务端的人员担任。</li>
</ol>
<p>优势：(1) 分析人员独立于业务部门，可以统一数据口径，并给出客观中立的报表； (2) 站在业务与后端IT 中间，作为两者最佳的构成桥梁，减少了沟通成本</p>
<p>劣势：一方面并没有真正贴近业务，另一方面偏离数据源有一定距离；一个是业务的理解，一个是资源分配与沟通；若处理不好，会进退两难；但若管理得当，是一个强有利的推进器。</p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S：对数据工作做了总结之后（分为两大模块：数据平台、数据使用），想了解当前社会对数据分析工作的定位是如何的；引发通过了解 数据分析部门所处的组织架构去认识&lt;/p&gt;
&lt;p&gt;W：通过对组织架构的研究，去定义/剖析不同组织架构下数据分析部门当前所处的阶段与机制；&lt;/p&gt;
&lt;p&gt;B：达到状态：能够去辨别一家公司对数据分析工作的定位与重视度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个企业中，可能数据部门在一个公司中组织架构中的位置，决定了部门的定位和一些做的事情，数据部门所处的组织架构对数据价值实现是一个很重要因素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据分析_发展历史</title>
    <link href="http://yoursite.com/2018/02/03/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2_20180203/"/>
    <id>http://yoursite.com/2018/02/03/数据分析/20_数据分析/数据分析_发展历史_20180203/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-02-21T08:56:21.930Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数据分析的发展历史</strong></p>
<a id="more"></a>
<p><br></p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>大师、企业家、权威机构；</p>
<p>求同，取精</p>
</blockquote>
<p><br></p>
<h2 id="驱动因素"><a href="#驱动因素" class="headerlink" title="驱动因素"></a>驱动因素</h2><blockquote>
<p>为什么产生、为什么受到关注、为什么变得流行</p>
</blockquote>
<p><br></p>
<h2 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h2><blockquote>
<p>特征、代表性观点/事件/人物、时间点</p>
</blockquote>
<p><br></p>
<h2 id="构成要素"><a href="#构成要素" class="headerlink" title="构成要素"></a>构成要素</h2><blockquote>
<p>模块、方面组成</p>
</blockquote>
<p><br></p>
<h2 id="模式类别"><a href="#模式类别" class="headerlink" title="模式类别"></a>模式类别</h2><blockquote>
<p>特点、典型代表、优劣势、适用情况</p>
<p>优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段</p>
</blockquote>
<p><br></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote>
<p>分模块 或者 分模式</p>
</blockquote>
<p><strong>数据只有结合了业务才是有价值的，数据体现可以用四个字词概括，<u>看数据、用数据、依赖数据、数据变现</u>。</strong></p>
<blockquote>
<p><a href="http://www.afenxi.com/post/39570" target="_blank" rel="external">http://www.afenxi.com/post/39570</a></p>
</blockquote>
<ol>
<li><strong>看数据，</strong> 能然让业务准确、及时、完整的看到数据， 落地是在报表、取数等；</li>
<li><strong>用数据，</strong> 业务上通过数据做出决策 ，落地是异常监控/专题分析；</li>
<li><strong>依赖数据，</strong>数据嵌入到业务的日常流程中，通过<strong>数据挖掘高价值信息推进业务</strong>，落地点在数据产品，数据挖掘产品；</li>
<li><strong>数据变现，</strong>利用数据来赚钱了，落地点可在外部数据平台，数据产品上；</li>
</ol>
<p>在这整个环节中”数据分析师“是做什么呢？我们从分析师的日常工作来分析看，临时需求、报表、数据分析与模型、数据产品，数据挖掘这几个角度来聊一下；</p>
<p><strong>临时需求，</strong>就是解决业务的一次性，临时的数据需求；报表，是根据业务的需要，对于常规且定期查看与分析的数据，形成report；</p>
<p><strong>数据分析与模型</strong>，与业务一起沟通，分析业务上的各种问题，提供一些业务上的建议与取舍，根据业务需要搞一些挖掘模型等；</p>
<p><strong>数据产品，</strong>是通过可视化的方式解决一些结构化（固化）业务问题；把数据分析模型、分析思路与数据结合、面向定向业务提供分析产品；</p>
<p><strong>数据挖掘，</strong><u>数据直接作用到业务上，比如作弊用户、标签推荐、用户行为的定向引导；</u></p>
<p><br></p>
<h2 id="导入方法"><a href="#导入方法" class="headerlink" title="导入方法"></a>导入方法</h2><blockquote>
<p>工作 &amp; 成果</p>
</blockquote>
<p>数据人就要考虑在当前的业务状态中，该如何考虑对业务做到帮助与支持，或者是做数据的的人必须深入到业务中，如何深入呢，或者说是消息一定要灵通；</p>
<p>1、要与各种boss 1vs1 了解他们的想法。</p>
<p>2、参与到管理层的会议中，可以不用发言，但是要一定了解公司的管理层的理念、思路与战略、甚至是feature 的发布；</p>
<p>3、多的时数据人应该与运营在一起、一些活动、一些运营数据分析师也要参与进去也要尝试去一起做一下；</p>
<p>4、参与到公司的日常产品设计中去，在产品的立项阶段就去尝试获取信息；</p>
<p><br></p>
<h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><blockquote>
<p>资料来源：《数据挖掘与数据化运营实战》 - 卢辉 ；<a href="http://www.chforce.com/books/datamining-om-by-data/index.html" target="_blank" rel="external">http://www.chforce.com/books/datamining-om-by-data/index.html</a></p>
</blockquote>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据挖掘是指从数据集合中<strong>自动抽取隐藏在数据中的</strong>那些有用信息的非平凡过程，这些信息的表现形式为规则、概念、规律及模式等。</p>
<p>数据挖掘融合了数据库、人工智能、机器学习、统计学、高性能计算、模式识别、神经网络、数据可视化、信息检索和空间数据分析等多个领域的理论和技术</p>
<p><br></p>
<h2 id="驱动因素-1"><a href="#驱动因素-1" class="headerlink" title="驱动因素"></a>驱动因素</h2><p><br></p>
<h2 id="发展阶段-1"><a href="#发展阶段-1" class="headerlink" title="发展阶段"></a>发展阶段</h2><p>数据挖掘起始于20世纪下半叶，是在当时多个学科发展的基础上发展起来的。随着数据库技术的发展应用，数据的积累不断膨胀，导致简单的查询和统计已经无法满足企业的商业需求，急需一些革命性的技术去挖掘数据背后的信息。同时，这期间计算机领域的人工智能（Artificial Intelligence）也取得了巨大进展，进入了机器学习的阶段。因此，人们将两者结合起来，<strong>用数据库管理系统存储数据，用计算机分析数据</strong>，并且尝试挖掘数据背后的信息。这两者的结合促生了一门新的学科，即数据库中的知识发现<strong>（Knowledge Discovery in Databases，KDD）</strong>。1989年8月召开的第11届国际人工智能联合会议的专题讨论会上首次出现了知识发现（KDD）这个术语，到目前为止，KDD的重点已经从发现方法转向了实践应用。</p>
<p>数据挖掘（Data Mining）则是知识发现（KDD）的核心部分，它指的是从数据集合中自动抽取隐藏在数据中的那些有用信息的非平凡过程，这些信息的表现形式为：规则、概念、规律及模式等。</p>
<p><br></p>
<h2 id="构成要素-1"><a href="#构成要素-1" class="headerlink" title="构成要素"></a>构成要素</h2><blockquote>
<p>模块、方面组成</p>
</blockquote>
<p>数据挖掘融合了<u><strong>数据库、人工智能、机器学习、统计学、高性能计算、模式识别</strong></u>、神经网络、数据可视化、<u><strong>信息检索</strong></u>和空间数据分析等多个领域的理论和技术</p>
<p><br></p>
<h3 id="统计分析-VS-数据挖掘"><a href="#统计分析-VS-数据挖掘" class="headerlink" title="统计分析 VS. 数据挖掘"></a>统计分析 VS. 数据挖掘</h3><h4 id="应用过程"><a href="#应用过程" class="headerlink" title="应用过程"></a>应用过程</h4><ul>
<li>统计分析的基础之一就是<strong>概率论</strong>，在对数据进行统计分析时，分析人员常常需要对数据分布和变量间的关系做<strong>假设</strong>，确定<strong>用什么概率函数来描述变量间的关系</strong>，以及如何<strong>检验参数的统计显著性</strong></li>
<li>在数据挖掘的应用中，分析人员<strong>不需要对数据分布做任何假设</strong>，数据挖掘中的<strong>算法会自动寻找</strong>变量间的关系。</li>
</ul>
<p><br></p>
<h4 id="侧重点-解释-VS-预测"><a href="#侧重点-解释-VS-预测" class="headerlink" title="侧重点 - 解释 VS. 预测"></a>侧重点 - 解释 VS. 预测</h4><ul>
<li>统计分析在预测中的应用常表现为一个或一组<strong>函数关系式</strong> （易于解释）</li>
<li>数据挖掘在预测应用中的<strong>重点在于预测的结果</strong>，很多时候并不会从结果中产生明确的函数关系式，有时候甚至<strong>不知道到底是哪些变量在起作用，又是如何起作用的。</strong> （也无需知道）<ul>
<li>最典型的例子就是“神经网络”挖掘技术，它里面的隐蔽层就是一个“黑箱”，没有人能在所有的情况下读懂里面的非线性函数是如何对自变量进行组合的。</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="结合应用"><a href="#结合应用" class="headerlink" title="结合应用"></a>结合应用</h3><p>针对具体的业务分析需求，<strong>先确定分析思路，然后根据这个分析思路去挑选和匹配合适的分析算法、分析技术</strong>，而且一个具体的分析需求一般都会有两种以上不同的思路和算法可以去探索，最后可根据验证的效果和资源匹配等一系列因素进行综合权衡，从而决定最终的思路、算法和解决方案。</p>
<p><br></p>
<h2 id="模式类别-1"><a href="#模式类别-1" class="headerlink" title="模式类别"></a>模式类别</h2><blockquote>
<p>特点、典型代表、优劣势、适用情况</p>
<p>优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段</p>
</blockquote>
<p><br></p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><ol>
<li>概念：建模过程类似一棵树的成长过程，即从根部开始，到树干，到分枝，再到细枝末节的分叉，最终生长出一片片的树叶。在决策树里，所分析的数据样本先是集成为一个树根，然后经过层层分枝，最终形成若干个结点，每个结点代表一个结论。</li>
<li>优势：<strong>易解释、高容错性</strong><ul>
<li>它所产生的一系列从树根到树枝（或树叶）的规则，可以很<strong>容易地被分析师和业务人员理解</strong>，而且这些典型的规则甚至不用整理（或稍加整理），就是现成的可以应用的业务优化策略和业务优化路径。</li>
<li>决策树技术<strong>对数据的分布甚至缺失非常宽容</strong>，不容易受到极值的影响。</li>
</ul>
</li>
<li>应用：<strong>分类、预测</strong><ul>
<li>作为分类、预测问题的典型支持技术，它在用户划分、行为预测、规则梳理等方面具有广泛的应用前景，决策树甚至可以作为其他建模技术前期进行变量筛选的一种方法，即通过决策树的分割来筛选有效地输入自变量。</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><ol>
<li>概念：“神经网络” 就是通过输入多个非线性模型以及不同模型之间的<strong>加权互联</strong>（加权的过程在隐蔽层完成），最终得到一个输出模型。其中，隐蔽层所包含的就是非线性函数。<ul>
<li>目前最主流的“神经网络”算法是反馈传播（Backpropagation），该算法在多层前向型（Multilayer Feed-Forward）神经网络上进行学习，而多层前向型神经网络又是由一个输入层、一个或多个隐蔽层以及一个输出层组成的</li>
</ul>
</li>
<li>优势：<strong>自适应性、自组织性、高容错性</strong><ul>
<li>拥有特有的大规模<strong>并行结构</strong>和信息的<strong>并行处理</strong>等特点，因此它具有良好的自适应性、自组织性和高容错性，并且具有较强的学习、记忆和识别功能。</li>
</ul>
</li>
<li>劣势：<strong>不可解释性</strong><ul>
<li>知识和结果的不可解释性，没有人知道隐蔽层里的非线性函数到底是如何处理自变量的</li>
</ul>
</li>
<li>应用：<strong>分类、预测</strong><ul>
<li>在用户划分、行为预测、营销响应等诸多方面具有广泛的应用前景。</li>
</ul>
</li>
<li>模型的重要因素：<ul>
<li>层数</li>
<li>每层中输入变量的数量</li>
<li>联系的种类</li>
<li>联系的程度</li>
<li>转换函数，又称激活函数或挤压函数</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><ol>
<li><p>概念：回归（Regression）分析包括线性回归（Linear Regression），这里主要是指<strong>多元线性回归</strong>和<strong>逻辑斯蒂回归</strong>（Logistic Regression）。</p>
<p>​</p>
</li>
<li><p>多元线性回归主要描述一个因变量如何随着一批自变量的变化而变化，其回归公式（回归方程）就是因变量与自变量关系的数据反映。因变量的变化包括两部分：系统性变化与随机变化，其中，系统性变化是由自变量引起的（自变量可以解释的），随机变化是不能由自变量解释的，通常也称作残值。</p>
<ul>
<li>用来估算多元线性回归方程中自变量系数的方法中，最常用的是<strong>最小二乘法</strong>，即找出一组对应自变量的相应参数，以使因变量的<strong>实际观测值与回归方程的预测值之间的总方差减到最小</strong>。</li>
<li>主要假设：<ul>
<li>输入变量是确定的变量，不是随机变量，而且输入的变量间无线性相关，即<u>无共线性</u>。</li>
<li>随机误差的期望值总和为零，即<u>随机误差与自变量不相关</u>。</li>
<li>随机误差呈现<u>正态分布</u></li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑斯蒂回归，它又包括响应预测、分类划分等。凡是预测“两选一”事件的可能性（比如，“响应”还是“不响应”；“买”还是“不买”；“流失”还是“不流失”），都可以采用逻辑斯蒂回归方程。</p>
<ul>
<li>因变量是介于0和1之间的概率</li>
<li><strong>最大似然法</strong>是逻辑斯蒂回归所采用的参数估计方法，<strong>其原理是找到这样一个参数，可以让样本数据所包含的观察值被观察到的可能性最大。</strong>这种寻找最大可能性的方法需要反复计算，对计算能力有很高的要求。最大似然法的优点是在大样本数据中参数的估值稳定、偏差小，估值方差小。</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h3><ol>
<li><p>概念：关联规则数据挖掘的主要目的是找<strong>出数据集中的频繁模式</strong>（Frequent Pattern），即多次重复出现的模式和并发关系（Cooccurrence Relationships），即同时出现的关系，频繁和并发关系也称作关联（Association）。</p>
<ul>
<li>应用关联规则最经典的案例就是购物篮分析（Basket Analysis），通过分析顾客购物篮中商品之间的关联，可以挖掘顾客的购物习惯，从而帮助零售商更好地制定有针对性的营销策略。</li>
<li>支持度（Support）和置信度（Confidence）是衡量关联规则强度的两个重要指标，它们分别反映着所发现规则的有用性和确定性。<ul>
<li>支持度：规则X→Y的支持度是指事物全集中包含X∪Y的<strong>事物百分比</strong>。支持度主要衡量规则的<strong>有用性</strong>，如果支持度太小，则说明相应规则只是偶发事件。在商业实战中，偶发事件很可能没有商业价值；</li>
<li>置信度：规则X→Y的置信度是指既包含了X又包含了Y的事物数量<strong>占所有包含了X的事物数量的百分比</strong>。置信度主要衡量规则的<strong>确定性（可预测性）</strong>，如果置信度太低，那么从X就很难可靠地推断出Y来</li>
</ul>
</li>
</ul>
<blockquote>
<p>婴儿尿不湿→啤酒[支持度=10%，置信度=70%]</p>
<p>这个规则表明，在所有顾客中，有10%的顾客同时购买了婴儿尿不湿和啤酒，而在所有购买了婴儿尿不湿的顾客中，占70%的人同时还购买了啤酒。发现这个关联规则后，超市零售商决定把婴儿尿不湿和啤酒摆放在一起进行促销，结果明显提升了销售额，这就是发生在沃尔玛超市中“啤酒和尿不湿”的经典营销案例。</p>
</blockquote>
</li>
<li><p>主要算法：Apriori</p>
<ul>
<li>（1）生成所有的频繁项目集。一个频繁项目集（Frequent Itemset）是一个支持度高于最小支持度阀值（min-sup）的项目集。</li>
<li>（2）从频繁项目集中生成所有的可信关联规则。这里可信关联规则是指置信度大于最小置信度阀值（min-conf）的规则。</li>
</ul>
</li>
<li><p>应用：比如发现单词间的并发关系以及Web的使用模式</p>
<ul>
<li>不但在数值型数据集的分析中有很大用途，而且在纯文本文档和网页文件中，也有着重要用途。</li>
</ul>
<p>​</p>
</li>
</ol>
<p><br></p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><ol>
<li><p>概念：针对几个特定的业务指标，可以将观察对象的群体按照相似性和相异性进行不同群组的划分。经过划分后，每个群组内部各对象间的相似度会很高，而在不同群组之间的对象彼此间将具有很高的相异度。</p>
</li>
<li><p>方法：算法可以分为<strong>划分的方法</strong>（Partitioning Method）、<strong>层次的方法</strong>（Hierarchical Method）、基于密度的方法（Density-based Method）、基于网格的方法（Grid-based Method）、基于模型的方法（Model-based Method）等，其中，前面两种方法最为常用。</p>
<ul>
<li>划分的方法（Partitioning Method），当给定m个对象的数据集，以及希望生成的细分群体数量K后，即可采用这种方法将这些对象分成K组（K≤m），使得每个组内对象是相似的，而组间的对象是相异的。<ul>
<li>常用的划分方法是K-Means方法，其具体原理是：首先，随机选择K个对象，并且所选择的每个对象都代表一个组的初始均值或初始的组中心值；对剩余的每个对象，根据其与各个组初始均值的距离，将它们分配给最近的（最相似）小组；然后，重新计算每个小组新的均值；这个过程不断重复，直到所有的对象在K组分布中都找到离自己最近的组。</li>
</ul>
</li>
<li>层次的方法（Hierarchical Method）则是指依次让最相似的数据对象两两合并，这样不断地合并，最后就形成了一棵聚类树。</li>
</ul>
</li>
<li><p>应用：既可以直接作为模型对观察对象进行群体划分（为业务方的精细化运营提供具体的细分依据和相应的运营方案建议）；又可在数据处理阶段用作数据探索的工具，包括发现离群点、孤立点，数据降维的手段和方法，通过聚类发现数据间的深层次的关系等。</p>
<p>​</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h3 id="贝叶斯方法"><a href="#贝叶斯方法" class="headerlink" title="贝叶斯方法"></a>贝叶斯方法</h3><ol>
<li><p>概念：贝叶斯分类方法（Bayesian Classifier）是非常成熟的统计学分类方法，它主要用来<strong>预测类成员间关系的可能性</strong>。比如通过一个给定观察值的相关属性来判断其属于一个特定类别的概率。贝叶斯分类方法是基于贝叶斯定理的，已经有研究表明，朴素贝叶斯分类方法作为一种简单贝叶斯分类算法甚至可以跟决策树和神经网络算法相媲美。</p>
<p>$$P(H|X) = {P(H|X)P(X) \over P(X)}$$</p>
<ul>
<li>其中，X表示n个属性的测量描述；H为某种假设，比如假设某观察值X属于某个特定的类别C；对于分类问题，希望确定P(H|X)，即能通过给定的X的测量描述，来得到H成立的概率，也就是给出X的属性值，计算出该观察值属于类别C的概率。因为P(H|X)是后验概率（Posterior Probability），所以又称其为在条件X下，H的后验概率。</li>
</ul>
<blockquote>
<p>举例来说，假设数据属性仅限于用教育背景和收入来描述顾客，而X是一位硕士学历，收入10万元的顾客。假定H表示假设我们的顾客将购买苹果手机，则P(H|X)表示当我们知道顾客的教育背景和收入情况后，该顾客将购买苹果手机的概率；相反，P(X|H)则表示如果已知顾客购买苹果手机，则该顾客是硕士学历并且收入10万元的概率；而P(X)则是X的先验概率，表示顾客中的某个人属于硕士学历且收入10万元的概率；P(H)也是先验概率，只不过是任意给定顾客将购买苹果手机的概率，而不会去管他们的教育背景和收入情况。</p>
<p>从上面的介绍可见，相比于先验概率P(H)，后验概率P(H|X)基于了更多的信息（比如顾客的信息属性），而P(H)是独立于X的。</p>
</blockquote>
</li>
<li><p>概念：朴素贝叶斯分类法（Naive Bayesian Classifier）。如果给定数据集里有M个分类类别，通过朴素贝叶斯分类法，可以预测给定观察值是否属于具有<strong>最高后验概率的特定类别</strong>，也就是说，朴素贝叶斯分类方法预测X属于类别Ci时，表示当且仅当</p>
<p>$$P(C_i|X) &gt; P(C_j|X) ; 1 \le j \le m， j \ne m$$</p>
<p>此时如果最大化P(Ci|X)，其P(Ci|X)最大的类Ci被称为最大后验假设，根据贝叶斯定理</p>
<p>$$P(C_i|X) = { P(X|C_i)P(C_i) \over P(X)}$$</p>
<p>可知，由于P(X)对于所有的类别是均等的，因此只需要P(X|Ci)P(Ci)取最大即可。为了预测一个未知样本X的类别，可对每个类别Ci估算相应的P(X|Ci)P(Ci)。样本X归属于类别Ci，当且仅当</p>
<p>P(Ci|X)＞P(Cj|X)1≤j≤m，j≠i</p>
</li>
<li><p>应用：<strong>分类</strong></p>
</li>
</ol>
<p><br></p>
<h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><ol>
<li>概念：支持向量机以结构风险最小为原则。在线性的情况下，就在原空间寻找两类样本的最优分类超平面。在非线性的情况下，它使用一种非线性的映射，将原训练集数据映射到较高的维上。在新的维上，它搜索线性最佳分离超平面。使用一个适当的对足够高维的非线性映射，两类数据总可以被超平面分开。<ul>
<li>设给定的训练样本集为{(x1,y1),(x2,y2),…,(xn,yn)}，其中xi∈Rn,y∈{-1,1}。</li>
<li>再假设该训练集可被一个超平面线性划分，设该超平面记为(w,x)+b=0。</li>
</ul>
</li>
<li>距离超平面最近的一类向量被称为支持向量（Support Vector），一组支持向量可以唯一地确定一个超平面。通过学习算法，SVM可以自动寻找出那些对分类有较好区分能力的支持向量，由此构造出的分类器则可以最大化类与类的间隔</li>
<li>优势：较好的适应能力和较高的分类准确率。</li>
<li>应用：分类、预测</li>
</ol>
<p><br></p>
<h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><ol>
<li>概念：主成分分析会通过线性组合将多个原始变量合并成若干个主成分，这样每个主成分都变成了原始变量的线性组合。<ul>
<li>这种转变的目的，一方面是可以大幅降低原始数据的维度，同时也在此过程中发现原始数据属性之间的关系。</li>
</ul>
</li>
<li>步骤：<ul>
<li>1）通常要先进行各变量的标准化工作，标准化的目的是将数据按照比例进行缩放，使之落入一个小的区间范围之内，从而让不同的变量经过标准化处理后可以有平等的分析和比较基础。</li>
<li>2）选择协方差阵或者相关阵计算特征根及对应的特征向量。</li>
<li>3）计算方差贡献率，并根据方差贡献率的阀值选取合适的主成分个数。</li>
<li>4）根据主成分载荷的大小对选择的主成分进行命名。</li>
<li>5）根据主成分载荷计算各个主成分的得分。</li>
</ul>
</li>
<li>因子分析：将主成分进行推广和延伸即成为因子分析（Factor Analysis），<strong>因子分析在综合原始变量信息的基础上将会力图构筑若干个意义较为明确的公因子</strong>；也就是说，采用少数几个因子描述多个指标之间的联系，将比较密切的变量归为同一类中，每类变量即是一个因子。之所以称其为因子，是因为它们实际上是不可测量的，只能解释。</li>
<li>主分成分析 VS. 因子分析 （主成分分析是因子分析的一个特例）<ul>
<li>主成分分析会<strong>把主成分表示成各个原始变量的线性组合</strong>，而因子分析则<strong>把原始变量表示成各个因子的线性组合</strong>。</li>
<li>主成分分析的重点在于解释原始变量的<strong>总方差</strong>，而因子分析的重点在于解释原始变量的<strong>协方差</strong>。</li>
<li>在主成分分析中，有几个原始变量就有几个主成分，而在因子分析中，因子个数可以根据业务场景的需要人为指定，并且指定的因子数量不同，则分析结果也会有差异。</li>
<li>在主成分分析中，给定的协方差矩阵或者相关矩阵的特征值是唯一时，主成分也是唯一的。但是在因子分析中，因子不是唯一的，并且通过旋转可以得到不同的因子。</li>
</ul>
</li>
<li>应用：<strong>数据处理、降维、变量间关系的探索</strong></li>
</ol>
<p><br></p>
<h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><ol>
<li>概念：假设检验的基本原理就是<strong>小概率事件原理</strong>，即观测小概率事件在假设成立的情况下是否发生。<u>如果在一次试验中，小概率事件发生了，那么说明假设在一定的显著性水平下不可靠或者不成立；如果在一次试验中，小概率事件没有发生，那么也只能说明没有足够理由相信假设是错误的，但是也并不能说明假设是正确的，因为无法收集到所有的证据来证明假设是正确的。</u><ul>
<li>假设检验的结论是在一定的显著性水平下得出的。因此，当采用此方法观测事件并下结论时，有可能会犯错，这些错误主要有两大类：<ul>
<li>第Ⅰ类错误：当原假设为真时，却否定它而犯的错误，即拒绝正确假设的错误。犯第Ⅰ类错误的概率记为α，通常也叫α错误，α=1-置信度。</li>
<li>第Ⅱ类错误：当原假设为假时，却肯定它而犯的错误，即接受错误假设的错误。犯第Ⅱ类错误的概率记为β，通常也叫β错误。</li>
</ul>
</li>
<li>上述这两类错误在其他条件不变的情况下是相反的，即α增大时，β就减小；α减小时，β就增大。α错误容易受数据分析人员的控制，因此在假设检验中，通常会先控制第Ⅰ类错误发生的概率α，具体表现为：在做假设检验之前先指定一个α的具体数值，通常取0.05或0.01，也可以取0.1或0.001。</li>
</ul>
</li>
<li>应用：运营效果的评估</li>
</ol>
<p><br></p>
<h1 id="大数据平台"><a href="#大数据平台" class="headerlink" title="大数据平台"></a>大数据平台</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>大师、企业家、权威机构；</p>
<p>求同，取精</p>
</blockquote>
<p><br></p>
<h2 id="驱动因素-2"><a href="#驱动因素-2" class="headerlink" title="驱动因素"></a>驱动因素</h2><blockquote>
<p>为什么产生、为什么受到关注、为什么变得流行</p>
</blockquote>
<h3 id="数据产品的产生"><a href="#数据产品的产生" class="headerlink" title="数据产品的产生"></a>数据产品的产生</h3><p>​    互联网企业随着数据更加逐渐被重视，分析师、数据开发在<strong>面对大量的数据需求、海量的临时需求疲惫不堪</strong>，变成了资源的瓶颈，在当时的状态传统的各类的Report、Olap 工具都无法满足互联网行业个性化的数据需求。<strong>开始考虑把需求固定化变为一个面向最终用户自助式、半自助的产品来满足快速获取数据&amp;分析的结果</strong>，当总结出的指标、分析方法(模型)、使用流程与工具有机的结合在一起时<strong><u>数据产品</u></strong>就诞生了。</p>
<p>​    数据产品按照面向的功能与业务可以划分为<strong>面向平台级别的工具型产品、面向用户端的业务级数据产品。</strong></p>
<p>​    按照用户分类可以分为面向内部用户数据产品，面向外部用户个人数据产品、商户(企业)数据产品。<br>​    面向平台级别有数据质量、元数据、调度、资管配置、数据同步分发等等。</p>
<p><br></p>
<h2 id="发展阶段-2"><a href="#发展阶段-2" class="headerlink" title="发展阶段"></a>发展阶段</h2><blockquote>
<p>特征、代表性观点/事件/人物、时间点</p>
</blockquote>
<h3 id="非互联网时代"><a href="#非互联网时代" class="headerlink" title="非互联网时代"></a>非互联网时代</h3><p>自从数据仓库发展起来到现在，基本上可以分为五个时代、四种架构</p>
<ol>
<li>约在1991年前的全企业集成</li>
<li>1991年后的企业数据集成EDW时代</li>
<li>1994年-1996年的数据集市</li>
<li>1996-1997年左右的两个架构吵架</li>
<li>1998年-2001年左右的合并年代</li>
</ol>
<p>五个时代划分是以重要事件或代表人物为标志：</p>
<ol>
<li>在<strong>企业数据集成EDW</strong>时代其重要代表人物是<strong>Bill Inmon</strong> 代表作<strong>数据仓库</strong>一书，更重要是他提出了如何建设数据仓库的指导性意见与原则。他遵循的是自上而下的建设原则，这个导致后来数据仓库在千禧年传到中国后的几年内，几个大实施厂商都是遵守该原则的实施方法，后来的数据仓库之路等各种专业论坛上针对数据仓库ODS-EDW的结构讨论</li>
<li>在<strong>数据集市</strong>年代其代表人物是<strong>Ralph kilmball</strong>，他的代表作是”The Data Warehouse Toolkit“，在数据仓库的建设上Ralph kilmball 提出的是自下而上的建设方法，刚好与Bill Innmon的建设方法相反，这两种架构方式各有千秋，所以就进入了争吵时代。</li>
<li>Bill Inmon 提出的CIF（corporation information factory） 架构模式、这也算是数据仓库的第三代架构，其架构特点是把整个架构划分为不同层次，把每一层次的定义与功能都详细的描述下来，从04年后国内的很多数据仓库架构、甚至互联网刚开始搞数据平台数据仓库架构模式也是这一种。</li>
</ol>
<p><br></p>
<p>ETL 代指数据从不同源到数据平台的整个过程，ETL Mapping 可理解为 数据加工算法，</p>
<p><br></p>
<h3 id="互联网时代"><a href="#互联网时代" class="headerlink" title="互联网时代"></a>互联网时代</h3><h4 id="数据源：多样化"><a href="#数据源：多样化" class="headerlink" title="数据源：多样化"></a>数据源：多样化</h4><p>​    做数据的人，从非互联网进入到互联网最显著的特点是面对的数据源类型忽然多了起来，在传统企业数据人员面对的是结构化存储数据，基本来自excel、表格、DB系统等，在数据的处理技术上与架构上是非常容易总结的，但是在互联网因为业务独特性导致了所接触到的数据源特性多样化，网站点击日志、视频、音频、图片数据等很多非结构化快速产生与保存</p>
<p>​    目前最火热的移动互联网,大家都在通过自己的手机、平板去访问网站、购物等所以每个人都是数据的生产者，移动用户在使用习惯上呈现移动化、碎片化，以至于业务特性、商业模式比传统互联网又有显著差别, 用户在不同位置需求是不同的、使用APP 也是不同的、手机终端类型也是多样化。这些差异性比较导致移动互联网的数据与传统的互联网时代又产生显著差异性。</p>
<blockquote>
<p>例如买家通过Pc购物从浏览物品到支付可能在很短时间内完成，但是通过手购物碎片化就显得多一些，可能在某个空余时间浏览物品，保存或放入购物车，等有时间在去做支付。大约在2009年到2012年之间做用户行为分析感觉很多原有网页端拍下物品去支付，逐渐转为PC端下单通过移动端支付。</p>
</blockquote>
<p>表 - 不同时代数据源的对比</p>
<table>
<thead>
<tr>
<th>行业域</th>
<th>非互联网</th>
<th>互联网</th>
<th>移动互联网</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据来源(相对于数据平台来讲)</td>
<td>结构化各类数据库(DB系统)、结构化文本、Excel表格等，少量word</td>
<td>Web、自定义、系统的日志，各类结构化DB数据、长文本、视频 主要是来自网页</td>
<td>除了互联网那些外还含有大量定位数据、自动化传感器、嵌入式设备、自动化设备等</td>
</tr>
<tr>
<td>数据包含信息</td>
<td>CRM客户信息、事务性 ERP/MRPII 数据、资金账务数据 等。</td>
<td>除了传统企业数据信息外，还含有用户各类点击日志、社交数据、多媒体、搜索、电邮数据等等</td>
<td>除了传统互联网的数据外，还含有Gps、穿戴设备、传感器各类采集数据、自动化传感器采集数据等等</td>
</tr>
<tr>
<td>数据结构特性</td>
<td>几乎都是结构化数据</td>
<td>非结构化数据居多</td>
<td>非结构化数据居多</td>
</tr>
<tr>
<td>数据存储/数据量</td>
<td>主要以DB结构化存储为主，从几百兆到 百G级别</td>
<td>文件形式、DB形式，流方式、 从TB 到PB</td>
<td>文件形式、流方式、DB范式，非结构化 从TB 到PB</td>
</tr>
<tr>
<td>产生周期</td>
<td>慢，几天甚至周为单位</td>
<td>秒或更小为单位</td>
<td>秒或更小为单位</td>
</tr>
<tr>
<td>对消费者行为采集与还原</td>
<td>粒度粗</td>
<td>粒度较细</td>
<td>粒度非常细</td>
</tr>
<tr>
<td>数据价值</td>
<td>长期有效</td>
<td>随着时间衰减</td>
<td>随着时间快速衰减</td>
</tr>
<tr>
<td>单位时间内数据聚合度</td>
<td>高度聚合</td>
<td>聚合度低</td>
<td>聚合度很低</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="数据平台的用户"><a href="#数据平台的用户" class="headerlink" title="数据平台的用户"></a>数据平台的用户</h4><ol>
<li><p><strong>阶段1：在2008年-2011年初。</strong>建设与使用上与非互联网数据平台有这蛮大的相似性，主要相似点在数据平台的建设角色、与使用到的技术上。</p>
<ul>
<li>老板们、运营的需求主要是依赖于报表、分析报告、临时需求、商业智能团队的<a href="http://www.thebigdata.cn/JiShuBoKe/31800.html" target="_blank" rel="external">数据分析</a>师去各种分析、临时需求、挖掘，这些角色是数据平台的适用方。</li>
<li>ETL开发工程师、数据模型建模、数据架构师、报表设计人员 ，同时这些角色又是数据平台数据建设与使用方。</li>
<li>数据平台的技术框架与工具实现主要有技术架构师、JAVA 开发等。</li>
<li>用户面对是结构化的生产数据、PC端非结构化log等 数据。</li>
<li>ELT的数据处理方式(备注在数据处理的方式上，由传统企业的ETL 基本进化为ELT)。</li>
</ul>
</li>
<li><p><strong>阶段2：约在2011年到2014 年。数据产品的诞生。</strong>互联网的数据平台除了受到技术、数据量的驱动外，同时还来自数据产品经理梳理用户的需求按照产品的思维去构建并部署在了数据的平台上。随着数据平台的建设逐渐的进入快速迭代期，数据产品、数据产品经理这两个词逐渐的升温以及被广泛得到认可，同时<strong>数据产品</strong>也随着需求、平台特性分为<strong>面向用户级数据产品、面向平台工具型产品</strong>两个维度分别去建设数据平台。</p>
<ul>
<li>企业各个主要角色都是数据平台用户。</li>
<li>各类数据产品经理(偏业务数据产品、偏工具平台数据产品)推进数据平台的建设。</li>
<li>分析师参与数据平台直接建设比重增加。</li>
<li>数据开发、数据模型角色都是数据平台的建设者与使用者(备注：相对与传统数据平台的数据开发来说，逐渐忽略了数据质量的关注度，数据模型设计角色逐渐被弱化)。</li>
<li>用户面对是数据源多样化，比如日志、生产数据库的数据、视频、音频等非结构化数据。</li>
<li>原有ETL中部分数据转换功能逐渐前置化，放到业务系统端进行(备注：部分原有在ETL阶段需要数据标准化一些过程前置在业务系统数据产生阶段进行，比如Log 日志。 移动互联网的日志标准化。</li>
</ul>
</li>
<li><p><strong>阶段3：</strong>从经营、分析的诉求重点转为数据化的<strong>精细运营上</strong>，对数据的粒度要求<strong>由高汇总逐渐转为过程化细粒度明细数据。</strong></p>
<ul>
<li>随着数据应用的深入，用数据往往不知道数据的口径与来源，加工数据的不知道业务含义，不同部门口径又是不一样，有的从交易来、有的从账务来。这里数据使用与数据加工上就出现了”断层”。有时在层级与功能部门前边也可能存在一个断层，对数据价值的内在衡量是不一样的，角色不一样，对于数据价值的的看法也就不同。</li>
<li>用数据的一些角色(分析师、运营或产品)会自己参与到从数据整理、加工、分析阶段。</li>
<li>当数据平台变为自由全开放，使用数据的人也参与到数据的体系建设时，基本会因为不专业型，导致数据质量问题、重复对分数据浪费存储与资源、口径多样化等等原因。此时原有建设数据平台的多个角色可能转为对其它非专业做数据人员的培训、咨询与落地写更加适合当前企业数据应用的一些方案等。</li>
<li>给用户提供的各类丰富的分析、取数的产品，简单上手的可以使用。</li>
<li>原有ETL、数据模型角色转为给用户提供平台、产品、数据培训与使用咨询。</li>
<li>数据分析师直接参与到数据平台过程、数据产品的建设中去。</li>
<li>用户面对是数据源多样化，比如日志、生产数据库的数据、视频、音频等非结构化数据。</li>
</ul>
<blockquote>
<p>比如说她，是银行的一名普通职员，每天的任务是结算、结汇，从早到晚都在跟数据打交道；因为只用整理好的数据，所以自然不在乎也不注意，数据是如何来的；<strong>整个总结下来是，用数据的人不知道数据哪里来的，做数据的人不知道数据有什么用处；</strong>回忆了下，这还真是一个普遍的现象；</p>
</blockquote>
</li>
</ol>
<p><br></p>
<h2 id="构成要素-2"><a href="#构成要素-2" class="headerlink" title="构成要素"></a>构成要素</h2><blockquote>
<p>模块、方面组成</p>
</blockquote>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><blockquote>
<p>在互联网时代被弱化的数据模型</p>
</blockquote>
<p>在传统数据平台要背后有一个完整数据仓库团队去服务业务方，业务方嗷嗷待哺的等待被动方式去满足。中低层数据基本不会对业务方开放，所以不管数据模型采用何种建模方式，主要满足当时数据架构规划即可。</p>
<p>互联网业务的快速发展使得大家已经从经营、分析的诉求重点转为数据化的精细运营上，如何做好精细化运营问题上来，当资源不够时用户就叫喊，甚至有的业务方会挽起袖子来自己参与到从数据整理、加工、分析阶段。</p>
<p><br></p>
<h2 id="模式类别-2"><a href="#模式类别-2" class="headerlink" title="模式类别"></a>模式类别</h2><blockquote>
<p>特点、典型代表、优劣势、适用情况</p>
<p>优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段</p>
</blockquote>
<p><br></p>
<h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote>
<p>分模块 或者 分模式</p>
</blockquote>
<p><br></p>
<h2 id="导入方法-1"><a href="#导入方法-1" class="headerlink" title="导入方法"></a>导入方法</h2><blockquote>
<p>工作 &amp; 成果</p>
</blockquote>
<p><br></p>
<h1 id="数据产品"><a href="#数据产品" class="headerlink" title="数据产品"></a>数据产品</h1><h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><p>要想把数据产品定义清楚，要拆分成 “数据”、“产品” 两个维度来看。</p>
<p><strong>“产品”</strong> 是一组将输入转化为输出的相互关联或相互作用的活动的结果，<strong>即“过程” 的结果“</strong>。在经济领域中,通常也可理解为组织制造的任何制品或制品的组合。<strong>产品的狭义概念:被生产出的物品；产品的广义概念:可以满足人们需求的载体。</strong></p>
<p><strong>互联网产品的概念</strong>是从传统意义上的“产品”延伸而来的，是在互联网领域中产出而用于经营的商品，它是满足互联网用户需求和欲望的无形载体。简单来说，互联网产品就是指网站为满足用户需求而创建的用于运营的功能及服务，它是网站功能与服务的集成。<em>大家可以分析下百度、腾讯、新浪、优酷、谷歌、facebook 各自的“产品”是什么？</em></p>
<p><strong>移动互联网产品又是什么呢？</strong>我是没有找到比较贴切的概念，只好依照自己简单的想象<u>“已移动设别、网络为基础，构建满足人们的需求而创造出来的功能与服务”，</u>例如基于手机、平板设备上的各种App，微信、手机百度、ingress手游、网易客户端等。</p>
<p><strong>所谓的产品，简单讲就是满足人们某个需求、或解决某个问题的东西。</strong></p>
<p><br></p>
<h2 id="发展阶段-3"><a href="#发展阶段-3" class="headerlink" title="发展阶段"></a>发展阶段</h2><p>自1954年计算机用于工资处理以后，一直到2016年的今天，企业在信息化处理上得到了长足的发展。在这个发展中经历过了数据处理系统、Mis管理系统、决策支持、商业智能。</p>
<p><br></p>
<h3 id="DSS决策支持"><a href="#DSS决策支持" class="headerlink" title="DSS决策支持"></a>DSS决策支持</h3><p><strong>Dss决策支持系统</strong>是建立在对传统企业历史数据集成基础上的数据探索应用，自从数据仓库的出现给对企业的决策支持注入了新的活力，发展到现在的互联网、移动互联网对数据的应用又是一个崭新阶段。</p>
<p>在<strong>20世纪60年到70年</strong>，决策中往往是需要查询多种异构数据源的业务系统、参考外部的数据，进行大量的数据分析后才能做出相关的决策来。</p>
<p>进入到<strong>20世纪80年代</strong>后，随着计算机技术发展、各类数据统计分析的工具逐步健全，尤其是数据仓库的技术发展给传统企业的决策支持系统带来了更大的便利性。传统企业更多的是围绕着日常经营去做经营分析，比如财务绩效状况、资产运营状况、偿债能力状况、发展能力状况等。</p>
<p><br></p>
<h3 id="商业智能"><a href="#商业智能" class="headerlink" title="商业智能"></a>商业智能</h3><p><strong>商业智能（Business Intelligence，简称BI）</strong>的概念最早是Gartner Group 的 Howard Dresner在<strong>1996 年</strong>提出来，传到国内有将之翻译为”商业智能”或”商务智能”。商业智能的应用领域典型电信、银行、保险、零售等，所有建立了数据仓库的企业其商业智能建设的<strong>主要目标是企业决策支持。</strong>商业智能通过对信息技术的运用在不同层面为战略、决策提供新的支持：提升决策者洞察力以及支持信息获取与分析。</p>
<p><strong>在传统企业的商业智能时代</strong>，我个人对其的认识是商业智能本来是<strong>把数据分析和统计运算的结果以多角度的方式存储，然后在OLAP、Report平台上形成一个个面向不同业务需要的数据集市以可视化的展现</strong>，让公司的管理层可以通过看及时和合适方式展示出来的信息来决策，让基层可以用统计运算后的数据进行经营分析与企业日常运作。</p>
<p>这种方式的<strong>核心</strong>是Bill Inmon 、Ralph Kimball的数据仓库Data Warehouse与Codd创造OLAP一词，E.F.Codd发明了在线分析处理（OLAP）一词，来表示多维分所结合的模式，为客户提供OLAP 平台，通过开发一些Report、Dashboard，后台通过ETL 自动刷新数据。        <em>其中ETL工具在当时使用的是Datastage、Informatica、微软Dts或自己开发的脚本等系列来做数据的清洗、转换、加载，而OLAP 平台基本上为BO、Congos、Oracle 等几家的OLAP引擎与报表设计平台。在数据仓库 Data warehouse 中大家可以看到DW层为存储、管理数据设计的模型、数据集市中为 OLAP 而设计的模型。其中数据集市的数据就是数据仓库各层的数据Join与Aggregate的数据集合。</em></p>
<p><strong>传统的数据团队的困惑</strong>在盲目的跟着需求开发，导致开发成果无法确认是否有用、够用，也无法避免无休止的需求变更，导致系统开发成本高、周期长、失败率居高不下。这样的数据平台最大的特点是庞大，初次使用感觉功能非常新鲜，但是在面对具体需求时使用起来难用，无法真正的解决问题。根本没有系统化、产品化，只是一堆数据的堆砌，僵死的报表或cube 开发、设计与开发与业务脱节非常严重，没有任何衔接可言。</p>
<p>——–分割线——–</p>
<p>随着时间的发展，业界听到的BI的声音越来越少了，反而是<strong>对探索数据的价值的数据分析、数据挖掘独立的声音出现</strong>，因为早期传统企业的BI在这件上非常吃力，在过去只是简单从不同角度的堆积数据看统计指标已经不适应决策要看原因，要看影响的程度，执行层面要根据数据分析、挖掘精确来执行。</p>
<ul>
<li>比如过去我们只是看商场的不同品牌的货物卖出多少，在现在要看商品在一天的那个时间段卖的好、摆放哪个位置卖的好、什么样的顾客容易买，客户总消费多少钱，客户订单次数，客户平均客单价、客户最近订单时间等等。</li>
</ul>
<p><strong>初BI</strong>刚进入企业眼前的时候，认为BI可以做很多厉害的事情，各种智能化。随着时间推移，BI从天上掉到了地下，90%多的企业只<strong>剩下数据集成和报表生成部门</strong>。目前一般企业普遍采用的办法是由业务部门提出分析需求，让BI部门统计和分析数据出结果，这样的组合看似合理，却有很多隐患。</p>
<ul>
<li>记得有家公司组建自己的BI团队前，曾经去寻找多家第三方企业来实BI，建立了数据模型和数据处理，交付物开发出各个业务线的需求报表，按照会员维度的日报、周报、月报，商户维度的日报、周报、月报。<strong>然后呢</strong>，业务上尝鲜几天时还挺爽，随后越来越少用直至不用，因为随着堆积迭代无法满足后来的业务需求，其主要数据质量有问题，每个报表数据经常不准、报表上根本看不出什么业务问题来，需要多张报表数据下载进一步加工，这是典型的不深入了解业务而导致数据模型、数据报表堆砌效应引起的。</li>
</ul>
<p><strong>当时大多数BI只能发挥不到1/3的作用，所受限制在于业务与数据的反复磨合，还有数据洞察与整合的客观的业务需要代沟，所谓的数据驱动只是停留在数据与业务分开干的阶段。</strong></p>
<p><br></p>
<h3 id="数据运营"><a href="#数据运营" class="headerlink" title="数据运营"></a>数据运营</h3><p><strong>大家已经从经营、分析的诉求重点转为数据化的精细运营上</strong>。随之而来的面临创新压力、如何做好精细化运营是当今企业遇到的问题。比如一款产品，想在互联网生存下去， 用户是基础，没有用户的产品或许可以自娱自娱自乐，否则将会面临一个问题，如何拉新、如何研究新用户，如何根据不同的用户习惯来调整产品。 对于产品的新用户，使用时会遇到各种问题，产品运营就必须去关注、去分析、以及去解决，<strong>这些过程都是需要数据来衡量与定位的。</strong>如果整个公司都处在一种由之前简单粗暴运营向经营分析乃至数据驱动的运营，必然会造成数据需求暴增。</p>
<p><strong>【数据产品产生的原因】</strong></p>
<ul>
<li>数据化运营对数据需求量越来越大，分析师、数据开发在面对大量的数据需求、海量的临时需求疲惫不堪，变成了资源的瓶颈， 用户其聚焦在无法快速的响应日常需求其表现为，做数据的已经无法满足当前业务日益增长的数据需求。</li>
<li>互联网企业在运营上精细化已经对数据的粒度要求由高汇总逐渐转为过程化细粒度明细数据。而传统的各类的Report、OLAP 工具都无法满足互联网行业个性化的数据需求。</li>
<li>统计过某公司近两个月分析师们的工作内容,背景是从3月份-5月份大家在邮件、需求登记管理平台等内容。大约覆盖分析师3个月工作85%左右，临时需求在69.44%之间，产品发布评估占到 8.89%、周期性需求为（新业务日报周报）6.11%、专题分析8%、数据类项占比为6.67%。这个团队的分析师平均每月工作天数如果全饱和，单纯临时需求总共消耗分析师超过140%时间，均超过35%人月，分析师没有一点时间搞其他的。变成了<strong>纯粹人肉取数机</strong>，更何况分析师还有其它日常工作、专题分析等，更不要说让分析师更有价值。</li>
</ul>
<p>当数据平台、数据分析师想摆脱临时需求的困扰，提高自身的价值时，开始考虑把需求固定化变为一个面向用户自助式、半自助的产品来满足快速获取数据&amp;分析的结果，<strong>当总结出的指标、分析方法（模型）、使用流程与工具有机的结合在一起时候，适合互联网时代的一类数据产品就诞生了。</strong></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;数据分析的发展历史&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>R转战Python</title>
    <link href="http://yoursite.com/2018/02/01/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/R%E8%BD%AC%E6%88%98Python_20180201/"/>
    <id>http://yoursite.com/2018/02/01/软件应用_程序编程/Python/Python_专题总结/R转战Python_20180201/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-13T13:12:59.942Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>从R转战Python：这些包你一定要知道！</strong></p>
<a id="more"></a>
<h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><ul>
<li><strong>R包glm，knn，randomForest，e1071 —&gt; Python模块scikit-learn</strong></li>
</ul>
<p>R中机器学习算法被进行分割，然后以各种包的形式存放，这意味着除非具有单个（或一组）能够执行一些公共算法的机器学习库，否则每个算法都会存在单独的包中。看着这些复杂、但又很清楚的算法时感觉会有点不错，但当日复一日的在算法之间来回切换时，恐怕就会觉得不适了，Python中的scikit-learn模块很好的处理了这个问题。具体的说，scikit-learn提供了一组常见的ML算法，所有算法都在同一个API下，这使得LogisticRegression和GradientBoostingMachines之间可以直接切换。</p>
<p><br></p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><ul>
<li><strong>R包reshape/reshape2,plyr/dplyr —&gt; Python模块 pandas</strong></li>
</ul>
<p>Pandas继承了R中数据变换的较好部分，并且把它转变成一个Python包。该包包括了python中数据框的实现以及修改和重构数据框的方法。基本上它继承了reshape/reshape2和plyr/dplyr并且python化它。</p>
<p><br></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><strong>stringr -&gt; nothing</strong></li>
</ul>
<p>stringr 实在是个神器。它写得很棒，性能也很好（至少我这么认为），而且很方便安装（不要小看这一点，如果人们无法安装你的软件，那么开发就没有意义）。关于stringr 的自卖自夸就结束了。好消息是Python的字符串功能很强大，你甚至不需要一个单独的字符串库！它有<u>超棒的内置正则表达式库，re，和内置的字母串元库，叫string。</u>你太幸运了，Python自带了全部字符串相关的功能。</p>
<p><br></p>
<h4 id="动态报告"><a href="#动态报告" class="headerlink" title="动态报告"></a>动态报告</h4><ul>
<li><strong>R包Knitr —&gt; Python模块 Jupyter</strong></li>
</ul>
<p>Knitr是一种使用R创建可重现和高度可视化分析的好方法。它已经成为Rtudio中一种稳定的功能。在Python世界中，最类似的包是Jupyter。Jupyter笔记本提供了一个用于Python编程（和其他语言）的交互式环境，专注于再现和可视化—它甚至有针对于R的插件。</p>
<p><br></p>
<h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><ul>
<li><strong>R包SQLdf—&gt; Python模块 pandasql</strong></li>
</ul>
<p>Sqldf是SQL用户在熟练操作数据的伟大的方式。当我第一次开始学R时，我自己用的就是这个包。当时，Yhat实际上创建了类似的Python包，称为pandasql。相同的概念：对你的数据框写入SQL查询命令，获取数据框！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;从R转战Python：这些包你一定要知道！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_安装设置&amp;jupyter</title>
    <link href="http://yoursite.com/2018/01/24/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE&amp;Jupyter/"/>
    <id>http://yoursite.com/2018/01/24/软件应用_程序编程/Python/Python_专题总结/Python_安装设置&amp;Jupyter/</id>
    <published>2018-01-23T16:00:00.000Z</published>
    <updated>2018-02-13T13:44:28.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h2><ul>
<li>‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</li>
</ul>
<blockquote>
<p>这个问题本质其实就是，windows的cmd并不能识别python这个符号（即无法识别这个符号是一个可执行程序），因为windows这里也是类似的，遇到一个字符，先会在默认path路径查询这个符号是不是一个可执行程序</p>
</blockquote>
<p>右键我的电脑-&gt;属性-&gt;高级系统配置-&gt;点击高级一栏，在这里栏点开环境变量-&gt;在系统变量PATH加入python的安装路径即可，比如我的就是D:\Python27</p>
<ul>
<li><code>pip</code>不是内部或外部命令，也不是可运行的程序</li>
</ul>
<p>添加Python的Script  到环境变量；在Path后面追加一下内容(Path： 不要复制进去) <code>Path:;C:\python;C:\Python\Scripts</code></p>
<a id="more"></a>
<p><br></p>
<h2 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h2><blockquote>
<p>查看Python版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; cmd</div><div class="line">&gt; python -v </div><div class="line">&gt;</div><div class="line">&gt; <span class="comment"># 或者</span></div><div class="line">&gt; cmd</div><div class="line">&gt; python --version</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<h3 id="pip-安装与卸载"><a href="#pip-安装与卸载" class="headerlink" title="pip 安装与卸载"></a>pip 安装与卸载</h3><blockquote>
<p>安装好Anaconda后，就默认安装了包管理工具pip</p>
</blockquote>
<ul>
<li>在命令提示符（cmd）窗口中使用命令pip install xxx（xxx表示要安装的包或模块名）。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pip install numpy  <span class="comment"># 安装</span></div><div class="line">pip install -U PackageName  <span class="comment"># 更新</span></div><div class="line">pip uninstall PackageName  <span class="comment"># 移除</span></div><div class="line">pip search PackageName  <span class="comment"># 搜索</span></div><div class="line">pip help  <span class="comment"># 帮助</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>conda 安装</strong></li>
</ul>
<p><br></p>
<h3 id="下载文件安装"><a href="#下载文件安装" class="headerlink" title="下载文件安装"></a>下载文件安装</h3><blockquote>
<p>若一种方法失败，可尝试用另一种方式</p>
</blockquote>
<ul>
<li>直接下载包或模块的安装文件，然后手动安装<ul>
<li><a href="https://pypi.python.org/pypi" target="_blank" rel="external">PyPI-the Python Package Index</a></li>
<li><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml" target="_blank" rel="external">https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</a></li>
<li><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">Python Extension Packages</a></li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>PyPI-the Python Package Index</strong></p>
<ol>
<li>在上面右上角红线框住的search中输入你要下载的包或模块名，即可进入下载页面。下载的是<strong>压缩文件</strong></li>
<li>解压 </li>
<li>在命令提示符窗口中，使用cd进入到解压后的文件的路径下 </li>
<li>输入命令python setup.py install</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmd </div><div class="line">cd /d  G:\Downloads\Chrome</div><div class="line">python setup.py install</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><strong>Python Extension Packages</strong><ol>
<li>直接把文件拷贝到 $python_dir/Lib/site packages </li>
<li>在命令提示符窗口中，转到指定路径（.whl安装文件的路径） </li>
<li>pip install .whl 文件名</li>
</ol>
</li>
</ul>
<blockquote>
<p>site_packages 用来存放第三方库</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmd</div><div class="line">cd /d G:\Downloads\Chrome</div><div class="line">pip install</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="单文件模块"><a href="#单文件模块" class="headerlink" title="单文件模块"></a>单文件模块</h3><ul>
<li>直接把文件拷贝到 $python_dir/Lib/site packages </li>
</ul>
<h3 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h3><ul>
<li><strong>Microsoft Visual C++ 14.0 is required.</strong><ul>
<li>往往并不是缺少 Visual 2015 ；而是缺少某个依赖包</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><p><br></p>
<h4 id="获取模块地址"><a href="#获取模块地址" class="headerlink" title="获取模块地址"></a>获取模块地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> a_module</div><div class="line"><span class="keyword">print</span> a_module.__file__</div><div class="line"></div><div class="line"><span class="comment"># 上述代码将范围 .pyc 文件被加载的路径，如果需要跨平台解决方案，可用下面代码：</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line">path = os.path.dirname(amodule.__file__)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="导入与移除模块"><a href="#导入与移除模块" class="headerlink" title="导入与移除模块"></a>导入与移除模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导入 </span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># 移除</span></div><div class="line"><span class="keyword">del</span> pd</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="连接数据库库"><a href="#连接数据库库" class="headerlink" title="连接数据库库"></a>连接数据库库</h2><blockquote>
<p>MySQL需要MySQLdb，SQL Server需要pymssql。两个模块大同小异，都遵循Python Database API</p>
<p> 必须先下载pymssql 模块，才能使用；<a href="http://www.pymssql.org/en/stable/" target="_blank" rel="external">http://www.pymssql.org/en/stable/</a></p>
</blockquote>
<p>安装pymssql好之后开工了。如果是连接本地的SQL Server需要在 SQL Server Configuration 中打开TCP/IP协议</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1335634-93526fa3dfa8f525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/562" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> pymssql</div><div class="line">conn = pymssql.connect(host=<span class="string">'127.0.0.1'</span>,user=<span class="string">'sa'</span>,</div><div class="line">                       password=<span class="string">'hello'</span>,database=<span class="string">'NPKW'</span>,</div><div class="line">                      charset=<span class="string">"utf8"</span>)</div><div class="line"><span class="comment">#查看连接是否成功</span></div><div class="line"><span class="keyword">print</span> conn</div><div class="line">cursor = conn.cursor()</div><div class="line">sql = <span class="string">'select * from contacts'</span></div><div class="line">cursor.execute(sql)</div><div class="line"><span class="comment">#用一个rs变量获取数据</span></div><div class="line">rs = cursor.fetchall()</div><div class="line"><span class="keyword">print</span> rs</div></pre></td></tr></table></figure>
<blockquote>
<p><pymssql.connection object="" at="" 0x02ff2cb0=""></pymssql.connection></p>
<p><pymssql.cursor object="" at="" 0x03124110=""><br>[(1, u’20111612210028’, u’ettingshausen’, u’’, u’’, u’’, u’’, u’’, u’’, u’’, u’’, u’’)]</pymssql.cursor></p>
</blockquote>
<p><br></p>
<h3 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h3><blockquote>
<p>Python Database API，只需要了解Connection Objects和Cursor Objects的常用方法。</p>
</blockquote>
<p>基本的步骤就是：</p>
<ol>
<li>使用<code>connect</code>创建连接对象</li>
<li><code>connect.cursor</code>创建游标对象，SQL语句的执行基本都在游标上进行</li>
<li><code>cursor.executeXXX</code>方法执行SQL语句，<code>cursor.fetchXXX</code>获取查询结果等<ul>
<li>通过cursor获取数据，具体可以是一次获取所有数据，也可以是一次获取一行。</li>
<li>整个结果集是元组列表，就是list类型的，而每一条记录是一个tuple，也就是元祖。</li>
</ul>
</li>
<li>如果是增、改数据，必须就要调用commit()函数来提交事务，否则程序已退出，数据库里的数据不会有变化。</li>
<li>调用<code>close</code>方法关闭游标<code>cursor</code>和数据库连接</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymssql</div><div class="line">conn = pymssql.connect(server=<span class="string">'anly3.dm.ytx.com'</span> ,database=<span class="string">'ADHOC_FDGJ'</span>, as_dict=<span class="keyword">True</span>)</div><div class="line">cur = conn.cursor()</div><div class="line">cur.execute(<span class="string">"select ..."</span>)  </div><div class="line"></div><div class="line"><span class="comment"># 先将SQL语句赋值为变量a</span></div><div class="line">a = <span class="string">"select ..."</span></div><div class="line">cur.execute(a)</div><div class="line"></div><div class="line">b= cur.fetchall()</div><div class="line"></div><div class="line">conn.close()</div><div class="line"></div><div class="line">df_b = pd.DataFrame(b)  <span class="comment"># 转化为数据框格式</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Connection-Objects"><a href="#Connection-Objects" class="headerlink" title="Connection Objects"></a>Connection Objects</h4><table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>connect</td>
<td>创建连接对象</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#cursor" target="_blank" rel="external">cursor</a></td>
<td>返回一个Cursor对象</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#commit" target="_blank" rel="external">commit</a></td>
<td>提交事务</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#rollback" target="_blank" rel="external">rollback</a></td>
<td>回滚</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#Connection.close" target="_blank" rel="external">close</a></td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
<p><br></p>
<ul>
<li><strong>connect(host, user, password, database, as_dict=True)</strong> ：创建连接对象</li>
</ul>
<blockquote>
<p>host :主机名</p>
<p>user：用户名</p>
<p>password：密码</p>
<p>database：数据库</p>
<p>charset：数据库的字符集；不指定此参数值时，程序使用默认值’UTF-8’</p>
<p>as_dict：布尔值,指定返回值是字典还是元组</p>
<p>timeout：查询超时<br>login_timeout：登陆超时<br>max_conn：最大连接数<br>trusted：布尔值,指定是否使用windows身份认证登陆</p>
</blockquote>
<ul>
<li><strong>cursor(as_dict=True)</strong>：创建游标。  <strong>一个连接一次只能有一个游标的查询处于活跃状态</strong><ul>
<li>创建多个连接来保证多个查询可以并行执行在不同连接的游标上</li>
<li>使用<code>fetchall</code>方法获取到游标查询结果之后再执行下一个查询</li>
</ul>
</li>
</ul>
<blockquote>
<p>as_dict : 使游标返回字典变量。字典中的键为数据表的列名</p>
<ul>
<li>pd.DataFrame( cursor.fetchall())  : 可将数据有 列表list 转为 数据框DataFrame</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ------------一个连接一次只能有一个游标的查询处于活跃状态</span></div><div class="line">c1 = conn.cursor()</div><div class="line">c1.execute(<span class="string">'SELECT * FROM persons'</span>)</div><div class="line"></div><div class="line">c2 = conn.cursor()</div><div class="line">c2.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)</div><div class="line"></div><div class="line">print( <span class="string">"all persons"</span> )</div><div class="line">print( c1.fetchall() )  <span class="comment"># 显示出的是c2游标查询出来的结果</span></div><div class="line"></div><div class="line">print( <span class="string">"John Doe"</span> )</div><div class="line">print( c2.fetchall() )  <span class="comment"># 不会有任何结果</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ------------解决办法：使用fetchall方法获取到游标查询结果之后再执行下一个查询--------------</span></div><div class="line">c1.execute(<span class="string">'SELECT ...'</span>)</div><div class="line">c1_list = c1.fetchall()</div><div class="line"></div><div class="line">c2.execute(<span class="string">'SELECT ...'</span>)</div><div class="line">c2_list = c2.fetchall()</div></pre></td></tr></table></figure>
<p><br></p>
<p>####Cursor Objects</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#id15" target="_blank" rel="external">execute</a></td>
<td>执行一条SQL语句</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#executemany" target="_blank" rel="external">executemany</a></td>
<td>执行多条语句</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#fetchone" target="_blank" rel="external">fetchone</a></td>
<td>获取一行数据</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#fetchmany" target="_blank" rel="external">fetchmany</a></td>
<td>获取n行的数据</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#fetchall" target="_blank" rel="external">fetchall</a></td>
<td>获取未返回（剩下的）数据</td>
</tr>
<tr>
<td>callproc</td>
<td>调用存储过程</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#Cursor.close" target="_blank" rel="external">close</a></td>
<td>关闭游标</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：fetchone / fetchmany / fetchall 与 read 是同样的运行方式；一旦倒出来一条数据，就少一条数据；</strong></p>
<p>例如：cursor.fetchone()  ，则已经少了一行数据；</p>
</blockquote>
<p><br></p>
<ul>
<li><strong>execute()</strong>：执行一条SQL语句</li>
</ul>
<blockquote>
<p>例子中查询操作的参数使用的<code>%s</code>而不是<code>&#39;%s&#39;</code>，<strong>若参数值是字符串</strong>，在执行语句时会自动添加单引号</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cursor.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)   <span class="comment"># 字符串没有使用引号</span></div><div class="line">row = cursor.fetchone()</div><div class="line"><span class="keyword">while</span> row:</div><div class="line">    print(<span class="string">"ID=%d, Name=%s"</span> % (row[<span class="number">0</span>], row[<span class="number">1</span>]))</div><div class="line">    row = cursor.fetchone()</div></pre></td></tr></table></figure>
<ul>
<li><strong>executemany()</strong>：指定多条SQL语句</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stmt=<span class="string">'insert into student (name, age) values (%s,%s)'</span></div><div class="line">data=[</div><div class="line">     (<span class="string">'Lucy'</span>,<span class="number">21</span>),</div><div class="line">     (<span class="string">'Tom'</span>,<span class="number">22</span>),</div><div class="line">     (<span class="string">'Lily'</span>,<span class="number">21</span>)]</div><div class="line">cursor.executemany(stmt,data)</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>callproc( procname [, parameters ] )</strong>：调用存储过程</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> pymssql.connect(server, user, password, database) <span class="keyword">as</span> conn:</div><div class="line">    <span class="keyword">with</span> conn.cursor(as_dict=<span class="keyword">True</span>) <span class="keyword">as</span> cursor:</div><div class="line">        <span class="comment"># 创建存储过程</span></div><div class="line">        cursor.execute(<span class="string">"""</span></div><div class="line">        CREATE PROCEDURE FindPerson</div><div class="line">            @name VARCHAR(100)</div><div class="line">        AS BEGIN</div><div class="line">            SELECT * FROM persons WHERE name = @name</div><div class="line">        END</div><div class="line">        """)</div><div class="line"></div><div class="line">        <span class="comment"># 调用存储过程</span></div><div class="line">        cursor.callproc(<span class="string">'FindPerson'</span>, (<span class="string">'Jane Doe'</span>,))   <span class="comment"># FindPerson 为之前创建的存储</span></div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">            print(<span class="string">"ID=%d, Name=%s"</span> % (row[<span class="string">'id'</span>], row[<span class="string">'name'</span>]))</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>使用 <code>with</code> 函数 完成后自动关闭数据库连接</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> pymssql.connect(server, user, password, <span class="string">"tempdb"</span>) <span class="keyword">as</span> conn:</div><div class="line">    <span class="keyword">with</span> conn.cursor(as_dict=<span class="keyword">True</span>) <span class="keyword">as</span> cursor:</div><div class="line">        cursor.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">            print(<span class="string">"ID=%d, Name=%s"</span> % (row[<span class="string">'id'</span>], row[<span class="string">'name'</span>]))</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><blockquote>
<p><strong>sqlserver数据库编码为gbk</strong></p>
<p>文件头加上 #coding=utf8</p>
<p>连接的时候加入charset设置信息 \<charset='utf8'>运行正常，<strong>输出依然乱码</strong>；不指定此参数值时，程序使用默认值’UTF-8’</charset='utf8'></p>
<p>pymssql.connect(host=self.host,user=self.user,password=self.pwd,database=self.db,charset=”utf8”)</p>
</blockquote>
<ul>
<li><strong>代码中显式转码</strong><ul>
<li><strong>unicode变量.encode(‘latin1’).decode(‘gbk’)</strong></li>
<li>一般情况下对unicode编码不做encode处理，但必要时可以encode为Latin1，实现脱unicode操作，然后再以合适字符集decode为正确unicode</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">"\t"</span>.join([str(room_id),room_name.encode(<span class="string">'latin1'</span>).decode(<span class="string">'gbk'</span>)])</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 在执行时进行encode</span></div><div class="line">cur = conn.cursor()</div><div class="line">sql = <span class="string">"select top 10 [ID],[Name] from [User]"</span></div><div class="line">cur.execute(sql)</div><div class="line">list = cur.fetchall()</div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> list:</div><div class="line">    print(row[<span class="string">"ID"</span>],row[<span class="string">"Name"</span>].encode(<span class="string">'latin-1'</span>).decode(<span class="string">'gbk'</span>))</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># sql语句中有中文的时候进行encode </span></div><div class="line">insertSql = <span class="string">"insert into WeiBo([UserId],[WeiBoContent],[PublishDate]) values(1,'测试','2012/2/1')"</span>.encode(<span class="string">"utf8"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># --------某一列中文有乱码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(a)</span>:</span></div><div class="line">  	a = a.encode(<span class="string">'latin-1'</span>).decode(<span class="string">'gbk'</span>)</div><div class="line">    <span class="keyword">return</span> a</div><div class="line"></div><div class="line">data[<span class="string">'访问次数'</span>] = data[<span class="string">'访问次数'</span>].apply(code)</div></pre></td></tr></table></figure>
<ul>
<li><strong>字符定义使用NVARCHAR</strong></li>
</ul>
<p>这种方式在存储和读取时都使用unicode编码，和python运转字节码一致，可以很好避免此类问题。当然<strong>数据库存储空间要牺牲一些</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[room_name] [nvarchar] (<span class="number">50</span>) COLLATE Chinese_PRC_CI_AS NULL</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymssql</div><div class="line">conn = pymssql.connect(server=<span class="string">'anly3.dm.ytx.com'</span> ,database=<span class="string">'ADHOC_FDGJ'</span>, as_dict=<span class="keyword">True</span>)</div><div class="line">cur = conn.cursor()</div><div class="line">cur.execute(<span class="string">"select ..."</span>)  </div><div class="line"></div><div class="line"><span class="comment"># 先将SQL语句赋值为变量a</span></div><div class="line">a = <span class="string">"select ..."</span></div><div class="line">cur.execute(a)</div><div class="line"></div><div class="line"><span class="comment"># 获取之后再赋值</span></div><div class="line">b= cur.fetchall()</div><div class="line"></div><div class="line">conn.close()</div><div class="line"></div><div class="line">df_b = pd.DataFrame(b)  <span class="comment"># 转化为数据框格式</span></div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># =-----------【代码参考】-----------------</span></div><div class="line"><span class="comment"># -*- coding:gbk -*-</span></div><div class="line"><span class="keyword">import</span> pymssql</div><div class="line"></div><div class="line"><span class="comment">#创建一个数据库连接，host是服务器的ip地址，如果是本机可以用"."，user是访问用户名，password是密码，database是数据库名，比ADO的连接似乎简单一些</span></div><div class="line">conn=pymssql.connect(host=<span class="string">"."</span>,user=<span class="string">"sa"</span>,password=<span class="string">"twinflag"</span>,database=<span class="string">"bbs"</span> , as_dict=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment">#创建游标对象，相当于ADO的记录集</span></div><div class="line">cou=conn.cursor()</div><div class="line"></div><div class="line"></div><div class="line">sql=<span class="string">"select id,name from user"</span></div><div class="line">cou.execute(sql)  <span class="comment">#执行命令</span></div><div class="line"><span class="comment"># -----------或者-------------</span></div><div class="line">cou.execute(<span class="string">'select id, name From user'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入一条记录</span></div><div class="line">cou.execute(sql)</div><div class="line"></div><div class="line"><span class="comment">#只有执行了下面的命令，上面的操作才能生效，配合异常处理，可以实现pymssql的事务操作</span></div><div class="line">conn.commit()</div><div class="line"></div><div class="line"><span class="comment">#关闭数据库的连接</span></div><div class="line">conn.close()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># =-----------【代码参考】-----------------</span></div><div class="line"><span class="keyword">import</span> pymssql</div><div class="line"></div><div class="line"><span class="comment"># server    数据库服务器名称或IP</span></div><div class="line"><span class="comment"># user      用户名</span></div><div class="line"><span class="comment"># password  密码</span></div><div class="line"><span class="comment"># database  数据库名称</span></div><div class="line">conn = pymssql.connect(server, user, password, database)</div><div class="line"></div><div class="line">cursor = conn.cursor()</div><div class="line"></div><div class="line"><span class="comment"># 新建、插入操作</span></div><div class="line">cursor.execute(<span class="string">"""</span></div><div class="line">IF OBJECT_ID('persons', 'U') IS NOT NULL</div><div class="line">    DROP TABLE persons</div><div class="line">CREATE TABLE persons (</div><div class="line">    id INT NOT NULL,</div><div class="line">    name VARCHAR(100),</div><div class="line">    salesrep VARCHAR(100),</div><div class="line">    PRIMARY KEY(id)</div><div class="line">)</div><div class="line">""")</div><div class="line">cursor.executemany(</div><div class="line">    <span class="string">"INSERT INTO persons VALUES (%d, %s, %s)"</span>,</div><div class="line">    [(<span class="number">1</span>, <span class="string">'John Smith'</span>, <span class="string">'John Doe'</span>),</div><div class="line">     (<span class="number">2</span>, <span class="string">'Jane Doe'</span>, <span class="string">'Joe Dog'</span>),</div><div class="line">     (<span class="number">3</span>, <span class="string">'Mike T.'</span>, <span class="string">'Sarah H.'</span>)])</div><div class="line"><span class="comment"># 如果没有指定autocommit属性为True的话就需要调用commit()方法</span></div><div class="line">conn.commit()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 查询操作</span></div><div class="line">cursor.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)</div><div class="line">row = cursor.fetchone()</div><div class="line">print(row)</div><div class="line"></div><div class="line">    </div><div class="line"><span class="comment"># 也可以使用for循环来迭代查询结果</span></div><div class="line"><span class="comment"># for row in cursor:</span></div><div class="line"><span class="comment">#     print("ID=%d, Name=%s" % (row[0], row[1]))</span></div><div class="line"></div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Juypter-Notebook"><a href="#Juypter-Notebook" class="headerlink" title="Juypter Notebook"></a>Juypter Notebook</h2><blockquote>
<p>知乎分享：<a href="https://www.zhihu.com/question/59392251" target="_blank" rel="external">https://www.zhihu.com/question/59392251</a>   品颜完月</p>
<p>27个技巧：<a href="http://liuchengxu.org/pelican-blog/jupyter-notebook-tips.html" target="_blank" rel="external">http://liuchengxu.org/pelican-blog/jupyter-notebook-tips.html</a></p>
</blockquote>
<p><br></p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><strong>【命令模式】</strong></p>
<p>如果单元格的边框为绿色（即为编辑模式），请按ESC键，退回到命令模式。在命令模式下被选中的单元采用灰色边框显示。按<strong>上下方向键</strong>可以移动选择框。</p>
<ul>
<li>数字键：将单元格变为标题类型，数字越大标题越小</li>
<li><strong>m：将单元格变为markdown类型，在markdown类型的单元格内可以编写文档</strong><ul>
<li>注：将代码类型改为标题类型和markdown类型之后，按Ctrl+Enter对其进行格式化显示。</li>
</ul>
</li>
<li><strong>y：将单元格变为代码类型，在代码类型的单元格中输入Python代码</strong></li>
<li>d: 按两下d按键删除单元格</li>
<li>z: 撤销最后删除单元格操作</li>
<li>a: 在当前单元格之上创建一个新的单元格</li>
<li>b: 在当前单元格之下创建一个新的单元格</li>
<li>x: 剪切当前单元格</li>
<li>c: 复制当前单元格</li>
<li>v: 在当前单元格之下粘贴剪切板中的单元格</li>
<li><strong>shift+k: 将当前单元格上移</strong></li>
<li><strong>shift+j: 将当前单元格下移</strong></li>
</ul>
<blockquote>
<p>一旦 cell 被选中，接着你可以进行批量删除/复制/剪切/粘贴.当你需要移动一部分notebook时，这非常有用。</p>
</blockquote>
<ul>
<li><strong>shift+m:与下面的单元合并</strong></li>
<li>d, d ：连按两下d 删除所选cell</li>
</ul>
<p><br></p>
<p><strong>【编辑和运行】</strong></p>
<p>编辑模式下单元使用绿色边框显示，在命令模式时<strong>按Enter即可进入编辑模式。</strong></p>
<ul>
<li><strong>Ctrl+Enter</strong>：结束编辑，对于代码单元将运行其中的代码，<strong>对于标题单元和markdown单元将格式化显示</strong></li>
<li>Shift+Enter：运行<strong>当前选择</strong>的代码单元，并自动选择下一个单元。</li>
<li>Alt+Enter：运行当前的代码并在下面插入新的单元。</li>
<li>ctrl+/：为一行或多行添加或取消注释</li>
<li><strong>多光标操作</strong> ：按住 <code>Alt</code> 进行点击和拖拽鼠标即可（选择所要编辑的区域；若要在最后都加上逗号，应该单独选最后的一纵列，而不是连通前面的内容也一起选）</li>
</ul>
<p><br></p>
<p><strong>【在线帮助和自动完成】</strong></p>
<ul>
<li>输入代码时，按 <strong>[TAB]键</strong> 可以显示自动完成提示框。自动完成支持当前执行环境中已知的模块名、变量名、对象的属性名，以及文件和目录名。</li>
<li>对于当前环境中已知的对象，可以在其<strong>后面添加问号</strong>查看相应的说明信息和文档，<strong>添加两个问号</strong>可以查看对象对应的源程序。<strong>按Ctrl+Enter显示</strong></li>
<li>在 Help 菜单你可以找到一些常用库文档的连接，包括 NumPy, Pandas, SciPy 和 Matplotlib.同时别忘了在一个库，方法或变量前加上 ?，你可以获得它的一个快速语法说明。<ul>
<li><code>?sum()</code></li>
</ul>
</li>
</ul>
<ul>
<li>调用函数时，按 [shift+tab]组合键 可以显示函数的<strong>调用参数和说明文档</strong>，按一次组合键显示基本信息，两次显示详细信息，三次延时停留信息框，四次则将信息显示在下方的滑动窗口中。</li>
</ul>
<p><br></p>
<p><strong>【操作运算核】</strong></p>
<p>如果进入了Python的死循环，可以在<strong>命令模式下按两下 i 按键终止循环</strong>。</p>
<p>注意右上角图标<strong>从空心圈变为实心圈</strong>，如上图，表示运算核<strong>正在工作</strong>，无法执行新的代码。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4a420e761f4b32320e55f152886338ce_hd.jpg" alt="img"></p>
<p><br></p>
<h3 id="markdown操作"><a href="#markdown操作" class="headerlink" title="markdown操作"></a>markdown操作</h3><ul>
<li>在命令模式下按Enter键进入编辑模式即可查看本段文字的Markdown代码。</li>
<li>在行内的数学公式使用单个$括起，单独占一行的数学公式使用$$括起</li>
<li>数学公式采用LaTeX格式编写，可以使用下面的在线编辑器编写LaTeX数学公式：<a href="http://www.codecogs.com/latex/eqneditor.php?lang=zh-cn" target="_blank" rel="external">http://www.codecogs.com/latex/eqneditor.php?lang=zh-cn</a></li>
</ul>
<p><br></p>
<p><br></p>
<p>###python 导入与运行</p>
<p><strong>【向jupyter notebook中导入python文件】</strong></p>
<ul>
<li>从本地导入python文件，可以直接使用<code>%load xxx.py</code>，比如把名字为untitled0.py的文件导入到jupyter中。<ul>
<li>注意：本地文件导入时的绝对路径和相对路径的引用方式的不同</li>
</ul>
</li>
<li>从网络中导入python代码，可以使用%load 网址</li>
</ul>
<p><br></p>
<p><strong>【jupyter中运行python文件】</strong></p>
<ul>
<li>输入：<code>%run xxx.py</code> 按Ctrl+Enter后</li>
</ul>
<p><br></p>
<h3 id="显示问题"><a href="#显示问题" class="headerlink" title="显示问题"></a>显示问题</h3><p><strong>【图片显示】</strong></p>
<ul>
<li>当在程序中使用了matplotlib绘图，不能直接显示时，需要加%matplotlib inline</li>
</ul>
<p><br></p>
<h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><h4 id="导出时去掉代码"><a href="#导出时去掉代码" class="headerlink" title="导出时去掉代码"></a>导出时去掉代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> IPython.core.display <span class="keyword">as</span> di</div><div class="line">di.display_html(<span class="string">'&lt;script&gt;jQuery(function() &#123;if (jQuery("body.notebook_app").length == 0) &#123; jQuery(".input_area").toggle(); jQuery(".prompt").toggle();&#125;&#125;);&lt;/script&gt;'</span>, raw=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h4 id="显示每行结果"><a href="#显示每行结果" class="headerlink" title="显示每行结果"></a>显示每行结果</h4><ul>
<li>可以选择修改 <code>ast_note_iteractively</code> kernal 选项来使得 Jupyter 为每一行的变量或语句执行这个操作，以便你可以立即看到多条语句一起输出。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure>
<ul>
<li>所有的Jupyter实例（Notebook和Console）都设置该选项，只需<strong>创建</strong> <code>~/.ipython/profile_default/ipython_config.py</code> 文件并写入一下内容</li>
</ul>
<blockquote>
<p><code>.ipython</code> 该文件夹一般在 user 的第一级目录下。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c = get_config()</div><div class="line"><span class="comment"># Run all nodes interactively</span></div><div class="line">c.InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">line1 = <span class="string">"this is from line 1"</span></div><div class="line">line2 = <span class="string">"this is from line 2"</span></div><div class="line"></div><div class="line">line1</div><div class="line">line2</div><div class="line"></div><div class="line">[out]:<span class="string">'this is from line 2'</span></div><div class="line">  </div><div class="line"><span class="comment"># 修改之后</span></div><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div><div class="line"></div><div class="line">line1</div><div class="line">line2</div><div class="line"></div><div class="line">[out]:</div><div class="line"><span class="string">'this is from line 1'</span></div><div class="line"><span class="string">'this is from line 2'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="导出为PDF"><a href="#导出为PDF" class="headerlink" title="导出为PDF"></a>导出为PDF</h4><ul>
<li>报错：Download as “PDF via LaTeX” fails - nbconvert fails, xelatex not found on PATH <ul>
<li>nbconvert failed: xelatex not found on PATH, if you have not installed xelatex you may need to do so. Find further instructions at <a href="https://nbconvert.readthedocs.io/en/latest/install.html#installing-tex" target="_blank" rel="external">https://nbconvert.readthedocs.io/en/latest/install.html#installing-tex</a>.</li>
</ul>
</li>
</ul>
<blockquote>
<p> <a href="https://github.com/jupyter/docker-stacks/issues/353" target="_blank" rel="external">https://github.com/jupyter/docker-stacks/issues/353</a></p>
<p> As said by Thomas K in the comments, you need to have Latex installed, and after add the path to the directory containing pdflatex.exe file to the PATH variable of your system.</p>
<p> I have looked for a lightweight distribution and tried installing TeXworks, but I didn’t find any pdflatex.exe file.<br> So I have tried TeX Live, which worked fine creating the pdflatex.exe file under the target installation directory. This path should be like C:...\texlive\2016\bin\win32.<br> Finally, you should just add this path to the PATH environment variable of your system (you can use the link shared by Thomas K).</p>
<p> In Jupyter, you can check your environment variables by running the following (refer to this link for details):</p>
<pre><code>import os
os.environ
</code></pre><p> so you can look for ‘PATH’: ‘C: … and check if it contains the path to pdflatex.exe file.</p>
<p> If you get some trouble when exporting your notebook to pdf due to missing files/packages (this happened to me), refer to this link to search and install them under TeX Live.</p>
</blockquote>
<p><br></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>【报告文档】</strong>（删去了业务人员不想查看的代码）</p>
<ul>
<li><strong>Jupyter Dashboards</strong>   </li>
<li><a href="https://github.com/jupyter/dashboards" target="_blank" rel="external">https://github.com/jupyter/dashboards</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install using pip from pypi and then activate the extension</span></div><div class="line">pip install jupyter_dashboards</div><div class="line">jupyter dashboards quick-setup --sys-prefix</div><div class="line"></div><div class="line"><span class="comment"># install using conda from conda-forge, no activation required</span></div><div class="line">conda install jupyter_dashboards -c conda-forge</div></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Anaconda安装&quot;&gt;&lt;a href=&quot;#Anaconda安装&quot; class=&quot;headerlink&quot; title=&quot;Anaconda安装&quot;&gt;&lt;/a&gt;Anaconda安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题本质其实就是，windows的cmd并不能识别python这个符号（即无法识别这个符号是一个可执行程序），因为windows这里也是类似的，遇到一个字符，先会在默认path路径查询这个符号是不是一个可执行程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;右键我的电脑-&amp;gt;属性-&amp;gt;高级系统配置-&amp;gt;点击高级一栏，在这里栏点开环境变量-&amp;gt;在系统变量PATH加入python的安装路径即可，比如我的就是D:\Python27&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt;不是内部或外部命令，也不是可运行的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;添加Python的Script  到环境变量；在Path后面追加一下内容(Path： 不要复制进去) &lt;code&gt;Path:;C:\python;C:\Python\Scripts&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_正则表达式_RE</title>
    <link href="http://yoursite.com/2018/01/24/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_RE/"/>
    <id>http://yoursite.com/2018/01/24/软件应用_程序编程/Python/Python_专题总结/Python_正则表达式_RE/</id>
    <published>2018-01-23T16:00:00.000Z</published>
    <updated>2018-02-13T13:44:18.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Re模块"><a href="#Re模块" class="headerlink" title="Re模块"></a>Re模块</h2><blockquote>
<p>Re模块的函数主要分三个大类：匹配模式、替换、拆分</p>
</blockquote>
<p><strong>Python字符串转义符 <code>\</code> </strong> </p>
<p><strong>因此强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">s = <span class="string">r'ABC\-001'</span> <span class="comment"># Python的字符串</span></div><div class="line"><span class="comment"># 对应的正则表达式字符串不变：</span></div><div class="line"><span class="comment"># 'ABC\-001'</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><br></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li>
<li>用编译后的正则表达式去匹配字符串。</li>
</ol>
<blockquote>
<p>Python代码最终被被编译为字节码，然后才被解释器执行。在匹配模式之前，正则表达式模式必须先被编译成regex对象。由于正则表达式在执行过程中多次被用于比较，所以强烈建议先对它进行预编译。</p>
</blockquote>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以<strong>预编译</strong>该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p>
<p><br></p>
<h4 id="compile-模块的函数"><a href="#compile-模块的函数" class="headerlink" title="compile - 模块的函数"></a>compile - 模块的函数</h4><ul>
<li><strong>re.compile(patter [, flags=0])</strong> 把正则表达式<strong>编译成一个正则对象（regex）</strong>;供其他函数 find()、match()、search() 等函数使用<ul>
<li>使用方式为 <strong>命名的变量.方法(查找对象的范围)</strong> ；其实因为在其他Re函数使用时，自动传递pattern</li>
<li>若对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建对象。</li>
</ul>
</li>
</ul>
<blockquote>
<p>flags 包括：<br>re.I 忽略大小写<br>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境<br>re.M 多行模式<br>re.S 即为’ . ’并且包括换行符在内的任意字符（’ . ’不包括换行符）<br>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库<br>re.X 为了增加可读性，忽略空格和’ # ’后面的注释</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">a = re.compile() <span class="comment"># 创建的正则规则</span></div><div class="line">result = a.findall(ojbect)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ----【 简单说明 】</span></div><div class="line">compiled_pattern = re.compile(pattren)</div><div class="line">resule = re.findall(compiled_pattern, string)  <span class="comment"># 这种方式更利于理解</span></div><div class="line"><span class="comment">#---------等价于--------------</span></div><div class="line">compiled_pattern = re.compile(pattren)</div><div class="line">result = compiled_patter.findall(string)  <span class="comment"># 使用方式为 命名的变量.方法(查找对象的范围) 。其实因为在其他Re函数使用时，自动传递pattern</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ----【 解释说明 】</span></div><div class="line"><span class="comment">## p 即为编译后的 pattern。 在其他Re函数使用时，自动传递pattern</span></div><div class="line">p = re.compile( <span class="string">'(one|two|three)'</span>)  </div><div class="line">p.sub( <span class="string">'num'</span>, <span class="string">'one word two words three words'</span>)   <span class="comment"># 其第一个参数为p，即将one|two|three作为查找的对象，替换为rep = num</span></div><div class="line"><span class="string">'num word num words num words'</span></div><div class="line"><span class="comment">### 正常应为 re.sub('(one|two|three)', 'num', 'one word two words three words')</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="comment"># 编译:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>)</div><div class="line"><span class="comment"># 使用：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-12345'</span>).groups()   </div><div class="line">(<span class="string">'010'</span>, <span class="string">'12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-8086'</span>).groups()</div><div class="line">(<span class="string">'010'</span>, <span class="string">'8086'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<blockquote>
<p>Re模块的函数和regex对象的方法</p>
<p>强调：查找的对象是 <strong>字符串string</strong></p>
</blockquote>
<h4 id="search-amp-match-搜索-amp-匹配"><a href="#search-amp-match-搜索-amp-匹配" class="headerlink" title="search &amp; match- 搜索&amp;匹配"></a>search &amp; match- 搜索&amp;匹配</h4><blockquote>
<p>search - 搜索；  match - 匹配</p>
<p>通过.group 返回对象</p>
</blockquote>
<ul>
<li><strong>match(pattern, string, flags=0)</strong>：在字符串string的<strong>开头 开始搜索</strong>正则表达式模式pattern；若匹配成功，则返回一个匹配对象<u>（仅返回匹配的部分）</u>；否则返回None</li>
</ul>
<ul>
<li><strong>search(pattern, string, flags=0)</strong>：从字符串string中<strong>（任意位置）</strong>搜索正则表达式模式pattern <strong>第一次出现的地方</strong>； 如果匹配成功，则返回一个匹配对象；否则返回None</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># match 应用</span></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'food on the table'</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">3</span>), match=<span class="string">'foo'</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'The food on the table'</span>) <span class="comment"># 什么都没有返回</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># search 应用</span></div><div class="line">re.search(<span class="string">'foo'</span>, <span class="string">'The food on the table'</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">4</span>, <span class="number">7</span>), match=<span class="string">'foo'</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">val = <span class="string">'abc, dca, guides'</span></div><div class="line"></div><div class="line">m = re.search(<span class="string">'uid'</span>, val)</div><div class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(9, 12), match='uid'&gt;</span></div><div class="line">val[m.start():m.end()]</div><div class="line"><span class="comment"># 'uid'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="findall-amp-finditer-查找"><a href="#findall-amp-finditer-查找" class="headerlink" title="findall &amp; finditer - 查找"></a>findall &amp; finditer - 查找</h4><blockquote>
<p>search 与 findall 不同之处在于：findall 总返回一个<strong>[ 列表 ] </strong></p>
</blockquote>
<ul>
<li><strong>findall(pattern, string [,flags])</strong> ：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，并返回一个匹配对象的 <strong>[列表 list]</strong></li>
</ul>
<blockquote>
<p>正则表达式</p>
</blockquote>
<ul>
<li><strong>finditer(pattern, string [, flags])</strong>：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，返回一个<strong>迭代器</strong>，该迭代器返回一个匹配对象</li>
</ul>
<p><br></p>
<h4 id="sub-替换"><a href="#sub-替换" class="headerlink" title="sub - 替换"></a>sub - 替换</h4><ul>
<li><strong>re.sub(pattern, repl ,string, max = 0)</strong> : 把字符串string中所有匹配正则表达式pattern的地方 <strong>替换</strong>成 字符串 repl <ul>
<li>如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。</li>
</ul>
</li>
</ul>
<blockquote>
<p>若max 的值没有给出，则对所有匹配的地方进行替换</p>
</blockquote>
<ul>
<li>re.subn - 该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">re.sub(pattern, repl, string[, count, flags])</div><div class="line"></div><div class="line"><span class="comment"># count=1 表示替换仅替换第一个</span></div><div class="line">p = re.compile( <span class="string">'(one|two|three)'</span>) </div><div class="line">p.sub( <span class="string">'num'</span>, <span class="string">'one word two words three words'</span>)   <span class="comment"># 其第一个参数为p，即将one|two|three作为查找的对象，替换为rep = num</span></div><div class="line"><span class="string">'num word num words num words'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ------------------------------------</span></div><div class="line">subn(repl, string[, count=<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="split-分割"><a href="#split-分割" class="headerlink" title="split - 分割"></a>split - 分割</h4><ul>
<li><strong>re.split(pattren, string, max=0)</strong> ： 根据正则表达式pattern中的分隔符 把字符串string <strong>分割为一个 [列表]</strong></li>
</ul>
<blockquote>
<p>若max 的值没有给出，则对所有匹配的地方进行分割</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="group-匹配对象"><a href="#group-匹配对象" class="headerlink" title="group - 匹配对象"></a>group - 匹配对象</h4><blockquote>
<p><strong>匹配对象的方法：在match &amp; search 被成功调用之后所返回的结果。</strong></p>
</blockquote>
<ul>
<li><strong>group(num=0)</strong>：<strong>返回全部匹配对象</strong>（或指定编号是num的子组）</li>
<li><strong>groups()</strong>：返回一个包含<strong>唯一或全部</strong>匹配的子组的<strong>元组</strong>（若正则表达式中没有子组，则返回一个空元组）</li>
</ul>
<blockquote>
<p>num 代表第1、2、……个子串。如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p>
<p>用<code>()</code>表示的就是要提取的分组(Group)，进行<strong>提取子串</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  group 应用</span></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'food on the table'</span>).group()</div><div class="line"><span class="string">'foo'</span></div><div class="line"></div><div class="line"><span class="comment"># groups 应用</span></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'food on the table'</span>).groups()</div><div class="line">()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 用()定义组</span></div><div class="line">^(\d&#123;<span class="number">3</span>&#125;)-(\d&#123;<span class="number">3</span>,<span class="number">8</span>&#125;)$  <span class="comment"># 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)  <span class="comment"># group(0) 永远是原始字符串</span></div><div class="line"><span class="string">'010-12345'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</div><div class="line"><span class="string">'010'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</div><div class="line"><span class="string">'12345'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()  <span class="comment"># 返回所有的值</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><ol>
<li>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。<ul>
<li>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'102300'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<ol>
<li>必须让<code>\d+</code>采用<strong>非贪婪匹配（也就是尽可能少匹配）</strong>，才能把后面的<code>0</code>匹配出来，<strong>加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+?)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'1023'</span>, <span class="string">'00'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="参考资料-：-正则表达式"><a href="#参考资料-：-正则表达式" class="headerlink" title="参考资料 ： 正则表达式"></a>参考资料 ： 正则表达式</h2><blockquote>
<p>元字符</p>
</blockquote>
<h3 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>.</strong></td>
<td>点号</td>
<td>匹配单个(除换行符以外)<strong>任意字符</strong> <strong>（含空格、下划线等）</strong></td>
</tr>
<tr>
<td><strong>\s </strong></td>
<td>空白/空格- space</td>
<td>匹配任意的<strong>空白符</strong></td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符</td>
<td>匹配<strong>任何非空白字符，相当于[^ fv]</strong></td>
</tr>
<tr>
<td><strong>\d</strong></td>
<td>数字 - digit</td>
<td>匹配<strong>数字 ，相当于[0-9]</strong></td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
<td>匹配任何<strong>非数字字符</strong>，相当于[^0-9]</td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td>任何字符 - whatever</td>
<td><strong>匹配任何字母数字字符，相当于[a-zA-Z0-9_]</strong></td>
</tr>
<tr>
<td>\W</td>
<td>非任何字符</td>
<td>匹配<strong>任何非字母数字字符</strong>，相当于[^a-zA-Z0-9_]</td>
</tr>
<tr>
<td><strong>[ ]</strong></td>
<td>字符组</td>
<td>匹配<strong>单个</strong>列出的字符，表示或的关系</td>
</tr>
<tr>
<td><strong>[^ ]</strong></td>
<td>排除性字符组</td>
<td>匹配<strong>单个</strong>未列出的字符</td>
</tr>
<tr>
<td>\char</td>
<td>转义字符</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于 ? 和 * 的对象在”匹配成功”时也可能并没有匹配任何内容。因为它们允许匹配的数量为0</p>
<p>即便是排除性字符，也需要匹配一个字符</p>
<p>转义符 <code>\\*</code>第一个转义符是对\进行转义，表示：查找 <code>\*</code>此类字符的内容</p>
<p>空格 也是一个字符</p>
<p>由于Python的字符串本身也用<code>\</code>转义，因此强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</p>
</blockquote>
<h4 id="字符组"><a href="#字符组" class="headerlink" title="字符组 [ ]"></a>字符组 [ ]</h4><ol>
<li><p>字符组内匹配的是<strong>列出的单个字符</strong>，<strong>或者</strong>的关系</p>
</li>
<li><p><strong>字符组元字符</strong> ：字符组内的元字符，<strong>其含义表示为本身的含义，即代表普通文本字符，相当于转义之后的字符（连字符 - 除外）</strong></p>
<ul>
<li><strong>连字符 ( - )</strong>表示一个<strong>范围</strong>；<strong>【注意：只有在字符组内部，连字符( - )才是元字符】</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span><span class="number">-9</span>]  <span class="comment"># 表示匹配的字符为0~9之间的任意一个</span></div></pre></td></tr></table></figure>
<ul>
<li>连字符 ( - ) 出现在<strong>字符组的开头</strong>，则仅代表<strong>普通文本字符</strong>； </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">-09</span>]  <span class="comment"># 表示匹配的字符为 - 或者 0 或者 9</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h3 id="量词-计数功能"><a href="#量词-计数功能" class="headerlink" title="量词 - 计数功能"></a>量词 - 计数功能</h3><p>对前一个/一组字符匹配的的次数</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>？</strong>  = 0 或 1</td>
<td><strong>问号</strong></td>
<td>不匹配，或仅匹配一次</td>
</tr>
<tr>
<td><strong>*</strong>     $\ge$ 0</td>
<td>星号</td>
<td>可能不匹配，也可能匹配任意多次</td>
</tr>
<tr>
<td><strong>+</strong>     $\ge$ 1</td>
<td>加号</td>
<td>至少匹配一次，也可能匹配任意多次</td>
</tr>
<tr>
<td>{m}</td>
<td></td>
<td>对于前一个字符重复m次</td>
</tr>
<tr>
<td><strong>{min, max}</strong></td>
<td>区间量词</td>
<td>对前一个字符重复min到max次</td>
</tr>
</tbody>
</table>
<h3 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>^</strong></td>
<td>脱字符</td>
<td>一行的开头位置</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>美元符</td>
<td>一行的结束位置</td>
</tr>
<tr>
<td>\b</td>
<td><strong>单词分界符</strong></td>
<td>匹配<strong>单词的开始或结束</strong> (用于精确匹配)</td>
</tr>
<tr>
<td>\D</td>
<td>非单词分界符</td>
<td>匹配<strong>不是单词开头或结束的位置</strong></td>
</tr>
</tbody>
</table>
<h3 id="其他元字符"><a href="#其他元字符" class="headerlink" title="其他元字符"></a>其他元字符</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>( )</td>
<td>括号</td>
<td>限定多线结构的范围； 为反向引用“捕获”文本</td>
</tr>
<tr>
<td>\1 , \2</td>
<td>反向引用</td>
<td>匹配之前的第一个、第二个括号内的字表达式<strong>所匹配的文本</strong>(即捕获的文本)</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>或者</td>
<td>匹配任意分隔的表达式</td>
</tr>
</tbody>
</table>
<blockquote>
<p>括号与反向引用的示例</p>
<ul>
<li><strong>分组0对应整个正则表达式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; \b(a-zA-Z)*+\<span class="number">1</span>\b</div><div class="line">&gt; <span class="comment"># 若 \b(a-zA-Z)*+ 任意字符找到的以单词开头的内容为the，则\1 表示其末尾也应为the的内容 </span></div><div class="line">&gt; <span class="comment"># 若有两个括号，\2表示第二个括号中所匹配的文本内容</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h4><ol>
<li><p>使用圆括号( ) 来进行表示，而非方括号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查找 gray 或 grey的写法</span></div><div class="line"></div><div class="line"><span class="number">1.</span> gr[ae]y</div><div class="line"><span class="number">2.</span> gr(a|e)y</div><div class="line"></div><div class="line"><span class="comment"># 错误的写法 gr[a|e]y  -表示查找 a 或者 | 或者 e</span></div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>多选结构可以匹配<strong>任意长度</strong>的字符，而字符组[ ]只能匹配<strong>单个</strong>字符</p>
</blockquote>
<h2 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h2><p>你在一篇英文小说里查找hi，你可以使用正则表达式hi</p>
<p>通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。</p>
<p>很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b</p>
<p><code>\bhi\b.*\bLucy\b</code>的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词</p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">f = open(<span class="string">'caihf001'</span>)</div><div class="line">text = f.read()</div><div class="line">f.close()</div><div class="line">k = re.compile(<span class="string">'Lemon'</span>, re.I)</div><div class="line">k.findall(text)</div><div class="line"></div><div class="line"><span class="comment"># ----效果同上</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'caihf001'</span>) <span class="keyword">as</span> f:</div><div class="line">    text = f.read()</div><div class="line"><span class="comment">#     print(text)</span></div><div class="line">    k = re.compile(<span class="string">'lemon'</span>,re.I)</div><div class="line">    l = re.findall(k,text)</div><div class="line">print(l)</div><div class="line"></div><div class="line"></div><div class="line">[<span class="string">'Lemon'</span>, <span class="string">'lemon'</span>, <span class="string">'Lemon'</span>, <span class="string">'Lemon'</span>, <span class="string">'LeMoN'</span>, <span class="string">'LEmon'</span>, <span class="string">'LEMON'</span>]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Re模块&quot;&gt;&lt;a href=&quot;#Re模块&quot; class=&quot;headerlink&quot; title=&quot;Re模块&quot;&gt;&lt;/a&gt;Re模块&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Re模块的函数主要分三个大类：匹配模式、替换、拆分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Python字符串转义符 &lt;code&gt;\&lt;/code&gt; &lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此强烈建议使用Python的&lt;code&gt;r&lt;/code&gt;前缀，就不用考虑转义的问题了：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s = &lt;span class=&quot;string&quot;&gt;r&#39;ABC\-001&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Python的字符串&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 对应的正则表达式字符串不变：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# &#39;ABC\-001&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_文件与目录操作_OS</title>
    <link href="http://yoursite.com/2018/01/23/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6&amp;%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA_OS&amp;Pandas/"/>
    <id>http://yoursite.com/2018/01/23/软件应用_程序编程/Python/Python_专题总结/Python_目录与文件&amp;导入导出_OS&amp;Pandas/</id>
    <published>2018-01-22T16:00:00.000Z</published>
    <updated>2018-02-13T13:11:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>Python_导入导出</p>
<a id="more"></a>
<h1 id="目录与文件操作-OS模块"><a href="#目录与文件操作-OS模块" class="headerlink" title="目录与文件操作 - OS模块"></a>目录与文件操作 - OS模块</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><blockquote>
<p>“./” 表示当前目录</p>
<p>“../“ 表示上一目录</p>
<p>Windows 中路径需要两个<code>\\</code>  如下为示例：</p>
<p><code>E:\\my_computer\\1_工作学习</code></p>
</blockquote>
<p><br></p>
<h4 id="getcwd-amp-os-chdir-工作目录"><a href="#getcwd-amp-os-chdir-工作目录" class="headerlink" title="getcwd &amp; os.chdir - 工作目录"></a>getcwd &amp; os.chdir - 工作目录</h4><ul>
<li><strong>os.getcwd()</strong> 函数得到当前工作目录，即当前Python脚本工作的目录路径。</li>
<li><strong>os.chdir(dirname)</strong>: 改变工作目录到dirname</li>
</ul>
<p><br></p>
<h4 id="listdir-文件与目录名"><a href="#listdir-文件与目录名" class="headerlink" title="listdir - 文件与目录名"></a>listdir - 文件与目录名</h4><ul>
<li><strong>os.listdir()</strong> 返回指定目录下的所有文件和目录名</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 返回当前目录下的文件名</span></div><div class="line">os.listdir()   </div><div class="line">os.listdir(<span class="string">'./'</span>)    </div><div class="line"></div><div class="line"><span class="comment"># 返回上一目录下的文件名</span></div><div class="line">os.listdir(<span class="string">'../'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>目录结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># 参考</span></div><div class="line">&gt; <span class="comment">## 工作目录为 /Users/ethan/coding/python</span></div><div class="line">&gt;</div><div class="line">&gt; Users/ethan</div><div class="line">&gt; └── coding</div><div class="line">&gt;     └── python</div><div class="line">&gt;         ├── hello.py    - 文件</div><div class="line">&gt;         └── web         - 目录</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<h4 id="path-abspath-绝对路径"><a href="#path-abspath-绝对路径" class="headerlink" title="path.abspath -  绝对路径"></a>path.abspath -  绝对路径</h4><ul>
<li><strong>os.path.abspath(file)</strong> ：获取<strong>文件或目录</strong>的<strong>绝对路径</strong></li>
<li><strong>os.path.abspath(‘.’)</strong> ：获取<strong>当前目录</strong>的绝对路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 文件的绝对绝对路径</span></div><div class="line">os.path.abspath(<span class="string">'hello.py'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding/python/hello.py'</span></div><div class="line"></div><div class="line"><span class="comment"># 文件夹的绝对路径</span></div><div class="line">os.path.abspath(<span class="string">'web'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding/python/web'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-dirname-文件路径"><a href="#path-dirname-文件路径" class="headerlink" title="path.dirname - 文件路径"></a>path.dirname - 文件路径</h4><ul>
<li><strong>os.path.dirname(path)</strong>：获取<strong>文件或文件夹</strong>的<strong>所在的路径</strong></li>
</ul>
<blockquote>
<p>对比<code>os.path.abspath</code>  hellp.py 得到的结果不同；</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取文件所在的路径</span></div><div class="line">os.path.dirname(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding/python'</span></div><div class="line"></div><div class="line"><span class="comment"># 获取文件夹的路径</span></div><div class="line">os.path.dirname(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-basename-文件名称"><a href="#path-basename-文件名称" class="headerlink" title="path.basename - 文件名称"></a>path.basename - 文件名称</h4><ul>
<li><strong>os.path.basename(path)</strong>：获取<strong>文件名或文件夹名</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从一个 绝对路径 中获取该 [文件] 的名称</span></div><div class="line">os.path.basename(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line"><span class="string">'hello.py'</span></div><div class="line"></div><div class="line"><span class="comment"># 从一个 绝对路径 中获取该 [文件夹] 的名称</span></div><div class="line">os.path.basename(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line"><span class="string">'python'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-split-目录与文件名"><a href="#path-split-目录与文件名" class="headerlink" title="path.split - 目录与文件名"></a>path.split - 目录与文件名</h4><ul>
<li><strong>os.path.split(path)</strong>：获取分离后的<strong>目录与文件名</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取分离后的目录与文件名</span></div><div class="line">os.path.split(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding/python'</span>, <span class="string">'hello.py'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 获取分离后的目录与文件夹名</span></div><div class="line">os.path.split(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding'</span>, <span class="string">'python'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-splitext-分离"><a href="#path-splitext-分离" class="headerlink" title="path.splitext - 分离"></a>path.splitext - 分离</h4><ul>
<li><strong>os.path.splitext(path)</strong>：分离<strong>文件名与扩展名</strong></li>
</ul>
<blockquote>
<p>事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取分离后的文件名与扩展名</span></div><div class="line">os.path.splitext(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding/python/hello'</span>, <span class="string">'.py'</span>)</div><div class="line"></div><div class="line">os.path.splitext(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding/python'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-join-连接"><a href="#path-join-连接" class="headerlink" title="path.join - 连接"></a>path.join - 连接</h4><ul>
<li><strong>os.path.join(path, name)</strong> ：连接<strong>目录与文件名</strong>或目录</li>
</ul>
<p><br></p>
<p>####walk - 遍历</p>
<ul>
<li><strong>os.walk()</strong>  遍历目录常用的模块，它返回一个包含 3 个元素的元祖：(dirpath, dirnames, filenames)。</li>
</ul>
<blockquote>
<p>dirpath 是以 string 字符串形式返回该目录下所有的<strong>绝对路径</strong>；</p>
<p>dirnames 是以列表 list 形式返回每一个绝对路径下的<strong>文件夹名字</strong>；</p>
<p>filesnames 是以列表 list 形式返回该路径下所有<strong>文件名字</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'/Users/ethan/coding'</span>):</div><div class="line">	<span class="keyword">print</span> root</div><div class="line">	<span class="keyword">print</span> dirs</div><div class="line">	<span class="keyword">print</span> files</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-sidir-判断目录"><a href="#path-sidir-判断目录" class="headerlink" title="path.sidir - 判断目录"></a>path.sidir - 判断目录</h4><ul>
<li><strong>os.path.isdir(name)</strong>： 判断name是不是目录，不是目录就返回false</li>
</ul>
<p><br></p>
<h4 id="path-exists-判断存在"><a href="#path-exists-判断存在" class="headerlink" title="path.exists - 判断存在"></a>path.exists - 判断存在</h4><ul>
<li><strong>os.path.exists(name)</strong> :判断是否存在文件或目录name</li>
</ul>
<p><br></p>
<h4 id="path-isfile-判断存在"><a href="#path-isfile-判断存在" class="headerlink" title="path.isfile - 判断存在"></a>path.isfile - 判断存在</h4><ul>
<li><strong>os.path.isfile(name)</strong> :判断name这个文件是否存在，不存在返回false</li>
</ul>
<p><br></p>
<h4 id="mkdir-创建"><a href="#mkdir-创建" class="headerlink" title="mkdir - 创建"></a>mkdir - 创建</h4><ul>
<li><strong>os.mkdir(‘file’)</strong> ：创建目录</li>
</ul>
<p><br></p>
<h4 id="rename-重命名"><a href="#rename-重命名" class="headerlink" title="rename - 重命名"></a>rename - 重命名</h4><ul>
<li><strong>os.rename(“oldname”,”newname”)</strong> ：重命名文件（目录）</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><br></p>
<h4 id="moknod-创建"><a href="#moknod-创建" class="headerlink" title="moknod - 创建"></a>moknod - 创建</h4><ul>
<li><strong>os.moknod(‘text.txt’)</strong> : 创建空文件</li>
</ul>
<p><br></p>
<h4 id="remove-移除"><a href="#remove-移除" class="headerlink" title="remove - 移除"></a>remove - 移除</h4><ul>
<li><strong>os.remove()</strong>：函数用来删除一个文件</li>
</ul>
<p><br></p>
<h4 id="open-打开"><a href="#open-打开" class="headerlink" title="open - 打开"></a>open - 打开</h4><blockquote>
<p>要以任何方式打开文件（即使是打印文档），都必须<strong>先打开文件</strong>，这样才能访问它。</p>
<p>读取文本文件时，Python将其中的所有文本都解读为<strong>字符串。如果你读取的是数字，需要转为int/float</strong></p>
</blockquote>
<ul>
<li><strong>open(file, [w])</strong> ：以某种方式打开文件</li>
<li><strong>with open(file, [w])</strong> ： with 关键字<strong>不再需要访问文件后将其关闭的操作；会自动关闭</strong></li>
</ul>
<blockquote>
<p>r - 只读模式</p>
<p>w - 只写模式。覆盖之前的同名文件（即删除里面的所有内容）。如果文件不存在就创建文件</p>
<p>a - 追加模式打开。附加到现有文件；若文件不存在则创建一个；添加到文件末尾</p>
<p>r+ - 读写模式</p>
<p>w+ 以读写模式打开<br>a+ 以读写模式打开<br>rb 以二进制读模式打开<br>wb 以二进制写模式打开 (参见 w )<br>ab 以二进制追加模式打开 (参见 a )<br>rb+ 以二进制读写模式打开 (参见 r+ )<br>wb+ 以二进制读写模式打开 (参见 w+ )<br>ab+ 以二进制读写模式打开 (参见 a+ )</p>
</blockquote>
<p><br></p>
<h4 id="read-读取"><a href="#read-读取" class="headerlink" title="read - 读取"></a>read - 读取</h4><blockquote>
<p>要以任何方式打开文件（即使是打印文档），都必须<strong>先打开文件</strong>，这样才能访问它。</p>
<p>读取文本文件时，Python将其中的所有文本都解读为<strong>字符串。如果你读取的是数字，需要转为int/float</strong></p>
<ul>
<li>所谓字符串，是指可以在内部查找的文档格式。</li>
</ul>
</blockquote>
<ul>
<li><strong>tb0.realine()</strong>： 读取第一行的数据，以 <strong>( 字符串str )</strong> 形式返回文件数据 ； 此时<strong>源数据 tb0已经缺少了第一行的数据</strong></li>
<li><strong>tb0.readlines()</strong>：按行读取所有的数据，以<strong>[ 列表list ]</strong>，准确的说<strong>包含字符串str的列表list</strong>，并且也包含<strong>换行符(\n)，制表符(\t)</strong> 形式返回文件数据</li>
<li><strong>tb0.read() </strong>：一次性读取所有数据，类型为 <strong>( 字符串str )</strong><ul>
<li>末尾多一行空行</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'filename.csv'</span>) <span class="keyword">as</span> tb01:  <span class="comment"># with 关键字不再需要访问文件后将其关闭的操作；会自动关闭</span></div><div class="line">    a = tb01.readline() <span class="comment"># 此时源数据tb01已经缺少了第一行的数据</span></div><div class="line">    b = tb01.readlinse() </div><div class="line">    c = tb01.read() <span class="comment"># 此时已经为空</span></div><div class="line"></div><div class="line"><span class="comment"># ----【 重要概念 】--------------------------------------    </span></div><div class="line">b[<span class="number">0</span>]  <span class="comment"># 获得列表中的第一个字符串 '003888800000798,160999900163133\n'</span></div><div class="line">b[<span class="number">0</span>][<span class="number">0</span>] <span class="comment"># 获得列表中第一个字符串的第一个字符 '0'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ----【 读取与替换】--------------------------------</span></div><div class="line"><span class="comment">## 创建里面为列表的列表</span></div><div class="line">l = []   <span class="comment"># 创建空列表</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:  <span class="comment"># b为列表，对每个对象进行逐一操作</span></div><div class="line">    m = re.sub(<span class="string">r'\n'</span>,<span class="string">''</span>,i)   <span class="comment"># 完成一系列对字符串的操作，结果仍为字符串string</span></div><div class="line"><span class="comment">#   p = re.split(',',m)  若需要，可对字符串进行分割，结果为列表list</span></div><div class="line">    l.append(m)</div><div class="line">l</div><div class="line">[<span class="string">',,,会员简称,成交量,比上一交易日增减,会员简称,持买单量,比上一交易日增减,会员简称,持卖单量,比上一交易日增减'</span>,</div><div class="line"> <span class="string">'20160111,IC1601                        ,1,海通期货    ,1581,31,上海东证    ,1287,-17,中信期货    ,2137,-95'</span>,</div><div class="line"> <span class="string">'20160111,IC1601                        ,2,中信期货    ,1437,-13,华泰期货    ,1124,-70,广发期货    ,1583,-194'</span>,</div><div class="line"> <span class="string">'20160111,IC1601                        ,3,国泰君安    ,1231,-55,海通期货    ,993,-16,国泰君安    ,831,-52'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用循环读取的结果为字符串格式</span></div><div class="line">l = <span class="string">''</span></div><div class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</div><div class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> file_object:</div><div class="line">		l = l + line</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="write-写入"><a href="#write-写入" class="headerlink" title="write - 写入"></a>write - 写入</h4><ul>
<li>write 不会在文本末尾添加换行符(\n)，若<strong>写入多行时，建议在最后添加换行符 \n.</strong><ul>
<li><code>tb1.write(&#39;I love programming.\n&#39;)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>r - 只读模式<br>w - 只写模式。覆盖之前的同名文件（即删除里面的所有内容）。如果文件不存在就创建文件<br>a - 追加模式打开。附加到现有文件；若文件不存在则创建一个；添加到文件末尾<br>r+ - 读写模式<br>w+ 以读写模式打开</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'path\filename.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> tb1:</div><div class="line">    tb1.write(<span class="string">'I love programming!'</span>)   <span class="comment"># 直接在该文件中最后写入</span></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment"># --------------若要写入文档，先完成数据的提取-----------------</span></div><div class="line">b = <span class="string">''</span>  <span class="comment"># 空字符串；因为文本文档均为字符串格式</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'path\filename.csv'</span>) <span class="keyword">as</span> f:</div><div class="line">    a = f.readlines()  <span class="comment"># 此时a为列表list格式； 也可为 a = f.read()，则该处a为字符串格式</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</div><div class="line">        b = b + str(i) + a[i]</div><div class="line"><span class="keyword">with</span> open(<span class="string">'path\filename.csv'</span>) <span class="keyword">as</span> f:</div><div class="line">    f1 = f.write(b)</div></pre></td></tr></table></figure>
<p><br> </p>
<p>##【实战演练】</p>
<p><strong>【获取上一层次目录中，test文件夹内的所有文件，并选取csv格式的文档】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="comment"># 方法一</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">'../'</span>) </div><div class="line">[<span class="string">'.ipynb_checkpoints'</span>,</div><div class="line"> <span class="string">'.Rhistory'</span>,</div><div class="line"> <span class="string">'Python'</span>,</div><div class="line"> <span class="string">'R_dir'</span>,</div><div class="line"> <span class="string">'test'</span>,</div><div class="line"> <span class="string">'test.ipynb'</span>]</div><div class="line"></div><div class="line"><span class="comment">## 手动添加目录</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>file_name = os.listdir(<span class="string">'../test'</span>)</div><div class="line">[<span class="string">'2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-13-T_1.csv'</span>]</div><div class="line"></div><div class="line"><span class="comment">## 用Re模块匹配符合的文档</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>k = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_name:</div><div class="line">    <span class="keyword">if</span> re.findall(<span class="string">r'.*\.csv$'</span>,i):</div><div class="line">        k.append(<span class="string">'../test/'</span>+i) </div><div class="line">k</div><div class="line"></div><div class="line">[<span class="string">'../test/2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'../test/2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'../test/2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'../test/2016-01-13-T_1.csv'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -------获得绝对路径的文件名-------------------------------------------------------</span></div><div class="line">dir_name = os.path.abspath(<span class="string">'../test/'</span>)</div><div class="line">dir_name</div><div class="line">k = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_name:</div><div class="line">    <span class="keyword">if</span> re.findall(<span class="string">r'.*\.csv$'</span>,i):</div><div class="line">        k.append(dir_name+i) </div><div class="line">k</div><div class="line">[<span class="string">'E:\\Jupyter_notebook\\test2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\test2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\test2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\test2016-01-13-T_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\testtest - 副本.csv'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ------------------------------------------------------</span></div><div class="line"><span class="comment"># 方法二</span></div><div class="line">dir_name1 = os.path.abspath(<span class="string">'../'</span>)</div><div class="line"><span class="string">'E:\\Jupyter_notebook'</span></div><div class="line"></div><div class="line">os.listdir(<span class="string">'../'</span>)  <span class="comment"># 结果同上</span></div><div class="line">test_dir  = os.path.join(dir_name1, <span class="string">'test'</span>)</div><div class="line">os.listdir(test_dir)</div><div class="line">[<span class="string">'2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-13-T_1.csv'</span>]</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>【获取其他目录下的文件】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取当前工作目录</span></div><div class="line">os.getcwd()</div><div class="line"></div><div class="line"><span class="comment"># 变更工作目录</span></div><div class="line">os.chdir(<span class="string">'E:\Others'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h1 id="导入与导出-pandas"><a href="#导入与导出-pandas" class="headerlink" title="导入与导出 - pandas"></a>导入与导出 - pandas</h1><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><blockquote>
<p>pandas默认将表格型数据读取为<strong>数据框格式（DataFrame）</strong></p>
<p>“./” 表示当前目录</p>
<p>“../“ 表示上一目录</p>
<p>import pandas as pd<br>import numpy as np</p>
<p>df：任意的Pandas DataFrame对象<br>s：任意的Pandas Series对象</p>
</blockquote>
<ul>
<li><strong>pd.read_csv(“./filename.txt”, sep=’,’, header=0, names=[‘a’,’b’], skiprows=0, index_col=’a’, na_values=’NULL’, nrows=1000, encoding=’gb2312’, thousands= ‘,’)</strong> ：从CSV文件导入数据</li>
</ul>
<blockquote>
<p>sep =’\s+’ 正则表达式的空白字符串 </p>
<p>header=0，表示默认第一行为列名； header=None 没有列名行</p>
<p>names=[‘a’, ‘b’] 用于指定列名，与header=None结合使用</p>
<p>skiprows=0, skiprows=[0,2,3] 表示跳过的观测行； </p>
<p>skip_footer=0，表示忽略的行数（从文件末尾算起）</p>
<p>index_col =[‘a’,’b’] 表示指定为索引列</p>
<p>na_valuse = [‘Null’] 一组将NA值替换为指定的字符’Null’ 或其他任意形式</p>
<p>nrows=1000 表示读取的行数，从文件开始处算起</p>
<p>thousands=’,’ / ‘.’ 千分位分隔符</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tb01 = pd.read_csv(<span class="string">"./filename.txt"</span>, sep=<span class="string">','</span>, header=<span class="number">0</span>, names=[<span class="string">'a'</span>,<span class="string">'b'</span>], skiprows=<span class="number">0</span>, index_col=<span class="string">'a'</span>, na_values=<span class="string">'NULL'</span>, nrows=<span class="number">1000</span>, encoding=<span class="string">'gb2312'</span>, thousands= <span class="string">','</span>)  <span class="comment"># 默认分隔符为逗号；  </span></div><div class="line">tb01 = pd.read_table() 　<span class="comment">#</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>pd.read_exce</strong>l(filename)：从Excel文件导入数据</li>
<li><strong>pd.read_table</strong>(filename)：从限定分隔符（默认为制表符 “\t”）的文本文件导入数据； 也可读csv格式的文档，但建议将sep=’,’</li>
<li><strong>pd.read_sql</strong>(query, connection_object)：从SQL表/库导入数据</li>
<li><strong>pd.read_json</strong>(json_string)：从JSON格式的字符串导入数据</li>
<li><strong>pd.read_html</strong>(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格</li>
<li><strong>pd.read_clipboard</strong>()：从你的粘贴板获取内容，并传给read_table()</li>
<li><strong>pd.DataFrame</strong>(dict)：从字典对象导入数据，Key是列名，Value是数据</li>
</ul>
<p><br></p>
<p>####数据清洗</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'关联客户0522.csv'</span>) <span class="keyword">as</span> tb0:</div><div class="line">    tb1 = tb0.readlines()  <span class="comment"># 将tb0中的内容按行读取为列表；(此时自动生成了一个换行符\n)</span></div><div class="line">    tb3 = []</div><div class="line">    <span class="keyword">for</span> tb <span class="keyword">in</span> tb1:  <span class="comment"># 一次访问列表list中的元素（此时各元素为字符串格式，故可以对其进行操作）</span></div><div class="line">        tb2 = tb.replace(<span class="string">'"'</span>, <span class="string">''</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>).strip().split(<span class="string">','</span>)  <span class="comment"># 依次完成各个操作 替换” - 替换\n - 去空格 - 按分隔符','将元素转化为列表</span></div><div class="line">        tb3.append(tb2)  <span class="comment"># 在列表tb3中添加以将各元素转为列表的值；最终类型为列表的列表</span></div><div class="line">print(tb3)</div><div class="line">tb3[<span class="number">1</span>][<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="显示所有行数"><a href="#显示所有行数" class="headerlink" title="显示所有行数"></a>显示所有行数</h4><blockquote>
<p>pandas默认会隐去中间的部分。如果希望能显示完整，可以使用下面的方法：</p>
</blockquote>
<ul>
<li>一次性设置Pandas运行环境，以便输出所有记录；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="keyword">None</span>)</div><div class="line">pd.set_option(<span class="string">'display.max_rows'</span>, <span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<ul>
<li>针对特定输出，设置Pandas参数。<strong>运行之后，再恢复到默认值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> pd.option_context(<span class="string">'display.max_rows'</span>, <span class="keyword">None</span>, <span class="string">'display.max_columns'</span>, <span class="number">3</span>):  <span class="comment"># None 为全部；或者指定具体的数值</span></div><div class="line">    <span class="keyword">print</span> (df)</div></pre></td></tr></table></figure>
<br>



<h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><blockquote>
<p><strong>缺失值 在输出结果中为 空字符串；</strong></p>
</blockquote>
<ul>
<li><strong>DataFrame.to_cvs(‘filename.csv’, sep=’,’, na_rep=’NULL’, index=False, header=False, cols=[‘a’,’b’,’c’])</strong>：导出数据到CSV文件</li>
</ul>
<ul>
<li><strong>df.to_exce</strong>l(filename)：导出数据到Excel文件<ul>
<li>DataFrame.to_excel(<em>excel_writer</em>, <em>sheet_name=’Sheet1’</em>, <em>na_rep=’’</em>, <em>float_format=None</em>, <em>columns=None</em>, <em>header=True</em>, <em>index=True</em>, <em>index_label=None</em>, <em>startrow=0</em>, <em>startcol=0</em>, <em>engine=None</em>, <em>merge_cells=True</em>, <em>encoding=None</em>, <em>inf_rep=’inf’</em>, <em>verbose=True</em>, <em>freeze_panes=None</em>)</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>excel_writer</strong> : string or ExcelWriter object. File path or existing ExcelWriter</p>
<p><strong>na_rep</strong> : string, default ‘’ . Missing data representation</p>
<p><strong>float_format</strong> : string, default None. Format string for floating point numbers</p>
<p><strong>columns</strong> : sequence, optional. Columns to write ；表示需要导出的列</p>
<p><strong>header</strong> : boolean or list of string, default True； 表示可以<strong><u>重命名列名</u></strong></p>
<p><strong>index</strong> : boolean, default True   ；是否包含索引列</p>
<p><strong>index_label</strong> : string or sequence, default None</p>
<p><strong>startrow :</strong>upper left cell row to dump data frame</p>
<p><strong>encoding: string, default None</strong></p>
</blockquote>
<ul>
<li><strong>df.to_sql</strong>(table_name, connection_object)：导出数据到SQL表</li>
<li><strong>df.to_json</strong>(filename)：以Json格式导出数据到文本文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导出数据</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir_name</div><div class="line"><span class="string">'E:\\my_computer\\1_工作学习\\10_工作文档\\5 银天下-数据分析\\30_专项分析\\0102_股今中外链接统计\\人员信息\\历史数据'</span></div><div class="line">lj01.to_excel(dir_name+<span class="string">'\\'</span>+<span class="string">'lj02.xls'</span>,index=<span class="keyword">False</span>)</div><div class="line">qian_all_data.to_csv(<span class="string">'qianguqg.csv'</span>, index=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 导入到同一Excel的多个sheet</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>writer = pd.ExcelWriter(<span class="string">'output.xlsx'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df1.to_excel(writer,<span class="string">'Sheet1'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df2.to_excel(writer,<span class="string">'Sheet2'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>writer.save()</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h2><h4 id="将所有CSV文档读入到同一个对象"><a href="#将所有CSV文档读入到同一个对象" class="headerlink" title="将所有CSV文档读入到同一个对象"></a>将所有CSV文档读入到同一个对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 读取csv的文件，并写入到一个列表 name2</span></div><div class="line">name2 = []</div><div class="line">l = re.compile(<span class="string">'.*\.csv'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name:</div><div class="line">    <span class="keyword">if</span> re.findall(l, i):</div><div class="line">        name2.append(i)</div><div class="line">        </div><div class="line"><span class="comment"># 读入到同一个对象        </span></div><div class="line">table1 = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name2:</div><div class="line"><span class="comment">#    print(i)</span></div><div class="line"><span class="comment">#      need_table = pd.read_csv(i)</span></div><div class="line">    table0 = pd.read_csv(<span class="string">'../future-exchange/'</span>+i, encoding = <span class="string">'gb2312'</span>)</div><div class="line">    table1.append(table0)</div></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python_导入导出&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hive_介绍</title>
    <link href="http://yoursite.com/2018/01/22/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Hive/Hive_%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/01/22/软件应用_程序编程/Hive/Hive_介绍/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-02-13T13:49:16.378Z</updated>
    
    <content type="html"><![CDATA[<p>Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。</p>
<p>术语“大数据”是大型数据集，其中包括体积庞大，高速，以及各种由与日俱增的数据的集合。使用传统的数据管理系统，它是难以加工大型数据。因此，Apache软件基金会推出了一款名为Hadoop的解决大数据管理和处理难题的框架。</p>
<p>参考链接：<a href="http://www.yiibai.com/hive/" target="_blank" rel="external">http://www.yiibai.com/hive/</a></p>
<a id="more"></a>
<p>​    </p>
<p><br></p>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop是一个开源框架来存储和处理大型数据在分布式环境中。它包含两个模块，一个是MapReduce，另外一个是Hadoop分布式文件系统（HDFS） Hadoop Distributed File System</p>
<ul>
<li><strong>MapReduce：</strong>它是一种并行编程模型在大型集群普通硬件可用于处理大型结构化，半结构化和非结构化数据。</li>
</ul>
<ul>
<li><strong>HDFS：</strong>Hadoop分布式文件系统是Hadoop的框架的一部分，用于存储和处理数据集。它提供了一个容错文件系统在普通硬件上运行。</li>
</ul>
<p>Hadoop生态系统包含了用于协助Hadoop的不同的子项目（工具）模块，如Sqoop, Pig 和 Hive。</p>
<ul>
<li><strong>Sqoop: </strong>它是用来在HDFS和RDBMS之间来回<strong><u>导入和导出数据</u></strong>。</li>
<li><strong>Pig:</strong> 它是用于开发MapReduce操作的<strong><u>脚本程序语言的平台</u></strong>。</li>
<li><strong>Hive:</strong> 它是用来开发<strong><u>SQL类型脚本</u></strong>用于做<strong><u>MapReduce操作的平台</u></strong>。</li>
</ul>
<p>注：有多种方法来执行MapReduce作业：</p>
<ul>
<li>传统的方法是使用Java MapReduce程序结构化，半结构化和非结构化数据。</li>
<li>针对MapReduce的脚本的方式，使用Pig来处理结构化和半结构化数据。</li>
<li>Hive查询语言（HiveQL或HQL）采用Hive为MapReduce的处理结构化数据。</li>
</ul>
<p><br></p>
<h2 id="Hive是什么？"><a href="#Hive是什么？" class="headerlink" title="Hive是什么？"></a>Hive是什么？</h2><p>Hive是一个<strong>数据仓库</strong>基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。</p>
<p>最初，Hive是由Facebook开发，后来由Apache软件基金会开发，并作为进一步将它作为名义下Apache Hive为一个开源项目。它用在好多不同的公司。例如，亚马逊使用它在 Amazon Elastic MapReduce。</p>
<h3 id="Hive-不是"><a href="#Hive-不是" class="headerlink" title="Hive 不是"></a>Hive 不是</h3><ul>
<li>一个关系数据库</li>
<li>一个设计用于联机事务处理（OLTP）</li>
<li>实时查询和行级更新的语言</li>
</ul>
<p><br></p>
<h2 id="Hiver特点"><a href="#Hiver特点" class="headerlink" title="Hiver特点"></a>Hiver特点</h2><ul>
<li>它存储架构在一个数据库中并处理数据到HDFS。</li>
<li>它是专为OLAP设计。</li>
<li>它提供SQL类型语言查询叫HiveQL或HQL。</li>
<li>它是熟知，快速，可扩展和可扩展的。</li>
</ul>
<p><br></p>
<h2 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h2><p>下面的组件图描绘了Hive的结构：</p>
<p><img src="http://www.yiibai.com/uploads/allimg/141228/1-14122R10152108.jpg" alt="Hive Architecture"></p>
<p>该组件图包含不同的单元。下表描述每个单元：</p>
<table>
<thead>
<tr>
<th>单元名称</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户接口/界面</td>
<td>Hive是一个数据仓库基础工具软件，可以创建用户和HDFS之间互动。用户界面，Hive支持是Hive的Web UI，Hive命令行，HiveHD洞察（在Windows服务器）。</td>
</tr>
<tr>
<td>元存储</td>
<td>Hive选择各自的数据库服务器，用以储存表，数据库，列模式或元数据表，它们的数据类型和HDFS映射。</td>
</tr>
<tr>
<td>HiveQL处理引擎</td>
<td>HiveQL类似于SQL的查询上Metastore模式信息。这是传统的方式进行MapReduce程序的替代品之一。相反，使用Java编写的MapReduce程序，可以编写为MapReduce工作，并处理它的查询。</td>
</tr>
<tr>
<td>执行引擎</td>
<td>HiveQL处理引擎和MapReduce的结合部分是由Hive执行引擎。执行引擎处理查询并产生结果和MapReduce的结果一样。它采用MapReduce方法。</td>
</tr>
<tr>
<td>HDFS 或 HBASE</td>
<td>Hadoop的分布式文件系统或者HBASE数据存储技术是用于将数据存储到文件系统。</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="Hive工作原理"><a href="#Hive工作原理" class="headerlink" title="Hive工作原理"></a>Hive工作原理</h2><p>下图描述了Hive 和Hadoop之间的工作流程。</p>
<p>下表定义Hive和Hadoop框架的交互方式：</p>
<table>
<thead>
<tr>
<th>Step No.</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>Execute Query</strong>Hive接口，如命令行或Web UI发送查询驱动程序（任何数据库驱动程序，如JDBC，ODBC等）来执行。</td>
</tr>
<tr>
<td>2</td>
<td><strong>Get Plan</strong>在驱动程序帮助下查询编译器，分析查询检查语法和查询计划或查询的要求。</td>
</tr>
<tr>
<td>3</td>
<td><strong>Get Metadata</strong>编译器发送元数据请求到Metastore（任何数据库）。</td>
</tr>
<tr>
<td>4</td>
<td><strong>Send Metadata</strong>Metastore发送元数据，以编译器的响应。</td>
</tr>
<tr>
<td>5</td>
<td><strong>Send Plan</strong>编译器检查要求，并重新发送计划给驱动程序。到此为止，查询解析和编译完成。</td>
</tr>
<tr>
<td>6</td>
<td><strong>Execute Plan</strong>驱动程序发送的执行计划到执行引擎。</td>
</tr>
<tr>
<td>7</td>
<td><strong>Execute Job</strong>在内部，执行作业的过程是一个MapReduce工作。执行引擎发送作业给JobTracker，在名称节点并把它分配作业到TaskTracker，这是在数据节点。在这里，查询执行MapReduce工作。</td>
</tr>
<tr>
<td>7.1</td>
<td><strong>Metadata Ops</strong>与此同时，在执行时，执行引擎可以通过Metastore执行元数据操作。</td>
</tr>
<tr>
<td>8</td>
<td><strong>Fetch Result</strong>执行引擎接收来自数据节点的结果。</td>
</tr>
<tr>
<td>9</td>
<td><strong>Send Results</strong>执行引擎发送这些结果值给驱动程序。</td>
</tr>
<tr>
<td>10</td>
<td><strong>Send Results</strong>驱动程序将结果发送给Hive接口。</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。</p>
<p>概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>
<h4 id="映射和归纳"><a href="#映射和归纳" class="headerlink" title="映射和归纳"></a>映射和归纳</h4><p>简单来说，一个<strong>映射</strong>函数就是对一些独立元素组成的概念上的列表（例如，一个测试成绩的列表）的每一个元素进行指定的操作（比如，有人发现所有学生的成绩都被高估了一分，他可以定义一个“减一”的映射函数，用来修正这个错误。）。事实上，每个元素都是被独立操作的，而原始列表没有被更改，因为这里创建了一个新的列表来保存新的答案。这就是说，Map操作是可以高度并行的，这对高性能要求的应用以及并行计算领域的需求非常有用。</p>
<p>而归<strong>纳操</strong>作指的是对一个列表的元素进行适当的合并（继续看前面的例子，如果有人想知道班级的平均分该怎么做？他可以定义一个归纳函数，通过让列表中的奇数（odd）或偶数（even）元素跟自己的相邻的元素相加的方式把列表减半，如此递归运算直到列表只剩下一个元素，然后用这个元素除以人数，就得到了平均分）。虽然他不如映射函数那么并行，但是因为归纳总是有一个简单的答案，大规模的运算相对独立，所以归纳函数在高度并行环境下也很有用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。&lt;/p&gt;
&lt;p&gt;术语“大数据”是大型数据集，其中包括体积庞大，高速，以及各种由与日俱增的数据的集合。使用传统的数据管理系统，它是难以加工大型数据。因此，Apache软件基金会推出了一款名为Hadoop的解决大数据管理和处理难题的框架。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;http://www.yiibai.com/hive/&quot;&gt;http://www.yiibai.com/hive/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Hive" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Hive/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Hive" scheme="http://yoursite.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>关于月度总结的几个问题</title>
    <link href="http://yoursite.com/2018/01/21/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E5%85%B3%E4%BA%8E%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98_20180121/"/>
    <id>http://yoursite.com/2018/01/21/个人日志/关于月度总结的几个问题_20180121/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-08-09T14:34:21.596Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="关于月度总结的几个问题"><a href="#关于月度总结的几个问题" class="headerlink" title="关于月度总结的几个问题"></a>关于月度总结的几个问题</h2><blockquote>
<p>【SCQA】 $\to$ 【SCA - WKO - RR - P】</p>
<blockquote>
<p>关键的触发器：S - W - R - P $\to$ 【Sword】</p>
</blockquote>
<p>S-C-A：当时是一个什么样的（S）场景 [where/when/who/what]，产生了这个方案/行为/问题/疑问 （Action / Answer）</p>
<p>Why：这个方案/问题的最终目的是？（一种状态 Be）</p>
<p>One：为了达成XX目的，最重要的一件事是什么？当前状态下能做的最重要的一件事又是什么？</p>
<blockquote>
<p>Key：达成这个目的/状态的关键问题是什么</p>
</blockquote>
<p>Reverse：这个方案/行动能解决真正的问题吗？为了解决问题，还需要什么内容？</p>
<p>Role：你扮演的角色是？</p>
<p>Defend：保护你的预留时间不被侵害</p>
</blockquote>
<p>【S-C-A】：<strong>发现自己的月度总结只是事件的堆砌，并没有实质性的总结与指导作用</strong>。这个体会之前就会，但一直没有去做改变。直到写2017年12月月度总结的时候，才准备做一些改变。那是因为，准备重新整理自己的博客；</p>
<p>【W】：<strong>(1) 记录并回顾过去一个月自己所经历的事情； (2) 对未来的行动方向做出调整</strong></p>
<p>【O】： (1) 及时记录； <strong>(2) 花足够的时间去重新梳理浪，并进一步思考；同时将待调整的行动具化到可执行的行动上。</strong></p>
<p>【o】：<strong>预留足够多的时间</strong>来给自己写总结</p>
<p>【R】：两个O只能达成一部分目的；另一部分是要确定如何来梳理同一类别下不同的事件（这个具体行动的时候可以在调整）</p>
<p>【R】：自我观察者</p>
<p>【D】：保护你的预留时间不被侵害</p>
<p><br></p>
<h2 id="对SCQA的思考"><a href="#对SCQA的思考" class="headerlink" title="对SCQA的思考"></a>对SCQA的思考</h2><p><strong>【原先的设定】</strong></p>
<p>在什么样的场景（S &amp; C）下，得出了这样的一个结论/方案（A），它的目的（Why）是达成什么样的一个状态（Be）或解决什么问题（Q）； </p>
<p><br></p>
<p><strong>【疑惑点】</strong></p>
<p>对于SCQA与Why的两种<strong>提问方式</strong>的不和谐感。因为其实这两个都是为了得到同一个目的：界定问题，但采取两种不同的表达方式。所以，当你同时采用的时候，总觉得会有一种不顺畅的感觉。</p>
<p>另外，实践才能检验。的确，必须要实际行动一遍，才能知道好用不好用。——浦东图书馆 2018.01.21  17:52</p>
<p><br></p>
<p><strong>【优化】</strong></p>
<p>对SCQA提问的思考：<strong>分开提问</strong></p>
<ol>
<li><p>S-C-A：当时是一个什么样的场景，产生了这个方案/行为/问题/疑问 </p>
</li>
<li><p>W ：这个方案/问题的最终目的是？</p>
<blockquote>
<p>通过SCA中自己发现的 [目的] 去与对方确认；同时明确对方的真正目的</p>
</blockquote>
</li>
<li><p>One：为了达成XX目的，最重要的一件事是什么？当前状态下能做的最重要的一件事又是什么？</p>
<blockquote>
<p>Key：达成这个目的/状态的关键问题是什么</p>
</blockquote>
</li>
<li><p>Reverse：这个方案/行动能解决真正的问题吗？为了解决问题，还需要什么内容？</p>
</li>
<li><p>Role：你扮演的角色是？</p>
</li>
<li><p>Defend：保护你的预留时间不被侵害</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;关于月度总结的几个问题&quot;&gt;&lt;a href=&quot;#关于月度总结的几个问题&quot; class=&quot;headerlink&quot; title=&quot;关于月度总结的几个问题&quot;&gt;&lt;/a&gt;关于月度总结的几个问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;【SC
    
    </summary>
    
      <category term="个人日志" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="个人日志" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>时间的朋友2017:中国式机会_罗辑思维</title>
    <link href="http://yoursite.com/2018/01/11/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/Others_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4/%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B2017-%E4%B8%AD%E5%9B%BD%E5%BC%8F%E6%9C%BA%E4%BC%9A_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_20180111/"/>
    <id>http://yoursite.com/2018/01/11/阅读书籍/Others_罗振宇-罗辑思维/时间的朋友/时间的朋友2017-中国式机会_罗辑思维_20180111/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2018-02-13T13:50:06.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六个问题"><a href="#六个问题" class="headerlink" title="六个问题"></a>六个问题</h2><blockquote>
<p>2017年哪一天、哪一个时刻你认为很重要？</p>
</blockquote>
<ol>
<li>不是强者，还能不能登上舞台？</li>
<li>刚刚进场者，能不能找到玩法？</li>
<li>如果跟不上变化，会不会被淘汰？</li>
<li>中国经济增长会不会遇到天花板？</li>
<li>中国经济增长有没有可持续性？</li>
<li>中国能否赢得良性的全球发展环境？</li>
</ol>
<p><br><a id="more"></a></p>
<p><br></p>
<h2 id="六个脑洞"><a href="#六个脑洞" class="headerlink" title="六个脑洞"></a>六个脑洞</h2><h3 id="1-动车组脑洞"><a href="#1-动车组脑洞" class="headerlink" title="1.动车组脑洞"></a>1.动车组脑洞</h3><blockquote>
<p>不是强者，还能不能登上舞台？</p>
</blockquote>
<p>平凡创新的动车组时代</p>
<p><br></p>
<h3 id="2-热带雨林脑洞"><a href="#2-热带雨林脑洞" class="headerlink" title="2.热带雨林脑洞"></a>2.热带雨林脑洞</h3><blockquote>
<p>刚刚进场者，能不能找到玩法？</p>
<p>新连接、小生态</p>
<p>核心：超级用户思维</p>
</blockquote>
<ol>
<li><p>一旦有人不断地涌入了互联网，就一定需要一个全新的连接器。</p>
</li>
<li><p>新物种，往往是高价值的连接器；</p>
<blockquote>
<p>零零后，区别就是有钱；</p>
</blockquote>
</li>
<li><p>老玩法：<strong>流量思维</strong>（一代商业思维；公平对待）；新玩法：<strong>超级用户思维</strong> （区别对待）</p>
<blockquote>
<p>优酷视频，一个会员对这家公司的贡献是免费用户的二十倍；资源肯定向你倾斜；但它目前的识别方式就是交费；是不是会员用户；</p>
<p><u> 【瓶盖测试：<strong>不管你对陌生普通用户有多好，请先关照你身边的超级用户的感受。】</strong></u> </p>
<blockquote>
<p>你跟你的女朋友一起去看电影，旁边一个姑娘想请你帮她拧开矿泉水瓶；</p>
</blockquote>
</blockquote>
</li>
<li><p>会员经济，最重要的是在企业和消费者之间建立了一种可持续信任的正式关系；</p>
</li>
<li><p><strong>超级用户思维，我希望你以我为荣；（用户以你们为荣，但同时我们也以用户为荣）。</strong>面朝超级用户，才能春暖花开。</p>
<ul>
<li>做给用户长脸的事情</li>
<li>绝不做给用户丢脸的事情（这个是克制本能冲动的事情）</li>
</ul>
</li>
<li><p>企业的使命，创造且留住顾客。——德鲁克</p>
</li>
</ol>
<p><br></p>
<h3 id="3-比特化脑洞"><a href="#3-比特化脑洞" class="headerlink" title="3.比特化脑洞"></a>3.比特化脑洞</h3><blockquote>
<p>如果跟不上变化，会不会被淘汰？</p>
<p>比特世界和我们想象的不一样；原来我们要费劲力量穿越进去，要转型，因此很焦虑。但真实的比特世界是一种席卷一切的力量，你想逃都逃不掉。</p>
<p>做最好的自己，以最高的效率最最好的自己。</p>
</blockquote>
<ol>
<li>小米：认知战。不是价格战；它是干掉你的选择，不是让你去评估选择。”闭着眼睛买东西”</li>
<li>互联网会变成一种基础设置；之前从无到有，之后三十年会是从有到无（无处不在的无）；</li>
<li>互联网革命，是一场裹挟一切的变革；（不要低估革命的力量；或者那些力量微小的就根本不是革命；）<ul>
<li>你说，我就站着不动，他们就有能力把你生拉上船；你不能，他们就有本事让你能。</li>
</ul>
</li>
<li>未来战争，不在于你拥有多少资源，而在于你能调动资源；</li>
<li>做最好的自己，同时保持开放。—— 90分旅行箱 </li>
<li>你不用急着出发，因为你会<strong>被抵达</strong>。 你不需要以互联网为彼岸，那不是你要穿越过去的，而是他们会来找你的。</li>
<li>效率越来越高，分工越来越细。<ul>
<li>只要你的方式是推动效率，你不用关系什么转型；</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="4-拔河脑洞"><a href="#4-拔河脑洞" class="headerlink" title="4.拔河脑洞"></a>4.拔河脑洞</h3><blockquote>
<p>中国经济增长会不会遇到天花板？</p>
</blockquote>
<ol>
<li><p>我们不能再中国国土框架内思考的，必须在全球框架内思考这个问题。</p>
</li>
<li><p>人们用两种范式来思考世界：自然地理、地缘政治 </p>
<ul>
<li>物理距离，并不是真实的距离</li>
<li>地缘政治把世界分割成地图上的样子</li>
<li>基础设置把世界连接成另外一个样子</li>
</ul>
</li>
<li><p>世界不再是块与块的拼图，还是基础设施连成的电线网</p>
<ul>
<li>城市化，把平摊的 “面” 变成聚拢的 “点”</li>
<li><strong>只拥有，不连接，就是一个资源孤岛</strong></li>
</ul>
</li>
<li><p>拔河游戏，是所有人都参与的游戏，希望所有人都参与。拳击比赛，是强者的比赛，是有准入门槛的；</p>
<ul>
<li><p>拳击比赛的逻辑不可持续，因为<strong>已经很难找到具体的人</strong> ；</p>
<blockquote>
<p> 【启示】一切的边界都在被模糊</p>
</blockquote>
</li>
<li><p>拔河游戏，只关心价值移动的方向；中国一家公司想创新的时候，它的创新能力会结合这个国家的规模，在世界上拔河，把这些价值向我们拉过来</p>
</li>
</ul>
</li>
<li><p>一个深刻的真理的反面，可能是一个更深刻的真理。 —— 玻儿</p>
</li>
</ol>
<p><br></p>
<h3 id="5-终点站脑洞"><a href="#5-终点站脑洞" class="headerlink" title="5.终点站脑洞"></a>5.终点站脑洞</h3><blockquote>
<p>中国经济增长有没有可持续性？</p>
</blockquote>
<ol>
<li>雁阵模型：产业会进行转移；</li>
<li>“比较理论” 在中国上失效了。</li>
<li>产业更新换代的速度太吓人了。<ul>
<li>我们并没有错做什么，但是不知道为什么，我们输了。 —— 诺记亚 <ul>
<li>自有生产线的速度跟不上产业创新的速度</li>
</ul>
</li>
</ul>
</li>
<li>从 “工厂外包” 到 “风险外包”  （苹果公司的创新速度）<ul>
<li>高效率 VS. 高弹性<ul>
<li>高效率来自分工；分工越细，越高效；但弹性与专业化是矛盾的；专业化带来的低弹性</li>
</ul>
</li>
<li>动态重组的供应链网络（积木）</li>
</ul>
</li>
<li>中国的超大规模性。规模本身就是一种能力；</li>
<li>中国是这一轮全球产业转移的终点站</li>
</ol>
<p><br></p>
<p><br></p>
<h3 id="6-枢纽脑洞"><a href="#6-枢纽脑洞" class="headerlink" title="6.枢纽脑洞"></a>6.枢纽脑洞</h3><blockquote>
<p>中国能否赢得良性的全球发展环境？</p>
</blockquote>
<ol>
<li><p>中国未来的全球角色？中国是世界秩序的自变量；</p>
</li>
<li><p>世界对中国的一个<strong>需求</strong>，把我们<strong>塑造成的一种角色</strong>；</p>
</li>
<li><p>双循环 结构。中国成为一个不可缺少的节点；是世界的十字路口；</p>
<ul>
<li>西方通过中国投放秩序；欠发达国家通过中国发展繁荣</li>
</ul>
</li>
<li><p>历史上的国家和衰败，只是影响到自己；今天任何一个国家的衰弱， 都可能影响世界上其他地方；—— 《枪炮病菌与钢铁》</p>
<ul>
<li>西方不输出繁荣和秩序，就会被输入贫穷和动乱</li>
<li>西方渴望帮助非洲，结果反而摧毁了非洲的经济</li>
</ul>
<blockquote>
<p>【共鸣】援助是没有办法真正改变贫穷的；</p>
</blockquote>
</li>
<li><p>建立秩序，必须把简单的援助转化为具体的经贸过程；</p>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ol>
<li><p>大者越大，强者恒强</p>
</li>
<li><p>“黑洞效应”：一家公司有两个特点：网络协同 + 数据只能</p>
</li>
<li><p>快：小米步枪（吃鸡游戏）；第三天网易发布两款同类游戏；一周内腾讯发布游戏；网络市场，先发优势很重要。小米步枪占领Apple Store 中国第一名，就省去了几百万美元的推广费；</p>
<blockquote>
<p>机器快、公司快、市场快、用户快</p>
</blockquote>
</li>
<li><p>一家游戏公司，在未取得授权之前在网络发布，等到第二天从市场数据的反馈告诉你哪个明星是有效的，立马与对方的经纪人联系。</p>
</li>
<li><p>玩家迭代的方向，就是产品迭代的方向。</p>
<blockquote>
<p>【启发】想起这样一句话，每个人都在问什么在变，我们要知道的是什么没有在变。客户对于简答的需求没有在变，那就是我们要做的方向。</p>
</blockquote>
</li>
<li><p>豌豆公主效应：体验是一种可训练的能力；一旦达成，就再也退不回去了。</p>
<blockquote>
<p>音频的二倍速、三倍速、五倍速；</p>
</blockquote>
</li>
<li><p>竞争是过去的商业关键词；现在是我们必须追赶用户。</p>
</li>
<li><p>你必须不停地奔跑，你才能留在原地。 ——《爱丽丝》</p>
</li>
<li><p>创新，就是解决问题的能力。—— 熊彼特</p>
</li>
</ol>
<p><br></p>
<h3 id="人生算法"><a href="#人生算法" class="headerlink" title="人生算法"></a>人生算法</h3><blockquote>
<p>算法 VS. 规律</p>
</blockquote>
<ol>
<li><p>即使机会相同，算法不同，结果就不同；</p>
<ul>
<li>一个按钮得100万美元；一个按钮一半得一亿美元，一半是什么都没有。</li>
</ul>
</li>
<li><p>人生算法，不断提高达成目标的概率的过程；</p>
</li>
<li><p>人生的一切结果本质上都是概率问题；所有的人生的选择和目标，都是那个一亿美元；</p>
</li>
<li><p>算法就是在连续性基础上运行的原则；</p>
</li>
<li><p><strong><u>所谓的人生算法，就是在漫长的过程中不断找到那个最初的原则。</u></strong></p>
<ul>
<li>当成功概率很高的时候，下最大的赌注；其余时间按兵不动；</li>
<li>人生就是滚雪球，找很多很湿的雪，加上一道很长很长的坡，然后把自己那个最原初的算法，那个雪球一直滚下去 —— 巴菲特</li>
<li>成就 = 核心算法 $\times$ 大量重复动作$^2$</li>
<li>找到那种值得不断重复下去的最基本的套路；</li>
<li>抓住它、重复它、强化它</li>
</ul>
</li>
<li><p>算法的力量，把一切软肋变成铠甲；</p>
</li>
<li><p>岁月不饶人，我亦未曾饶过岁月。—— 木心</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><ol>
<li>罗胖的内容很正能量，很有感染力；同时也会营销；（拿出你的手机，拍照照，发个朋友圈，说我相信）</li>
<li>罗胖，一直不忘记他的用户；也不忘记他的赞助商；他真诚，这个也是我所需要的。 视频160分处</li>
<li>对时间的掌控能力，尤其是最后一段时间；真厉害；</li>
</ol>
<p><br></p>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ol>
<li>《超级版图》：真实的世界什么样？</li>
<li>《枢纽》</li>
<li>《原则》Ray Darial</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;六个问题&quot;&gt;&lt;a href=&quot;#六个问题&quot; class=&quot;headerlink&quot; title=&quot;六个问题&quot;&gt;&lt;/a&gt;六个问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2017年哪一天、哪一个时刻你认为很重要？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;不是强者，还能不能登上舞台？&lt;/li&gt;
&lt;li&gt;刚刚进场者，能不能找到玩法？&lt;/li&gt;
&lt;li&gt;如果跟不上变化，会不会被淘汰？&lt;/li&gt;
&lt;li&gt;中国经济增长会不会遇到天花板？&lt;/li&gt;
&lt;li&gt;中国经济增长有没有可持续性？&lt;/li&gt;
&lt;li&gt;中国能否赢得良性的全球发展环境？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
