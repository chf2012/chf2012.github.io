<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《乌合之众》读书笔记]]></title>
      <url>%2F2018%2F08%2F08%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F30_%E8%A1%8C%E4%B8%BA%E5%BF%83%E7%90%86%E5%AD%A6%2F%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%5B%E6%B3%95%5D%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB.%E5%8B%92%E5%BA%9E_201807%2F</url>
      <content type="text"><![CDATA[《乌合之众》 - [法] 古斯塔夫.勒庞 | 《The Crowd》 Gustave Le Bon | 1895 01 【初始疑问与目的】 S：阅读《人生定位》之后，认识到他人的重要性。故了解他人在社会中的力量是如何产生影响的。 W：他人如何在社会/群体中产生影响 02 【作者关注的问题】 what：个人在群体中会发生什么样的变化 作者的原文回答： 群体的无意识行为代替了个人的有意识行为。 03 【文章展开的方式】 文章脉络如何展开： 其他人的观点： 作为读者，你怎么看： 04 【对我的指导意义与行动】 对我生活与工作的指导意义： 准备具体怎么去做： 05 【总结回顾】 回答自己的问题： 作者简介与著作背景： 一句话概括： 总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。所以，做完读书笔记之后，重新再次思考；回答一下所有的问题。 前言群体的无意识行为代替了个人的有意识行为。 社会事实如此复杂，根本不可能全盘掌握或预见到它们的相互影响带来的后果。此外，可见的事实背后，有时还隐藏着成千种看不见的原因。可见的社会现象可能是某种巨大的无意识机制的结果，而这一机制通常超出了我们的分析范围。 【解读】表述出真实社会/世界是非常复杂的，以致于我们根本无法系统、全面地去分析 考虑事物虚幻的形状，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速阅读]]></title>
      <url>%2F2018%2F07%2F08%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F40_%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB_%E6%95%B4%E7%90%86_20180708%2F</url>
      <content type="text"><![CDATA[S：在知乎上看到关于 “ 快速阅读 “ 的问题，然后提到说要 &lt; 消除内语 &gt;，即脑中的声音。让眼睛去读，而不是发声去读；但尝试几次之后，依然失败；同时，在《精进》一本书中提到关于学习，应该以 &lt; 自己的初始疑问为中心 &gt;，去阅读。 另外，认识到快速阅读的重要性以及对今后的帮助，所有准备重新整理，并落实到行动 W：知晓快速阅读的核心观念，具体执行的方法，并落实到可执行的行为 整理快速阅读的核心与方法 总结 去结合《精进》中提到的学习方法 知乎问题：快速阅读该怎么学 观点一：确定作者关注的问题，并寻找答案 【思考】这个观点，是从作者为中心的角度去思考，旨在剖析文章； 知乎 From 核聚 读书就是探索。 目标1：确定作者在关注什么问题？ 如果一本专著没有讨论任何问题，或者讨论了各种问题而没有突出的问题，那就算不上专著，只能是文集之类 很多情况下，&lt; 书名 &gt; 就是说明了关注的问题 目标2：找出书中最关键的问题来回答这个问题，而且必须要找到书中的原话。而不是自己模糊的感觉。 目标3：针对这个问题，找出书中有没有提到其他不一样的、别人的观点？ 目标4：两者相比较，哪一方的观点更有道理？为什么？ 目标5：自我思考；作为读者，你怎么看？ 这样读一本书，你未必会读得很快。但读书会变成福尔摩斯探案，围绕着核心问题，不断找线索、找证据，最终发现答案。 ​ 效果，完全可以用来写个书评，或者做个读书报告。细节部分，再根据主题内容做补充即可。若有其他需要，可以回头再查阅。这个方法可以用来速读，也可以精读。所谓精读，是对书的某一个章节，甚至一个段落，都可以用这种方式提问，挖掘到深刻的部分，并将问题、事实与概念在大脑中串起来。如果经常这么做，读书就会很快。因为同一领域的书，大部分内容都是重复的。 不适用的场景与书籍： 太经典的书籍 例如《道德经》；处处都是重点，处处都是核心；因为智慧已经被浓缩的不能再浓缩了。 太专业的书籍 例如《童年的秘密》、《纯粹理性批判》；有的书太深奥，一环扣一环；或者太专业，太深刻 例如充斥着图表和公式的书，适合做工具书；或者深究 《如何阅读一本书》 明确自己的阅读目的；消遣、获取信息、形成观点 “ 形成观点 “，你需要知道作者的想法和观点，并形成自己的观点，而且还要能够批判他人提出的观点，时刻注意想法的差异；这是训练批判性思维的一种方法，有利于形成自己的价值观； 基于你具体的初始问题，筛选有用的信息；本田直之先生所著的《杠杆阅读术》一书中，做过如下解释 “一本书里的重要内容占20%，再从其中抽取80%后，所提炼的要点只占16%。如果是200页的书，就只有32页是关键内容” 、 找主题句。 主题句为段落第一句。 主题句为段落第二句。 主题句为段落最后一句。 但我还是要请求你，假如读了之后觉得它们不合口味，那就把它们搁到一边吧，因为除非你能真正享受它们，否则读来也无用。没有人有义务一定阅读诗歌、小说或其他可以归入纯文学类的作品。人一定是为了寻求乐趣而阅读，然而谁又能保证使某个人快乐的事物也一定会使其他人快乐呢！ From 毛姆 观点二：具体的阅读方法 避免发声。出声阅读是影响阅读速度的重要因素。 实验统计表明，朗读的速度最快每分钟只能达到200字，而默读每分钟可达800字左右，是朗读的4倍。因此，提高阅读首先要学会默读。默读的关键在于避免出声，有的人在读时虽然听不到有明显的出声现象，但是仔细观察会发现他的唇或舌在动，说明其阅读仍有不易觉察的潜在发声现象，这仍会影响到阅读的速度。在实际阅读训练中，要有意识地克服唇动、舌动的现象。 即使有内语，也可以加快速度，快速阅读。 实际发现，还是很有帮助的。 减少注视点。 阅读过程中，眼睛是以快速眼跳运动 的方式进行的。而眼跳运动的时间只占10%，而眼睛停留在各个注视点上停留的时间占90%。可见，眼睛不是靠眼跳的运动，而是通过眼跳过程中的 注意停顿 来获取信息的；这样，减少一行乃至一页文字中的注视点，也就相应使得视觉幅度扩大，每次眼停获得的信息增多，从而可以节省阅读时间，提高阅读的效率。 缩短眼停时间。 避免回视； 回视是指眼跳经过某一注视点后又重新返回。回视的次数越多，阅读的速度就会越慢。因此，必须努力克服回视的毛病。一般来说，回视的出现是由于注意力不够集中、阅读缺乏自信，总担心没有完全看清楚。要避免回视，就应从这些方面多加注意。 《博赞脑力训练手册》当中，作者已经做过大量研究。 阅读速度的提高并不会影响理解力，你不理解某个内容是因为你过去的知识储备不够。 你反复回读、复读是不会增强你的理解力的，反而会阻碍你对整篇文章的理解。 文章是一个整体，中间出现一些不太明白的词，只要不影响你对主题的理解，你不理解也没有关系，直接顺下去读就可以了。 只有当你的阅读速度影响了你对作品主旨的理解，降低了阅读的快感时，才需要调整 麦田星空 的回答 用视觉输入代替逐字输入。 很多人的阅读习惯是从左往右、从上往下，逐字逐行地读，这其实是效率最低下的阅读方式。 阅读本身分为 阅和读 两个部分。阅，对应的动作是看，读对应的是听； 阅是视觉输入，就像你看一幅画一样，你不会从上往下从左往右按着顺序来看，你一眼瞄过去就能知道这是幅人物画还是风景画。 读，是听觉输入；你得按照一定的顺序描述才能把它还原成一幅画，既然看一段文字就像看一幅画，你一眼瞄过去就应该知道一幅画的内容，那就没必要逐字去读。 理解这一点很重要，所谓快速阅读，就是指快速地找出一段话的关键信息，直接跳过和忽略那些不重要的辅助信息。 抓概念。 没接触过的新概念；方法论也可以归为新概念； 不够重视的旧概念；就是作者试图用自己的论证来说服你，让你了解自己以前的观念是错的，是具有片面性的，是可以重新解释的。 观点三：反对意见 Pierre ​ 不要自学，因为关于快速阅读的训练基本都是骗人的；你的阅读速度取决于 1) 大脑的理解速度； 2) 你的专注程度 ​ 前者基本由你对文字和概念的处理速度决定，可以通过多阅读和多了解阅读材料的相关知识来提到；后者可通过手指或笔 指引自己阅读来避免走神； ​ 如何做到看英文不用在内心读出来？ 关于默读的形成机制和深层原理直到现在都还有争论，总的来说，它是人类大脑在阅读文字时的自然过程，学术界对默读一般有以下三种认识： 对看到的文字进行语音化处理（phonological coding，即默读）是在阅读行为最开始就会发生的，很有可能是在大脑获取单词含义这一过程中产生。 默读是「大脑用来理解词汇」或者「理解词汇之后增强短期记忆、帮助理解、还原音韵和语调」的。这个或者代表学术界对此还有争议。 默读是阅读过程的副产品，在高水平的阅读者中，默读是普遍存在的。 一个有意思的知识：天生的聋哑人在阅读时也会进行默读这一过程。 目前为止，还没发现有哪篇论文含有「默读会降低阅读速度」这一结果的。 正常人英语母语阅读速度为每分钟 200~400 单词（对内容完全理解的前提下），而速读布道者则宣称可以通过消除默读的方式来通过视读（visual reading）来达到 700 单词每分钟以上的阅读速度。 总的来说，教授得出了结论：所谓速读，不过是略读（skimming）罢了。略读谁都会，略得越多，读得越快，懂得越少罢了。 200~400 单词每分钟是充分理解全文的正常阅读速度。高于这个速度是完全可以做到的，只不过需要通过牺牲阅读效果 / 质量来达成罢了：读得越快，所能够理解的部分就越少。脱离对材料的实际理解程度（阅读效果）来一味追求阅读速度没有意义。 【总结】 默读是正常现象，且不存在任何科学研究来表明，默认会降低阅读速度； 所谓速读，不过是略读；略读越多，读得越快，但懂得也越少 通过 手指或笔 指引来避免走神，只是帮助那些原本阅读速度低下的人回到正常水平； 1460 看到有的人说，第一步要抑制脑中发音。这是完全错误的。说这话的人，严重怀疑他没练过！！！千万不要主动抑制发音！！！重要的事，说一遍！！！否则将完成严重的后果！！！ 观点四：对于快速阅读的理解 Rainbow清浅 快速阅读的概念应该分为2种： 一种是阅读速度（理解速度），即每分钟阅读多少字 另一种是通过科学的方法用较少的时间掌握书中大部分的重点。 关于文字的阅读速度本质上是理解速度的问题，这取决于阅读对象的难易、逻辑结构、语言、对这类内容的认知度等。有很多快速阅读文字的训练方法，比如抑制默读则阅读记忆速度会更快、眼球跟着一个物体移动、甚至于说将文字像拍照一样摄入大脑，颇受人追捧，但是我之前看过不少分析这些方法并不科学的文章，深以为然。 要提升文字阅读速度还是要多看多练，自然就会提升了，无捷径。 不用轻信一些快速阅读的方法，要有自己的判断是否科学； 个人是采用SQ3R阅读法，用较少的时间理解一本书中60%-80%的内容。这个方法也不是适用所有书籍的，像散文之类的还是仔细品味吧，这个快速阅读法比较适用于商业类、个人提升类的书籍。 01 | 纵览全局 书名和副标题、目录、作者介绍、推荐、自序，第一页和最后一页，先快速看一遍这些内容，对整本书的结构内容、作者精通的领域、整本书最大的特色和价值所在有个直观的了解。 之后拿一张纸写下问题，比如通过这本书来解答什么疑惑，书中的知识能解决什么问题等，带着问题找答案总是会更容易集中精神。 通过纵览全局，确定几个问题；例如作者写作的背景、作者关注的问题，等（这些问题后续总结） 02 | 关键点扫读 浏览粗体字、段落开头、段落结尾，并将重点内容标记出来。 03 | 建立框架 完成关键点扫读后将还能记得的内容建成一个框架（我是手绘逻辑图的，觉得顺手的方法就好），这时候会有很多东西不记得，没关系，这是很正常的情况，将记得的内容梳理完后，再通过快速浏览一遍关键点将框架补全即可。 04 | 重新阅读 采用何种方式，阅读哪些内容，我一般根据时间和目的来决定的。 比如说，我在做关于定位概念的主题阅读，那我在建立出框架后，就只阅读关于定位的内容，其余都忽略，留待之后有需求的时候再阅读。 如果我是想完整地阅读这本书，那我会从关键点中挑选我不明白和感兴趣的内容来精读，其余的则扫读带过。 不管采用何种方式，重点都需要标记出来。 05 | 回忆&amp;记录 在阅读完一个关键点或者章节后，用自己的语言将关键信息填充到框架中。填充完成后再回顾一下标注的重点，查漏补缺。方法根据自己的习惯，思维导图、手写、手绘、大纲都可以。 06 | 回顾 在完善框架之后，其实一份读书笔记就已经完成了，之后隔一段时间把读书笔记拿出来温故一下，有利于记忆及运用。 ————————–分割线——————————– sting 很多人在说，干嘛要快速阅读？应该找一本好书精读。 我的理解，快速阅读就是根据自己的需要来找信息和读书的一个策略。为了从海量的知识库中能够迅速找到自己想要的知识，我们往往使用搜索引擎找文章。 在此过程中，找到值得精读和练习的书，还是需要精读。 对于快速阅读，他的理解也是为了快速定位所需的内容，而不是增加阅读速度；是基于一定目的的阅读； 正确的速读方法：眼睛每一次停顿时，尽量同时多看几个字。不要逐字阅读，不要回读，不要复读。 初期训练时候，可以用手指指示，实验表明，跟着手指运动，眼睛更加放松、更加高效。 大脑中一定要有目的性，这样才能快速扫描和迅速记忆。 观点五：不同的阅读速度我把读书分为悟读、精读和泛读。 所谓悟读，就是认真领悟，一句一句认真理解和阅读，最后甚至通过反复阅读背诵出来。这样阅读的范围一定是顶级经典著作，是对人类文明和智慧带来重大价值的著作。 今天我们已经不一定非要把四书五经都背出来，但像《论语》《中庸》《孟子》这样的内容依然值得深度理解，并把极好的内容背下来。这一类著作有很多，像《老子》《庄子》《孙子兵法》，以及一些宗教经典，都可以列入这类。读这样的书，一天只要读一段就行，要反复咀嚼反复朗读，直到有所领悟方可罢休。拿起这样的书，先必须凝神屏息，心态保持宁静，不能有杂念和烦恼留在心里。 所谓精读，就是碰到你特别喜爱的书，在文笔上、知识上、思想上、高度上都有启示的图书，就可以多读几遍。 比如我把马尔克斯的《百年孤独》读了四到五遍，书中魔幻现实主义的描写、文笔的流畅、人物命运的描述，都让我有爱不释手的感觉。阿来的《尘埃落定》我也读了三遍，文笔铺陈上和《百年孤独》有类似的手法。岳南的《南渡北归》厚厚三本书百万字，我也阅读了两遍，对于一代知识分子的命运总是心有戚戚然，久久不能释怀，拿起了放下，放下了再拿起来。一个人一生，总应该有十本左右的书是反复阅读的，通过深度阅读，提升自己的情感度和智慧度。在我前面一个月介绍的几十本书里，《通向常识之路》就是值得大家读第二遍的书。 所谓泛读，就是泛泛阅读。我认为世界上大部分的书，泛泛阅读就可以了，主要是为了增加自己知识的广度和思维的宽度。 我拿到一本新书，一般都会先随意从中抽取几页阅读，如果读出点感觉，就会从头往后顺序翻阅，凡是觉得罗嗦不值得花时间的地方，眼睛就扫过去，凡是需要认真阅读的段落，就放慢速度仔细阅读。有的时候读到好的地方，也会用笔做标志，这样读完了可以把重点再读一遍。这样的阅读，我的速度大概每分钟一页左右，一半300页左右的书4个小时左右读完。这次读书活动我为大家介绍的书，大部分都在泛读之列。这也是为什么我能够每天给大家介绍一本书的原因。但泛泛阅读也不是读过就算，书中如果有给你灵感和思考的地方，依然要重点标注出来，或者扫描存档，以备以后学习和引用。 根据不同的内容，进行选择；凡是觉得不重要的地方直接扫过去就行；凡是需要认真阅读的段落，就一定要放慢速度仔细阅读。 观点六：读书目的一、要确定读书的目的，根据读书目的的不同要有不同的方法。 曾看过一篇网上的文章，说林志颖带Kimi参加法国图书节最终被劝退。为什么呢？不是因为Kimi不认真，而是因为他太认真了。认真到废寝忘食专注读书，读得还很快，难道这不好吗？是的，组委会认为一点都不好，他们认为这种一心只为得奖的做法有违读书节的初衷。读书是为了让自己沉浸于书中的世界充分享受读书的乐趣，而不是为了任何别的功利的目的。 但如果我们读的是商务类书籍，那么请一定带着目的去阅读。因为如果你读书是有目的的，你告诉自己的大脑要练习什么，寻找什么，那么在读书的时候你会更快地找到答案，从而使读书显得更高效。 二、阅读一本书不必头读到尾。 当我们第一次去一个陌生的很大的地方，比如公园，我们要做的第一件事是什么？对，找地图，地图能指引我们找到目标。同理，去一个新公司上任，首要的就是了解这个公司的组织架构，这一定是一个最好的开始。 有启发的对比与比喻；找地图是自己的习惯，但对于读书，却没有，需要反思； 读书，也是如此。一本书的序言、目录、后记有助于我们最快地掌握全文概要，这样我们可以在有限地时间里抓住书的重点，在有限的生命里多读几本书。因为受各种因素的影响，就像二八定律所说，一本书中的重要内容不会超过20% 三、一定要想办法将书弄脏。 建议用各种方式，如划线、记号、括号、折页、便利贴等自己独特的方式做标记来打造一个自己专属的书籍。这样的方式有助于我们对书的理解和记忆，是一笔很大的财富。 五、一年读多少本书不是关键，重要地是学以致用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《人生定位》读书笔记_杰克.特劳特]]></title>
      <url>%2F2018%2F07%2F01%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F10_%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%2F%E3%80%8A%E4%BA%BA%E7%94%9F%E5%AE%9A%E4%BD%8D%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%9D%B0%E5%85%8B.%E7%89%B9%E5%8A%B3%E7%89%B9%2F</url>
      <content type="text"><![CDATA[《人生定位》 - [美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 AI Ries &amp; Jack Trout | 2011.09 01 【初始疑问与目的】 S：近期比较焦虑，于是在知乎上翻看 “ 为什么越努力，越焦虑 “ 的讨论；其中看到一个观点说的是，&lt; 个人努力只是成功很小的一个要素，更大的成分在于外界 &gt;；并且提到了一本书《人生定位》；于是乎，就买了阅读； W：真正去理解 &lt; 个人努力只是成功很小的一个要素，更大的成分在于外界 &gt; 这样的一个观点；做独立判断后，尝试改变自己的固有思维；把眼界向外看，而不是像之前一样一直向内看； 02 【作者关注的问题】 what：如何借助外力取得成功。不要一味地把重心放在自己的身上。 03 【文章展开的方式】 文章脉络如何展开：通过表达个人努力并不那么重要，引入外界因素的重要性，并进而引出几种不同风险的外界因素进行阐述。风险的高低，根据依赖自身的程度进行区分；越是依赖自身，风险就越高。 作者的原文回答：成功根本不是某种你能自发产生的结果，成功的关键是你能从别人那里获得什么。想要获得巨大的成功，你必须找到一匹可以驾驭的好马。 其他人的观点： 作为读者，你怎么看： 04 【对我的指导意义与行动】 对我生活与工作的指导意义： 更加客观、全面地看待自己的努力所带来的成果，以及会更加注意外界的因素； 观念的改变；不会说一定靠自己的能力去获取成功，而是更加全面、客观地看待所谓成功的这件事中其他因素的重要性。 对于今后孩子的教育，会让他明白倚靠他人是正常并且正确的行为，不要以此而感到羞愧 准备具体怎么去做： 05 【总结回顾】 回答自己的问题： 作者简介与著作背景： 一句话概括： 总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。 成功根本不是某种你能自发产生的结果，成功的关键是你能从别人那里获得什么。 引言与伏笔很多人认为努力工作、设定目标、相信自己才是成功之道。 因为那些外在的因素太复杂，也难以把握，是脱离自身的；也没有人喜欢会说自己成功是因为靠外界因素，但可能真相恰恰如此。 不要只盯着自己，你要看着外面。找到一匹好马，你的人生将会精彩纷呈。 我要做自己。” 我想去闯一闯，我要向自己证明，向外界证明，我可以成为一个大人物。我不要老爸的钱，也不需要他的贷款。 “ 这很正常，你每天都会听到有人这么说，尤其是孩子和青少年。有些人永远长不大，他们力争获取外在的成功，总想以此来证明自己的聪明与能干。 现状：中国青少年也是如此，包括年轻人。突然觉得我们只是 &lt; 过度强化 &gt; 了自身的力量。 原因：1) 可能也是由于外界的因素本身不可控，2) 其次没有人喜欢把成功归因于外界。 人在本应借助外力的时候，却要自己做。但是只靠自己是不可能获得成功的，是其他人使你成功。 如果你能把成功看做别人为你所做的事，而不是你为自己所做的事，你就不太可能陷入追逐成功的不安之中。 【态度】 三种不同风险的赛马高风险赛马 成功完全依靠自己。 努力型赛马 | 100：1最大的高风险赛马就是 &lt; 你自己 &gt; 成功人士往往努力工作，但并不等于说努力工作的人就能获得成功。 时刻记住，努力工作只是一个选项而已。 智商型赛马 | 75：1智商与成功并无太大的关联。越聪明的人，越会依靠自己。 教育型赛马 | 60：1记住，教育的作用只是让你进入比赛。凭学历不大可能让你的马跑得更快；[ 并不是说学历没有帮助 ] 企业型赛马 | 50：1著名的大企业是你职业生涯非常好的起点，只要它是一家合适的大企业。 不要问你能为企业做什么，要为企业能为你做什么。 不管你多么聪明，把注压在一个输家身上是永远得不到回报的；如果有人竭力推荐你加盟一个输家，那么一定要给你实权职务，而且公司董事会要做出明确的变革来进行变革。（输家，指的是那些发展并不良好的企业） 那些最后在大企业工作的人发现，通往事业巅峰的道路很辛苦。有一个叫做 “99%法则”，即 因为拥有合适的品质，看上去也很杰出，而受雇的100人中，只有10个人能够升至中间管理层的职位，只有1个人能达到主管的层次； 残酷的现实是，对于成功来说，能力不是最重要的因素。企业并不是理性实体，不会为个人的最佳发展提供无尽的帮助。企业是那些试图超过他们竞争对手的各类人的组合。 【思考】所以，不要 只 关注能力的提升；另外，让企业匹配你的发展阶段，而不是你去匹配企业；在这之前，必须要明白自己的道路以及所处的阶段； 骑上企业型赛马的最佳时机是要趁早，而最好的企业型赛马就是领先行业里的领先企业；我们要去识别，尤其是对于下一个领先的行业。那下一个领先的行业是什么呢？在事实没有出现之前，没有人知道。这使得驾驭企业型赛马成为一场赌博。 为了增加你个人成功的概率，需要做的是从潜在企业清单上划掉那些绝对不是领先行业的候选机构。 【共鸣】芒格的 反过来思考：想要成功，要首先知道哪些是不该做的事。 大企业里，你不能太直率，你必须委婉、间接。你必须学会当一个政治家。你不能依靠自己的努力达到企业的高层，你必须依靠提拔。 谁来提拔你？别人。 这就是你想要在大企业有所成就就必须成为一个政治家的原因。把工作做好只是第一步，你必须找到一种方法，让别人知道你能够把工作做好。你的工作技能没有你的政治技能重要。 对于 &lt; 你的工作技能没有你的政治技能重要 &gt; 赞同一半；正常情况下，赞同一半； 但仔细思考，想的确如此；那些领导人并不一定是最能有能力的；一开始不赞同，只是不愿意接受这样的事实。、 导师与保人；导师通常年纪比你大，对你的事业有着个人的兴趣，给你提供免费的建议；保人比导师更近一步，保人会提拔你，或者至少会利用他的影响力影响那些可以提拔你的人。 如果你在一家大企业工作，要问自己最重要的问题，不是” 我做得怎么样 “， 而是 “ 我的保人是谁 “ ;没有保人，你将停滞不前； 很多企业都有保密的 “ 高潜力 “ 员工名单。你在这名单里面吗，尽可能证实它。如果你不在这个名单上，那你需要继续跳槽； 但有个悖论是，可能在一段时间之后，你才能成为 “ 高潜力 “ 名单中的人；所以，需要的是了解这个时间的周期，然后给自己一个时限 所以，有两个选择 1) 进入” 高潜力 “名单 2) 离开该企业 企业的规模越大，缺乏合作精神的员工越可能在远没有达到高层之前就被清理出局。当你在一个大企业工作时，你必须不断展示你的忠诚，而不是你的才智。 到了一定时间，企业更钟爱忠诚的员工，其次才会才智 认清现实与事实 “ 是什么 “，而不是 “ 应该是什么样子 “ 【做一个耀眼的人】如果想觉得进步，就必须找到一种方法把自己展现给高级管理者；个人关系是你努力攀登企业阶梯的关键。 加入你在通用电气工作了20年，韦尔奇本人并不认识你，那在该企业工作的你将不会有前景你的老板知道你，你的老板的老板也很可能知道那你。但是你职位之上的第三人呢？你怎么才能引起这个人的注意？ 【行动】你可以不用特意去做这些事，但至少你要有这个意识；也认同这样的观念，接受这样的事实。 【做一名英雄】 最简单、最直接的方法是让自己与你的企业推出的最耀眼、最激动人心的新产品或新服务联系在一起。 如果你获得了一个大露脸的机会，谨慎的开始这个工作，摸索两三个月，直到站稳脚跟。这种方法是错误的。确保尽快采取强硬、大胆的行动才是正确的。在开始的100天内，你是 “ 防弹型 “ 。确保自己用正确的方法做正确的事情，特别是一些令人讨厌的事情 (例如关闭一家工厂、停产一系列产品或解雇员工) 给你委派工作的人在前两三个月里是不会解雇你的。这样的话，会给那个人带来不利影响。你可以自由行动，要了利用这点。 不要接受首席执行官视线之外的任何工作，这种任务都是死路一条。（例如，海外职务） 关键是你是否想在这个企业长久地担任下去；若不是，这种经历对于以后的工作或许也不错。 当企业经营良好的时候，常常回从内部提拔人才，这个就是那些政治家或英雄接手的时候；但当经营不善时，内部人士是没有机会的，这时候需要新鲜血液。 中风险赛马 成功部分依靠自己奋斗，部分借助外力； 才华型赛马 | 25：1想要成为创意达人，你需要的不仅仅是才华，还需要人们的认可。 （后者才是真正的关键部分；那如何获取人们的认可呢？） 创造性人才必须学会如何聆听观众的心声。观众希望他们怎样，他们就得去适应，而不是让观众来适应你。失败的人通常只关注自身内部的因素，他们不会倾听。 他们想当然地认为 “ 才华会得到施展 “，那那种才能给你的不过是一张彩票而已。才华型赛马要获得成功，几乎比其他任何类型的赛马都更需要外界的认可。 你的问题的实质是外界的认可。 无论你是作家、画家、歌手、演员等角色，你都要把大部分时间用来寻找能够证明你创造力的外部专家。 全新的一个视角与概念； 【共鸣】想起之前看过的内容：畅销书的作家，并不一定是写文章做好的作家，但一定是懂得包装与倾听市场的作家； 如果你只想做一个有才华的人，那就像 梵.高 那样，自顾自地把全部时间都用在你的艺术创作上；如果你想拥有才华并取得成功，那就需要花一点时间用于艺术创作，再花一点时间向他人推销自己。 自我膨胀十有八九会成为你成功路上的绊脚石。人们都希望别人认可自己的创造力而不是推销能力。不妨问问自己，这真的有那么重要吗？ 思维：关注结果；明白你真正想要的是什么。 产品的外包装与产品一样重要，有时还比产品本身更重要。 爱好型赛马 | 20：1只有单纯地将其视作爱好而不是成功的方法。很明显，当你关注外在目标时，你的动机就不一样了。 地利型赛马 | 15：1环境的选择。 宣传型赛马 | 10：190%的人都不会独立思考，所以你完全可以骑着宣传型赛马一路登顶。 如果你打算骑上宣传型赛马，首先要给自己一个称号或主意。你必须下决心丢下各种资料，这样才能将焦点集中在一个主意或概念上。 低风险赛马 成功完全取决于外力。 产品型赛马 | 5：1认可他人的天赋几乎总是让人获得成功的关键。 发现好的产品，关键是认可对方的产品/天赋；做一个能够识别机会的人。 发明者 VS. 识别者 迄今发明的最成功的产品都没有给发明者带来足够的利益，但却让识别者发了大财。 你是否具有创新能力并没有那重要。即使你没有什么创新的天分，也同样可以跨上产品型赛马。关键在于你判别他人天分的能力。 很多发明都是巧合，它们很大程度上取决于你是否能从发生的事情中领悟到什么。 【警惕市场调研】 因为调研是基于过去&amp;现在的认知与经验，而新的产品是未来的。 要留心，重要的产品创意的检验结果通常不会很好。有过一次调研，说到2000年计算机的应用数量只有1000台。那为什么要发明一种市场潜在规模如此之小的产品呢？ 别小看了形象的重要性。等你有了钱，你或许仍然会为了声誉而工作。 简单概念好于复杂概念。 【学会说：就这样了】 有一个常态：通常人们在看到一个创意时，会说” 这个尝试很不；我来提几点建议吧 “ ；其实他们是在说，在跳上这匹马之前，先让我看看能否介入这个产品；这是个错误。当你找到一匹出色的产品型赛马时，先别急着让自己介入，把别人逼走。何不干脆先跳上去。为什么不说，” 就这样了，我们去骑一圈吧 “ 你要改变的一切原因在于你试图让自己介入那个产品。忘记自己，要仅仅根据那是不是一匹骏马来评估产品。 【如果找不到产品，那就找出问题来】愤怒这一因素的占比越大，就越有可能带来某种可以赚钱的产品创意。不要抵御这种感觉，要让愤怒因素带领你走向解决自身问题的道路。 【你永远不会太年轻】要认识到，机遇永远比努力更稀缺。 若有机遇来临，不要说自己还没准备好；去尝试抓住他，因为努力这件事可以从这一刻开始，若失去了机遇，那是无法挽回的。 【你永远不会太老】怀着一颗开放的心态看待生活，你就永远不会太老。 【媒体炒作】你要明白媒体大肆宣传的并不是新产品的潜力，而是宣传者的声望。 （通用公司推出Saturn汽车被媒体大肆报道，仅仅只是因为是通用公司推出的） 创意型赛马 | 4：1你必须愿意面可笑的、有争议的创意，你也必须乐意逆潮流而行。 没有证据表明，人们普遍持有的观点就是正确的。 如果你无法把一个创意推销给自己，那么你就不大可能把它推销给其他人。并且，如果你不愿意把一生中大部分时间和资源用在这个想法上，那么其他人不大可能这么做。你不能用业余时间来骑创意型赛马。 如果有一个好的创意来解决某个问题的一半，而不是思考一个周全的创意来解决整个问题，那么你的境况会好很多。 千万不要把你的想法往你的上司桌上一丢，然后让他来决定是否实施。那样的话，就等于放弃了你的所有权。 你要对这个想法做出承诺，不管以哪种形式（备忘录、演示、非公开的会议），重要的是让企业管理层知道你才是这个想法的提出者。若遇到反对意见，要表现得友好，要感谢他们的帮助，并且请他们以书面形式提交反对意见。（这一做法通常会阻止掉那些更加愚蠢的反对意见）如有一些与你没有竞争关系的伙伴赞同你的想法，要确保他们提供相关的证明，让他们给个人给你写一份备忘录。 他人型赛马 | 3：1成功的关键总是依靠他人。即使你驾驭着一个可以让你走向巅峰的创意或产品，还是要依靠他人识别该创意或该产品的价值。 你个人不能完成销售，要靠他人来购买。 你应该更多地审度你为之工作的那个人，而不是你为之共的那家公司。 他是否有前途？如果没有，那么谁有？要始终尝试为你所能找到最聪明的、最有能力的人工作。如果你的老板前途光明，那么很可能你也一样。无论你相信与否，有些人喜欢为无能之人工作。原因是他们觉得，如果老板是个庸才的话，那他们就能鹤立鸡群，更能脱颖而出。但实际情况恰恰相反，高级管理层往往会认为整个团队都能力欠缺。 如果他们对某项工作有所不满，他们会把相关的每个人都剔除出局。 当你为一家大企业工作时，引起他人注意就意味着你已经成功了一半。 伙伴型赛马 | 5：2配偶型赛马 | 2：1“ 我想做自己 “ 几乎是年轻一族的箴言（当你老一些的时候，你会意识自己可能错过了一个重要的机遇） 不要让你的自我意识阻碍了你。 要记住，每个人都需要一匹马。 家族型赛马 | 3：2只要对情况稍加分析，就不难看出能力之间的差异远小于所取得的成就方面的差异。 从实际情况来看，看不出家族出身的管理者和非家族出身的管理者之间在能力上有什么差异。 【认知】对于成功来说，能力的差异可能是最微不足道的；虽然很让人寒心，但现实可能就是如此。 然后，大多数的豪门子弟都希望凭借自己的能力开创一番天地，也许是处于自负心理，也许是因为公平意识。你需要知道的是，” 没有哪个人是独自一人取得成功的，每个人都需要一匹坐骑。 “ 反正你永远也不可能理直气壮地说，所有的一切都是单凭我自己完成的。所以不妨骑上那匹坐骑。真正的悲剧不在于孩子没有这种意识，而在于父母缺乏这种意识。 如果你是父母，请不要在家族企业里仅给孩子一个底层工作，而是要鼓励他们，理解他们。 我想凭借自己的能力取得成功，而不是仅凭老板的儿子这一身份 ，这是一种健康的心理态度。但你要知道，没有人可以单凭自己取得成功。 家族型赛马能帮你占据一个良好的起点，而良好的起点至少是成功的一半。 更换赛马事实上，人人都安于现状。当然，每个人也都希望境况能更好一些，赚的钱更多一些，买更好的房子。我们都希望人生的曲线能够 &lt; 平稳地 &gt; 按照我的期望向上延伸。 但是 &lt; 变化 &gt;（而且常常是意外的变化） 才是人生取得极大成功的必要条件。 如果你稍有野心，那还不够。大多数人不曾接近过自己的真实潜力，这并不是因为努力不够，有时候甚至不是因为没有能力找到一匹坐骑，而是因为他们害怕变化。还是那句话，如果你总是做过去一直在做的事情，那么你就只能得到你惯常所得到的的东西。 导致人们不肯更换坐骑的主要原因在于对未知事物的恐惧。人们抓住原有的不放，在于他们不能很好地应对新的尝试中所包含的不确定性。【但是，必须明白，你目前正在做的事，并没有给你带来想要的生活】 【共鸣】《The Millionair Fastlane》 中提到停止你现在正在做的事情，因为它们并没有给那你带来成功。可能是时间不够，但更可能是这并不是正确的行为。 当你拥有工作的时候，你会停止搜索。你会专心于自己的职位、企业和晋升机会。你此时的策略是努力工作，这样也许他们会注意到。但你也就成了一匹被蒙上双眼的马，一门心思放在赢得比赛上。有些人在同样的赛道上奔跑了二十年，但成就甚微。那么他们会怎么做呢？他们会更努力。我们称之为 “ 掉队心理 “。 努力工作蒙蔽了你的头脑，它使你一直重复过去的老路。 你可以变换策略，更改坐骑。但最难的一点往往在做出更换坐骑这个决定，而找到另一匹赛马反倒并不会很困难。 When：何时更换？ 当你原来的工作不再充满乐趣的时候，你就应该寻找另一份工作。 你应该远在你的工作给你造成困扰之前，就应该抬腿走人。因为如果在目前境况还算乐观的时候这么做，那你就处于主动而非被动的地位。 问自己，” 从现在起，我打算在这家公司干5年吗？ “ 如果答案是，” 绝对如此 “，那么你已经找到自己的坐骑了，你应该全力以赴骑上它。但如果不是，你就应该着手去寻找另一匹坐骑。慢慢弄来，不要仓促行事。你现在的工作尚有乐趣可言，所以你还有一段缓冲时间，可以慢慢选择，而不是饥不择食地接受第一个上门的机会。 然后，你要记住，你要的不是一份工作，而是一匹赛马，这两者之间很很大的不同。工作指的是一份职责、薪水、福利等相关的职位，而赛马指的是一种创意、产品或某个人。当你接受某个工作岗位时，你就等于置自己于流水线之上，要求自己提供具体的服务。当你骑上一匹赛马时，你等于是要与自身之外的某人或某事共命运。 你最终所做的事可能与你最初的期待完全不同。 当一个新兴行业兴起之时，大多数人都唯恐不及，因为他们在这个行业里毫无经验。但是不要忘了，其他人也一样。 在某人决定不把某份你想要的工作给你之后，如果你在旁边等待，你就给了他们再次拒绝你的机会。 第二幕今天就是今天，今日的机遇不会出现在昨日的成功之中； 无论你多么聪明机智，你也不可能缔造成功，你只能寻找成功。 【思考】如果你真正明白努力只是成功中微不足道的一个因素，那你就不会大胆到说要去再次创造成功。 在首次成功的这片土壤上，唯一生长出来的是你个人的自大意识。 自负是一切 “ 第二幕 “ 公司灾难的根源。你也许必须向自己证明你确实能再次成功，但必须在向其他人证明。因为你曾经做到过一次，就已经证明了你的实力。 借口，还是借口事情的真相是，外面是一个广阔世界，而就机遇而言，它总会越来越大。 智力往往使人们把注意力集中在自己以及自己的世界观上。智力超群的人往往会对整个世界抱有不切实际的幻想 当你发现那匹可以带你到达顶峰的赛马时，不要犹豫。放弃你正在做的一切，因为你可能在也没有这样的机会了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The Millionaire Fastlane]]></title>
      <url>%2F2018%2F06%2F30%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%2F%E3%80%8AThe%20Millionaire%20Fastlane%E3%80%8B%2F%E3%80%8AThe%20Millionaire%20Fastlane%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_MJ.DeMarco%2F</url>
      <content type="text"><![CDATA[《The Millionaire Fastlane》 - MJ.Demacro S：目前正在焦虑，对于未来。此时需要重新思考，如何才能致富；所有，重新来回顾这篇文章； W：力图改变一些自己的思维定势，然后列出一些具体的行为清单，去执行； 用一句话概括 启发 ##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精进》读书笔记_采铜]]></title>
      <url>%2F2018%2F05%2F19%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A%E7%B2%BE%E8%BF%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%87%87%E9%93%9C%2F</url>
      <content type="text"><![CDATA[《精进》_采铜 S：2018年初专研&lt; 精要主义 &gt;时一起购买的书籍 哪些有意义的启发 时间之尺 对待时间：收益半衰期 + 快工作慢生活； 一个人如何对待时间：茫然 VS. 焦虑 ； 过去 VS. 未来 利用图形将这个概念画出来：用矩阵 、 用象限 去描述； 认真对待对方；当你的孩子/朋友用真诚或严肃的态度向你提问时，无论该问题是否幼稚（该问题越是幼稚，你越应该打精神，由其是面对孩子的很多”幼稚”的问题时）；这个时候，放下你的轻浮。认真去对待； 孩子：尊重 向五年后的自己提问；解决远期、近期的冲突 远期未来的视角：倾向于抽象、概括的方式去思考；所以，远期视角下的想法更多的是考虑这件事的价值和意义，而常常缺乏细节； 近期未来的视角：倾向于到具体的情景中去考虑；而同时人们倾向于做可行性高、容易实现的事情； 【启发】当你想要不做一件事时，尽量提高完成它的难度，主动增加障碍；反之，若想要去改变一件事/完成一件事，就尽量排除触发的障碍； 比如删除电脑里所有的电影、游戏；剪断网线，把手机换成非智能机等；可能有的人会说，电影删了可以再下，等等；这个而方法有用吗？ 有用 。因为虽然可能会反复出现，但这种反复会使得原来简单且惯常的行为变得更麻烦了，逃避的便利性减少了； 【新观点】收益半衰期 （用矩阵、坐标轴来描述与记忆）[ 如同：真理都是简单的 ] 收益值：这件事 当下 带给我的收益大小，可以是物质，也可以是精神层面的 半衰期：这昂收益岁时间衰减的速度； 我们常常只关注到一件事情在发生时带给我们的即刻的好处，而忽略了这一好处是否可以持续下去，产生长期的效果；只要不是短半衰期的事情，只要这个收益可以被累加，尽管去做；很多时间，我们难以选择，往往是并没有全面考虑的结果； 【行动】可以用该概念来衡量一件事情 时间管理，很多时候并没有真正解决问题；我们原本就因为快而痛苦，可时间管理却教我们如何更快；（想起《80/20法则》or《每周工作4小时》中提到，“我们不是时间不够用，而是对待时间的方式错了；” ） 我们无法预估未来发生的意外事件，而意外事件却恰恰频繁发生，扰乱人们的原定计划；但你必须意识到，我们所处的社会是”液态的”，是一个流动的世界，在这个世界里，一切都处于不确定性中；当一个原本预定的计划并没有完成时，我们往往会陷入自责之中；其实，更令人担心的是陷入这种自责之中无法自拔； 工作要快，但生活要慢 尽可能慢的事情：与朋友共度闲暇时光、欣赏作品、自我反思（写总结时，往往太过仓促）、散步，不要方向、在完全安静的环境看一本书、 尽可能快的事情：完成常规的事务性工作 【共鸣】曾在其他书籍中也看到过这样的观点； 回想自己经常去外滩吹风发呆，其实就是一种慢生活的体验； 提升时间的使用深度；（同样是安排休闲时间，坐在电视机前来电视的&lt; 被动式休闲 &gt;所带给人的满足感，远不如从事一项自己喜欢的业务爱好所带来的满足感；所以，从闲暇中获得满足的程度取决于质量，而不是时间；） 寻找心中的“巴拿马” 做出更好的选择：从终极目标出发：以人生最高目标作为第一原则； 从终极目标出发：以人生最高目标作为第一原则； 【思考】你想要成为一个什么样的人，这是你必须想清楚的问题；人生中到底想要什么，追求什么。 做一个多维度的人，科学&amp;文学；（但显然，自己对文学著作不感兴趣） 隐含假设：[ 很多人痛苦不堪，可能就是因为陷在了他们置身认知范围内的某种假设；在你分析事物（自身或他人）时，试着问自己，对应这个情景它的隐含假设是什么，很可能就会豁然开朗。 ] 错误、狭隘的隐含假设往往会缩小你的备选；我们往往在做选择/做计划的时候，往往是站在当下，（潜意识中）某种假设的前提下进行的，但我们并没有觉察到。 【启发】对于隐含假设，是一个新的概念； 【行动】 分析时，试着去找你的隐含假设； 请求他人/第三方的建议，往往能给出不同范围的选择（因为第三方的角度、经历与经验，与你完全是不同的，包括他的成长背景，所有必然会给你带来新的视角） 目标悬置。斯坦福大学在2015年10月宣布开启了一项学制改革，将传统的集中在18-22岁区间的连续四年制改为终身多次进出学校的六年制学习。称之为 “开环大学”。 【思考】这样的方式，让你接触新的东西后，在回来；视角、态度会完全不一样。 人生是持续而反复的构造。 涉及情感、喜好等主观性特别强的选择时，最好的方法是聆听内心的声音。 即可行动 最有效的，是即可行动。 开始并完成一件事，比做好它更重要。因为只有开始了，才有机会把它做得更好。 “精益创业” 中提到 “最小化可行性产品”，指的是使用最少的资源、被最快制作出来的、可执行基本功能的、能被用户使用的试验性产品，创业者应该尽快把最小化可行性产品发布出去，然后根据用户使用它的反馈来进行优化。 【唤起】想起之前的文章提过的概念，这一方式最重要的是 &lt; 将其置于真实场景 &gt; 中； 一个人的 “最小可行性产品” 是什么？ 产品不是过程，而是结果 产品不是对原料、素材的简单堆积，而是对它们结构性的整合和组织 产品不是创造者锁在自己保险箱里的东西，而是能被其他人使用和体验的 产品能独立对世界产品影响 产品也是一种媒介 ​ 比如在某家公司的工作经历不是产品，但基于工作经历写成的系统性总结报告可以算作产品；阅读一本书的经历不是产品，但对一本书深入、透彻分析的文章可以算作产品；拥有绘画技能不是产品，但使用这项技能创作的绘画作品可以算是产品； 我们永远无法完全准备好。 事情一步一步来，不要总想着一步到位；包括工作、成家、旅行等 提前对要完成的任务进行有效的剖析，区分出 &lt; 容忍中断 &gt; 与 &lt; 无法容忍中断 &gt; 的部分，然后用可保证的相对完整的时间去进行那些 &lt; 无法容忍中断 &gt; 的部分；因为对于一些操作性的事情时，你并不会太介意被打断。 （例如，你在寻找配图或调整字体时） 对不同认知类型的工作分层处理；即不要在不同认知类型的事情上来回切换。因为当在不同类型进行切换时，人需要重新进行调整，这样任务的转换损耗会比较大。例如在本书的写作中，很多章节是配图的，如果按照一般顺序的写作手法，在写到需要用配图的地方，把文字停下来着手寻找配图，这样的方式其实是很损耗精力的。 同时，集中处理同性质的工作。 怎样的学习，才能够直面现实 - Key 成为一个高段位的学习者 只有最后能够作用于现实的学习，才是唯一有效的学习。 找到一切学习的导向 对问题的好奇、对答案的渴望，是驱动自我学习和探索的主要动力。 学习，应该以学习者心中的问题为中心，让问题引导着我们去探求答案； 不经提问的学习，一直存在于生活当中： 订立计划；例如接下来两个星期看完《XXX》 实施学习；从头至尾观看一本书/一门课程，把其中认为重要的点摘取出来，并记成笔记 回顾和整理；对笔记进行整理，或者画一张思维导图，把书中的知识要点以整体的形式体现出来 ​ 做到以上三点已经是比较优秀的学习者，但是在这个过程中占据 &lt; 中心位置 &gt; 的是编织好的教程/课程，是既成的已有知识，而不是你心中的困惑——那些待解的难题。 ​ 以既成知识为核心的学习，学习者扮演的是 &lt; 吸纳者 &gt; 或 &lt; 搬运工 &gt; 的角色，他们把外部的知识经过消化后搬运到头脑内部，知识在传递过程中的精确性、完整性被认为是至关重要的，而学习者自身的心智，包括他原有的知识体系、方法、观点乃至困惑，却可以被搁置起来，不闻不问。 ​ 很多人没有思考过，”为什么要看这本书？” 因为大家都在推荐，因为它很热门，还是根本没有考虑过为什么，只是隐约觉得对自己有用？ 我在标注重点及记笔记的时候，是依据什么来判断哪些值得记、哪些不值得记？有没有有一个特定的标准还是只是凭借感觉？我在学完之后积累下来的知识，是不是还是不知道怎么用，而只是增加了一点点掌握知识的满足感？ 【反思】这也是自己的现状； 【行动】写下自己为什么看一本书/学习一门课，做一件是的触发场景，所要达到的目的，以及之后该有的可落实的行动（这一步很关键，能让你去反馈/检验 前面的整个过程，也能让你时刻牢记自己做这件事的原因与目的）。 打破新旧知识之前的通道；常思考的问题 针对当前的材料，已经具备了哪些相关的知识？ 针对当前的材料，学到了哪些新知识？这些新知识对缘由知识构成了何种补充与挑战？ 针对当前的材料，还有哪些是未知的，并且通过简单探索就可以了解的？ 针对当前的材料，哪些是未知的，且无法轻易获得，同时又有价值成为我长期去探索的问题？ 在没有问题引导时，可能我们常常只是零散的、随性地去涉猎学习材料，去捕获一些不相干的知识。这种学习结果是得到已按知识的砂砾。而在问题的牵引下的学习，则是连续地构筑着知识之网，使它们以一种有意义的方式连接在一起。 【共鸣】如同《地头力》中提到的，目标是一块磁铁，能够让你将力量往一个方向作用； 不只做信息的搬运工 通过解码，才能深入事物的深层。解码不等同于一般所说的理解。理解通常只涉及对字面意义的解读，常以自动化的方式进行，无需做太深入的思考，并且理解应遵从客体本身，不可擅自演化；而解码是一个更为主动和主观的过程，不同的解读对同一材料的解码可能是完全不一样的，就如果看一部电影不同的人看出不同的意味。 解码的基本规律（不同的人看待同一事物的角度是完全不同的） 在玩具店里看到 &quot;会说话的小黄鸭&quot;。 在孩子眼中，他关心的是 “小黄鸭说了什么”，于是他听到的是儿歌、故事。即孩子关心的是最直接的信息。 在家长眼中，他关心的是 “小黄鸭是什么”，首先会将其定义为一个玩具，然后对它的娱乐性、教育性、安全性进行评估；即家长关心的是价值和意义 在玩具工程师眼中，他关心的是 “小黄鸭是怎么做出来的”，他会思考和设计小黄鸭有哪些功能，会想它的电路结构和声光效果；即工程师关心的是结构和实现 不同的人，对于同一事物的关注点是完全不同的；而对于现在的我来说，要做的是不能只关注最直接的信息，而且要去关注背后的价值和意义。 关于解码的入口 不只要寻找结论，还要寻找过程；即我们不仅要知道结果是什么，还应该知道这个结果是如何得来的 不只要去做归纳，还要去做延伸； 不知要去比较相似，还要去比较不同 技能，才是学习的终点 你能够调用的知识有多少？ 基本的学习理念：你掌握了多少知识，并不取决于你记忆了多少知识，而是取决于你能调用多少知识。 认知心理学研究表明，记忆提取的操作起到了 “记忆修改器” 的作用：一个曾经被调用过的知识，和从未调用过的知识相比，在今后更有可能被调用。”构成学习者思维独特性的并非是他所录入的观点序列，而是他有能力启动和调用的关联。” 教育界中，发现以 &lt; 练习 &gt; 为主导的方法是有效性最高的。 因此，要做的是主动的知识点的回想与调起，而不是被动的去看之前记录的东西。 正如之前自己做过的 Anki 求知分为三个层级：信息、知识、技能 最差的学习者：接受信息 好一点的学习者：看重知识，以记忆为目标 更高层次的学习者：磨炼技能 技能是终点，信息与知识只是迈向这个终点的路与桥 分离的知识，难以解答真正的现实。因为显示是各种复杂的集合体。 修炼思维，向未知逼近 修炼思维 定期闭关，屏蔽外界干扰；说的是，每隔一段时间，给自己一个仪式，让自己去思考与回顾。 比尔盖茨每年都会抽出两个星期的时间闭关，也就是一个人呆在个地方，只看书和思考，不允许任何人去打扰他 培养简洁表达的能力。 “好的写作的秘诀就是剥离每一句话中的杂物，只存留其最洁净的部分。每一个无用之词、每一个动词中已经表示其相同意思的副词、每一个使读者不知道谁在干什么的被动语态结构 —— 这些都是削弱句子力度的掺杂物。” 一次只做一件事。 关于发散思维 和 收敛思维，重点在于它们两个是独立的阶段，而不应该把两者混在一起。 发散思考的时候不要收敛思考，反之同理； 图解思考。越是抽象的研究，图解思考所能发挥的作用可能越大。 文档创建不同的版本与副本是个好习惯 【行动】：之后更重要的是去回顾各个版本，去回顾自己的思考过程。 努力，是一种最需要学习的才能 不断优化你的&lt; 努力 &gt;方式；努力本身就是一冲才能，努力需要有效的策略 努力本身就是一种才能。在努力这件事情上，除了自我激励，更应该思考：到底应该怎么努力，应该采取什么样的策略来投入自己的时间和精力，应该怎样有效的启动、维持和优化对一件事情的投入。 对于努力，去思考，去做计划； 转变心智的方法：改变自己的语言习惯，把封闭的、绝对性的总结评价改为开放式的启发提问。 比如说，”我不擅长做这件事，” 改为 “要做成这件事，我还有哪些地方需要提高”； 不要说 “这件事我做不好”，而是说 “怎样才能把搞定” 发展自己的长项 对于 “木桶理论” 的误区：”木桶理论” 最早是用来类比团队管理的。对一个团队来说，决定其绩效的是组织中最弱的那个成员。因为团队中每个人都有自己的分工，这些分工构成了结构紧密的整体，所以一旦哪个环节出了问题会影响整个团队的表现。 但仔细思考，适用于团队的木桶理论正好推导出它并不适用于个人。因为如果一家公司笃信木桶理论，那么它就会要求所属的每一块木板就尽可能的长，而不会允许特别短的木板存在。也就是说，公司中的每个岗位都不容许能力平平的人，而是要求每个岗位都聘用能完全胜任的人。又由于现代社会分工的特点，大多数的岗位需要的技能一定是某一个领域的专长。（大企业如此，但对于小企业，可能未必） 很多人倾诉关于自己未来的职业迷茫，大部分并没有意识到**专注发展个人才能**的重要性。 【启发】对于事件的触发场景，很重要；对于一些观点、知识及理论更是如此。 通过与人合作来平衡自己的劣势，回避在很多不同方向上空耗精力。 让专业的人去做专业的事情；不同的领域，可以去尝试了解，但目标不是精通； T型人才，依然适用。 学习的策略；花大部分时间专注于某个领域学习，拿出较小一部分时间做积极大胆的探索和尝试，以博取迎接”黑天鹅”事件的机会。例如，每天有10个小时的时间，根据20/80法则，其中8个小时专注于你的主业上，剩余2小时可以进行完全自由的学习，接触不同领域的知识，学习一些小而美的技能。 每一个成功者都是唯一的 创造成功，而不是复制成功 费曼给我的启示是，抽象的理论和生动的现实是可以没有边界的，如果有人觉得存在边界的话，恰是因为他的知识和思考尚不足以洞见两者深处的关联。 独特性是最好的竞争力。迈克尔波特说，“战略的意义是让你远离竞争，战略不是要你做得更好，而是让你做得不同。” 【共鸣】战略是让你远离竞争，而不是让你在竞争中胜出。后者，是策略要思考的事情。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《运营之光》读书笔记_黄有璨_201802]]></title>
      <url>%2F2018%2F03%2F26%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F120_%E4%BA%92%E8%81%94%E7%BD%91%E8%BF%90%E8%90%A5%2F%E3%80%8A%E8%BF%90%E8%90%A5%E4%B9%8B%E5%85%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%BB%84%E6%9C%89%E7%92%A8_20180206%2F</url>
      <content type="text"><![CDATA[主题 阅于2018年2月6日 S：当时一次产品会议以及之后对APP用户的课题分析，促使对运营的兴趣 W：了解产品运营是怎么样的；关注点是什么； 序 行业发展初期是产品为王，因为并没有对手；行业发展过程中是渠道为王，因为谁占领了渠道，谁就赢得了用户；但是在充分竞争的互联网领域，是运营决胜的； 如果产品不一样，”运营” 作为于产品的方式，肯定是不一样的； 三种同维度和层次的运用 微观的运营：具体的运营手段；比如如何做好一个活动，如何写好一篇推广文案； 抽象一点看，一切运营的手段其实就是两个导向：1) 拉新、引流和转化； 2) 用户维系 宏观的运营：N多具体的运营手段到底该如何被组织和串联起来，以便更好地作用于一款产品；关注运营的策略、规划和资源分配； 作为一种艺术而存在的运用 管理者的工作不是让大家去工作，而是去创造环境，让大家可以用顺利开展工作。——《人件》；其实运营也是在做类似的事情，运营或许不是非要把用户拉过来，而是要搭建和创造一个环境，让用户们可以更愿意来与你发生互动和玩耍。 【启发】管理的核心是创造环境，这个环境是能够发挥人的主观能动性的； 引言 国内互联网发展的3个阶段 概念驱动时代；1995 ~2004；互联网刚刚起步，线上世界一片空白，大家对于什么是 “好产品” ，甚至怎么做产品都还没有什么认知； 产品驱动时代；2004 ~ 至今（2017年）；各类互联网产品更加重视 “用户体验” 运营驱动时代 整个行业的发展阶段和需求决定了现阶段整个行业对于研发和产品的刚性需求是更大的，整个互联网行业现在正处于一种爆发式增长和发展的阶段；但是你想干互联网或者做个网站和APP，第一步一定是先把产品做出来；如果产品都看不到，谈何运营？ 【启发】思考&amp;回顾 数据分析的历史、当前行业所处的阶段 ​ 第1章 运营是什么运营的四大模块 内容运营、用户运营、活动运营、产品运营、其他 内容运营；核心：围绕着内容的生产和消费搭建起来一个良性循环，持续提升各类跟内容相关的数据；如内容数量、内容浏览量、内容互动数、内容传播数； 内容基础属性是什么（文字？图片？视频？）需要那种调性（搞笑？深度评论？）内容从哪里来（UGC？PGC？） 如何组织与呈现？如何更容易、更高频地被客户消费（标题怎么写？推送？频率？） 用户运营；核心：围绕着用户的新增—留存—活跃—传播以及用户之间的价值供给关系建立起一个良性的循环，持续提升各类与用户有关的数据；如用户数、精英用户数、用户停留时间； 用户从哪里来？（微博？豆瓣？地推？）如何落实（付费？渠道建设？销售？） 如何建立和维护与用户的关系（互动？反馈？礼物？） 如何让更多的用户愿意留下来玩（分析数据？关注留存？关注活动？激励体系设计？） 用户规模庞大时，如何对整个用户生态的影响与掌控（如何分类？不同用户如何服务和管理？不同类型用户之间的如何产生价值关系？） 活动运营；核心：围绕着一个或一系列活动的策划、资源确认、宣传推广、效果评估等一系列流程做好全流程的项目推进、进度管理和执行落地。一个活动运营，必须先确定活动的目标，并持续跟踪活动过程中的相关数据，做好效果评估。 产品运营；核心：通过一系列不同的运营手段，去拉升某个产品的特定数据；如装机量、注册量、用户访问深度、访问频次、用户关系对数量、发帖量； 其他的集中运营：新媒体运营、APP商店推广运营、SEO/SEM运营、广告投放运营/流量运营、淘宝店铺运营、编辑、QQ群、小组运营； 不同业务类型的产品和公司 工具类产品；注重效率和体验 社交/社区类产品；注重社交氛围、话题和玩法 内容类产品；持续做出独特、高质量的内容，并把这些内容包装好，让用户更易于消费 电商类产品；1) 商品和品类的运营，选择什么样的商品； 2) 促销活动的策划与落地； 3) 推广和流量建设； 4) 用户关怀和维系 平台类产品；特别注意 “节奏” ；即在不同的阶段，一定要确定合适的目标； 游戏类产品； 1) 推广； 2) 收入； 【意义】帮你去囊括已有的产品类型 运营的职能 用户参与构成了互联网产品核心价值的重要组成部分。 传统价值产品 = 功能 + 体验 互联网产品价值 = 功能 + 体验 + 用户参与价值 首先，任何一项业务，都存在三个不可或缺的要素：产品、用户、运营；其次，任何一个产品，只有在与用户发生关系之后，才具备价值； 再次，基于业务类型的不同，一款产品与用户间的关系类型会有很大的差异；（例如一次性关系、高频次等） 所谓运营，其实就是为了帮助产品与用户之间更好的建立关系，以及更好地维系住这种关系；最大的区别在于关系类型不同，运营的导向性也是完全不同的；因此，运营应当是大于&lt;营销、策划、文案、编辑、传播、用户管理&gt; 这些概念的总和。实际意义上的运营工作，应该更侧重于使用哪种运营手段，事实上取决于你的业务类型，以及你的产品和用户之间的关系。 【启发】因此，你必须明确你的业务类型、你的用户与你的产品之间的关系是什么 运营 VS. 市场 市场部：创造和管理消费者无形价值的部门；市场所做的一切，都应该瞄准着扩大品牌、产品的用户认知和提升产品的无形价值； 运营，在做的事，是一定要落实到响应产品数据上，比如流量、注册量、留存率、活跃率等 运营 VS. 产品 产品方向和产品形态决定运营的思路；反过来，又需要运营根据用户反馈和运营需求来决定产品的调整和迭代；产品负责界定和提供长期长期用户价值，运营负责创造短期用户价值 + 协助产品完善长期价值； 如果你们公司的产品很烂，做为运用，需要做的是： 对任何一个早期产品， “烂” 是正常的现象；这个阶段，需要运营维护好早期核心用户； 若从用户层面感受到了问题，你需要有能力回归到具体真实的用户使用场景中去向大家说明这个需求和功能可能是有问题的，或者用数据证明它。 最好还可以提出一些解决方案，并通过一些验证和数据去证明它是可行的； 产品烂其实一点也不可怕；真正可怕的是：产品很烂，但提不出解决方案，或者压根不想去解决和优化； 运营的简史 在某种意义上，我相信，一个事物，如果你并不足够了解它的过去，那你一定很难真正去理解它的现在和未来。 【启发】去了解数据分析的过去 运营的最终目的时候为了 &lt;更好地连接产品和用户&gt;。 能顾获取用户，并实现用户付费 （需要关注信息分发和传播的逻辑变化，以及流量获取的成本） 能够更好地维系住这些用户，令之愿意与你持续发生关系 （需要结合产品形态来关注随着用户体量呈不同变化时，该如何更好地作为一个群体的用户进行沟通与互动，较好地控制用户的预期、甚至构成体验） 运营的工作内容从来都不是固定的，往往会随着主流产品形态和整个互联网中信息分发和传播的逻辑而改变。&lt;流量&gt; 和 &lt;用户&gt; 在哪里，运营的关注就在哪里。 互联网运营的7个阶段 1984 - 1993：互联网的萌芽 1994 - 1997：互联网是什么 用户体量不足30万； 代表产品：门户、早期BBS；两者最大的区别，门户（PGC）、BBS（UGC） 代表性运营工作：网站编辑、BBS管理员 1998 - 2001：第一波潮流 用户体量：100 ~ 2000万 代表产品：聊天室、更成熟的BBS、QQ、联众、下载类站点 代表性运营工作：在线推广、社区管理 2001 - 2005：流量为王的时代与运营的出现 用户体量：2200万~ 1.03亿 代表产品：百度、hao123、淘宝、网游、各种安装插件 代表性运营工作：SEO/SEM、流量分发、QQ群管理、电商运营 2005 - 2009：Web2.0时代的运营 —— 用户的崛起 用户体量：1.03亿~ 3.84亿 代表产品：博客、wiki、视频网站、P2P下载、论坛、SNS 代表性运营工作：网络推手、论坛营销、事件营销与传播 所谓Web2.0 可以简单地理解为是 &lt;由用户主导而生成内容的互联网产品模式&gt; 2009 - 2013：微博时代与移动互联网大局下的运营 用户体量：3.84亿~ 6.18亿 代表产品：各类APP、微博、知乎、微信、团购 代表性运营工作：微博运营、社会化媒体营销、APP推广 2013 - 至今：连接一切的互联网与运营 用户体量：6.18亿~ 7.10亿 代表产品：微信、O2O产品、滴滴出行、今日头条、罗辑思维等自媒体 代表性运营工作：新媒体运营、社群运营、微博运营、社会化媒体运营、APP推广 ​ ​ 第2章 运营之”光” 两种思维意识：目标导向意识、效率意识 目标导向意识； 纯粹的职能支持类工作 目标导向类工作 【启发】不仅仅是运营，数据分析更是如此；牢记你的目标，最好的方式是写下你的目标 效率意识；在效率意识的观念下，你的所有时间及所有在做的工作，可能都是成本。所以，在相同的成本投入下，你如何让自己的产出变得更强大？如何持续去优化自己的投入产出比 我这周都做了哪些事？哪些事情是有产出的？哪些事情的产出不够？哪些事情的产出效率尤其地高，值得我花更多时间投入？而哪些事情产出明显不足，可能应该去忽略它？ 【共鸣】精要主义；这种反思要经常做 传统运营讲转化，需要以交易达成为中心；互联网运营讲用户，需要以用户价值为核心； 精益运营 面对不确定环境下的工作方法： 找出最核心的不确定要素 先以最小成本去搭建一个真实的应用场景 当在一个具体项目中面临N多不确定因素的时候，往往存在一个最重要的因素，它可能会成为整件事情顺畅发生的核心前提；在互联网世界里，这个最重要的因素往往是 &lt;一个基于某种假设的产品或服务，能否得到用户真实、自发的认可&gt;。 用最低的成本去搭建一个真实的用户应用场景，并去验证这个场景下，用户是否真的会产生你所预期的行为；要注意，你所搭建的场景一定是无限接近于真实的； 做运营的三个底层方法 让自己拥有对新鲜事物的高度敏感 让自己拥有对于用户的洞察（自己成为用户） 尽可能把自己变成一个真正的典型用户，让自己大量置身于真实用户的真实体验场景下；久而久之，你自然会慢慢拥有一种对于你的用户们的洞察力；而这样的洞察力，很多时候会成为一个优秀运营的核心价值； 学会更具有打动力和说服力的表达 获取注意力：需要抛出一个可以让对方大吃一惊或十分好奇的观点和结论，瞬间击中对方，然后再去逐一论证你的观点是否可以成立 前天我去参加了一个会议，那会议上有好多人；有XX公司、XX公司；然后，有一个著名的基金合伙人，在会议上做了一个演讲，他结合了自己对于教育行业的观察，从20世纪90年代的教育行业发展讲起，具体讲了新东方、学而思等公司的成长路径，还有在线教育的一些趋势。 前天我参加了一个会议，有个著名基金的合伙人聊了一个特别有意思的颠覆性观点，叫做：教育将死，学习永生 （激发倾听的欲望） 说服对方：需要先从大量事实和一些细节的刻画出发，通过事实和细节引发出对方的感知、共鸣和认同，再逐步引申出你的结论。 这部电影超级好，我推荐你一定要去看看 我昨天刚刚看了一部电影，这部电影播放的过程中，我先后4次被感动到落泪；另外，在电影结束播放时，我们那个全场爆满的影厅里，有超过一半的人自发地为这部电影鼓掌 （大量事实和细节的刻画） 【启发】表达之前，你要明白你的目的是什么，然后基于你的目的选择应该的表达方式；（记录到沟通中） 运营需要懂产品 对于一个合格的产品经理，&lt;用户、需求、场景&gt; 永远是在其产品设计和需求分析时必不可少的3要素； 【反思】场景与目的，是需要分别做充分挖掘的；不仅仅是界定场景，还需要分析现有的结构、资源等 第3章 运营的核心技能&amp;工作方法 基于目标的拆解 VS. 基于场景的拆解 基于目标：咨询思维 销售额 = 活动流量 付费率 ARPU值 基于场景：运营思维 思考的几个步骤 界定这个指标是由哪些要素构成；需要把这些要素的关系界定出来，最好变成一个公式/图解/矩阵的样子 这些要素是否要有可以提升的空间 思考如果要提升具体某个指标，需要将其拆分和落实为哪些具体的运营手段？ 数据分析方法和意识 框架不是为了束缚思维，而是用来整理思路的； 数据在运营中的作用 数据可以客观反映出一款产品当前的状态好坏和所处阶段 假如做了一件事但效果不好，数据可以告诉你，问题出在哪里 如果要实现某个目标，数据可以帮助你找到最佳路径 极度精细的数据分析可以帮助你通过层层拆分，对用户更了解，也对整个站内的生态更有掌控力； 数据分析中的基本概念：度量、维度 度量：具体的数据指标（具体指标、具体用户行为数据） 维度：看待指标的不同角度（层次差异[不同用户类型]、角度差异[不同时间、地区]） 所谓数据分析，其实就是界定清楚了评估的度量有哪些，然后需要知道你可能有哪些维度去看待这些度量；之后还需要在不同维度和度量间做交叉分析和对比，最后产出结论，把结果用图表等方式呈现出来。 【启发】先确定具体的度量值，然后在思考可能的维度；之后对需要的部分做交叉分析和对比；在思考的时候，这两个步骤分开来做；例如才子提到的方式：第一阶段就只做列度量值，不去思考整体之间的关系和结构；做完第一步之后，再做内容的归类与可能的交叉分析（矩阵） 数据中可能隐藏着一些潜在的让你把一件事情变得更好的线索和彩蛋，有待你去发现和挖掘 内容的运营 内容运营要做的事，是持续关注内容从生产到消费再到流通和传播的全过程，并通过自己撰写、编辑、组织加工、外部渠道等一系列手段去促进这个过程的发生。 在整个过程中，需要持续关注并提升各类跟内容相关的数据，如内容数量、内容浏览量、内容互动数、内容传播数等 内容的定位、调性和基本原则 做内容，永远都关注长、短两条线； 短线，是尽一切努力促进内容被消费 长线，是以一系列长期、持续的内容为载体，面向用户建立起一种识别度和信任感 为了做好这一点，必须明确你的内容边界（什么能写，什么不能写），并给你的内容打上某种风格化的标签 ；即定位和调性 重要性在于，一旦这个调性被成功树立起来，就可以在用户心中牢牢占据一个位置，进而大大降低以后要去建立用户认知的成本 关于定位和调性的难点并不在于想清楚的调性是什么，而是在于 必须给自己的内容找到显著的不同和差异所在 要落地到实处找到具体的发力点 内容运营过程中关注的点 内容的生产； 对于UGC型的内容生态来说，从&lt;优质内容如何被生产出来&gt; 到 &lt;优质内容如何可以持续地被生产出来&gt; 是两个重要的问题 内容的组织和包装 单篇内容的组建和标准 相关内容的聚合 整体内容的导览和索引 界定用户的访问模式，是你在负责一款内容型产品时，首先就要回答的问题 闲逛式：用户在访问时可能没有什么特定的目的 目的导向式：用户在访问时是为了解决某个特定的问题，或为了查询某个特定的资料 围绕闲逛式的行为方式，内容的组织解决方案可能比较适合通过信息流这种可以随意刷新、随机获取信息的方式，或者比较突出热门话题、官方推荐、最新最热等内容的方式；这样的方式，重在可以让用户以较小的成本获取到一些能够给自己带来刺激或价值的内容 围绕目的导向式的行为方式，内容的组织解决方案可能更适合通过分类、加强搜索体验和引导等方式；重在给予客户一条明确的路径和查询线索，帮助用户更高效地找到自己想要的内容； 【思考】今日头条，用户的访问模式本质上是闲逛式的；只是对于大类的做了划分而已； 核心拳头内容的呈现 内容的流通 内容的流通：当你已经有了一定数量的内容后，需要考虑以某种方式让你已有的内容可以流动起来，通过流动令之展现在用户面前，从而让用户可以发现和消费它。 假如不存在这样的流通形式和流通机制，很容易出现就是老的内容被大量堆在深谷，很难被用户找到或看到，又或者内容和用户间的匹配效率始终不高； 需要关注的维度：如何通过一些机制或手段促进内容的流同，以及促进流通中的内容与用户的匹配效率 转化型文案的写作方法 转化型文案，就是这个文案的目的是特定的，它被写出来的唯一意义就是引导用户去完成某个特定的行为； 标题的最大意义，就是吸引读者去阅读正文； 商品详情页最大的意义，促成用户下单购买 你只有先帮用建立起认知，才有机会激发用户的兴趣。即就是你的文案要先确保用户能够看得懂，在这个基础上才能进一步激发用户的转化。 成为内容领域的高手 内容本身的价值、打动力，与内容的传播、用户消费几率等，已经越来越合一（之前内容只是为了如何简单粗暴地获取流量而服务，至于内容本身的价值并不重要），用户在内容面前的话语权越来越大，而不再是渠道。一个内容能不能火，本质上越来越取决于用户是否认可它，传播它，而不再是核心渠道是否能够推荐它。 如果做内容，尽量不要只做一维的资讯。或者说，即便做资讯，背后也应该包含了某种既定的思想与价值主张。因为如果你提供的是思想、知识、价值主张等，可能会更容易得到用户的认可，而这种认可如果长期积累下来，可能会为你构建起来一种穿透性的用户信任感，且这个信任感可以沉淀转化到任何东西上。比如罗辑思维建立起来的影响力，完全可以转化到卖月饼、卖桃子事情上。 我觉得，人活着，总是需要先能够打破边界，然后再找到边界。前一个边界是外界给自己设定的限制和束缚；后一个边界，则指的是自己的能力、野心和欲望可及和应及的范围。打破前者，为的是找到这个世界的丰富和可能性，打开眼界和格局。找到后者，则为的是找到个人的局限和使命，获得谦卑、专注于平静。 【思考】两个边界：外部、自我 我相信，你应该把你的内容当做一种 &lt;与读者交朋友&gt; 的形式。若想要获得用户持续给予的发自内心的信任，你们之间的关系，必是无限接近于&lt;朋友&gt;的关系。因而，你必须要思考，在一个你最好的朋友面前，你会如何表现？如何表达？然后带着类似的立场去做你的内容；就我来说， 在最好的朋友面前，往往是性格鲜明、情感丰富的；在他们面前，我不会中庸，不会高大上。而是该骂时骂，该哭时哭，该逗乐开心时逗乐开心，该义正言辞时义正言辞，偶尔不靠谱时就自黑调侃地聊聊自己的不靠谱。 【反思】这是真实。真实的你是什么样的呢？矛盾、简单又复杂。 所谓伦理，核心只有一点：跟你从认识一个朋友到愿意毫无保留地相信他是漫长的过程一样，也要相信通过内容来与用户建立信任是一件长期的事情，所以在内容面前，凡是不妨都往长远看一点。 我喜欢的工作方法是： 先找到一个你长期愿意相信的东西，坚守住它，确定一个不可逾越的底线 在此基础上再考虑向一些短期的诱惑去妥协 否则，若无长期坚守，哪怕你短线战绩再辉煌，你在用户眼中很可能只能车呢各位一个过眼云烟式的枪手 以我为例，可能很多人都发现了，我喜欢写长篇大论式的认真表达，不太喜欢短平快的段子，这在今天的互联网上其实有点非主流。尤其是好久以前就不断有人跟我说，现在已经是读图的时代了，已经是短视频的时代了，已经是表情秀、冷笑话，你那种长篇大论的东西没人看，你要跟上时代。 【反思&amp;行动】慢慢写字，这么舒服的纸张，要让你的字配得上它。慢慢写字，慢慢说话，把东西写清楚，把话说清楚； 我觉得，他们的状态其实很惨。因为他们的内容背后展现的，已经不是真实的自己。就像我们说的，一个做内容的人，其实是让自己的内容代表自己去与用户交朋友。但，如果你的内容所展现的都不是一个真实的、诚恳的、性格鲜明的你，用户如何能够相信你？ 【反思】一直就有的观点，你的作品就代表了你的人；其实生活中，勇敢去做自己，不要中庸，不要敷衍，更不要奉承；做一个性格鲜明的你，坦诚一点，真实一点；活出自己，才会是最大的坦荡；那一刻的你，就会像是拥有了一颗坚定的信念，毫无畏惧。 用户运营的逻辑、策略于工作方法 第4章 运营的宏观规律和逻辑 第5章 运营的职业发展与成长 第6章 运营人的思考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SyncToy使用说明]]></title>
      <url>%2F2018%2F02%2F12%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FSyncToy%2FSyncToy%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[SyncToy使用说明 synchronize ：在这个模式下，SyncToy会使得两个文件夹完全一致，无论在哪一个文件夹中操作，对应的操作相当于都在另一个文件夹中执行了一次。（也就是我们所说的“同步”）。 echo：echo模式的效果是，使得在左边文件夹中新增加的和被改变的内容会被备份到右边的文件夹中。在左侧被重命名的文件以及被删除了的文件，将也会在右侧的文件夹中删除。（这种模式与synchronize 很像，差别就在于这里只会从左边同步到右边，右边的操作对左边的文件夹无效~）。 Contribute ：也就是我们常说的“增量备份”，相当于在echo的基础上，把所有的删除操作都屏蔽掉了，只要在左边文件夹中存在过的文件都会在右侧文件夹中存在。 博客文档，选用echo模式；因为并不是所有的文章都要发表 并且，在右侧删除的内容，对同一个 &lt;同步设置&gt; 再次执行时，右侧被删除的文档不会被再次增加。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_数据处理_pandas]]></title>
      <url>%2F2018%2F02%2F06%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_pandas%2F</url>
      <content type="text"><![CDATA[pandas 指引 : http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window DataFrame 单独取出一列是 Series 格式 根据pandas的官方文档，重新调整结构 [TOC] 笔记方法： 列出关键的参数 示例部分一定要是自己的代码 其他均可以上网找 12import pandas as pdimport numpy as np 官方文档：http://pandas.pydata.org/pandas-docs/stable/api.html Input/Output - 输入/输出 General func - 一般功能 datetimelike 顶层处理pd.to_datetime Convert argument to datetime. pandas.to_datetime(arg, errors=’raise’, dayfirst=False, yearfirst=False, utc=None, box=True, format=None, exact=True, unit=None, infer_datetime_format=False, origin=’unix’) arg : integer, float, string, datetime, list, tuple, 1-d array, Series errors : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’ If ‘raise’, then invalid parsing will raise an exception (唤起异常) If ‘coerce’, then invalid parsing will be set as NaT If ‘ignore’, then invalid parsing will return the input dayfirst : boolean, default False If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10. box : boolean, default True If True returns a DatetimeIndex If False returns ndarray of values. format : string, default None strftime to parse time, eg “%d/%m/%Y”, note that “%f” will parse all the way up to nanoseconds (纳秒). unit : string, default ‘ns’ (默认为纳秒) unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number. Return type depends on input: list-like: DatetimeIndex Series: Series of datetime64 dtype scalar: Timestamp 12345678910111213&gt;&gt;&gt; df = pd.DataFrame(&#123;'year': [2015, 2016], 'month': [2, 3], 'day': [4, 5]&#125;)day month year0 4 2 20151 5 3 2016&gt;&gt;&gt; pd.to_datetime(df)0 2015-02-041 2016-03-05dtype: datetime64[ns] # 对于一列的DataFrame其实就是一个Series，返回的对象类型为 datetime64 dtype #----------------- pd.to_timedeltapd.date_range Return a fixed frequency DatetimeIndex, with day (calendar) as the default frequency pandas.date_range(start=None, end=None, periods=None, freq=’D’, tz=None, normalize=False, name=None, closed=None, **kwargs) pd.bdate_rangepd.period_rangepd.timedelta_rangepd.infer_freq #Series #DataFrame 构造函数pd.DataFrame pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) data : numpy ndarray (structured or homogeneous), dict, or DataFrame Dict can contain Series, arrays, constants, or list-like objects 123456&gt;&gt;&gt; d = &#123;'col1': [1, 2], 'col2': [3, 4]&#125;&gt;&gt;&gt; df = pd.DataFrame(data=d)&gt;&gt;&gt; df col1 col20 1 31 2 4 ##重编索引/选择/标签操作 pd.DataFrame.reindex Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index. / Retrun reindexed : DataFrame DataFrame.reindex(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None) labels : array-like, optional New labels / index to conform the axis specified by ‘axis’ to. index, columns : array-like, optional (should be specified using keywords) axis : int or str, optional ; (axis=1, 表示对列进行重排) Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1). method : {None, ‘backfill’/’bfill’, ‘pad’/’ffill’, ‘nearest’}, optional （仅对调单递增/递减的空位处进行填充 - 向前/向后等） method to use for filling holes in reindexed DataFrame. Please note: this is only applicable to DataFrames/Series with a monotonically increasing/decreasing index. default: don’t fill gaps pad / ffill: propagate last valid observation forward to next valid backfill / bfill: use next valid observation to fill gap nearest: use nearest valid observations to fill gap fill_value : scalar, default np.NaN Value to use for missing values. Defaults to NaN, but can be any “compatible” value 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#--------------- reindex the columns.&gt;&gt;&gt; df.reindex(columns=['http_status', 'user_agent']) # 通过columns 来重排 http_status user_agentFirefox 200 NaNChrome 200 NaNSafari 404 NaNIE10 404 NaNKonqueror 301 NaN&gt;&gt;&gt; df.reindex(['http_status', 'user_agent'], axis="columns") # 通过axis 指定来重排 / axis=1 类同 http_status user_agentFirefox 200 NaNChrome 200 NaNSafari 404 NaNIE10 404 NaNKonqueror 301 NaN#--------------- reindex the index.&gt;&gt;&gt; index = ['Firefox', 'Chrome', 'Safari', 'IE10', 'Konqueror']&gt;&gt;&gt; df = pd.DataFrame(&#123;... 'http_status': [200,200,404,404,301],... 'response_time': [0.04, 0.02, 0.07, 0.08, 1.0]&#125;,... index=index)&gt;&gt;&gt; df http_status response_timeFirefox 200 0.04Chrome 200 0.02Safari 404 0.07IE10 404 0.08Konqueror 301 1.00# -------------Create a new index and reindex the dataframe. &gt;&gt;&gt; new_index= ['Safari', 'Iceweasel', 'Comodo Dragon', 'IE10',... 'Chrome']&gt;&gt;&gt; df.reindex(new_index) http_status response_timeSafari 404.0 0.07Iceweasel NaN NaN ## 无法匹配的索引默认填充 NaNComodo Dragon NaN NaNIE10 404.0 0.08Chrome 200.0 0.02&gt;&gt;&gt; df.reindex(new_index, fill_value=0) # NaN 用0来填充&gt;&gt;&gt; df.reindex(new_index, fill_value='missing') # NaN 用‘missing’来填充 #panel - 面板 #Index - 索引 #Numeric Index - 数字化索引 #CategoricalIndex - 分类索引 #IntervalIndex - 交互索引 #MultiIndex #DatetimeIndex - 日期时间索引 #TimedeltaIndex - 时间间隔索引 #PeriodIndex - 间隔索引 #Scales - 标量 #Windows - 窗口 Groupby - 分组 #Resampling - 重新取样 #Style- 样式 #General utility func - 通用效用函数 old 创建与变更格式创建对象 pd.Series( [], index=[], name=’’ )：创建Series pd.DataFrame(np.random.rand(20,5) , index=[], columns=[] )：创建20行5列的随机数组成的DataFrame对象 DataFrame会自动创建索引，且会被有序排列； Index索引对象是不可修改的。除非在第一次写入时缺少索引列，可进行定义。 传入等长的列表或NumPy数组组成的 字典。 若传入的列在数据中查询不到，就会产生NA 1234567891011121314151617DataFrame(obj, colums=[], index=[])# columns 按照指定的列进行显示# index 指定索引的名称，但并不改变行的顺序; 若对已存在的索引（eg:嵌套字典），若index中的索引不存在，则不显示# 创建对象：运用字典--------------------data = &#123;'state': ['Ohi', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]&#125;frame = DataFrame(data, columns = ['year', 'state', 'pop'], index=[1,2,3,4,2]) # 按照指定列进行排序# 创建对象：运用列表pd.DataFrame([[4,7],[5,10]],columns=['a','b'],index=[1,2])# ------嵌套字典-----------pop = &#123;'Nevada': &#123;2001: 2.4, 2002: 2.9&#125;, 'Ohio': &#123;2000: 1.5, 2001: 1.7, 2002: 3.6&#125;&#125;frame3 = DataFrame(pop) 查看数据 df.shape()：查看行数和列数 df.head(n)：查看DataFrame对象的前n行 df.tail(n)：查看DataFrame对象的最后n行 df.describe()：查看数值型列的汇总统计 df.columns ：查看列名 s.value_counts(dropna=False)：查看Series对象的唯一值和计数 df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数 http://df.info()：查看索引、数据类型和内存信息 数据整理重命名 - rename df.set_index(‘column_one’)：更改索引列 df.columns：获取当前列名 df.columns = [‘a’,’b’,’c’]：重命名列名 df.rename( columns = {‘a’ : ‘A’} , inplace = True )：只修改特定的列；将’a’ 改为 ‘A’ df.rename(columns=lambda x: x + 1)：批量更改列名 1234df.rename(columns=&#123;'old_name': 'new_ name'&#125;) # 选择性更改列名df.rename(columns=lambda x: x + 1) # 批量更改列名df.rename(index=lambda x: x + 1) # 批量重命名索引 批量重命名 - 前缀/后缀 DataFrame.add_prefix(prefix) ：将前缀字符串与面板项名称串联在一起。 DataFrame.add_suffix(suffix)：将后缀字符串与面板项名称串联在一起。、 123456789# 分组运算并合并数据df.groupby('key1').transform('mean').add_prefix('mean_') # DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。mean_data1 mean_data20 0.486419 -0.3796531 0.486419 -0.3796532 -0.771562 -0.5620443 -0.771562 -0.5620444 0.486419 -0.379653 排序 - sort_valuese 根据列的值进行排序 df.sort_values(col1)：按照列col1排序数据，默认升序排列 df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据 12df.sort_value(col1, ascendding=False)## ascendding=False，按照列col1降序排列数据；默认按升序排列 根据索引调整 df.sort_index(asix=1, ascending=False) ：根据索引/列名标签对数据结构进行调整 若axis=1，则根据列名的顺序进行调整结构，行不变。 df.reset_index()：重新设置行的索引 s.sort_index() ：根据索引进行排序 s.order() 列/行索引重排 DataFrame.reindex(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)：根据新索引进行重新排序 只显示符合当前索引的值。可加入新的索引值，若不存在则显示为NaN axsi = 1 ，则表示对 [列 Columns ] 进行重排 支持两种形式（建议采用第二种） (index=index_labels, columns=column_labels, ...) (labels, axis={&#39;index&#39;, &#39;columns&#39;}, ...) labels : array-like, optional. New labels / index to conform the axis specified by ‘axis’ to. index： 用作索引的新序列 axis : int or str, optional. Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1). fill_value ：缺失值NaN的替代值 method： = ffill /bfill；向前填充/向后填充；只适用于单调增长/减少的索引 limit： 向前或向后填充的最大填充量； 向前，即正向填充，向后一位数字（数值2位于1的前面） level ： copy： 默认为True，无论如何都复制；若为False，则新旧不相等时复制 1234567891011121314151617181920&gt;&gt;&gt; df http_status response_timeFirefox 200 0.04Chrome 200 0.02Safari 404 0.07IE10 404 0.08Konqueror 301 1.00&gt;&gt;&gt; df.reindex(['http_status', 'user_agent'], axis="columns") http_status user_agentFirefox 200 NaNChrome 200 NaNSafari 404 NaNIE10 404 NaNKonqueror 301 NaN# 将制定的列提到最前面df.reindex(['mean'] + list(df.columns[:-1]), axis=1) df.index.is_unique()：判断索引值是否唯一，若某个索引对应多个值，则返回一个Series，否则返回单个值 排名 - rank df.rank(method = ‘’)：会把对象的 values 替换成名次 排名作用与排序的不同之处在于，它会把对象的 values 替换成名次。 这时唯一的问题在于如何处理平级项，方法里的 method 参数就是起这个作用的 method 排名时处理平级值的方式。 average ：默认，为各个值分配平均排名 min：使用整个分组的 [最小] 排名 max：使用整个分组的 [最大] 排名 first：按值在原始数据中的出现顺序分配排名 max 与 min的区别：相等时，显示的排名按最大/最小排名来显示 12345678910111213141516171819# ------------示例-------------obj = Series([1,2,3,3,4,4,4]) obj.rank(method='max') # 对于3这个值，最大排序为4，所以显示40 1.01 2.02 4.03 4.04 7.05 7.06 7.0obj.rank(method='min') # 对于3这个值，最下排序为3，所以显示30 1.01 2.02 3.03 3.04 5.05 5.06 5.0 格式转换 ​ 布局转换 - 长宽格式 宽格式 $\to$ 长格式 df.melt(id_vars=[‘A’], value_vars=[‘B’, ‘C’]) 1234567891011121314151617181920df.melt(id_ars=[], value_vars=[], var_name='', value_name='')## id_vars，以该变量为基准进行重构## vaule_vars，需要将哪些变量组合进id列的变量，其值自动填充# 示例-------------------&gt;&gt;&gt; df A B C0 a 1 21 b 3 42 c 5 6df.melt(id_vars=['A'], value_vars=['B', 'C']) A variable value0 a B 11 b B 32 c B 53 a C 24 b C 45 c C 6 长格式 $\to$ 宽格式 df.pivot(val1, val2, val3)：将df的val1作为[行]索引的列名，val2为用作[列]索引的列名，val3作为用于[填列值]的列名 层次化索引的重塑 - stack stack()：列转行；将数据的列 “旋转” 为行 unstack()：列转行；将数据的行 “旋转” 为列 stack操作的是对最内层的索引进行操作。 若用字符串表示，则直接输入该索引的名称 .stack(‘number’) 若用数字表示，0 - 第一层索引； 1 - 第二层索引 数据透视表 df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表 格式：数字、时间与日期 pandas库是基于整列的操作 格式转换 - 通用 DataFrame.astype(dtype, copy=True, errors=’raise’, **kwargs) ：Cast a pandas object to a specified dtype dtype dtype : data type, or dict of column name 123456789&gt;&gt;&gt; ser = pd.Series([1, 2], dtype='int32')&gt;&gt;&gt; ser0 11 2dtype: int32&gt;&gt;&gt; ser.astype('int64')0 11 2dtype: int64 # dtype 注意此处 数字操作格式转换 pandas.to_numeric(arg, errors=’raise’, downcast=None) ：将变量转为数值类型 arg : list, tuple, 1-d array, or Series downcast : {‘integer’, ‘signed’, ‘unsigned’, ‘float’} , default None ‘integer’ or ‘signed’: smallest signed int dtype (min.: np.int8) ‘unsigned’: smallest unsigned int dtype (min.: np.uint8) ‘float’: smallest float dtype (min.: np.float32) 数字格式定义 str.format( { : } ) ：格式化输出字符串使用format()函数, 字符串即类, 可以使用方法。可使用 print(&quot;FORMAT&quot;.format(NUMBER)); 来运行示例 http://blog.xiayf.cn/2013/01/26/python-string-format/ 语法是{ }中带 : 号 &#39;{:,}&#39;.format(&#39;str&#39;) 符号 {} 是替换变量的占位符 转义大括号：若你需要使用大括号，只要写两次就可以了 字符串的参数使用 { num } 进行表示 ,0, 表示第一个参数,1, 表示第二个参数 使用“:”, 指定代表元素需要的操作 , 如”:.3”小数点三位, “:8”占8个字符空间等; 添加特定的字母 ‘b’ - 二进制. 将数字以2为基数进行输出. ‘c’ - 字符. 在打印之前将整数转换成对应的Unicode字符串. ‘d’ - 十进制整数. 将数字以10为基数进行输出. ‘o’ - 八进制. 将数字以8为基数进行输出. ‘x’ - 十六进制. 将数字以16为基数进行输出, 9以上的位数用小写字母. ‘e’ - 幂符号. 用科学计数法打印数字, 用’e’表示幂. ‘g’ - 一般格式. 将数值以fixed-point格式输出. 当数值特别大的时候, 用幂形式打印. ‘n’ - 数字. 当值为整数时和’d’相同, 值为浮点数时和’g’相同. 不同的是它会根据区域设置插入数字分隔符. ‘%’ - 百分数. 将数值乘以100然后以fixed-point(‘f’)格式打印, 值后面会有一个百分号. 对齐方式 &lt; （默认）左对齐 > 右对齐 ^ 中间对齐 = （只用于数字）在小数点后进行补齐 12345678910111213141516171819202122# 主要用法 '&#123;:,&#125;'.format('str')# 符号 &#123;&#125; 是替换变量的占位符。若没有指定格式，则直接将变量值作为字符串插入。 "glazed with &#123;&#125; water beside the &#123;&#125; chickens".format("rain", "white")# 可以使用变量的位置数值，在字符串中改变它们，进行格式化时。如果搞错了顺序，你可以轻易地修正而不需要打乱所有的变量。s1 = " &#123;0&#125; is better than &#123;1&#125; ".format("emacs", "vim")s2 = " &#123;1&#125; is better than &#123;0&#125; ".format("emacs", "vim")# 默认顺序为0str = "Oh &#123;0&#125;, &#123;0&#125;! wherefore art thou &#123;0&#125;?".format("Romeo")&gt;&gt;&gt; Oh Romeo, Romeo! wherefore art thou Romeo?# 命名参数：将新的格式字符串用作模板引擎，使用命名参数，这样就不要求有严格的顺序。madlib = " I &#123;verb&#125; the &#123;object&#125; off the &#123;place&#125; ".format(verb="took", object="cheese", place="table")&gt;&gt;&gt; I took the cheese off the table# 转义大括号：若你需要使用大括号，只要写两次就可以了print(" The &#123;&#125; set is often represented as &#123; &#123;0&#125; &#125; ".format("empty")) 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:, } 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 【应用到列】 123456# 定义函数de format_qian(a): b = '&#123;:,&#125;'.format(a) retrun(b) qian_all_data['参与人次'].apply(format_qian) 日期操作格式转换#####转为日期格式 pandas.to_datetime( arg, errors=’raise’, dayfirst=False, yearfirst=False, utc=None, box=True, format=None, exact=True, unit=None, infer_datetime_format=False, origin=’unix’ )：将字符类型转化成时间格式 dayfirst : boolean, default False ; If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10. box : boolean, default True If True returns a DatetimeIndex If False returns ndarray of values. format : string, default None errors : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’ If ‘raise’, then invalid parsing will raise an exception 引发异常 If ‘coerce’, then invalid parsing will be set as NaT If ‘ignore’, then invalid parsing will return the input unit : string, default ‘ns’ unit of the arg (D,s,ms,us,ns) denote the unit 123456789101112&gt;&gt;&gt; df = pd.DataFrame(&#123;'year': [2015, 2016], 'month': [2, 3], 'day': [4, 5]&#125;)&gt;&gt;&gt; pd.to_datetime(df)0 2015-02-041 2016-03-05dtype: datetime64[ns] # 指定格式 &gt;&gt;&gt; pd.to_datetime('13000101', format='%Y%m%d', errors='ignore')datetime.datetime(1300, 1, 1, 0, 0) #####转为日期差值 pandas.to_timedelta(arg, unit=’ns’, box=True, errors=’raise’) ：Convert argument to timedelta timedelta 表示两个datetime之间的时间差。 123&gt;&gt;&gt; pd.to_timedelta(['1 days 06:05:01.00003', '15.5us', 'nan'])TimedeltaIndex(['1 days 06:05:01.000030', '0 days 00:00:00.000015', NaT], dtype='timedelta64[ns]', freq=None) DatetimeIndex.strftime(date_format) ：返回指定格式的字符串格式 Series.dt.strftime(*args, **kwargs) ：单列转为字符串格式，格式化输出 date_format : str ; date format string (e.g. “%Y-%m-%d”) Timestamp.strptime() ：string, format -&gt; new datetime parsed from a string (like time.strptime()). ​ ####基本操作 【选取】 12# 过滤某个时间片的数据&amp;取某个时间片的数据df[df['date']&lt;=pd.datetime(2016,6,10)] 【返回】 1234# 返回某个日期是周几pd.to_datetime(df['date']).dt.weekday_name # 返回星期名；pd.to_datetime(df['date']).dt.weekday # 返回数字； 【判断】 dt.is_month_start ：判断是否为一个月的第一天 dt.is_month_end：判断是否为一个月的最后一天 日期格式定义【datetime格式定义】 代码 说明 %Y 4位数的年 %y 2位数的年 %m 2位数的月 [01, 12] %d 2位数的日 [01, 31] %F %Y-%m-%d 简写形式；2012-04-18 %D %m/%d/%y 简写形式；04/18/12 %H 时间（24小时制） [00, 23] %I 时间（12小时制） [00, 12] %M 2位数的分钟 [00, 59] %S 秒 [00, 61] (秒60和61用于闰秒) %w 用整数表示的星期几 （星期天为第0天） [0, 6] %U 每年的第几周 [00, 53]。星期天被认为是每周的第一天，每年第一个星期天之前的那几天被认为是 “第0周” %W 每年的第几周 [00, 53]。星期一被认为是每周的第一天，每年第一个星期一之前的那几天被认为是 “第0周” %z 以+HHMM 或-HHMM 表示的UTC时区偏移量 【特定于当前环境的日期格式】 代码 说明 %a 星期几的简写 %A 星期几的全称 %b 月份的简写 %B 月份的全称 %c 完成的日期和时间；Tue 01 May 2012 04:20:57 pm %p 不同环境中的AM 或PM %x 适用于当前环境的日期格式 ；若在美国， “May 1 2012” 会产生 “05/01/2012” %X 适用于当前环境的时间格式； “04:24:12 PM” ##合并数据 横向合并 - 类同 join DataFrame.join(other, on=None, how=’left’, lsuffix=’’, rsuffix=’’, sort=False) other : DataFrame, Series with name field set, or list of DataFrame 方法对象必须是DataFrame，但join的对象可以是多个类型的；通用性比 pd.merge 更加好 on ：若不指定，按照索引来进行join； column name, tuple/list of column names, or array-like Column(s) in the caller to join on the index in other. lsuffix / rsuffix : string. Suffix to use from left /right frame’s overlapping columns； 均在已有列名之后跟字符串 sort : boolean, default False 1234567891011121314# 使用索引进行连接&gt;&gt;&gt; caller.join(other, lsuffix='_caller', rsuffix='_other')&gt;&gt;&gt; A key_caller B key_other 0 A0 K0 B0 K0 1 A1 K1 B1 K1 2 A2 K2 B2 K2 3 A3 K3 NaN NaN 4 A4 K4 NaN NaN 5 A5 K5 NaN NaN # 使用关键列进行连接；需要指定连接的列名&gt;&gt;&gt; caller.join(other.set_index('key'), on='key') pd.merge(df1,df2, on =’val’, how=’inner’)：将df1，df2根据val列进行内联接 pd.merge(df1, df2, on = ,[left_on=] how = , [left_index=False, srot=True, copy=True, suffixes=(‘_x’,’_y’)]) df1, df2 ：必须都是DataFrame on = ‘val’ 用于连接的列名；若不指定则以列名的交集作为连接列 当涉及左右两个表单列名不相同时，需使用left_on / right_on left_on = ‘val1’ 左侧表中用作连接的列 right_on = ‘val2’ 右侧表中用作连接的列 left_index / right_index =True ,将索引列作为 [连接列] how = ‘inner’ / ‘left’ / ‘right’ / ‘outer’ （outer为求并集） sort = True/False ，根据连接列对合并的数据进行排序，默认为True suffixs，字符串元组，在两个表中有重复的列名时，可用将字符串追加到重叠列名的末尾，默认为(‘_x’,’_y’) copy = True，默认为True，即将结果复制到数据结构中 对于层次化索引，以 [列表的形式] 指名作用合并键的多个列 12345678910111213141516171819202122232425&gt; pd.merge(lefth, righth, left_on = ['key1', 'key2'], right_index=True)&gt; data key1 key2 event1 event2&gt; 0 0 Ohio 2000 4 5&gt; 0 0 Ohio 2000 6 7&gt; 1 1 Ohio 2001 8 9&gt; 2 2 Ohio 2002 10 11&gt; 3 3 Nevda 2001 0 1&gt;&gt; lefth&gt; data key1 key2&gt; 0 0 Ohio 2000&gt; 1 1 Ohio 2001&gt; 2 2 Ohio 2002&gt; 3 3 Nevda 2001&gt; 4 4 Nevda 2002&gt;&gt; righth&gt; event1 event2&gt; Nevda 2001 0 1&gt; 2000 2 3&gt; Ohio 2000 4 5&gt; 2000 6 7&gt; 2001 8 9&gt; 2002 10 11&gt; 纵向合并 - 增加行 df1.append(df2)：将df2中的 [行] 添加到df1的尾部 df.concat([df1,df2], ignore_index = True) ：纵向合并，将df2中的 [所有行] 添加到df1的尾部 ignore_index = True，表示进行纵向合并，不保留轴上的索引，产生一组新的索引 数据选取与删除行列选取 涉及布尔判断时，默认的对象为所有观测行的所有列 选取的内容会包含索引与数值 通过索引方式返回的列只是相应数据的视图。对此所做的任何修改，会直接反映到源数据。 df[col]：根据列名，并以Series的形式返回 [列] df[ [col1, col2] ]：以DataFrame形式返回 [多列] df[ df[col] &gt; 0.5 ]：选择col列的值大于0.5的所有行 先对 df[col] &gt;0.5 进行布尔判断，返回True 和 False，再选取所有True的值 对具体的观测行进行条件选取 ；等价于 Select * From table where col &gt; 0.5 也可为布尔型数组(过滤行)、切片（行切片）、布尔型DataFrame 1234567891011121314# 指定列中的特定值，并返回所有的行data[data['three']&gt;5] one two three fourColorado 4 5 6 7Utah 8 9 10 11New York 12 13 14 15# 返回布尔值data &gt; 5 one two three fourOhio False False False FalseColorado False False True TrueUtah True True True TrueNew York True True True True df.loc[ n [, m] ] ：通过 [ 行标签 ] 索引行数据 。 主要基于标签的, 但也可以与布尔数组一起使用。 n 为行标签；若行标签为字符串，则也需要用字符串表示。loc[‘d’] 表示索引的是第’d’行（index 是字符） 若出现m，则表示可以索引行与列 起始索引值为0； df.iloc[ n [,m] ]：通过 [ 行号 ] 索引行数据 。 主要基于整数位置 (从0到 length-1 轴), 但也可以与布尔数组一起使用。 n 为行号； 若出现m，则表示可以索引行与列 loc 在index的标签上进行索引,范围包括start和end. iloc 在index的位置上进行索引,不包括end. 12345678910111213141516171819202122232425# ---- loc -------import pandas as pddata = [[1,2,3],[4,5,6],[7,8,9]] index = [0,1,2] columns=['a','b','c'] df = pd.DataFrame(data=data, index=index, columns=columns) &gt;&gt;&gt; df a b c0 1 2 31 4 5 62 7 8 9&gt;&gt;&gt; df[0:1]a b c0 1 2 31 4 5 6# 索引某行某列df.loc['d',['b','c']] # ---- iloc -------## 索引第一列的所有数据df.iloc[:,[1]] 多条件选取1234567891011121314151617181920212223242526272829303132data = [[1,2,3],[4,5,6],[7,8,9]] index = [0,1,2] columns=['a','b','c'] df = pd.DataFrame(data=data, index=index, columns=columns) # 所有列的多条件选取df[(df['b']&gt;2 ) &amp; (df['a']&gt;1)] a b c1 4 5 62 7 8 9# 指定列的多条件选取df['c'][(df['b']&gt;2 ) &amp; (df['a']&gt;1)]1 62 9# 指定列的多条件选取&gt;&gt;&gt; df.loc[(df['b']&gt;2 ) &amp; (df['a']&gt;1),'c']1 62 9Name: c, dtype: int64# 指定多列的 多条件选择df.loc[(df['b']&gt;2 ) &amp; (df['a']&gt;1),'b':'c'] # 获取值&gt;&gt;&gt; df.loc[(df['b']&gt;2 ) &amp; (df['a']&gt;1),'c'].valuesarray([6, 9], dtype=int64) df.ix[1, val ] 因为容易混淆，建议不使用。 df.ix[1, val ]：既能通过行号，也可以通过索引位置来进行选取，但ix中的索引右端为包含； 因为容易混淆，建议不要使用。 若行的索引名为数字时，在进行选中时，选择的为行索引的数值名称，而非位置 123456789101112# 因行索引不为数字，故代表位置，右端不包含data.ix[0:2] one two three fourOhio 0 1 2 3Colorado 4 5 6 7# 因行索引为数字，故代表的为行索引的名称data.ix[0:2] Id Survived0 1 01 2 12 3 1 ###条件选取 - filter df.filter(item=[val], like= , regex=’’, axis=1)：选择DataFrame中满足条件的子集 filter的条件判断是对 行索引/ 列名 进行的匹配，而非具体的观测值 item：指定的列名；若不指定，则表示全体 regex：满足正则表达式的列名 ，此时axis=1 like ：满足like的行索引的所有行，此时axis=0 （该功能是SQL中没有的） axis = 1 ：基于列； axis = 0 ：基于行 123456789101112131415161718192021222324&gt;&gt;&gt; dfone two threemouse 1 2 3rabbit 4 5 6&gt;&gt;&gt; # select columns by name&gt;&gt;&gt; df.filter(items=['one', 'three']) one threemouse 1 3rabbit 4 6&gt;&gt;&gt; # select columns by regular expression&gt;&gt;&gt; df.filter(regex='e$', axis=1) one threemouse 1 3rabbit 4 6&gt;&gt;&gt; # select rows containing 'bbi'&gt;&gt;&gt; df.filter(like='bbi', axis=0)one two threerabbit 4 5 6 ###随机与排序选取 df.sample(frac=0.5)：随机选取所有数据中的50%的观测行 df.sample(n=10)：随机选取10行 df.nlargest(n, ‘value’)：根据’value’进行排列，并选取最前面的n个值 df.nsmallest(n, ‘value’):根据n进行排序，并选取最后面的n个值 s.iloc[0]：按位置选取数据 s.loc[‘index_one’]：按索引选取数据 重复值 - duplicated df.duplicated()：判断是否有重复行 df.duplicates()：移除重复行，默认保留第一个出现的值组合 df.duplicates([val1, val2], take_last=True)：指定部分列进行重复项判断； take_last=True 指定保留最后一个 s.dropna()：将Series中删除所有包含空值的行 s.astype(float)：将Series中的数据类型更改为float类型 s.replace(1,’one’)：用‘one’代替所有等于1的值 s.replace([1,3],[‘one’,’three’])：用’one’代替1，用’three’代替3 唯一值 - unique df[‘val’].unique：返回某一列的唯一值 df.[‘val’].value_conuts：计算列中每个值出现的次数 数据删除 - drop df.drop(val, axis=0 )：删除索引行/变量列，并返回一个新的对象 axis默认为0，删除索引为val1,val2的观测 [行] 1df.drop([val1,val2], axis=1) # 删除列名为val1,val2的 [列]，并返回一个新的对象； s.drop() 【实战演练】返回某列中不为NUll的所有行1data1 = data0[data0['column'].notnull()] 创建新变量 往往需要用到apply函数，然后用 merge 或者 join 来进行合并 增加列 df[‘Volumn’] = df.Length * df.Height 1234567In [219]: df['b']=1 In [220]: df Out[220]: c a b 0 1 5 1 1 2 6 1 pd.Series(my_list)：从可迭代对象my_list创建一个Series对象 若不指定索引 index = [‘’, ‘’ ] ，则会自动创建从0开始的索引列 通过索引返回/赋值的数据，是对应数据的视图；所做的修改都会直接反映在源数据上； 算术运算中，会自动对齐不同索引的数据，若对应索引不存在，则填充为NaN 12345obj2 = Series([4, 7, -5, 3], index = ['b', 'd', 'a', 'c']) # 指定索引# 字典创建：字典中的 键 = 索引sdata = &#123;'Ohio': 35000, 'Texas': 71000, 'Orgen': 16000, 'Utah': 5000&#125;obj3 = Series(sdata) df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])：增加一个日期索引 apply DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds) 若提前定义了函数，默认将之前的才变量传入为第一个参数； 例如 apply(sum)，其实是将变量传递给sum()的第一个变量 func : Function to apply to each column/row np.mean / np.sum ：常规统计函数均可用np.xxx 表示对每一列使用该函数 123456789101112&gt;&gt;&gt; df.apply(numpy.sum, axis=0) # equiv to df.sum(0)# 定义链接的函数；为apply做准备；def link(a): a = str(a) # 必须是字符串格式 link = 'http://xinyitong.gensee.com/webcast/site/entry/join-5c9543e2905146aa9a6f2b16bd1f6de0' c = '?nickName=visitor' return (link + c + a) link_add = tb0['员工编号'].apply(link); 重编码 - 字符串 字符串操作：Python内置、Re模块、矢量化操作 Re模块的函数主要分三个大类：匹配模式、替换、拆分 矢量化”(简化)是重写循环的过程，使得不是将阵列的单个元素处理N次，而是将阵列的4个元素同时N / 4次处理。 使用 str.func 在str属性上使用索引 12345678&gt; # 使用str.func&gt; matches = df.str.match(pattern)&gt;&gt; # 在str属性上使用索引&gt; matches.str[0]&gt;&gt; matches.str.get(1)&gt; &gt; 常常需要结合 apply 函数进行批量操作 匹配 - find &amp; match &amp; search Python 内置 find()：返回第一个发现的子串的第一个字符所在的位置；否则返回 -1 rfind()：返回最后一个发现的子串的第一个字符所在的位置；否则返回 -1 index()：返回子串第一个字符所在的位置；若没有找到返回ValueError startswith() / endswith() ：判断字符是否以某个前缀/后缀 开始或结尾，返回True count：返回子串在字符串中出现的次数（非重复） Re模块 match(pattern, string, flags=0)：字符串string的开头 开始搜索正则表达式模式pattern；若匹配成功，则返回一个匹配对象（仅返回匹配的部分）；否则返回None search(pattern,string, flags=0)：从字符串string中（任意位置）搜索正则表达式模式pattern 第一次出现的地方； 如果匹配成功，则返回一个匹配对象；否则返回None findall(pattern, string [,flags]) ：在字符串string中搜索匹配pattern的所有内容，并返回一个匹配对象的 [列表 list] finditer(pattern, string [, flags])：在字符串string中搜索匹配pattern的所有内容，返回一个迭代器，该迭代器返回一个匹配对象 矢量化的字符串方法 df.str.func match() ：根据指定的正则表达式对各个元素执行re.match findall() startswith / endswith contains() ：返回各字符串是否含有指定模式的布尔型数组 count：模式出现的次数 ​ 替换 - replace &amp; sub python内置 strip / lstrip / rstrip：去除空格（包括换行符）。相当于对各个元素执行x.strip() ljust /rjust ：用空格（或其他字符）填充字符串的空白侧以返回符合最低宽度的字符串 df.replace(1,’one’)：用‘one’代替所有等于1的值 df.replcae([1,2], [‘one’, ‘two’]) ：多个值之间替换 df.replace({-999:na.nan, -1000:0})： 传入的参数也可以是字典 replace - 替换； 此处的替换为对整个值进行查找，而非值中的部分值 eg: 第3个观测行daf\n ，无法用 data.replace(’\n‘, ‘’) 进行替换 12df.replace(old, new [,max]) # 将old值替换为new# max，可选字符串, 替换不超过 max 次 lower / upper () ：转化为小写/大写 Re模块 re.sub(pattern, repl ,string, max = 0) : 把字符串string中所有匹配正则表达式pattern的地方 替换成 字符串 repl 如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。 若max 的值没有给出，则对所有匹配的地方进行替换 subn() ：该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数 矢量化的字符串 strip / lstrip / rstrip：去除空格（包括换行符）。相当于对各个元素执行x.strip() pad()：在字符串左边、右边或两侧添加空白符 center()：相当于pad(side=’both’) replace()：用指定字符串替换找到的模式 repeat()：重复值； s.str.repeat(3) 相当于对各个字符串执行 x *3 get()：获取各元素的第i个元素 len()：计算各字符串长度 lower / upper () ：转化为小写/大写 分隔与连接 Python内置 split：通过指定的分隔符将字符串拆分为一组子串 ‘sep’.join(seq) ：将字符串用作连接其他字符串序列的分隔符 sep：分隔符；可以为空 seq：要连接的元素序列、字符串、元组、字典 123&gt;&gt;&gt; seq1 = ['hello','good','boy','doiido'] &gt;&gt;&gt; print ':'.join(seq1) hello:good:boy:doiido Re模块 split：根据找到的模式将字符串拆分为数段 矢量化字符串函数 split() slice()：对Series中的各个字符串进行子串截取； cat()：实现元素级的字符串连接操作，可指定分隔符 对象类型 dir()：获得对象的所有属性与类型 type() - 判断对象类型 instance() - 判断一个对象是否为某种类型：返回布尔值Ture/Falses 12345678910111213141516171819# 指定判断类型&gt;&gt;&gt; isinstance('a', str)True&gt;&gt;&gt; isinstance(123, int)True# 先创建判断的对象&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True# 还可以判断一个变量是否是某些类型中的一种&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 能用type()判断的基本类型也可以用isinstance()判断 常规格式转化 int(x [,base ]) ：将x转换为一个整数 long(x [,base ]) ：将x转换为一个长整数 float(x)：将x转换到一个浮点数 str(x)：将对象 x 转换为字符串 repr(x)：将对象 x 转换为表达式字符串 eval(str) ：用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s)：将序列 s 转换为一个元组 list(s)：将序列 s 转换为一个列表 chr(x) ：将一个整数转换为一个字符 unichr(x) ：将一个整数转换为Unicode字符 ord(x)：将一个字符转换为它的整数值 hex(x)：将一个整数转换为一个十六进制字符串 oct(x)：将一个整数转换为一个八进制字符串 complex(real [,imag ])：创建一个复数 缺失值###判断 df.isnull()：检查DataFrame对象中的空值，并返回一个Boolean数组 df.notnull()：检查DataFrame对象中的非空值，并返回一个Boolean数组 Python中内置的None会被当做NA处理 pandas用浮点值NaN (Not a Number) 表示浮点和非浮点数据中的缺失数据；其类型为 float ###移除 df.dropna()：删除所有包含空值的行，返回为剔除后的对象（一行中只要有一个值为NaN，就删除整行） 12345df.dropna(how='all', axis=1, thresh=n)## how='all', 指定排除一行中 [所有值均NA] 行/列## axis=1, 删除所有包含空值的 [列]; 默认axis=0, 即删除所有包含空置的[行]## axis=1,thresh=n, 删除所有 [小于n个非空值] 的 [行] ###重编码 df.fillna(x, inplace=True)：用x替换DataFrame对象中所有的空值，inplace表示在源数据中修改 123456789fillna(value [, method = 'ffill',limit =n, axis=0, inplace=False])# value 填充值# method 差值方式，默认为ffill；也可为bfill# limit 可以连续填充的最大数量# axis 待填充的轴，默认为0# inplace 默认为False，表示返回新对象；若为True，则对原始数据进行修改df.fillna(0) # 将缺失值替换为0df.fillna(&#123;1: 0.5, 3: -1&#125;) # 对位置值为1的 [列]，缺失值替换为0.5；即对第二列，将NaN值替换为0.5 汇总与描述统计 常规情况下，axis=1 代表列； axis=0 代表行； 计算情况下，axis=1 代表沿着每一行遍历所有的列，并向下执行方法 常规统计值 count()：非NA的数量 describe()：计算统计汇总 sum() mean() / median() quantile() min() / max() var()：方差 / std()：标准差 mad() :根据平均值计算平均绝对离差 argmin() / argmax()：计算能够获取到最小值/最大值的索引位置（整数） （对应 iloc） idxmin() / idxmax()：计算能过获取到最小值/最大值的所索引值 （对应loc） 常规统计值 - 高阶 cumsum()：累计和 cummin() /cummax() ：累计最小值/累计最大值 cumprod()：累计积 skew()：偏度（三阶矩） kurt()：峰度（四阶矩） diff()：一阶差分（对时间序列很有用） pct_change()：百分数变化 corr()：相关系数 ocv()：协方差 数据聚合与分组分组聚合是由三个过程来组成的：拆分Split - 应用Apply - 合并Combine 数据根据所提供的一个或多个键被拆分 (Split) 为多组。并且拆分操作是在对象的特定轴 (axis=1 列； 或 axis=0 - 行)上执行的 将一个函数Apply应用到各个分组并产生一个新的值 将所有的结果合并Combine到最终结果的对象中 grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df[‘key1’]的中间数据而已。该对象已经有了所需的一切信息 123456789101112131415161718import pandas as pdimport numpy as npdf = pd.DataFrame(&#123;'key1':['a','a','b','b','a'], 'key2':['one','two','one','two','one'], 'data1':np.random.randn(5), 'data2':np.random.randn(5)&#125;)# grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已grouped = df['data1'].groupby(df['key1'])grouped&lt;pandas.core.groupby.SeriesGroupBy object at 0x000000000876EBA8&gt;# 调用GroupBy的方法进行聚合计算grouped.mean() key1a 0.486419b -0.771562Name: data1, dtype: float64 分组 groupby：在分组的基础上，计算非NA的值统计量； 并且对所有的数值数据进行统计计算，而对非数据数据列则会排除。 默认对axis=0上进行分组；该场景应认为是计算的场景，axis=0 表示以列为单位，遍历每一行；即对该列中的各个值进行分组；效果等同于SQL中的groupby df.groupby(‘ col’ )：返回一个按列col进行分组的Groupby对象 df.groupby( [‘col1’,’col2’] )：多条件分组； （ 等价于SQL中Group by key1, key2 ） df.groupby().size()：返回一个包含分组大小的Series as_index = False ：以 “无索引” 的形式返回聚合数据 group_keys = False ：禁止分组键。分组键会跟原始对象的索引共同构成结果对象中的层次化索引。该函数可禁止该效果。 123456789101112131415161718192021222324252627282930313233343536373839# grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已grouped = df['data1'].groupby(df['key1'])grouped&lt;pandas.core.groupby.SeriesGroupBy object at 0x000000000876EBA8&gt;# 调用GroupBy的方法进行聚合计算grouped.mean() key1a 0.486419b -0.771562Name: data1, dtype: float64 # 对所有的数值数据进行统计计算，而对非数据数据列则会排除。 'key2'列自动被排除在外df.groupby('key1').mean() data1 data2key1 a 0.486419 -0.379653b -0.771562 -0.562044 # -----------df.groupby(['col1', 'col2'])-----------------# 一次传入多个数组，表示多条件分组 df.loc[:,'data1'].groupby([df['key1'],df['key2']]).mean() # 等价于SQL中 Group by key1, key2 key1 key2a one 0.882282 two -0.305308b one -1.010323 two -0.532800Name: data1, dtype: float64 # ---------------Size--------------------df.groupby('key1').size() key1a 3b 2dtype: int64 层次化索引的重塑 - stack 可构建类似数据透视表的结构 stack()：列转行；将数据的列 “旋转” 为行 unstack()：列转行；将数据的行 “旋转” 为列 stack操作的是对最内层的索引进行操作。 若用字符串表示，则直接输入该索引的名称 .stack(‘number’) 若用数字表示，0 - 第一层索引； 1 - 第二层索引 123456df.loc[:,'data1'].groupby([df['key1'],df['key2']]).mean().unstack()key2 one twokey1 a 0.882282 -0.305308b -1.010323 -0.532800 选取部分列 分组 df[‘data1’].groupby(df[‘key1’])：返回的一个已分组的数据框对象（语法糖：df.groupby(‘key1’)[‘data1’] ） df[[‘data1’]].groupby(df[‘key1’]) ： 语法糖为df.groupby(‘key1’)[[‘data1’]] 通过函数 - 分组 任何被当做分组键的函数都会在各个索引值 （行的索引值，而非列名）上被调用一次，其返回值就会被用作分组名称。 若索引为人的名字；假设你希望根据人名的长度进行分组，虽然可以求取一个字符串长度数组，但其实仅需 传入len函数即可 1people.groupby(len).sum() ####通过索引级别 - 分组 针对层次化索引数据集，可以根据索引级别进行分组；通过level 关键字传入 级别编码 或者 名称 即可。 df.groupby(level=’cty’, axis=1).mean() 对层次化索引的数据，根据索引级别进行聚合.通过level关键字传入级别编号或名称 1hier_df.groupby(level='cty', axis=1).count() 对分组进行迭代通过字典或Series 分组 传入一个 字典或Series 根据其值的内容分别分组 数据聚合 聚合：从数组产生标量值的数据转换过程 GroupBy会高效地对Series进行切片，然后对各片调用Piece，最后将这些结果组装为最终结果 自定义聚合函数 将自定义的函数传入aggregate 或 agg方法即可 aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。 df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值df 1234def peak_to_peak(arr): return arr.max() - arr.min()df.groupby('key1').agg(peak_to_peak) 优化过的GroupBy 方法 .count() ： 非NA值的数量.sum() ： 非NA值的和.mean().mdian()： 非NA值的算术中位数.std / .var： 无偏（分母为n-1）标准差和方差.min / .max.prod()： 非NA值的积.first / .last ：第一个和最后一个非NA的值 面向列的多函数应用 一次应用多个函数 df.groupby( [‘sum’, ‘mean’]) ：一次应用多个函数：对于描述统计，可以将函数名以 字符串str 的形式传入，并作为一个 列表list 传入，得到一个以相应的函数命名的列 df.groupby( [ (‘foo’, ‘mean’), (‘bar’, ‘sum’) ]) ：传入多个函数，并重命名列名。 当传入的是一个由 (name, function)元组组成的列表list ，则各元组的第一个元素会被用作DataFrame的列名（可以将这种二元元组看做一个有序映射） 123456789101112131415161718192021df.groupby('key1').agg(['sum','mean']) data1 data2 sum mean sum meankey1 a 1.459256 0.486419 -1.138960 -0.379653b -1.543123 -0.771562 -1.124087 -0.562044# ---- 先定义要传入的多个函数为对象A；也可以运行fc = ['count', 'mean', 'max'] df.groupby('key1').agg(fc) data1 data2 count mean max count mean maxkey1 a 3 0.486419 1.041325 3 -0.379653 0.010709b 2 -0.771562 -0.532800 2 -0.562044 0.038084# 传入带有自定义名称的元组列表fc_name = [('计数','count'),('最大值','max')] 对不同的列使用不同的聚合函数 df.groupby(‘key1’).agg( { ‘tip’: np.max, ‘size’: ‘sum’} ) ：向 agg 传入一个列名映射到函数的 字典dict df.groupby(‘key1’).agg( { ‘tip_pct’ : [‘min’, ‘,max’], ‘size’: ‘sum’}) ：对不同列完成不同数量的聚合 分组运算transform &amp; apply transform &amp; apply 只能产生两种结果： 一个可以广播出去的标量值 一个相同大小的结果数组 aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。 df.groupby(‘val’).transform( func )：将一个函数应用到各个分组，返回该结果的值； 若产生的是一个标量值，则该值会被广播出去。 123456789101112131415161718df.groupby('key1').transform('mean') data1 data20 0.486419 -0.3796531 0.486419 -0.3796532 -0.771562 -0.5620443 -0.771562 -0.5620444 0.486419 -0.379653# 对比 df.groupby('key1').mean() data1 data2key1 a 0.486419 -0.379653b -0.771562 -0.562044# 分组运算并合并数据df.groupby('key1').transform('mean').add_prefix('mean_') # DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。 apply 是更一般性的 “拆分-应用-合并”； 传入的函数一般都是需要提前定义的；而无法直接调用已有的函数（sum/mean等） GroupBy.apply(func)： data.apply(np.mean)：对DataFrame中的每一 [列] 应用函数np.mean axis = 0 默认：以行为单位，遍历列的所以行；可以理解为 SQL中指定某列的Group by axis = 1 ：以列为单位，遍历行的所有列。 1234567891011# 定义函数：根据分组选出最高的5个tip_pct值def top(df, n=5, column = 'tip_pct'): return df.sort_index(by=column)[-n:] # 将该函数应用tips.groupby('smoker').apply(top)# -----------------------------------------------# 如果传入的函数能够接受其他参数或关键字，可以将这些内容直接放在函数名后面一并传入applytips.groupby(['smoker', 'day']).apply(top, n=1, column = 'totoal_bill') 样式输出 - style 【提醒】 采用格式化函数之后，整个对象类型则变更为 styler ，此时不应该赋值给原对象。因为赋值后，无法应用任何 DataFrame的函数； 格式输出并不改变原对象的值 在最后阶段应用格式化输出的函数 输出设置 Styler.format(formatter, subset=None)：格式化单元格的文本显示值 pandas.io.formats.style.Styler.format 对象必须是 DataFrame；对于Series无效；即若只取 DataFrame的一列，则会报错； formatter: str, callable, or dict &lt; formatter是 a 或 dict {column name： a} &gt;； a 是如下之一 str: this will be wrapped in: a.format(x) ； 这将包装在：a.format(x) callable: called with the value of an individual cell 使用单个单元格的值调用 subset: IndexSlice An argument to DataFrame.loc that restricts which elements formatter is applied to 123456789&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(4, 2), columns=['a', 'b'])# 对所有对象调用格式化函数&gt;&gt;&gt; df.style.format('&#123;:.2%&#125;') # 注意&#123;&#125;是用引号 括起来的&gt;&gt;&gt; df['c'] = ['a', 'b', 'c', 'd']# 通过字典的方式来指定特定列的输出格式 ## 对于数值类型，直接调用format函数； 对于文本，直接调用str.funcdf.style.format(&#123;'a':format('&#123;:.2%&#125;'),'b':format('&#123;:.2%&#125;'),'c':str.upper&#125;) 对于数值类型，直接调用format函数； 对于文本，直接调用str.func 格式化单元格的文本显示值。 参考说明axis的含义【结论】 常规情况下，axis=1 代表列； axis=0 代表行； 计算情况下，axis=1 代表沿着每一行遍历所有的列，并向下执行对一个的方法 如果我们调用df.mean(axis=1),我们将得到按行计算的均值 如果我们调用 df.drop((name, axis=1),我们实际上删掉了一列，而不是一行 df.mean其实是在每一行上取所有列的均值，而不是保留每一列的均值。也许简单的来记就是axis=0代表往跨行（down)，而axis=1代表跨列（across)，作为方法动作的副词（译者注） 换句话说： 使用0值 表示沿着每一列或行标签\索引值向下执行方法 使用1值 表示沿着每一行或者列标签模向执行对应的方法 下图代表在DataFrame当中axis为0和1时分别代表的含义: axis参数作用方向图示 另外，记住，Pandas保持了Numpy对关键字axis的用法，用法在Numpy库的词汇表当中有过解释： 轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。 所以问题当中第一个列子 df.mean(axis=1)代表沿着列水平方向计算均值，而第二个列子df.drop(name, axis=1) 代表将name对应的列标签（们）沿着水平的方向依次删掉。 12345678910111213141516171819&gt;&gt;&gt;df = pd.DataFrame([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], \columns=["col1", "col2", "col3", "col4"])&gt;&gt;&gt;df col1 col2 col3 col4 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 &gt;&gt;&gt; df.mean(axis=1)0 11 22 3&gt;&gt;&gt; df.drop("col4", axis=1) col1 col2 col30 1 1 11 2 2 22 3 3 3 常见问题两行相减 &amp; 环比12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_日期处理]]></title>
      <url>%2F2018%2F02%2F05%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[日期与时间 datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。 如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。 Python中关于时间、日期的处理库有三个：time、datetime和Calendar。 datetime又有datetime.date、datetime.time、datetime.datetime三个类 时间又可以分为时间戳、本地时间和UTC时间（世界标准时间） from time import time from datetime import datetime 时间序列的几种内容 时间戳 (timestamp)，特定的时刻 固定时期 (period)，如2017年1月或2017年全年 时间间隔 (internal) ，由起始时间和结束时间戳表示。时期 (period) 可以看做间隔的一个特例 datetime模块 datetime是Python处理日期和时间的标准库。 from datetime import datetime datetime模块。该模块中包含4个主要的类： datetime.date：日期类，只包含年、月、日、星期等日期信息。 datetime.time：时间类，只包含时、分、秒、微秒等时间信息。 datetime.datetime：日期时间类，包含以上两者的全部信息。 datetime.timedelta：时间日期差值类，用来表示两个datetime之间的差值（日、秒、毫秒）。 12345678&gt; # 获取当前时间&gt; &gt;&gt;&gt; from datetime import datetime&gt; &gt;&gt;&gt; now = datetime.now() # 获取当前datetime&gt; &gt;&gt;&gt; print(now)&gt; 2015-05-18 16:28:07.198690&gt; &gt;&gt;&gt; print(type(now))&gt; &lt;class 'datetime.datetime'&gt;&gt; &gt; 注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。 如果仅导入import datetime，则必须引用全名datetime.datetime。 datetime.now()返回当前日期和时间，其类型是datetime。 时间获取 datetime.datetime.now()：获取当前日期与时间 datetime.datetime(2012, 1, 12)：获取指定日期与时间 ####指定部分 datetime.year : 获取日期与时间的指定部分 datetime.year datetime.month datetime.day datetime.hour datetime.minute datetime.second datetime.microsecond In range(1000000) datetime.date()：获得日期部分 datetime.time() datetime.weekday()：将星期几作为整数返回，其中星期一为0，星期日为6 datetime.isoweek()：将星期几作为整数返回，星期一为1，星期日为7 字符串转换 datetime.strftime( format ) ：时间转为字符串 f：表示from strftime() 用来格式化 datetime对象 format : ‘%Y-%M-%D %H:%M:%S’ 123456# datetime.datetime类型转字符串print(a_datetime_local.strftime("%Y-%m-%d, %H:%M:%S, %w")) # 字符串转datetime.datetime格式a_datetime = datetime.datetime.strptime("2016-11-15, 15:32:12, 2", "%Y-%m-%d, %H:%M:%S, %w") datetime.strptime( ‘date_string’, ‘%Y-%M-%D’)：字符串转为时间格式 datetime.strptime 是通过已知的格式进行日期解析的方式。但每次都必须要编写格式定义。 parser.parse(‘str’ ,dayfirst =True)：可以解析几乎所有人类能够理解的日期表示形式（中文除外） 对于常见的日期格式，可以使用dateutil 第三方包中的 parser.parse 方法 注意：它并不是一个完美的工具；因为会把一些原本不是日期的字符串认作是日期（比如 “42”会被解析为2042年的今天） dayfirst =True ，将日期显示在最前面；因为国际通用格式中，日通常排在月的前面。 1234from dateutil.parser import parseparse('2011-03-11')[out]:datetime.datetime(2011, 3, 11, 0, 0) timedelta对象 + 加减datetime.timedelta 表示两个datetime之间的时间差。 给datetime对象加上一个或多个 timedelta，会产生一个新的对象； now + timedelta(days=n, hours=m)：在原有基础上加减日期 对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类： yearsmonthsdayshoursminutesseconds 123456789101112131415# 日期加减from datetime import timedeltastart = datetime(2011,1,7)start + timedelta(12)[out]:datetime.datetime(2011, 1, 19, 0, 0) # 返回间隔delta = datetime(2011, 1, 7) - datetime(2008, 6, 24)delta[out]:datetime.timedelta(927)delta.days[out]:927 time模块在time模块中，时间有三种表现形式： 时间戳，一般指Unix时间戳，是从1970年开始到现在的秒数。 1970年以前的时间timestamp为负数 本地时间的struct_time形式：一个长度为11的命名元组，第一位为年，第二位为月…. UTC时间的struct_time形式：一个长度为11的命名元组，类似于上个，只不过为UTC时间 其中后两者的类型一致，区别在于一个是本地时间（localtime），一个是utc时间。 时间获取12345678910# 时间戳：1479193181.829338print("time stamp:", time.time()) # struct_time类型的本地时间print("local time:", time.localtime()) time.struct_time(tm_year=2016, tm_mon=11, tm_mday=15, tm_hour=14, tm_min=59, tm_sec=41, tm_wday=1, tm_yday=320, tm_isdst=0)# struct_time类型的utc时间print("utc time:", time.gmtime()) time.struct_time(tm_year=2016, tm_mon=11, tm_mday=15, tm_hour=6, tm_min=59, tm_sec=41, tm_wday=1, tm_yday=320, tm_isdst=0) 字符串转换 time.strptime()：字符串转为时间格式 time.strftime()：时间格式转为字符串 123456789101112131415# 时间戳转字符串(本地时间字符串)print(time.ctime(time_stamp)) # struct_time类型的本地时间转字符串print(time.asctime(local_time)) # struct_time类型的utc时间转字符串print(time.asctime(utc_time)) # struct_time类型的本地时间转字符串：自定义格式print(time.strftime("%Y-%m-%d, %H:%M:%S, %w", local_time))# struct_time类型的utc时间转字符串：自定义格式print(time.strftime("%Y-%m-%d, %H:%M:%S, %w", utc_time))struct_time = time.strptime("2016-11-15, 15:32:12, 2", "%Y-%m-%d, %H:%M:%S, %w") datetime 与 timestamp转换在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp 12345# 可以认为timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00# 对应的北京时间是：timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00 可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。 datetime 转 timestamp dt.timestamp()：把datetime对象转化为timestamp 1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp1429417200.0 timestamp 转 datetime datetime.fromtimestamp(t)：从timestamp 转为datetime（本地时间） 注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。 datetime. utcfromstimestamp(t)：从timestamp 转为datetime（UTC时间） 1234567&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; t = 1429417200.0&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间2015-04-19 12:20:00 &gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间2015-04-19 04:20:00 类型和时间戳、struct_time类型的相互转换 1234567891011121314 # datetime类型转时间戳time_stamp = a_datetime_local.timestamp() print(time_stamp)# 时间戳转datetime.datetime类型的本地时间a_datetime_local = datetime.datetime.fromtimestamp(time.time()) a_datetime_utc = datetime.datetime.utcfromtimestamp(time.time()) # 时间戳转datetime.datetime类型的utc时间print(a_datetime_local, a_datetime_utc)# datetime类型转struct_time类型print(a_datetime_local.timetuple()) print(a_datetime_utc.utctimetuple()) # datetime类型转struct_time类型 时区本地时间转UTC时间 本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。 一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区： 12345678&gt;&gt;&gt; from datetime import datetime, timedelta, timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00&gt;&gt;&gt; dtdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))) 时区转换 utcnow()：获取当前的UTC时间 时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。 利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。 12345678910111213141516171819# 拿到UTC时间，并强制设置时区为UTC+0:00:&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)&gt;&gt;&gt; print(utc_dt)2015-05-18 09:05:12.377316+00:00 # astimezone()将转换时区为北京时间:&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))&gt;&gt;&gt; print(bj_dt)2015-05-18 17:05:12.377316+08:00 # astimezone()将转换时区为东京时间:&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt)2015-05-18 18:05:12.377316+09:00 # astimezone()将bj_dt转换时区为东京时间:&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt2)2015-05-18 18:05:12.377316+09:00 注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。 格式定义datetime格式定义 代码 说明 %Y 4位数的年 %y 2位数的年 %m 2位数的月 [01, 12] %d 2位数的日 [01, 31] %F %Y-%m-%d 简写形式；2012-04-18 %D %m/%d/%y 简写形式；04/18/12 %H 时间（24小时制） [00, 23] %I 时间（12小时制） [00, 12] %M 2位数的分钟 [00, 59] %S 秒 [00, 61] (秒60和61用于闰秒) %w 用整数表示的星期几 （星期天为第0天） [0, 6] %U 每年的第几周 [00, 53]。星期天被认为是每周的第一天，每年第一个星期天之前的那几天被认为是 “第0周” %W 每年的第几周 [00, 53]。星期一被认为是每周的第一天，每年第一个星期一之前的那几天被认为是 “第0周” %z 以+HHMM 或-HHMM 表示的UTC时区偏移量 特定于当前环境的日期格式 代码 说明 %a 星期几的简写 %A 星期几的全称 %b 月份的简写 %B 月份的全称 %c 完成的日期和时间；Tue 01 May 2012 04:20:57 pm %p 不同环境中的AM 或PM %x 适用于当前环境的日期格式 ；若在美国， “May 1 2012” 会产生 “05/01/2012” %X 适用于当前环境的时间格式； “04:24:12 PM” 【实战演练】输出为 月-日格式 时间序列pandas最基本的时间序列类型就是以时间戳为索引的Series； 当创建一个带有DatatimeIndex 的Series时，pandas就会知道该对象是一个时间序列 索引是 时间格式的字段；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书籍_2018年度]]></title>
      <url>%2F2018%2F02%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB_2018%E5%B9%B4%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[记录2018年度阅读的书籍。 [TOC] 类别 《书名》_作者 | 出版时间/ 购买时间 / 阅读时间 - 网址链接 （若时间点只有一个，表示阅读与购买时间为同一时段） 《book name》_author | 2011.09 / 2017-02 （注意两个时间的格式不一样） 一句话概括整本书的核心内容，最多不超过三句话。这个是原则。 互联网运营 《运营之光：我的互联网运营方法论与自白 2.0》_黄有璨 / 2017-12 / 2018-02 《小群效应》_徐志斌 / 2018-02 思维意识与生活态度 《精进》_采铜 / 2018-01 /2018-05 《人生定位》_[美] 艾.里斯 &amp; 杰克.特劳特 (AI Ries &amp; Jack Trout) |2011.09 / 2018-07]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书籍汇总]]></title>
      <url>%2F2018%2F02%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[2008-2017年度共阅读13个大类（不完全统计），共计161本，读书笔记98篇，罗辑思维音频若干（含2场时间的朋友）。 [TOC] 类别 《书名》_作者 |出版时间 / 购买时间 / 阅读时间 - 网址链接 （若只有一个时间点，则购买时间与阅读时间为同一时间段） 《原名》 - 原作者 一句话概括整本书的核心内容，最多不超过三句话。这个是原则。 关于一本书的概括，暂未做补充。 心理学、社会认知与发展史 - 21本 《社会心理学》_周晓虹 / 2009-09 《天下大道》_奥修 / 2009-11 《道德的理由》_詹姆斯.雷切尔斯 / 2009-12 《世界简史》_中山大学历史系 / 2009-12 《101个道德难题》_马丁.科恩 / 2010-01 《汤普森谈判学》_利·汤普森 / 2010-07 《潜规则：中国历史中的真实游戏》_吴思 / 2010-07 《中国大历史》_黄仁宇 / 2010-09 《赫逊河畔谈中国历史》_黄仁宇 / 2010-09 《社会学的想象力》_赖特.米尔斯 / 2010-10 《意识形态与乌托邦》_卡尔.曼海姆 / 2010-10 《影响力》_[美] 罗伯特.西奥迪尼 / 2015-03 《意志力》_[美] 罗伊.鲍迈斯特 / 2015-04 《沟通的艺术》_[美] 罗纳德.B.阿德勒 / 2015-12 《少有人走的路1：心智成熟的旅程》_ M.斯科特.派克(M.Scott Peck) / 2016-07 《稀缺：我们是如何陷入贫穷与忙碌的》_塞德希尔·穆来纳森(Sendhil Mullainathan) / 2016-10 《理性乐观派》_[英]马特.里德利(Matt.Ridley) / 2017-04 从经济学的角度解释了整个社会的发展。 《未来简史》_[以色列]尤瓦尔•赫拉丽(Yuval Noah Harari) / 2017-04 《文明是副产物》_郑也夫 / 2017-05 《代价论》_郑也夫 / 2017-06 《信任论》_郑也夫 / 2017-06 思维意识与生活态度 - 20本 《做人有学问》_李镇 / 2009-01 《开放你的人生》_王辉耀 /2010-03 《杠杆思考术》_[日] 本田直之 / 2011-3 《秘密》_朗达·拜恩(Rhonda Byrne) / 2012-03 《地头力：从结果出发思考问题》_[日] 细谷功 / 2014-05 《锻炼“地头力”：打造你的黄金自考力》_[日] 细谷功 / 2014-07 《高效能人士的七个习惯》_[美]史蒂芬·柯维 / 2014-11 《思考的艺术》_[美]文森特·赖安·拉吉罗(Vincent Ryan Ruggiero) / 2015-03 《每周工作4小时》_蒂莫西.费里斯 / 2016-07 《80/20法则》_[英] 理查德.科克 / 2016-08 《断舍离》_[日] 山下英子 / 2017-10 《怦然心动的人生整理魔法》_[日] 近藤麻理惠 / 2017-10 《人活到极致一定是素与简》_[日] 山口势子 / 2017-12 《麦肯锡教我的思考武器》_[日] 安宅和人 / 2017-12 《最重要的事只有一件》_[美] 加里.凯勒 &amp;杰伊.帕帕森(Gray Keller &amp; Jay Papasan) / 2017-12 《精要主义》_[英] 格雷戈.麦吉沃恩(Grey Mckeown) / 2017-12 《专注力：化简为繁的惊人力量》_[英] 于尔根.沃尔夫(Jurgen Wolff) / 2017-12 《每天最重要的2小时》_[美] 乔西.戴维斯(Josh Davis) / 2017-12 《精进》_采铜 / 2018-05 《人生定位》_[美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 (AI Ries &amp; Jack Trout) | 2011.09 / 2018-07 工作与学习方法 - 16本 《像咨询顾问一样思考》_王佑 / 2010-06 《金字塔原理》_巴巴拉·明托 / 2010-09 《用图表说话》_[美]基恩·泽拉兹尼(Gene Zelazny) / 2013-05 《餐巾纸的背面》_丹·罗姆 / 2014-12 《如何阅读一本书》_莫提默·J.艾德勒 &amp; 查尔斯·范多伦 / 2015-03 《读书经验分享 - 知乎Live》_李笑来 / 2017-04 《如何自学计算机专业课程 - 知乎Live》 / 2017-06 虽然标题是关于自学计算机课程，但很大部分内容是关于大脑对记忆与学习的机理。包括工作记忆与长期记忆，包括学习的过程是建立新知识与已有知识网络的连接，是重组神经元的过程。知识，必须形成网状结构的知识，才是有效的知识。这一部分对于更好地利用大脑特性学习新知识有很大帮助。 《麦肯锡方法》_艾森.拉塞尔 / 2017-07 （二刷） 《金字塔原理》_巴巴拉·明托 / 2017-06 （二刷） 《学习之道》_芭芭拉•奥克利(Barbara Oakley) / 2017-06 《刻意练习》_[美] 安德斯.艾利克森 &amp; 罗伯特.普尔(Anders Ericsson &amp; Robert Pool) / 2017-07 《练习的心态》_[美] 托马斯 M. 斯特纳 / 2017-07 《The Practicing Mind》_ Thomas M. Sterner 《麦肯锡精英的48个工作习惯》_[日] 户塚隆将 / 2017-07 《麦肯锡精英的39个工作习惯》_[日] 大岛祥誉 / 2017-07 《习惯的力量》_[美] 查尔斯.杜希格 / 2017-11 《The Power of Habit》_ Charles Duhigg 《思考，快与慢》_丹尼尔.卡尼曼 / 2017-10 个人与团队管理 - 19本 《卓有成效的管理者》_[美] 彼得·德鲁克 / 2008-12 《卡耐基精英之道》_[美] 戴尔.卡耐基 / 2009-01 《卡耐基沟通与人际关系》_[美] 戴尔.卡耐基 / 2009-05 《一分钟自我表现术》_杰夫 / 2009-06 《团队管理》_[美]马蒂·布隆斯坦 / 2009-07 《铁军：如何打造一支过得硬的团队》_程冲 / 2009-07 《有效沟通》_桑德拉黑.贝尔斯 / 2009-09 《有效沟通：管理者的沟通艺术》_余世维 / 2009-09 《他们为什么效忠希特勒》_英克.布罗德森 / 2009-10 《时间管理》_[美]波利·伯德 / 2009-12 《时间管理：高效人士的成功利器》_朱信凯 / 2009-12 《个人效率提升系统》_赵明 / 2009-12 《培训培训师：TTT全案》_刘永中 / 2010-01 《打造无敌团队》_[英] 莱斯利.雷 / 2010-02 《培训学习手册》_[美] 大卫.梅尔 / 2010-02 《高效团队24法则》_小文斯.隆巴迪 / 2010-06 《打造高绩效团队》_余世维 / 2010-06 《哈佛团队》_向洪 / 2010-06 《忠仆：领导就是服务》_詹姆斯.C.亨特 / 2010-06 企业发展与管理 《影响世界的西方管理思想》_斯图尔特.克雷纳 / 2009-02 《IBM营销革命》_保罗.甘布尔 / 2009-03 《门槛：创业，从准备到行动》_赵延忱 / 2009-09 《营销：来自世界一流企业的4C营销方案》_方全 / 2009-10 《新直销营销》_李野新 / 2009-10 《与成功签约：CCTV赢在中国创业自问》_CCTV赢在中国项目组 / 2009-10 《史玉柱点评创业》_CCTV赢在中国项目组 / 2009-10 《只有CEO才能做的事》_雷福礼 / 2009-11 《马云点评创业》_CCTV赢在中国项目组 / 2009-11 《牛根生创业人生》_CCTV赢在中国项目组 / 2009-11 《创业企业融资》_杰弗里.蒂蒙斯 / 2009-12 《战略与竞争分析：商业竞争分析的方法与技巧》_[加]弗莱舍 / 2010-03 《麦肯锡传奇》_伊丽莎白·哈斯·埃德莎姆 / 2010-04 《麦肯锡意识》_艾森·拉塞尔 / 2010-04 《麦肯锡方法》_艾森·拉塞尔 / 2010-04 《咨询学》_余明阳 / 2010-06 《顶级咨询》_卡尔弗特.马克汉姆 / 2010-07 《管理咨询行业指南》_苏格塔.比斯沃斯 / 2010-07 《打败麦肯锡》_王瑶 / 2010-07 《从优秀到卓越》_[美] 吉姆.柯林斯 / 2010-09 《追求卓越》_[美] 汤姆.彼得斯 / 2010-09 《咨询的谎言》_[美] 马丁.基恩 / 2012-03 《商业模式新生代》_亚历山大·奥斯特瓦德 / 2013-11 《竞争战略》_迈克尔·波特 (Michael E. Porter) / 2013-12 《市场营销原理》_菲利普·科特勒 &amp; 加里·阿姆斯特朗 / 2014-02 《领导梯队：全面打造领导力驱动型公司》_[美] 拉姆·查兰 / 2014-07 《从0到1》_[美] 彼得.蒂尔 / 2015-07 《参与感：小米口碑营销内部手册》_黎万强 / 2015-09 《星巴克：关于咖啡、商业和文化的传奇》_泰勒.克拉克(Taylor Clark) / 2016-06 《浪潮之巅》_吴军 / 2017-11 数据分析 - 16本 《深入浅出数据分析》_迈克尔.米尔顿 / 2016-09 《深入浅出SQL》_[美] 贝里(Beighley L.) / 2016-09 《商务与经济统计学》_詹姆斯·麦克拉夫(James T.McClave) / 2016-10 《R语言实战》_卡巴科弗(Robert I.Kabacoff) / 2016-10 《ggplot2：数据分析与图形艺术》_哈德利·威克姆(Hadley Wickham) / 2016-11 《精通Web Analytics 2.0》 / 2016-11 《数据挖掘导论》 / 2016-11 （未完） 《Python编程：从入门到实践》_[美] Eric Matthes / 2017-05 《利用Python进行数据分析》_Wes McKinney / 2017-05 《Python核心编程》_[美] Wesley J. Chun / 2017-12 《统计学习导论：基于R应用》_[美] 加雷斯.詹姆斯 &amp; 丹妮拉.威滕 / 2017-09 《An Introduction to Statistical Learning : with Application in R》_Gareth James &amp; Daniela Witten 《数据的本质》_车品觉 / 2017-10 《数学之美》_吴军 / 2017-11 《大数据时代》_维克托.迈尔.舍恩伯格 &amp; 肯尼斯.库克耶(Viktor.Mayer.Schonberger &amp; Kenneth.Cukier) / 2017-11 《智能时代》_吴军 / 2017-11 《精益数据分析》_[加] 阿利斯泰尔.克罗尔 &amp; 本杰明.尤科维奇(Croll, A. &amp; Yoskovitz, B) / 2017-11 从商业运作的角度阐述了不同行业运作的规则，并针对性地给出不同行业中所关注的核心指标。 经济学 - 6本 《世纪末金融风暴》_韩文高 / 2009-11 《小的是美好的》_E.F.舒马赫 / 2009-11 《经济学原理：微观经济学分册》_N.格里高利·曼昆 / 2010-04 《经济学原理：宏观经济学分册》_N.格里高利·曼昆 / 2010-04 《增长的困惑》_[英] 理查德.杜韦斯特 / 2012-02 《货币金融学》_费雷德里克.S.米什金(Frederic S. Mishkin ) / 2017-07 （未完） 投资理财 - 7本 《彼得·林奇的成功投资》_彼得·林奇 / 2009-11 《投资者的未来》_[美]杰里米.J.西格尔 / 2009-12 《漫步华尔街》_伯顿 G·马尔基尔 / 2009-12 《巴比伦富翁的理财课》_乔治·克拉森 / 2014-12 《富爸爸穷爸爸》_罗伯特·清崎 &amp; 莎伦·莱希特 / 2015-01 《小狗钱钱》_[德] 博多.舍费尔 / 2015-01 《The Millionaire Fastlane》_MJ.DeMarco / 2016-06 虽然是一本全英文书籍，但内容很好。 人物传记 - 7本 《马云创造：颠覆传统的草根创业者传奇》_杨艾祥 / 2008-12 《林肯》_[德] 艾密尔.鲁特维克 / 2009-01 《105亿传奇：黄光裕和他的国美帝国》_吴阿仑 / 2009-11 《杰克.韦尔奇自传》_[美]杰克.韦尔奇 / 2010-11 《史蒂夫.乔布斯传》_[美] 沃尔特.艾萨克森 / 2012-03 《你好，我是费曼》_[美]理查德.费曼(Richard P. Feynman) / 2017-07 《向死而生：我修的死亡学分》_李开复 / 2017-11 讲述的是李开复在诊断出患有癌症后，在治疗中关于对待人生的感悟，对于在事业、家人与生活之间的关系有了新的认识。 ​ 文学小说 - 12本 《莎士比亚四大悲剧》_[英] 威廉.莎士比亚 / 2010-02 《哈姆雷特》《奥赛罗》《李尔王》《麦克白斯》 《围城》_钱钟书 / 2010-03 《狼图腾》_姜戎 / 2010-10 《不能承受的生命之轻》_米兰·昆德拉(Milan Kundera) / 2011-03 《假如给我三天光明》_[美] 凯勒 / 2014-08 《何以笙箫默》_顾漫 / 2014-11 《活出生命的意义》_[美] 维克多.弗兰克尔 / 2015-03 《小王子》_[法] 圣埃克苏佩里 / 2015-05 《皮囊》_蔡崇达 / 2016-04 《离开前请叫醒我》_卢思浩 / 2017-03 《局外人》_[法] 加缪 / 2017-12 《看见》_柴静 / 2017-10 （未完） 哲学 - 4本 《超越神话：古希腊人的哲学智慧》_曹兴 / 2008-12 《逻辑学》_[德] 黑格尔 / 2009-02 《逻辑学基础教程》_南开大学哲学系 / 2009-02 《逻辑》_雍琦 / 2009-07 军事 - 4本 《二战十六大战役故事秘档全公开》_侯鲁梁 / 2009-03 《孙子兵法全集》_陈才俊 / 2012-03 《三十六计全集》_陈才俊 / 2012-03 《三十六计全鉴》_东篱子 / 2012-03 自然科学 - 1本 《狭义与广义相对论浅说》_[美] 阿尔伯特·爱因斯坦 / 2015-01]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据分析_组织架构]]></title>
      <url>%2F2018%2F02%2F04%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E6%95%B0%E6%8D%AE%E9%83%A8%E9%97%A8_%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84_20180204%2F</url>
      <content type="text"><![CDATA[S：对数据工作做了总结之后（分为两大模块：数据平台、数据使用），想了解当前社会对数据分析工作的定位是如何的；引发通过了解 数据分析部门所处的组织架构去认识 W：通过对组织架构的研究，去定义/剖析不同组织架构下数据分析部门当前所处的阶段与机制； B：达到状态：能够去辨别一家公司对数据分析工作的定位与重视度 在一个企业中，可能数据部门在一个公司中组织架构中的位置，决定了部门的定位和一些做的事情，数据部门所处的组织架构对数据价值实现是一个很重要因素。 [TOC] 数据部门发展的阶段这是一个必须要经历的过程。 数据工作的两大模块数据部门分成二个部门： 后端：数据仓库，大数据平台等； 前端，例如：数据分析，数据挖掘，数据产品等; 常见的部门架构分散式数据平台由技术部建设，技术没有数据分析/业务分析人员；这部分人员都分到各个业务块中。 技术部负责搭建大数据平台(在传统主要叫数据仓库)。目前大数据平台，如果比较大型的公司基本上会包括几块内容： 分布式：hadoop 平台; 实时计算: storm平台 内存计算：spark 平台 传统关系数据库 业务分析人员获取数据 向数据平台接口人提需求，最终以报表的形式获取数据。把业务方的进行转化，转为PRD文档，让ETL开发工程师，报表开发工程师实现 。【业务人员是没有访问数据仓库的权限的】 开放所有给业务人员进行去访问，业务可以自己访问部分数据，去写SQL去取数据。 适合情况： 在一些业务变化不快，或者业务相对不那么复杂的公司可能比较好。 对一些业务复杂，业务变化非常快的可能就不适合： 数据平台/仓库建议跟不上业务变化。造成数据仓库效率低，数据口径混乱。因为数据仓库架构离业务比较远，对业务理解不深。 业务数据分析师很多人的知识不能很有效沉淀下来。 这会导致业务要求为各个业务建议自己 “数据集市”，当这种数据集市我的时候，又会造成数据仓库负担中，各个业务方的数据“各大自为政”。最终公司数据混乱，后面大家对数据都摇头。 对于不把数据分析独立存在的公司，数据分析只是个数据展现工具，根本谈不上分析，而形成不了整体的营销能力. 集中式公司所有的数据相关都归到一个部门中。业务方有任何需要都会向数据部门提出，数据部门会在内部对这些需求和报表进行沟通，避免重复开发，也便于对需求进行总结。 优势：所有的数据都是一个部门出，相对来说数据的口径会比较统一; 劣势：如果部门组织的不好。会造成数据部门离业务比较远 ;有时候对于数据的思考不够深入，造成与业务部门的沟通成本上升。 混合式大数据平台建设由技术负责，他们核心是把数据平台建设的足够强大。 有一个比较大的数据部门，负责数据分析，挖掘，数据统一工作。一般来说这个部门会直接像管理层汇报，主要服务公司管理层;同时也会和业务方的数据分析师合作一起解决某个具体问题。 在业务方也会有自己的小数据分析团队。 这个数据团队主要服务由自己这个业务团队，同时也会和公司的数据部门有沟通和合作。 传统BI 问题：为什么传统BI没有达到今天互联网数据应用的高度呢? 在传统的BI中，更多只实现最底层价值。 $$ &lt; 数据存储技术与成本 \to 数据运算效率 \to 公司数据价值意识 \to 数据相关部门架构 &gt; $$ 传统的BI，更多是偏重数据仓库的架构，根据需求来帮报表。 在数据部门没有一批主动去思考业务，思考业务与数据关系的人。这种人很可能都是在业务方，他们更多把业务问题转为要看的报表，然后与数据部门沟通报表开发，数据部门收集需求沟通后，进行排期 对当前公司架构的思考组织架构：混合式的优化版 大数据平台、数据仓库由技术部门统一负责 各个业务团队成立独立的数据分析部门，进行数据分析、挖掘、数据统一工作。也是由专业的数据分析人员构成，而非业务端的人员担任。 优势：(1) 分析人员独立于业务部门，可以统一数据口径，并给出客观中立的报表； (2) 站在业务与后端IT 中间，作为两者最佳的构成桥梁，减少了沟通成本 劣势：一方面并没有真正贴近业务，另一方面偏离数据源有一定距离；一个是业务的理解，一个是资源分配与沟通；若处理不好，会进退两难；但若管理得当，是一个强有利的推进器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据分析_发展历史]]></title>
      <url>%2F2018%2F02%2F03%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F20_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2_20180203%2F</url>
      <content type="text"><![CDATA[数据分析的发展历史 数据分析基本概念 大师、企业家、权威机构； 求同，取精 驱动因素 为什么产生、为什么受到关注、为什么变得流行 发展阶段 特征、代表性观点/事件/人物、时间点 构成要素 模块、方面组成 模式类别 特点、典型代表、优劣势、适用情况 优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段 最佳实践 分模块 或者 分模式 数据只有结合了业务才是有价值的，数据体现可以用四个字词概括，看数据、用数据、依赖数据、数据变现。 http://www.afenxi.com/post/39570 看数据， 能然让业务准确、及时、完整的看到数据， 落地是在报表、取数等； 用数据， 业务上通过数据做出决策 ，落地是异常监控/专题分析； 依赖数据，数据嵌入到业务的日常流程中，通过数据挖掘高价值信息推进业务，落地点在数据产品，数据挖掘产品； 数据变现，利用数据来赚钱了，落地点可在外部数据平台，数据产品上； 在这整个环节中”数据分析师“是做什么呢？我们从分析师的日常工作来分析看，临时需求、报表、数据分析与模型、数据产品，数据挖掘这几个角度来聊一下； 临时需求，就是解决业务的一次性，临时的数据需求；报表，是根据业务的需要，对于常规且定期查看与分析的数据，形成report； 数据分析与模型，与业务一起沟通，分析业务上的各种问题，提供一些业务上的建议与取舍，根据业务需要搞一些挖掘模型等； 数据产品，是通过可视化的方式解决一些结构化（固化）业务问题；把数据分析模型、分析思路与数据结合、面向定向业务提供分析产品； 数据挖掘，数据直接作用到业务上，比如作弊用户、标签推荐、用户行为的定向引导； 导入方法 工作 &amp; 成果 数据人就要考虑在当前的业务状态中，该如何考虑对业务做到帮助与支持，或者是做数据的的人必须深入到业务中，如何深入呢，或者说是消息一定要灵通； 1、要与各种boss 1vs1 了解他们的想法。 2、参与到管理层的会议中，可以不用发言，但是要一定了解公司的管理层的理念、思路与战略、甚至是feature 的发布； 3、多的时数据人应该与运营在一起、一些活动、一些运营数据分析师也要参与进去也要尝试去一起做一下； 4、参与到公司的日常产品设计中去，在产品的立项阶段就去尝试获取信息； 数据挖掘 资料来源：《数据挖掘与数据化运营实战》 - 卢辉 ；http://www.chforce.com/books/datamining-om-by-data/index.html 基本概念数据挖掘是指从数据集合中自动抽取隐藏在数据中的那些有用信息的非平凡过程，这些信息的表现形式为规则、概念、规律及模式等。 数据挖掘融合了数据库、人工智能、机器学习、统计学、高性能计算、模式识别、神经网络、数据可视化、信息检索和空间数据分析等多个领域的理论和技术 驱动因素 发展阶段数据挖掘起始于20世纪下半叶，是在当时多个学科发展的基础上发展起来的。随着数据库技术的发展应用，数据的积累不断膨胀，导致简单的查询和统计已经无法满足企业的商业需求，急需一些革命性的技术去挖掘数据背后的信息。同时，这期间计算机领域的人工智能（Artificial Intelligence）也取得了巨大进展，进入了机器学习的阶段。因此，人们将两者结合起来，用数据库管理系统存储数据，用计算机分析数据，并且尝试挖掘数据背后的信息。这两者的结合促生了一门新的学科，即数据库中的知识发现（Knowledge Discovery in Databases，KDD）。1989年8月召开的第11届国际人工智能联合会议的专题讨论会上首次出现了知识发现（KDD）这个术语，到目前为止，KDD的重点已经从发现方法转向了实践应用。 数据挖掘（Data Mining）则是知识发现（KDD）的核心部分，它指的是从数据集合中自动抽取隐藏在数据中的那些有用信息的非平凡过程，这些信息的表现形式为：规则、概念、规律及模式等。 构成要素 模块、方面组成 数据挖掘融合了数据库、人工智能、机器学习、统计学、高性能计算、模式识别、神经网络、数据可视化、信息检索和空间数据分析等多个领域的理论和技术 统计分析 VS. 数据挖掘应用过程 统计分析的基础之一就是概率论，在对数据进行统计分析时，分析人员常常需要对数据分布和变量间的关系做假设，确定用什么概率函数来描述变量间的关系，以及如何检验参数的统计显著性 在数据挖掘的应用中，分析人员不需要对数据分布做任何假设，数据挖掘中的算法会自动寻找变量间的关系。 侧重点 - 解释 VS. 预测 统计分析在预测中的应用常表现为一个或一组函数关系式 （易于解释） 数据挖掘在预测应用中的重点在于预测的结果，很多时候并不会从结果中产生明确的函数关系式，有时候甚至不知道到底是哪些变量在起作用，又是如何起作用的。 （也无需知道） 最典型的例子就是“神经网络”挖掘技术，它里面的隐蔽层就是一个“黑箱”，没有人能在所有的情况下读懂里面的非线性函数是如何对自变量进行组合的。 结合应用针对具体的业务分析需求，先确定分析思路，然后根据这个分析思路去挑选和匹配合适的分析算法、分析技术，而且一个具体的分析需求一般都会有两种以上不同的思路和算法可以去探索，最后可根据验证的效果和资源匹配等一系列因素进行综合权衡，从而决定最终的思路、算法和解决方案。 模式类别 特点、典型代表、优劣势、适用情况 优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段 决策树 概念：建模过程类似一棵树的成长过程，即从根部开始，到树干，到分枝，再到细枝末节的分叉，最终生长出一片片的树叶。在决策树里，所分析的数据样本先是集成为一个树根，然后经过层层分枝，最终形成若干个结点，每个结点代表一个结论。 优势：易解释、高容错性 它所产生的一系列从树根到树枝（或树叶）的规则，可以很容易地被分析师和业务人员理解，而且这些典型的规则甚至不用整理（或稍加整理），就是现成的可以应用的业务优化策略和业务优化路径。 决策树技术对数据的分布甚至缺失非常宽容，不容易受到极值的影响。 应用：分类、预测 作为分类、预测问题的典型支持技术，它在用户划分、行为预测、规则梳理等方面具有广泛的应用前景，决策树甚至可以作为其他建模技术前期进行变量筛选的一种方法，即通过决策树的分割来筛选有效地输入自变量。 神经网络 概念：“神经网络” 就是通过输入多个非线性模型以及不同模型之间的加权互联（加权的过程在隐蔽层完成），最终得到一个输出模型。其中，隐蔽层所包含的就是非线性函数。 目前最主流的“神经网络”算法是反馈传播（Backpropagation），该算法在多层前向型（Multilayer Feed-Forward）神经网络上进行学习，而多层前向型神经网络又是由一个输入层、一个或多个隐蔽层以及一个输出层组成的 优势：自适应性、自组织性、高容错性 拥有特有的大规模并行结构和信息的并行处理等特点，因此它具有良好的自适应性、自组织性和高容错性，并且具有较强的学习、记忆和识别功能。 劣势：不可解释性 知识和结果的不可解释性，没有人知道隐蔽层里的非线性函数到底是如何处理自变量的 应用：分类、预测 在用户划分、行为预测、营销响应等诸多方面具有广泛的应用前景。 模型的重要因素： 层数 每层中输入变量的数量 联系的种类 联系的程度 转换函数，又称激活函数或挤压函数 回归 概念：回归（Regression）分析包括线性回归（Linear Regression），这里主要是指多元线性回归和逻辑斯蒂回归（Logistic Regression）。 ​ 多元线性回归主要描述一个因变量如何随着一批自变量的变化而变化，其回归公式（回归方程）就是因变量与自变量关系的数据反映。因变量的变化包括两部分：系统性变化与随机变化，其中，系统性变化是由自变量引起的（自变量可以解释的），随机变化是不能由自变量解释的，通常也称作残值。 用来估算多元线性回归方程中自变量系数的方法中，最常用的是最小二乘法，即找出一组对应自变量的相应参数，以使因变量的实际观测值与回归方程的预测值之间的总方差减到最小。 主要假设： 输入变量是确定的变量，不是随机变量，而且输入的变量间无线性相关，即无共线性。 随机误差的期望值总和为零，即随机误差与自变量不相关。 随机误差呈现正态分布 逻辑斯蒂回归，它又包括响应预测、分类划分等。凡是预测“两选一”事件的可能性（比如，“响应”还是“不响应”；“买”还是“不买”；“流失”还是“不流失”），都可以采用逻辑斯蒂回归方程。 因变量是介于0和1之间的概率 最大似然法是逻辑斯蒂回归所采用的参数估计方法，其原理是找到这样一个参数，可以让样本数据所包含的观察值被观察到的可能性最大。这种寻找最大可能性的方法需要反复计算，对计算能力有很高的要求。最大似然法的优点是在大样本数据中参数的估值稳定、偏差小，估值方差小。 关联规则 概念：关联规则数据挖掘的主要目的是找出数据集中的频繁模式（Frequent Pattern），即多次重复出现的模式和并发关系（Cooccurrence Relationships），即同时出现的关系，频繁和并发关系也称作关联（Association）。 应用关联规则最经典的案例就是购物篮分析（Basket Analysis），通过分析顾客购物篮中商品之间的关联，可以挖掘顾客的购物习惯，从而帮助零售商更好地制定有针对性的营销策略。 支持度（Support）和置信度（Confidence）是衡量关联规则强度的两个重要指标，它们分别反映着所发现规则的有用性和确定性。 支持度：规则X→Y的支持度是指事物全集中包含X∪Y的事物百分比。支持度主要衡量规则的有用性，如果支持度太小，则说明相应规则只是偶发事件。在商业实战中，偶发事件很可能没有商业价值； 置信度：规则X→Y的置信度是指既包含了X又包含了Y的事物数量占所有包含了X的事物数量的百分比。置信度主要衡量规则的确定性（可预测性），如果置信度太低，那么从X就很难可靠地推断出Y来 婴儿尿不湿→啤酒[支持度=10%，置信度=70%] 这个规则表明，在所有顾客中，有10%的顾客同时购买了婴儿尿不湿和啤酒，而在所有购买了婴儿尿不湿的顾客中，占70%的人同时还购买了啤酒。发现这个关联规则后，超市零售商决定把婴儿尿不湿和啤酒摆放在一起进行促销，结果明显提升了销售额，这就是发生在沃尔玛超市中“啤酒和尿不湿”的经典营销案例。 主要算法：Apriori （1）生成所有的频繁项目集。一个频繁项目集（Frequent Itemset）是一个支持度高于最小支持度阀值（min-sup）的项目集。 （2）从频繁项目集中生成所有的可信关联规则。这里可信关联规则是指置信度大于最小置信度阀值（min-conf）的规则。 应用：比如发现单词间的并发关系以及Web的使用模式 不但在数值型数据集的分析中有很大用途，而且在纯文本文档和网页文件中，也有着重要用途。 ​ 聚类 概念：针对几个特定的业务指标，可以将观察对象的群体按照相似性和相异性进行不同群组的划分。经过划分后，每个群组内部各对象间的相似度会很高，而在不同群组之间的对象彼此间将具有很高的相异度。 方法：算法可以分为划分的方法（Partitioning Method）、层次的方法（Hierarchical Method）、基于密度的方法（Density-based Method）、基于网格的方法（Grid-based Method）、基于模型的方法（Model-based Method）等，其中，前面两种方法最为常用。 划分的方法（Partitioning Method），当给定m个对象的数据集，以及希望生成的细分群体数量K后，即可采用这种方法将这些对象分成K组（K≤m），使得每个组内对象是相似的，而组间的对象是相异的。 常用的划分方法是K-Means方法，其具体原理是：首先，随机选择K个对象，并且所选择的每个对象都代表一个组的初始均值或初始的组中心值；对剩余的每个对象，根据其与各个组初始均值的距离，将它们分配给最近的（最相似）小组；然后，重新计算每个小组新的均值；这个过程不断重复，直到所有的对象在K组分布中都找到离自己最近的组。 层次的方法（Hierarchical Method）则是指依次让最相似的数据对象两两合并，这样不断地合并，最后就形成了一棵聚类树。 应用：既可以直接作为模型对观察对象进行群体划分（为业务方的精细化运营提供具体的细分依据和相应的运营方案建议）；又可在数据处理阶段用作数据探索的工具，包括发现离群点、孤立点，数据降维的手段和方法，通过聚类发现数据间的深层次的关系等。 ​ ​ 贝叶斯方法 概念：贝叶斯分类方法（Bayesian Classifier）是非常成熟的统计学分类方法，它主要用来预测类成员间关系的可能性。比如通过一个给定观察值的相关属性来判断其属于一个特定类别的概率。贝叶斯分类方法是基于贝叶斯定理的，已经有研究表明，朴素贝叶斯分类方法作为一种简单贝叶斯分类算法甚至可以跟决策树和神经网络算法相媲美。 $$P(H|X) = {P(H|X)P(X) \over P(X)}$$ 其中，X表示n个属性的测量描述；H为某种假设，比如假设某观察值X属于某个特定的类别C；对于分类问题，希望确定P(H|X)，即能通过给定的X的测量描述，来得到H成立的概率，也就是给出X的属性值，计算出该观察值属于类别C的概率。因为P(H|X)是后验概率（Posterior Probability），所以又称其为在条件X下，H的后验概率。 举例来说，假设数据属性仅限于用教育背景和收入来描述顾客，而X是一位硕士学历，收入10万元的顾客。假定H表示假设我们的顾客将购买苹果手机，则P(H|X)表示当我们知道顾客的教育背景和收入情况后，该顾客将购买苹果手机的概率；相反，P(X|H)则表示如果已知顾客购买苹果手机，则该顾客是硕士学历并且收入10万元的概率；而P(X)则是X的先验概率，表示顾客中的某个人属于硕士学历且收入10万元的概率；P(H)也是先验概率，只不过是任意给定顾客将购买苹果手机的概率，而不会去管他们的教育背景和收入情况。 从上面的介绍可见，相比于先验概率P(H)，后验概率P(H|X)基于了更多的信息（比如顾客的信息属性），而P(H)是独立于X的。 概念：朴素贝叶斯分类法（Naive Bayesian Classifier）。如果给定数据集里有M个分类类别，通过朴素贝叶斯分类法，可以预测给定观察值是否属于具有最高后验概率的特定类别，也就是说，朴素贝叶斯分类方法预测X属于类别Ci时，表示当且仅当 $$P(C_i|X) &gt; P(C_j|X) ; 1 \le j \le m， j \ne m$$ 此时如果最大化P(Ci|X)，其P(Ci|X)最大的类Ci被称为最大后验假设，根据贝叶斯定理 $$P(C_i|X) = { P(X|C_i)P(C_i) \over P(X)}$$ 可知，由于P(X)对于所有的类别是均等的，因此只需要P(X|Ci)P(Ci)取最大即可。为了预测一个未知样本X的类别，可对每个类别Ci估算相应的P(X|Ci)P(Ci)。样本X归属于类别Ci，当且仅当 P(Ci|X)＞P(Cj|X)1≤j≤m，j≠i 应用：分类 支持向量机 概念：支持向量机以结构风险最小为原则。在线性的情况下，就在原空间寻找两类样本的最优分类超平面。在非线性的情况下，它使用一种非线性的映射，将原训练集数据映射到较高的维上。在新的维上，它搜索线性最佳分离超平面。使用一个适当的对足够高维的非线性映射，两类数据总可以被超平面分开。 设给定的训练样本集为{(x1,y1),(x2,y2),…,(xn,yn)}，其中xi∈Rn,y∈{-1,1}。 再假设该训练集可被一个超平面线性划分，设该超平面记为(w,x)+b=0。 距离超平面最近的一类向量被称为支持向量（Support Vector），一组支持向量可以唯一地确定一个超平面。通过学习算法，SVM可以自动寻找出那些对分类有较好区分能力的支持向量，由此构造出的分类器则可以最大化类与类的间隔 优势：较好的适应能力和较高的分类准确率。 应用：分类、预测 主成分分析 概念：主成分分析会通过线性组合将多个原始变量合并成若干个主成分，这样每个主成分都变成了原始变量的线性组合。 这种转变的目的，一方面是可以大幅降低原始数据的维度，同时也在此过程中发现原始数据属性之间的关系。 步骤： 1）通常要先进行各变量的标准化工作，标准化的目的是将数据按照比例进行缩放，使之落入一个小的区间范围之内，从而让不同的变量经过标准化处理后可以有平等的分析和比较基础。 2）选择协方差阵或者相关阵计算特征根及对应的特征向量。 3）计算方差贡献率，并根据方差贡献率的阀值选取合适的主成分个数。 4）根据主成分载荷的大小对选择的主成分进行命名。 5）根据主成分载荷计算各个主成分的得分。 因子分析：将主成分进行推广和延伸即成为因子分析（Factor Analysis），因子分析在综合原始变量信息的基础上将会力图构筑若干个意义较为明确的公因子；也就是说，采用少数几个因子描述多个指标之间的联系，将比较密切的变量归为同一类中，每类变量即是一个因子。之所以称其为因子，是因为它们实际上是不可测量的，只能解释。 主分成分析 VS. 因子分析 （主成分分析是因子分析的一个特例） 主成分分析会把主成分表示成各个原始变量的线性组合，而因子分析则把原始变量表示成各个因子的线性组合。 主成分分析的重点在于解释原始变量的总方差，而因子分析的重点在于解释原始变量的协方差。 在主成分分析中，有几个原始变量就有几个主成分，而在因子分析中，因子个数可以根据业务场景的需要人为指定，并且指定的因子数量不同，则分析结果也会有差异。 在主成分分析中，给定的协方差矩阵或者相关矩阵的特征值是唯一时，主成分也是唯一的。但是在因子分析中，因子不是唯一的，并且通过旋转可以得到不同的因子。 应用：数据处理、降维、变量间关系的探索 假设检验 概念：假设检验的基本原理就是小概率事件原理，即观测小概率事件在假设成立的情况下是否发生。如果在一次试验中，小概率事件发生了，那么说明假设在一定的显著性水平下不可靠或者不成立；如果在一次试验中，小概率事件没有发生，那么也只能说明没有足够理由相信假设是错误的，但是也并不能说明假设是正确的，因为无法收集到所有的证据来证明假设是正确的。 假设检验的结论是在一定的显著性水平下得出的。因此，当采用此方法观测事件并下结论时，有可能会犯错，这些错误主要有两大类： 第Ⅰ类错误：当原假设为真时，却否定它而犯的错误，即拒绝正确假设的错误。犯第Ⅰ类错误的概率记为α，通常也叫α错误，α=1-置信度。 第Ⅱ类错误：当原假设为假时，却肯定它而犯的错误，即接受错误假设的错误。犯第Ⅱ类错误的概率记为β，通常也叫β错误。 上述这两类错误在其他条件不变的情况下是相反的，即α增大时，β就减小；α减小时，β就增大。α错误容易受数据分析人员的控制，因此在假设检验中，通常会先控制第Ⅰ类错误发生的概率α，具体表现为：在做假设检验之前先指定一个α的具体数值，通常取0.05或0.01，也可以取0.1或0.001。 应用：运营效果的评估 大数据平台基本概念 大师、企业家、权威机构； 求同，取精 驱动因素 为什么产生、为什么受到关注、为什么变得流行 数据产品的产生​ 互联网企业随着数据更加逐渐被重视，分析师、数据开发在面对大量的数据需求、海量的临时需求疲惫不堪，变成了资源的瓶颈，在当时的状态传统的各类的Report、Olap 工具都无法满足互联网行业个性化的数据需求。开始考虑把需求固定化变为一个面向最终用户自助式、半自助的产品来满足快速获取数据&amp;分析的结果，当总结出的指标、分析方法(模型)、使用流程与工具有机的结合在一起时数据产品就诞生了。 ​ 数据产品按照面向的功能与业务可以划分为面向平台级别的工具型产品、面向用户端的业务级数据产品。 ​ 按照用户分类可以分为面向内部用户数据产品，面向外部用户个人数据产品、商户(企业)数据产品。​ 面向平台级别有数据质量、元数据、调度、资管配置、数据同步分发等等。 发展阶段 特征、代表性观点/事件/人物、时间点 非互联网时代自从数据仓库发展起来到现在，基本上可以分为五个时代、四种架构 约在1991年前的全企业集成 1991年后的企业数据集成EDW时代 1994年-1996年的数据集市 1996-1997年左右的两个架构吵架 1998年-2001年左右的合并年代 五个时代划分是以重要事件或代表人物为标志： 在企业数据集成EDW时代其重要代表人物是Bill Inmon 代表作数据仓库一书，更重要是他提出了如何建设数据仓库的指导性意见与原则。他遵循的是自上而下的建设原则，这个导致后来数据仓库在千禧年传到中国后的几年内，几个大实施厂商都是遵守该原则的实施方法，后来的数据仓库之路等各种专业论坛上针对数据仓库ODS-EDW的结构讨论 在数据集市年代其代表人物是Ralph kilmball，他的代表作是”The Data Warehouse Toolkit“，在数据仓库的建设上Ralph kilmball 提出的是自下而上的建设方法，刚好与Bill Innmon的建设方法相反，这两种架构方式各有千秋，所以就进入了争吵时代。 Bill Inmon 提出的CIF（corporation information factory） 架构模式、这也算是数据仓库的第三代架构，其架构特点是把整个架构划分为不同层次，把每一层次的定义与功能都详细的描述下来，从04年后国内的很多数据仓库架构、甚至互联网刚开始搞数据平台数据仓库架构模式也是这一种。 ETL 代指数据从不同源到数据平台的整个过程，ETL Mapping 可理解为 数据加工算法， 互联网时代数据源：多样化​ 做数据的人，从非互联网进入到互联网最显著的特点是面对的数据源类型忽然多了起来，在传统企业数据人员面对的是结构化存储数据，基本来自excel、表格、DB系统等，在数据的处理技术上与架构上是非常容易总结的，但是在互联网因为业务独特性导致了所接触到的数据源特性多样化，网站点击日志、视频、音频、图片数据等很多非结构化快速产生与保存 ​ 目前最火热的移动互联网,大家都在通过自己的手机、平板去访问网站、购物等所以每个人都是数据的生产者，移动用户在使用习惯上呈现移动化、碎片化，以至于业务特性、商业模式比传统互联网又有显著差别, 用户在不同位置需求是不同的、使用APP 也是不同的、手机终端类型也是多样化。这些差异性比较导致移动互联网的数据与传统的互联网时代又产生显著差异性。 例如买家通过Pc购物从浏览物品到支付可能在很短时间内完成，但是通过手购物碎片化就显得多一些，可能在某个空余时间浏览物品，保存或放入购物车，等有时间在去做支付。大约在2009年到2012年之间做用户行为分析感觉很多原有网页端拍下物品去支付，逐渐转为PC端下单通过移动端支付。 表 - 不同时代数据源的对比 行业域 非互联网 互联网 移动互联网 数据来源(相对于数据平台来讲) 结构化各类数据库(DB系统)、结构化文本、Excel表格等，少量word Web、自定义、系统的日志，各类结构化DB数据、长文本、视频 主要是来自网页 除了互联网那些外还含有大量定位数据、自动化传感器、嵌入式设备、自动化设备等 数据包含信息 CRM客户信息、事务性 ERP/MRPII 数据、资金账务数据 等。 除了传统企业数据信息外，还含有用户各类点击日志、社交数据、多媒体、搜索、电邮数据等等 除了传统互联网的数据外，还含有Gps、穿戴设备、传感器各类采集数据、自动化传感器采集数据等等 数据结构特性 几乎都是结构化数据 非结构化数据居多 非结构化数据居多 数据存储/数据量 主要以DB结构化存储为主，从几百兆到 百G级别 文件形式、DB形式，流方式、 从TB 到PB 文件形式、流方式、DB范式，非结构化 从TB 到PB 产生周期 慢，几天甚至周为单位 秒或更小为单位 秒或更小为单位 对消费者行为采集与还原 粒度粗 粒度较细 粒度非常细 数据价值 长期有效 随着时间衰减 随着时间快速衰减 单位时间内数据聚合度 高度聚合 聚合度低 聚合度很低 数据平台的用户 阶段1：在2008年-2011年初。建设与使用上与非互联网数据平台有这蛮大的相似性，主要相似点在数据平台的建设角色、与使用到的技术上。 老板们、运营的需求主要是依赖于报表、分析报告、临时需求、商业智能团队的数据分析师去各种分析、临时需求、挖掘，这些角色是数据平台的适用方。 ETL开发工程师、数据模型建模、数据架构师、报表设计人员 ，同时这些角色又是数据平台数据建设与使用方。 数据平台的技术框架与工具实现主要有技术架构师、JAVA 开发等。 用户面对是结构化的生产数据、PC端非结构化log等 数据。 ELT的数据处理方式(备注在数据处理的方式上，由传统企业的ETL 基本进化为ELT)。 阶段2：约在2011年到2014 年。数据产品的诞生。互联网的数据平台除了受到技术、数据量的驱动外，同时还来自数据产品经理梳理用户的需求按照产品的思维去构建并部署在了数据的平台上。随着数据平台的建设逐渐的进入快速迭代期，数据产品、数据产品经理这两个词逐渐的升温以及被广泛得到认可，同时数据产品也随着需求、平台特性分为面向用户级数据产品、面向平台工具型产品两个维度分别去建设数据平台。 企业各个主要角色都是数据平台用户。 各类数据产品经理(偏业务数据产品、偏工具平台数据产品)推进数据平台的建设。 分析师参与数据平台直接建设比重增加。 数据开发、数据模型角色都是数据平台的建设者与使用者(备注：相对与传统数据平台的数据开发来说，逐渐忽略了数据质量的关注度，数据模型设计角色逐渐被弱化)。 用户面对是数据源多样化，比如日志、生产数据库的数据、视频、音频等非结构化数据。 原有ETL中部分数据转换功能逐渐前置化，放到业务系统端进行(备注：部分原有在ETL阶段需要数据标准化一些过程前置在业务系统数据产生阶段进行，比如Log 日志。 移动互联网的日志标准化。 阶段3：从经营、分析的诉求重点转为数据化的精细运营上，对数据的粒度要求由高汇总逐渐转为过程化细粒度明细数据。 随着数据应用的深入，用数据往往不知道数据的口径与来源，加工数据的不知道业务含义，不同部门口径又是不一样，有的从交易来、有的从账务来。这里数据使用与数据加工上就出现了”断层”。有时在层级与功能部门前边也可能存在一个断层，对数据价值的内在衡量是不一样的，角色不一样，对于数据价值的的看法也就不同。 用数据的一些角色(分析师、运营或产品)会自己参与到从数据整理、加工、分析阶段。 当数据平台变为自由全开放，使用数据的人也参与到数据的体系建设时，基本会因为不专业型，导致数据质量问题、重复对分数据浪费存储与资源、口径多样化等等原因。此时原有建设数据平台的多个角色可能转为对其它非专业做数据人员的培训、咨询与落地写更加适合当前企业数据应用的一些方案等。 给用户提供的各类丰富的分析、取数的产品，简单上手的可以使用。 原有ETL、数据模型角色转为给用户提供平台、产品、数据培训与使用咨询。 数据分析师直接参与到数据平台过程、数据产品的建设中去。 用户面对是数据源多样化，比如日志、生产数据库的数据、视频、音频等非结构化数据。 比如说她，是银行的一名普通职员，每天的任务是结算、结汇，从早到晚都在跟数据打交道；因为只用整理好的数据，所以自然不在乎也不注意，数据是如何来的；整个总结下来是，用数据的人不知道数据哪里来的，做数据的人不知道数据有什么用处；回忆了下，这还真是一个普遍的现象； 构成要素 模块、方面组成 数据模型 在互联网时代被弱化的数据模型 在传统数据平台要背后有一个完整数据仓库团队去服务业务方，业务方嗷嗷待哺的等待被动方式去满足。中低层数据基本不会对业务方开放，所以不管数据模型采用何种建模方式，主要满足当时数据架构规划即可。 互联网业务的快速发展使得大家已经从经营、分析的诉求重点转为数据化的精细运营上，如何做好精细化运营问题上来，当资源不够时用户就叫喊，甚至有的业务方会挽起袖子来自己参与到从数据整理、加工、分析阶段。 模式类别 特点、典型代表、优劣势、适用情况 优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段 最佳实践 分模块 或者 分模式 导入方法 工作 &amp; 成果 数据产品基本概念要想把数据产品定义清楚，要拆分成 “数据”、“产品” 两个维度来看。 “产品” 是一组将输入转化为输出的相互关联或相互作用的活动的结果，即“过程” 的结果“。在经济领域中,通常也可理解为组织制造的任何制品或制品的组合。产品的狭义概念:被生产出的物品；产品的广义概念:可以满足人们需求的载体。 互联网产品的概念是从传统意义上的“产品”延伸而来的，是在互联网领域中产出而用于经营的商品，它是满足互联网用户需求和欲望的无形载体。简单来说，互联网产品就是指网站为满足用户需求而创建的用于运营的功能及服务，它是网站功能与服务的集成。大家可以分析下百度、腾讯、新浪、优酷、谷歌、facebook 各自的“产品”是什么？ 移动互联网产品又是什么呢？我是没有找到比较贴切的概念，只好依照自己简单的想象“已移动设别、网络为基础，构建满足人们的需求而创造出来的功能与服务”，例如基于手机、平板设备上的各种App，微信、手机百度、ingress手游、网易客户端等。 所谓的产品，简单讲就是满足人们某个需求、或解决某个问题的东西。 发展阶段自1954年计算机用于工资处理以后，一直到2016年的今天，企业在信息化处理上得到了长足的发展。在这个发展中经历过了数据处理系统、Mis管理系统、决策支持、商业智能。 DSS决策支持Dss决策支持系统是建立在对传统企业历史数据集成基础上的数据探索应用，自从数据仓库的出现给对企业的决策支持注入了新的活力，发展到现在的互联网、移动互联网对数据的应用又是一个崭新阶段。 在20世纪60年到70年，决策中往往是需要查询多种异构数据源的业务系统、参考外部的数据，进行大量的数据分析后才能做出相关的决策来。 进入到20世纪80年代后，随着计算机技术发展、各类数据统计分析的工具逐步健全，尤其是数据仓库的技术发展给传统企业的决策支持系统带来了更大的便利性。传统企业更多的是围绕着日常经营去做经营分析，比如财务绩效状况、资产运营状况、偿债能力状况、发展能力状况等。 商业智能商业智能（Business Intelligence，简称BI）的概念最早是Gartner Group 的 Howard Dresner在1996 年提出来，传到国内有将之翻译为”商业智能”或”商务智能”。商业智能的应用领域典型电信、银行、保险、零售等，所有建立了数据仓库的企业其商业智能建设的主要目标是企业决策支持。商业智能通过对信息技术的运用在不同层面为战略、决策提供新的支持：提升决策者洞察力以及支持信息获取与分析。 在传统企业的商业智能时代，我个人对其的认识是商业智能本来是把数据分析和统计运算的结果以多角度的方式存储，然后在OLAP、Report平台上形成一个个面向不同业务需要的数据集市以可视化的展现，让公司的管理层可以通过看及时和合适方式展示出来的信息来决策，让基层可以用统计运算后的数据进行经营分析与企业日常运作。 这种方式的核心是Bill Inmon 、Ralph Kimball的数据仓库Data Warehouse与Codd创造OLAP一词，E.F.Codd发明了在线分析处理（OLAP）一词，来表示多维分所结合的模式，为客户提供OLAP 平台，通过开发一些Report、Dashboard，后台通过ETL 自动刷新数据。 其中ETL工具在当时使用的是Datastage、Informatica、微软Dts或自己开发的脚本等系列来做数据的清洗、转换、加载，而OLAP 平台基本上为BO、Congos、Oracle 等几家的OLAP引擎与报表设计平台。在数据仓库 Data warehouse 中大家可以看到DW层为存储、管理数据设计的模型、数据集市中为 OLAP 而设计的模型。其中数据集市的数据就是数据仓库各层的数据Join与Aggregate的数据集合。 传统的数据团队的困惑在盲目的跟着需求开发，导致开发成果无法确认是否有用、够用，也无法避免无休止的需求变更，导致系统开发成本高、周期长、失败率居高不下。这样的数据平台最大的特点是庞大，初次使用感觉功能非常新鲜，但是在面对具体需求时使用起来难用，无法真正的解决问题。根本没有系统化、产品化，只是一堆数据的堆砌，僵死的报表或cube 开发、设计与开发与业务脱节非常严重，没有任何衔接可言。 ——–分割线——– 随着时间的发展，业界听到的BI的声音越来越少了，反而是对探索数据的价值的数据分析、数据挖掘独立的声音出现，因为早期传统企业的BI在这件上非常吃力，在过去只是简单从不同角度的堆积数据看统计指标已经不适应决策要看原因，要看影响的程度，执行层面要根据数据分析、挖掘精确来执行。 比如过去我们只是看商场的不同品牌的货物卖出多少，在现在要看商品在一天的那个时间段卖的好、摆放哪个位置卖的好、什么样的顾客容易买，客户总消费多少钱，客户订单次数，客户平均客单价、客户最近订单时间等等。 初BI刚进入企业眼前的时候，认为BI可以做很多厉害的事情，各种智能化。随着时间推移，BI从天上掉到了地下，90%多的企业只剩下数据集成和报表生成部门。目前一般企业普遍采用的办法是由业务部门提出分析需求，让BI部门统计和分析数据出结果，这样的组合看似合理，却有很多隐患。 记得有家公司组建自己的BI团队前，曾经去寻找多家第三方企业来实BI，建立了数据模型和数据处理，交付物开发出各个业务线的需求报表，按照会员维度的日报、周报、月报，商户维度的日报、周报、月报。然后呢，业务上尝鲜几天时还挺爽，随后越来越少用直至不用，因为随着堆积迭代无法满足后来的业务需求，其主要数据质量有问题，每个报表数据经常不准、报表上根本看不出什么业务问题来，需要多张报表数据下载进一步加工，这是典型的不深入了解业务而导致数据模型、数据报表堆砌效应引起的。 当时大多数BI只能发挥不到1/3的作用，所受限制在于业务与数据的反复磨合，还有数据洞察与整合的客观的业务需要代沟，所谓的数据驱动只是停留在数据与业务分开干的阶段。 数据运营大家已经从经营、分析的诉求重点转为数据化的精细运营上。随之而来的面临创新压力、如何做好精细化运营是当今企业遇到的问题。比如一款产品，想在互联网生存下去， 用户是基础，没有用户的产品或许可以自娱自娱自乐，否则将会面临一个问题，如何拉新、如何研究新用户，如何根据不同的用户习惯来调整产品。 对于产品的新用户，使用时会遇到各种问题，产品运营就必须去关注、去分析、以及去解决，这些过程都是需要数据来衡量与定位的。如果整个公司都处在一种由之前简单粗暴运营向经营分析乃至数据驱动的运营，必然会造成数据需求暴增。 【数据产品产生的原因】 数据化运营对数据需求量越来越大，分析师、数据开发在面对大量的数据需求、海量的临时需求疲惫不堪，变成了资源的瓶颈， 用户其聚焦在无法快速的响应日常需求其表现为，做数据的已经无法满足当前业务日益增长的数据需求。 互联网企业在运营上精细化已经对数据的粒度要求由高汇总逐渐转为过程化细粒度明细数据。而传统的各类的Report、OLAP 工具都无法满足互联网行业个性化的数据需求。 统计过某公司近两个月分析师们的工作内容,背景是从3月份-5月份大家在邮件、需求登记管理平台等内容。大约覆盖分析师3个月工作85%左右，临时需求在69.44%之间，产品发布评估占到 8.89%、周期性需求为（新业务日报周报）6.11%、专题分析8%、数据类项占比为6.67%。这个团队的分析师平均每月工作天数如果全饱和，单纯临时需求总共消耗分析师超过140%时间，均超过35%人月，分析师没有一点时间搞其他的。变成了纯粹人肉取数机，更何况分析师还有其它日常工作、专题分析等，更不要说让分析师更有价值。 当数据平台、数据分析师想摆脱临时需求的困扰，提高自身的价值时，开始考虑把需求固定化变为一个面向用户自助式、半自助的产品来满足快速获取数据&amp;分析的结果，当总结出的指标、分析方法（模型）、使用流程与工具有机的结合在一起时候，适合互联网时代的一类数据产品就诞生了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R转战Python]]></title>
      <url>%2F2018%2F02%2F01%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR%E8%BD%AC%E6%88%98Python_20180201%2F</url>
      <content type="text"><![CDATA[从R转战Python：这些包你一定要知道！ 统计学习 R包glm，knn，randomForest，e1071 —&gt; Python模块scikit-learn R中机器学习算法被进行分割，然后以各种包的形式存放，这意味着除非具有单个（或一组）能够执行一些公共算法的机器学习库，否则每个算法都会存在单独的包中。看着这些复杂、但又很清楚的算法时感觉会有点不错，但当日复一日的在算法之间来回切换时，恐怕就会觉得不适了，Python中的scikit-learn模块很好的处理了这个问题。具体的说，scikit-learn提供了一组常见的ML算法，所有算法都在同一个API下，这使得LogisticRegression和GradientBoostingMachines之间可以直接切换。 数据处理 R包reshape/reshape2,plyr/dplyr —&gt; Python模块 pandas Pandas继承了R中数据变换的较好部分，并且把它转变成一个Python包。该包包括了python中数据框的实现以及修改和重构数据框的方法。基本上它继承了reshape/reshape2和plyr/dplyr并且python化它。 字符串 stringr -&gt; nothing stringr 实在是个神器。它写得很棒，性能也很好（至少我这么认为），而且很方便安装（不要小看这一点，如果人们无法安装你的软件，那么开发就没有意义）。关于stringr 的自卖自夸就结束了。好消息是Python的字符串功能很强大，你甚至不需要一个单独的字符串库！它有超棒的内置正则表达式库，re，和内置的字母串元库，叫string。你太幸运了，Python自带了全部字符串相关的功能。 动态报告 R包Knitr —&gt; Python模块 Jupyter Knitr是一种使用R创建可重现和高度可视化分析的好方法。它已经成为Rtudio中一种稳定的功能。在Python世界中，最类似的包是Jupyter。Jupyter笔记本提供了一个用于Python编程（和其他语言）的交互式环境，专注于再现和可视化—它甚至有针对于R的插件。 数据库连接 R包SQLdf—&gt; Python模块 pandasql Sqldf是SQL用户在熟练操作数据的伟大的方式。当我第一次开始学R时，我自己用的就是这个包。当时，Yhat实际上创建了类似的Python包，称为pandasql。相同的概念：对你的数据框写入SQL查询命令，获取数据框！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_安装设置&jupyter]]></title>
      <url>%2F2018%2F01%2F24%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE%26Jupyter%2F</url>
      <content type="text"><![CDATA[Anaconda安装 ‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 这个问题本质其实就是，windows的cmd并不能识别python这个符号（即无法识别这个符号是一个可执行程序），因为windows这里也是类似的，遇到一个字符，先会在默认path路径查询这个符号是不是一个可执行程序 右键我的电脑-&gt;属性-&gt;高级系统配置-&gt;点击高级一栏，在这里栏点开环境变量-&gt;在系统变量PATH加入python的安装路径即可，比如我的就是D:\Python27 pip不是内部或外部命令，也不是可运行的程序 添加Python的Script 到环境变量；在Path后面追加一下内容(Path： 不要复制进去) Path:;C:\python;C:\Python\Scripts 模块安装 查看Python版本 1234567&gt; cmd&gt; python -v &gt;&gt; # 或者&gt; cmd&gt; python --version&gt; pip 安装与卸载 安装好Anaconda后，就默认安装了包管理工具pip 在命令提示符（cmd）窗口中使用命令pip install xxx（xxx表示要安装的包或模块名）。 12345pip install numpy # 安装pip install -U PackageName # 更新pip uninstall PackageName # 移除pip search PackageName # 搜索pip help # 帮助 conda 安装 下载文件安装 若一种方法失败，可尝试用另一种方式 直接下载包或模块的安装文件，然后手动安装 PyPI-the Python Package Index https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml Python Extension Packages PyPI-the Python Package Index 在上面右上角红线框住的search中输入你要下载的包或模块名，即可进入下载页面。下载的是压缩文件 解压 在命令提示符窗口中，使用cd进入到解压后的文件的路径下 输入命令python setup.py install 123cmd cd /d G:\Downloads\Chromepython setup.py install ​ Python Extension Packages 直接把文件拷贝到 $python_dir/Lib/site packages 在命令提示符窗口中，转到指定路径（.whl安装文件的路径） pip install .whl 文件名 site_packages 用来存放第三方库 123cmdcd /d G:\Downloads\Chromepip install 单文件模块 直接把文件拷贝到 $python_dir/Lib/site packages 常见报错 Microsoft Visual C++ 14.0 is required. 往往并不是缺少 Visual 2015 ；而是缺少某个依赖包 模块使用 获取模块地址1234567import a_moduleprint a_module.__file__# 上述代码将范围 .pyc 文件被加载的路径，如果需要跨平台解决方案，可用下面代码：import ospath = os.path.dirname(amodule.__file__) 导入与移除模块123456# 导入 import pandas as pdfrom pandas import *# 移除del pd 连接数据库库 MySQL需要MySQLdb，SQL Server需要pymssql。两个模块大同小异，都遵循Python Database API 必须先下载pymssql 模块，才能使用；http://www.pymssql.org/en/stable/ 安装pymssql好之后开工了。如果是连接本地的SQL Server需要在 SQL Server Configuration 中打开TCP/IP协议 12345678910111213#coding=utf-8import pymssqlconn = pymssql.connect(host='127.0.0.1',user='sa', password='hello',database='NPKW', charset="utf8")#查看连接是否成功print conncursor = conn.cursor()sql = 'select * from contacts'cursor.execute(sql)#用一个rs变量获取数据rs = cursor.fetchall()print rs [(1, u’20111612210028’, u’ettingshausen’, u’’, u’’, u’’, u’’, u’’, u’’, u’’, u’’, u’’)] SQL Server Python Database API，只需要了解Connection Objects和Cursor Objects的常用方法。 基本的步骤就是： 使用connect创建连接对象 connect.cursor创建游标对象，SQL语句的执行基本都在游标上进行 cursor.executeXXX方法执行SQL语句，cursor.fetchXXX获取查询结果等 通过cursor获取数据，具体可以是一次获取所有数据，也可以是一次获取一行。 整个结果集是元组列表，就是list类型的，而每一条记录是一个tuple，也就是元祖。 如果是增、改数据，必须就要调用commit()函数来提交事务，否则程序已退出，数据库里的数据不会有变化。 调用close方法关闭游标cursor和数据库连接 1234567891011121314import pymssqlconn = pymssql.connect(server='anly3.dm.ytx.com' ,database='ADHOC_FDGJ', as_dict=True)cur = conn.cursor()cur.execute("select ...") # 先将SQL语句赋值为变量aa = "select ..."cur.execute(a)b= cur.fetchall()conn.close()df_b = pd.DataFrame(b) # 转化为数据框格式 Connection Objects 方法 含义 connect 创建连接对象 cursor 返回一个Cursor对象 commit 提交事务 rollback 回滚 close 关闭连接 connect(host, user, password, database, as_dict=True) ：创建连接对象 host :主机名 user：用户名 password：密码 database：数据库 charset：数据库的字符集；不指定此参数值时，程序使用默认值’UTF-8’ as_dict：布尔值,指定返回值是字典还是元组 timeout：查询超时login_timeout：登陆超时max_conn：最大连接数trusted：布尔值,指定是否使用windows身份认证登陆 cursor(as_dict=True)：创建游标。 一个连接一次只能有一个游标的查询处于活跃状态 创建多个连接来保证多个查询可以并行执行在不同连接的游标上 使用fetchall方法获取到游标查询结果之后再执行下一个查询 as_dict : 使游标返回字典变量。字典中的键为数据表的列名 pd.DataFrame( cursor.fetchall()) : 可将数据有 列表list 转为 数据框DataFrame 123456789101112131415161718192021# ------------一个连接一次只能有一个游标的查询处于活跃状态c1 = conn.cursor()c1.execute('SELECT * FROM persons')c2 = conn.cursor()c2.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')print( "all persons" )print( c1.fetchall() ) # 显示出的是c2游标查询出来的结果print( "John Doe" )print( c2.fetchall() ) # 不会有任何结果# ------------解决办法：使用fetchall方法获取到游标查询结果之后再执行下一个查询--------------c1.execute('SELECT ...')c1_list = c1.fetchall()c2.execute('SELECT ...')c2_list = c2.fetchall() ####Cursor Objects 方法 含义 execute 执行一条SQL语句 executemany 执行多条语句 fetchone 获取一行数据 fetchmany 获取n行的数据 fetchall 获取未返回（剩下的）数据 callproc 调用存储过程 close 关闭游标 注意：fetchone / fetchmany / fetchall 与 read 是同样的运行方式；一旦倒出来一条数据，就少一条数据； 例如：cursor.fetchone() ，则已经少了一行数据； execute()：执行一条SQL语句 例子中查询操作的参数使用的%s而不是&#39;%s&#39;，若参数值是字符串，在执行语句时会自动添加单引号 12345cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe') # 字符串没有使用引号row = cursor.fetchone()while row: print("ID=%d, Name=%s" % (row[0], row[1])) row = cursor.fetchone() executemany()：指定多条SQL语句 123456stmt='insert into student (name, age) values (%s,%s)'data=[ ('Lucy',21), ('Tom',22), ('Lily',21)]cursor.executemany(stmt,data) callproc( procname [, parameters ] )：调用存储过程 123456789101112131415with pymssql.connect(server, user, password, database) as conn: with conn.cursor(as_dict=True) as cursor: # 创建存储过程 cursor.execute(""" CREATE PROCEDURE FindPerson @name VARCHAR(100) AS BEGIN SELECT * FROM persons WHERE name = @name END """) # 调用存储过程 cursor.callproc('FindPerson', ('Jane Doe',)) # FindPerson 为之前创建的存储 for row in cursor: print("ID=%d, Name=%s" % (row['id'], row['name'])) 使用 with 函数 完成后自动关闭数据库连接 12345with pymssql.connect(server, user, password, "tempdb") as conn: with conn.cursor(as_dict=True) as cursor: cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe') for row in cursor: print("ID=%d, Name=%s" % (row['id'], row['name'])) 中文乱码问题 sqlserver数据库编码为gbk 文件头加上 #coding=utf8 连接的时候加入charset设置信息 \运行正常，输出依然乱码；不指定此参数值时，程序使用默认值’UTF-8’ pymssql.connect(host=self.host,user=self.user,password=self.pwd,database=self.db,charset=”utf8”) 代码中显式转码 unicode变量.encode(‘latin1’).decode(‘gbk’) 一般情况下对unicode编码不做encode处理，但必要时可以encode为Latin1，实现脱unicode操作，然后再以合适字符集decode为正确unicode 12345678910111213141516171819202122print "\t".join([str(room_id),room_name.encode('latin1').decode('gbk')])# 在执行时进行encodecur = conn.cursor()sql = "select top 10 [ID],[Name] from [User]"cur.execute(sql)list = cur.fetchall()for row in list: print(row["ID"],row["Name"].encode('latin-1').decode('gbk')) # sql语句中有中文的时候进行encode insertSql = "insert into WeiBo([UserId],[WeiBoContent],[PublishDate]) values(1,'测试','2012/2/1')".encode("utf8")# --------某一列中文有乱码def code(a): a = a.encode('latin-1').decode('gbk') return adata['访问次数'] = data['访问次数'].apply(code) 字符定义使用NVARCHAR 这种方式在存储和读取时都使用unicode编码，和python运转字节码一致，可以很好避免此类问题。当然数据库存储空间要牺牲一些。 1[room_name] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL 【实战演练】123456789101112131415import pymssqlconn = pymssql.connect(server='anly3.dm.ytx.com' ,database='ADHOC_FDGJ', as_dict=True)cur = conn.cursor()cur.execute("select ...") # 先将SQL语句赋值为变量aa = "select ..."cur.execute(a)# 获取之后再赋值b= cur.fetchall()conn.close()df_b = pd.DataFrame(b) # 转化为数据框格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# =-----------【代码参考】-----------------# -*- coding:gbk -*-import pymssql#创建一个数据库连接，host是服务器的ip地址，如果是本机可以用"."，user是访问用户名，password是密码，database是数据库名，比ADO的连接似乎简单一些conn=pymssql.connect(host=".",user="sa",password="twinflag",database="bbs" , as_dict=True)#创建游标对象，相当于ADO的记录集cou=conn.cursor()sql="select id,name from user"cou.execute(sql) #执行命令# -----------或者-------------cou.execute('select id, name From user')#插入一条记录cou.execute(sql)#只有执行了下面的命令，上面的操作才能生效，配合异常处理，可以实现pymssql的事务操作conn.commit()#关闭数据库的连接conn.close()# =-----------【代码参考】-----------------import pymssql# server 数据库服务器名称或IP# user 用户名# password 密码# database 数据库名称conn = pymssql.connect(server, user, password, database)cursor = conn.cursor()# 新建、插入操作cursor.execute("""IF OBJECT_ID('persons', 'U') IS NOT NULL DROP TABLE personsCREATE TABLE persons ( id INT NOT NULL, name VARCHAR(100), salesrep VARCHAR(100), PRIMARY KEY(id))""")cursor.executemany( "INSERT INTO persons VALUES (%d, %s, %s)", [(1, 'John Smith', 'John Doe'), (2, 'Jane Doe', 'Joe Dog'), (3, 'Mike T.', 'Sarah H.')])# 如果没有指定autocommit属性为True的话就需要调用commit()方法conn.commit()# 查询操作cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')row = cursor.fetchone()print(row) # 也可以使用for循环来迭代查询结果# for row in cursor:# print("ID=%d, Name=%s" % (row[0], row[1]))# 关闭连接conn.close() Juypter Notebook 知乎分享：https://www.zhihu.com/question/59392251 品颜完月 27个技巧：http://liuchengxu.org/pelican-blog/jupyter-notebook-tips.html 快捷键【命令模式】 如果单元格的边框为绿色（即为编辑模式），请按ESC键，退回到命令模式。在命令模式下被选中的单元采用灰色边框显示。按上下方向键可以移动选择框。 数字键：将单元格变为标题类型，数字越大标题越小 m：将单元格变为markdown类型，在markdown类型的单元格内可以编写文档 注：将代码类型改为标题类型和markdown类型之后，按Ctrl+Enter对其进行格式化显示。 y：将单元格变为代码类型，在代码类型的单元格中输入Python代码 d: 按两下d按键删除单元格 z: 撤销最后删除单元格操作 a: 在当前单元格之上创建一个新的单元格 b: 在当前单元格之下创建一个新的单元格 x: 剪切当前单元格 c: 复制当前单元格 v: 在当前单元格之下粘贴剪切板中的单元格 shift+k: 将当前单元格上移 shift+j: 将当前单元格下移 一旦 cell 被选中，接着你可以进行批量删除/复制/剪切/粘贴.当你需要移动一部分notebook时，这非常有用。 shift+m:与下面的单元合并 d, d ：连按两下d 删除所选cell 【编辑和运行】 编辑模式下单元使用绿色边框显示，在命令模式时按Enter即可进入编辑模式。 Ctrl+Enter：结束编辑，对于代码单元将运行其中的代码，对于标题单元和markdown单元将格式化显示 Shift+Enter：运行当前选择的代码单元，并自动选择下一个单元。 Alt+Enter：运行当前的代码并在下面插入新的单元。 ctrl+/：为一行或多行添加或取消注释 多光标操作 ：按住 Alt 进行点击和拖拽鼠标即可（选择所要编辑的区域；若要在最后都加上逗号，应该单独选最后的一纵列，而不是连通前面的内容也一起选） 【在线帮助和自动完成】 输入代码时，按 [TAB]键 可以显示自动完成提示框。自动完成支持当前执行环境中已知的模块名、变量名、对象的属性名，以及文件和目录名。 对于当前环境中已知的对象，可以在其后面添加问号查看相应的说明信息和文档，添加两个问号可以查看对象对应的源程序。按Ctrl+Enter显示 在 Help 菜单你可以找到一些常用库文档的连接，包括 NumPy, Pandas, SciPy 和 Matplotlib.同时别忘了在一个库，方法或变量前加上 ?，你可以获得它的一个快速语法说明。 ?sum() 调用函数时，按 [shift+tab]组合键 可以显示函数的调用参数和说明文档，按一次组合键显示基本信息，两次显示详细信息，三次延时停留信息框，四次则将信息显示在下方的滑动窗口中。 【操作运算核】 如果进入了Python的死循环，可以在命令模式下按两下 i 按键终止循环。 注意右上角图标从空心圈变为实心圈，如上图，表示运算核正在工作，无法执行新的代码。 markdown操作 在命令模式下按Enter键进入编辑模式即可查看本段文字的Markdown代码。 在行内的数学公式使用单个$括起，单独占一行的数学公式使用$$括起 数学公式采用LaTeX格式编写，可以使用下面的在线编辑器编写LaTeX数学公式：http://www.codecogs.com/latex/eqneditor.php?lang=zh-cn ###python 导入与运行 【向jupyter notebook中导入python文件】 从本地导入python文件，可以直接使用%load xxx.py，比如把名字为untitled0.py的文件导入到jupyter中。 注意：本地文件导入时的绝对路径和相对路径的引用方式的不同 从网络中导入python代码，可以使用%load 网址 【jupyter中运行python文件】 输入：%run xxx.py 按Ctrl+Enter后 显示问题【图片显示】 当在程序中使用了matplotlib绘图，不能直接显示时，需要加%matplotlib inline 输出设置导出时去掉代码12import IPython.core.display as didi.display_html('&lt;script&gt;jQuery(function() &#123;if (jQuery("body.notebook_app").length == 0) &#123; jQuery(".input_area").toggle(); jQuery(".prompt").toggle();&#125;&#125;);&lt;/script&gt;', raw=True) 显示每行结果 可以选择修改 ast_note_iteractively kernal 选项来使得 Jupyter 为每一行的变量或语句执行这个操作，以便你可以立即看到多条语句一起输出。 12from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all" 所有的Jupyter实例（Notebook和Console）都设置该选项，只需创建 ~/.ipython/profile_default/ipython_config.py 文件并写入一下内容 .ipython 该文件夹一般在 user 的第一级目录下。 123c = get_config()# Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = "all" 123456789101112131415161718line1 = "this is from line 1"line2 = "this is from line 2"line1line2[out]:'this is from line 2' # 修改之后from IPython.core.interactiveshell import InteractiveShellInteractiveShell.ast_node_interactivity = "all"line1line2[out]:'this is from line 1''this is from line 2' 导出为PDF 报错：Download as “PDF via LaTeX” fails - nbconvert fails, xelatex not found on PATH nbconvert failed: xelatex not found on PATH, if you have not installed xelatex you may need to do so. Find further instructions at https://nbconvert.readthedocs.io/en/latest/install.html#installing-tex. https://github.com/jupyter/docker-stacks/issues/353 As said by Thomas K in the comments, you need to have Latex installed, and after add the path to the directory containing pdflatex.exe file to the PATH variable of your system. I have looked for a lightweight distribution and tried installing TeXworks, but I didn’t find any pdflatex.exe file. So I have tried TeX Live, which worked fine creating the pdflatex.exe file under the target installation directory. This path should be like C:...\texlive\2016\bin\win32. Finally, you should just add this path to the PATH environment variable of your system (you can use the link shared by Thomas K). In Jupyter, you can check your environment variables by running the following (refer to this link for details): import os os.environ so you can look for ‘PATH’: ‘C: … and check if it contains the path to pdflatex.exe file. If you get some trouble when exporting your notebook to pdf due to missing files/packages (this happened to me), refer to this link to search and install them under TeX Live. 插件【报告文档】（删去了业务人员不想查看的代码） Jupyter Dashboards https://github.com/jupyter/dashboards 123456# install using pip from pypi and then activate the extensionpip install jupyter_dashboardsjupyter dashboards quick-setup --sys-prefix# install using conda from conda-forge, no activation requiredconda install jupyter_dashboards -c conda-forge]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_正则表达式_RE]]></title>
      <url>%2F2018%2F01%2F24%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_RE%2F</url>
      <content type="text"><![CDATA[Re模块 Re模块的函数主要分三个大类：匹配模式、替换、拆分 Python字符串转义符 \ 因此强烈建议使用Python的r前缀，就不用考虑转义的问题了： 12345import res = r'ABC\-001' # Python的字符串# 对应的正则表达式字符串不变：# 'ABC\-001' 编译当我们在Python中使用正则表达式时，re模块内部会干两件事情： 编译正则表达式，如果正则表达式的字符串本身不合法，会报错； 用编译后的正则表达式去匹配字符串。 Python代码最终被被编译为字节码，然后才被解释器执行。在匹配模式之前，正则表达式模式必须先被编译成regex对象。由于正则表达式在执行过程中多次被用于比较，所以强烈建议先对它进行预编译。 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配： compile - 模块的函数 re.compile(patter [, flags=0]) 把正则表达式编译成一个正则对象（regex）;供其他函数 find()、match()、search() 等函数使用 使用方式为 命名的变量.方法(查找对象的范围) ；其实因为在其他Re函数使用时，自动传递pattern 若对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建对象。 flags 包括：re.I 忽略大小写re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境re.M 多行模式re.S 即为’ . ’并且包括换行符在内的任意字符（’ . ’不包括换行符）re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库re.X 为了增加可读性，忽略空格和’ # ’后面的注释 123456789101112131415161718192021222324252627282930a = re.compile() # 创建的正则规则result = a.findall(ojbect)# ----【 简单说明 】compiled_pattern = re.compile(pattren)resule = re.findall(compiled_pattern, string) # 这种方式更利于理解#---------等价于--------------compiled_pattern = re.compile(pattren)result = compiled_patter.findall(string) # 使用方式为 命名的变量.方法(查找对象的范围) 。其实因为在其他Re函数使用时，自动传递pattern# ----【 解释说明 】## p 即为编译后的 pattern。 在其他Re函数使用时，自动传递patternp = re.compile( '(one|two|three)') p.sub( 'num', 'one word two words three words') # 其第一个参数为p，即将one|two|three作为查找的对象，替换为rep = num'num word num words num words'### 正常应为 re.sub('(one|two|three)', 'num', 'one word two words three words')&gt;&gt;&gt; import re# 编译:&gt;&gt;&gt; re_telephone = re.compile(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$')# 使用：&gt;&gt;&gt; re_telephone.match('010-12345').groups() ('010', '12345')&gt;&gt;&gt; re_telephone.match('010-8086').groups()('010', '8086') Re模块的函数和regex对象的方法 强调：查找的对象是 字符串string search &amp; match- 搜索&amp;匹配 search - 搜索； match - 匹配 通过.group 返回对象 match(pattern, string, flags=0)：在字符串string的开头 开始搜索正则表达式模式pattern；若匹配成功，则返回一个匹配对象（仅返回匹配的部分）；否则返回None search(pattern, string, flags=0)：从字符串string中（任意位置）搜索正则表达式模式pattern 第一次出现的地方； 如果匹配成功，则返回一个匹配对象；否则返回None 12345678910111213141516171819# match 应用re.match('foo', 'food on the table')&lt;_sre.SRE_Match object; span=(0, 3), match='foo'&gt;re.match('foo', 'The food on the table') # 什么都没有返回# search 应用re.search('foo', 'The food on the table')&lt;_sre.SRE_Match object; span=(4, 7), match='foo'&gt;val = 'abc, dca, guides'm = re.search('uid', val)# &lt;_sre.SRE_Match object; span=(9, 12), match='uid'&gt;val[m.start():m.end()]# 'uid' findall &amp; finditer - 查找 search 与 findall 不同之处在于：findall 总返回一个[ 列表 ] findall(pattern, string [,flags]) ：在字符串string中搜索匹配pattern的所有内容，并返回一个匹配对象的 [列表 list] 正则表达式 finditer(pattern, string [, flags])：在字符串string中搜索匹配pattern的所有内容，返回一个迭代器，该迭代器返回一个匹配对象 sub - 替换 re.sub(pattern, repl ,string, max = 0) : 把字符串string中所有匹配正则表达式pattern的地方 替换成 字符串 repl 如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。 若max 的值没有给出，则对所有匹配的地方进行替换 re.subn - 该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数 12345678910re.sub(pattern, repl, string[, count, flags])# count=1 表示替换仅替换第一个p = re.compile( '(one|two|three)') p.sub( 'num', 'one word two words three words') # 其第一个参数为p，即将one|two|three作为查找的对象，替换为rep = num'num word num words num words'# ------------------------------------subn(repl, string[, count=0]) split - 分割 re.split(pattren, string, max=0) ： 根据正则表达式pattern中的分隔符 把字符串string 分割为一个 [列表] 若max 的值没有给出，则对所有匹配的地方进行分割 1re.split(pattern, string[, maxsplit=0, flags=0]) group - 匹配对象 匹配对象的方法：在match &amp; search 被成功调用之后所返回的结果。 group(num=0)：返回全部匹配对象（或指定编号是num的子组） groups()：返回一个包含唯一或全部匹配的子组的元组（若正则表达式中没有子组，则返回一个空元组） num 代表第1、2、……个子串。如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。 用()表示的就是要提取的分组(Group)，进行提取子串 12345678910111213141516171819202122# group 应用re.match('foo', 'food on the table').group()'foo'# groups 应用re.match('foo', 'food on the table').groups()()# 用()定义组^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$ # 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：&gt;&gt;&gt; m = re.match(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$', '010-12345')&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;&gt;&gt;&gt; m.group(0) # group(0) 永远是原始字符串'010-12345'&gt;&gt;&gt; m.group(1)'010'&gt;&gt;&gt; m.group(2)'12345'&gt;&gt;&gt; m.group() # 返回所有的值 贪婪匹配 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 12&gt;&gt;&gt; re.match(r'^(\d+)(0*)$', '102300').groups()('102300', '') 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配： 12&gt;&gt;&gt; re.match(r'^(\d+?)(0*)$', '102300').groups()('1023', '00') 参考资料 ： 正则表达式 元字符 匹配对象 符号 含义 解释 . 点号 匹配单个(除换行符以外)任意字符 （含空格、下划线等） \s 空白/空格- space 匹配任意的空白符 \S 非空白字符 匹配任何非空白字符，相当于[^ fv] \d 数字 - digit 匹配数字 ，相当于[0-9] \D 非数字 匹配任何非数字字符，相当于[^0-9] \w 任何字符 - whatever 匹配任何字母数字字符，相当于[a-zA-Z0-9_] \W 非任何字符 匹配任何非字母数字字符，相当于[^a-zA-Z0-9_] [ ] 字符组 匹配单个列出的字符，表示或的关系 [^ ] 排除性字符组 匹配单个未列出的字符 \char 转义字符 对于 ? 和 * 的对象在”匹配成功”时也可能并没有匹配任何内容。因为它们允许匹配的数量为0 即便是排除性字符，也需要匹配一个字符 转义符 \\*第一个转义符是对\进行转义，表示：查找 \*此类字符的内容 空格 也是一个字符 由于Python的字符串本身也用\转义，因此强烈建议使用Python的r前缀，就不用考虑转义的问题了： 字符组 [ ] 字符组内匹配的是列出的单个字符，或者的关系 字符组元字符 ：字符组内的元字符，其含义表示为本身的含义，即代表普通文本字符，相当于转义之后的字符（连字符 - 除外） 连字符 ( - )表示一个范围；【注意：只有在字符组内部，连字符( - )才是元字符】 1[0-9] # 表示匹配的字符为0~9之间的任意一个 连字符 ( - ) 出现在字符组的开头，则仅代表普通文本字符； 1[-09] # 表示匹配的字符为 - 或者 0 或者 9 ​ 量词 - 计数功能对前一个/一组字符匹配的的次数 符号 含义 解释 ？ = 0 或 1 问号 不匹配，或仅匹配一次 * $\ge$ 0 星号 可能不匹配，也可能匹配任意多次 + $\ge$ 1 加号 至少匹配一次，也可能匹配任意多次 {m} 对于前一个字符重复m次 {min, max} 区间量词 对前一个字符重复min到max次 匹配位置 符号 含义 解释 ^ 脱字符 一行的开头位置 $ 美元符 一行的结束位置 \b 单词分界符 匹配单词的开始或结束 (用于精确匹配) \D 非单词分界符 匹配不是单词开头或结束的位置 其他元字符 符号 含义 解释 ( ) 括号 限定多线结构的范围； 为反向引用“捕获”文本 \1 , \2 反向引用 匹配之前的第一个、第二个括号内的字表达式所匹配的文本(即捕获的文本) \ 或者 匹配任意分隔的表达式 括号与反向引用的示例 分组0对应整个正则表达式 1234&gt; \b(a-zA-Z)*+\1\b&gt; # 若 \b(a-zA-Z)*+ 任意字符找到的以单词开头的内容为the，则\1 表示其末尾也应为the的内容 &gt; # 若有两个括号，\2表示第二个括号中所匹配的文本内容&gt; 多选结构 使用圆括号( ) 来进行表示，而非方括号 123456# 查找 gray 或 grey的写法1. gr[ae]y2. gr(a|e)y# 错误的写法 gr[a|e]y -表示查找 a 或者 | 或者 e 多选结构可以匹配任意长度的字符，而字符组[ ]只能匹配单个字符 【实战演练】你在一篇英文小说里查找hi，你可以使用正则表达式hi 通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。 很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b \bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词 12345678910111213141516171819import osimport ref = open('caihf001')text = f.read()f.close()k = re.compile('Lemon', re.I)k.findall(text)# ----效果同上with open('caihf001') as f: text = f.read()# print(text) k = re.compile('lemon',re.I) l = re.findall(k,text)print(l)['Lemon', 'lemon', 'Lemon', 'Lemon', 'LeMoN', 'LEmon', 'LEMON']]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_文件与目录操作_OS]]></title>
      <url>%2F2018%2F01%2F23%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6%26%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA_OS%26Pandas%2F</url>
      <content type="text"><![CDATA[Python_导入导出 目录与文件操作 - OS模块目录操作 “./” 表示当前目录 “../“ 表示上一目录 Windows 中路径需要两个\\ 如下为示例： E:\\my_computer\\1_工作学习 getcwd &amp; os.chdir - 工作目录 os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径。 os.chdir(dirname): 改变工作目录到dirname listdir - 文件与目录名 os.listdir() 返回指定目录下的所有文件和目录名 123456# 返回当前目录下的文件名os.listdir() os.listdir('./') # 返回上一目录下的文件名os.listdir('../') 目录结构 123456789&gt; # 参考&gt; ## 工作目录为 /Users/ethan/coding/python&gt;&gt; Users/ethan&gt; └── coding&gt; └── python&gt; ├── hello.py - 文件&gt; └── web - 目录&gt; path.abspath - 绝对路径 os.path.abspath(file) ：获取文件或目录的绝对路径 os.path.abspath(‘.’) ：获取当前目录的绝对路径 1234567# 文件的绝对绝对路径os.path.abspath('hello.py')'/Users/ethan/coding/python/hello.py'# 文件夹的绝对路径os.path.abspath('web')'/Users/ethan/coding/python/web' path.dirname - 文件路径 os.path.dirname(path)：获取文件或文件夹的所在的路径 对比os.path.abspath hellp.py 得到的结果不同； 1234567# 获取文件所在的路径os.path.dirname('/Users/ethan/coding/python/hello.py')'/Users/ethan/coding/python'# 获取文件夹的路径os.path.dirname('/Users/ethan/coding/python')'/Users/ethan/coding' path.basename - 文件名称 os.path.basename(path)：获取文件名或文件夹名 1234567# 从一个 绝对路径 中获取该 [文件] 的名称os.path.basename('/Users/ethan/coding/python/hello.py')'hello.py'# 从一个 绝对路径 中获取该 [文件夹] 的名称os.path.basename('/Users/ethan/coding/python')'python' path.split - 目录与文件名 os.path.split(path)：获取分离后的目录与文件名 1234567# 获取分离后的目录与文件名os.path.split('/Users/ethan/coding/python/hello.py')('/Users/ethan/coding/python', 'hello.py')# 获取分离后的目录与文件夹名os.path.split('/Users/ethan/coding/python')('/Users/ethan/coding', 'python') path.splitext - 分离 os.path.splitext(path)：分离文件名与扩展名 事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在 123456# 获取分离后的文件名与扩展名os.path.splitext('/Users/ethan/coding/python/hello.py')('/Users/ethan/coding/python/hello', '.py')os.path.splitext('/Users/ethan/coding/python')('/Users/ethan/coding/python', '') path.join - 连接 os.path.join(path, name) ：连接目录与文件名或目录 ####walk - 遍历 os.walk() 遍历目录常用的模块，它返回一个包含 3 个元素的元祖：(dirpath, dirnames, filenames)。 dirpath 是以 string 字符串形式返回该目录下所有的绝对路径； dirnames 是以列表 list 形式返回每一个绝对路径下的文件夹名字； filesnames 是以列表 list 形式返回该路径下所有文件名字 1234for root, dirs, files in os.walk('/Users/ethan/coding'): print root print dirs print files path.sidir - 判断目录 os.path.isdir(name)： 判断name是不是目录，不是目录就返回false path.exists - 判断存在 os.path.exists(name) :判断是否存在文件或目录name path.isfile - 判断存在 os.path.isfile(name) :判断name这个文件是否存在，不存在返回false mkdir - 创建 os.mkdir(‘file’) ：创建目录 rename - 重命名 os.rename(“oldname”,”newname”) ：重命名文件（目录） 文件操作 moknod - 创建 os.moknod(‘text.txt’) : 创建空文件 remove - 移除 os.remove()：函数用来删除一个文件 open - 打开 要以任何方式打开文件（即使是打印文档），都必须先打开文件，这样才能访问它。 读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，需要转为int/float open(file, [w]) ：以某种方式打开文件 with open(file, [w]) ： with 关键字不再需要访问文件后将其关闭的操作；会自动关闭 r - 只读模式 w - 只写模式。覆盖之前的同名文件（即删除里面的所有内容）。如果文件不存在就创建文件 a - 追加模式打开。附加到现有文件；若文件不存在则创建一个；添加到文件末尾 r+ - 读写模式 w+ 以读写模式打开a+ 以读写模式打开rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ ) read - 读取 要以任何方式打开文件（即使是打印文档），都必须先打开文件，这样才能访问它。 读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，需要转为int/float 所谓字符串，是指可以在内部查找的文档格式。 tb0.realine()： 读取第一行的数据，以 ( 字符串str ) 形式返回文件数据 ； 此时源数据 tb0已经缺少了第一行的数据 tb0.readlines()：按行读取所有的数据，以[ 列表list ]，准确的说包含字符串str的列表list，并且也包含换行符(\n)，制表符(\t) 形式返回文件数据 tb0.read() ：一次性读取所有数据，类型为 ( 字符串str ) 末尾多一行空行 12345678910111213141516171819202122with open('filename.csv') as tb01: # with 关键字不再需要访问文件后将其关闭的操作；会自动关闭 a = tb01.readline() # 此时源数据tb01已经缺少了第一行的数据 b = tb01.readlinse() c = tb01.read() # 此时已经为空# ----【 重要概念 】-------------------------------------- b[0] # 获得列表中的第一个字符串 '003888800000798,160999900163133\n'b[0][0] # 获得列表中第一个字符串的第一个字符 '0'# ----【 读取与替换】--------------------------------## 创建里面为列表的列表l = [] # 创建空列表for i in b: # b为列表，对每个对象进行逐一操作 m = re.sub(r'\n','',i) # 完成一系列对字符串的操作，结果仍为字符串string# p = re.split(',',m) 若需要，可对字符串进行分割，结果为列表list l.append(m)l[',,,会员简称,成交量,比上一交易日增减,会员简称,持买单量,比上一交易日增减,会员简称,持卖单量,比上一交易日增减', '20160111,IC1601 ,1,海通期货 ,1581,31,上海东证 ,1287,-17,中信期货 ,2137,-95', '20160111,IC1601 ,2,中信期货 ,1437,-13,华泰期货 ,1124,-70,广发期货 ,1583,-194', '20160111,IC1601 ,3,国泰君安 ,1231,-55,海通期货 ,993,-16,国泰君安 ,831,-52'] 12345# 用循环读取的结果为字符串格式l = ''with open(filename) as file_object: for line in file_object: l = l + line write - 写入 write 不会在文本末尾添加换行符(\n)，若写入多行时，建议在最后添加换行符 \n. tb1.write(&#39;I love programming.\n&#39;) r - 只读模式w - 只写模式。覆盖之前的同名文件（即删除里面的所有内容）。如果文件不存在就创建文件a - 追加模式打开。附加到现有文件；若文件不存在则创建一个；添加到文件末尾r+ - 读写模式w+ 以读写模式打开 123456789101112with open('path\filename.csv', 'w') as tb1: tb1.write('I love programming!') # 直接在该文件中最后写入 # --------------若要写入文档，先完成数据的提取-----------------b = '' # 空字符串；因为文本文档均为字符串格式with open('path\filename.csv') as f: a = f.readlines() # 此时a为列表list格式； 也可为 a = f.read()，则该处a为字符串格式 for i in range(len(a)): b = b + str(i) + a[i]with open('path\filename.csv') as f: f1 = f.write(b) ##【实战演练】 【获取上一层次目录中，test文件夹内的所有文件，并选取csv格式的文档】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import osimport re# 方法一&gt;&gt;&gt; os.listdir('../') ['.ipynb_checkpoints', '.Rhistory', 'Python', 'R_dir', 'test', 'test.ipynb']## 手动添加目录&gt;&gt;&gt; file_name = os.listdir('../test')['2016-01-11-IC_1.csv', '2016-01-11-IH_1.csv', '2016-01-12-TF_1.csv', '2016-01-13-T_1.csv']## 用Re模块匹配符合的文档&gt;&gt;&gt; k = []for i in file_name: if re.findall(r'.*\.csv$',i): k.append('../test/'+i) k['../test/2016-01-11-IC_1.csv', '../test/2016-01-11-IH_1.csv', '../test/2016-01-12-TF_1.csv', '../test/2016-01-13-T_1.csv']# -------获得绝对路径的文件名-------------------------------------------------------dir_name = os.path.abspath('../test/')dir_namek = []for i in file_name: if re.findall(r'.*\.csv$',i): k.append(dir_name+i) k['E:\\Jupyter_notebook\\test2016-01-11-IC_1.csv', 'E:\\Jupyter_notebook\\test2016-01-11-IH_1.csv', 'E:\\Jupyter_notebook\\test2016-01-12-TF_1.csv', 'E:\\Jupyter_notebook\\test2016-01-13-T_1.csv', 'E:\\Jupyter_notebook\\testtest - 副本.csv']# ------------------------------------------------------# 方法二dir_name1 = os.path.abspath('../')'E:\\Jupyter_notebook'os.listdir('../') # 结果同上test_dir = os.path.join(dir_name1, 'test')os.listdir(test_dir)['2016-01-11-IC_1.csv', '2016-01-11-IH_1.csv', '2016-01-12-TF_1.csv', '2016-01-13-T_1.csv'] 【获取其他目录下的文件】 12345# 获取当前工作目录os.getcwd()# 变更工作目录os.chdir('E:\Others') 导入与导出 - pandas导入数据 pandas默认将表格型数据读取为数据框格式（DataFrame） “./” 表示当前目录 “../“ 表示上一目录 import pandas as pdimport numpy as np df：任意的Pandas DataFrame对象s：任意的Pandas Series对象 pd.read_csv(“./filename.txt”, sep=’,’, header=0, names=[‘a’,’b’], skiprows=0, index_col=’a’, na_values=’NULL’, nrows=1000, encoding=’gb2312’, thousands= ‘,’) ：从CSV文件导入数据 sep =’\s+’ 正则表达式的空白字符串 header=0，表示默认第一行为列名； header=None 没有列名行 names=[‘a’, ‘b’] 用于指定列名，与header=None结合使用 skiprows=0, skiprows=[0,2,3] 表示跳过的观测行； skip_footer=0，表示忽略的行数（从文件末尾算起） index_col =[‘a’,’b’] 表示指定为索引列 na_valuse = [‘Null’] 一组将NA值替换为指定的字符’Null’ 或其他任意形式 nrows=1000 表示读取的行数，从文件开始处算起 thousands=’,’ / ‘.’ 千分位分隔符 12tb01 = pd.read_csv("./filename.txt", sep=',', header=0, names=['a','b'], skiprows=0, index_col='a', na_values='NULL', nrows=1000, encoding='gb2312', thousands= ',') # 默认分隔符为逗号； tb01 = pd.read_table() # pd.read_excel(filename)：从Excel文件导入数据 pd.read_table(filename)：从限定分隔符（默认为制表符 “\t”）的文本文件导入数据； 也可读csv格式的文档，但建议将sep=’,’ pd.read_sql(query, connection_object)：从SQL表/库导入数据 pd.read_json(json_string)：从JSON格式的字符串导入数据 pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格 pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table() pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据 ####数据清洗 12345678with open('关联客户0522.csv') as tb0: tb1 = tb0.readlines() # 将tb0中的内容按行读取为列表；(此时自动生成了一个换行符\n) tb3 = [] for tb in tb1: # 一次访问列表list中的元素（此时各元素为字符串格式，故可以对其进行操作） tb2 = tb.replace('"', '').replace('\n','').strip().split(',') # 依次完成各个操作 替换” - 替换\n - 去空格 - 按分隔符','将元素转化为列表 tb3.append(tb2) # 在列表tb3中添加以将各元素转为列表的值；最终类型为列表的列表print(tb3)tb3[1][1] 显示所有行数 pandas默认会隐去中间的部分。如果希望能显示完整，可以使用下面的方法： 一次性设置Pandas运行环境，以便输出所有记录； 12pd.set_option('display.max_columns', None)pd.set_option('display.max_rows', None) 针对特定输出，设置Pandas参数。运行之后，再恢复到默认值 12with pd.option_context('display.max_rows', None, 'display.max_columns', 3): # None 为全部；或者指定具体的数值 print (df) 导出数据 缺失值 在输出结果中为 空字符串； DataFrame.to_cvs(‘filename.csv’, sep=’,’, na_rep=’NULL’, index=False, header=False, cols=[‘a’,’b’,’c’])：导出数据到CSV文件 df.to_excel(filename)：导出数据到Excel文件 DataFrame.to_excel(excel_writer, sheet_name=’Sheet1’, na_rep=’’, float_format=None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep=’inf’, verbose=True, freeze_panes=None) excel_writer : string or ExcelWriter object. File path or existing ExcelWriter na_rep : string, default ‘’ . Missing data representation float_format : string, default None. Format string for floating point numbers columns : sequence, optional. Columns to write ；表示需要导出的列 header : boolean or list of string, default True； 表示可以重命名列名 index : boolean, default True ；是否包含索引列 index_label : string or sequence, default None startrow :upper left cell row to dump data frame encoding: string, default None df.to_sql(table_name, connection_object)：导出数据到SQL表 df.to_json(filename)：以Json格式导出数据到文本文件 123456789101112# 导出数据&gt;&gt;&gt; dir_name'E:\\my_computer\\1_工作学习\\10_工作文档\\5 银天下-数据分析\\30_专项分析\\0102_股今中外链接统计\\人员信息\\历史数据'lj01.to_excel(dir_name+'\\'+'lj02.xls',index=False)qian_all_data.to_csv('qianguqg.csv', index=False)# 导入到同一Excel的多个sheet&gt;&gt;&gt; writer = pd.ExcelWriter('output.xlsx')&gt;&gt;&gt; df1.to_excel(writer,'Sheet1')&gt;&gt;&gt; df2.to_excel(writer,'Sheet2')&gt;&gt;&gt; writer.save() 【实战演练】将所有CSV文档读入到同一个对象1234567891011121314151617import pandas as pdimport re# 读取csv的文件，并写入到一个列表 name2name2 = []l = re.compile('.*\.csv')for i in name: if re.findall(l, i): name2.append(i) # 读入到同一个对象 table1 = []for i in name2:# print(i)# need_table = pd.read_csv(i) table0 = pd.read_csv('../future-exchange/'+i, encoding = 'gb2312') table1.append(table0)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hive_介绍]]></title>
      <url>%2F2018%2F01%2F22%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FHive%2FHive_%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 术语“大数据”是大型数据集，其中包括体积庞大，高速，以及各种由与日俱增的数据的集合。使用传统的数据管理系统，它是难以加工大型数据。因此，Apache软件基金会推出了一款名为Hadoop的解决大数据管理和处理难题的框架。 参考链接：http://www.yiibai.com/hive/ ​ HadoopHadoop是一个开源框架来存储和处理大型数据在分布式环境中。它包含两个模块，一个是MapReduce，另外一个是Hadoop分布式文件系统（HDFS） Hadoop Distributed File System MapReduce：它是一种并行编程模型在大型集群普通硬件可用于处理大型结构化，半结构化和非结构化数据。 HDFS：Hadoop分布式文件系统是Hadoop的框架的一部分，用于存储和处理数据集。它提供了一个容错文件系统在普通硬件上运行。 Hadoop生态系统包含了用于协助Hadoop的不同的子项目（工具）模块，如Sqoop, Pig 和 Hive。 Sqoop: 它是用来在HDFS和RDBMS之间来回导入和导出数据。 Pig: 它是用于开发MapReduce操作的脚本程序语言的平台。 Hive: 它是用来开发SQL类型脚本用于做MapReduce操作的平台。 注：有多种方法来执行MapReduce作业： 传统的方法是使用Java MapReduce程序结构化，半结构化和非结构化数据。 针对MapReduce的脚本的方式，使用Pig来处理结构化和半结构化数据。 Hive查询语言（HiveQL或HQL）采用Hive为MapReduce的处理结构化数据。 Hive是什么？Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。 最初，Hive是由Facebook开发，后来由Apache软件基金会开发，并作为进一步将它作为名义下Apache Hive为一个开源项目。它用在好多不同的公司。例如，亚马逊使用它在 Amazon Elastic MapReduce。 Hive 不是 一个关系数据库 一个设计用于联机事务处理（OLTP） 实时查询和行级更新的语言 Hiver特点 它存储架构在一个数据库中并处理数据到HDFS。 它是专为OLAP设计。 它提供SQL类型语言查询叫HiveQL或HQL。 它是熟知，快速，可扩展和可扩展的。 Hive架构下面的组件图描绘了Hive的结构： 该组件图包含不同的单元。下表描述每个单元： 单元名称 操作 用户接口/界面 Hive是一个数据仓库基础工具软件，可以创建用户和HDFS之间互动。用户界面，Hive支持是Hive的Web UI，Hive命令行，HiveHD洞察（在Windows服务器）。 元存储 Hive选择各自的数据库服务器，用以储存表，数据库，列模式或元数据表，它们的数据类型和HDFS映射。 HiveQL处理引擎 HiveQL类似于SQL的查询上Metastore模式信息。这是传统的方式进行MapReduce程序的替代品之一。相反，使用Java编写的MapReduce程序，可以编写为MapReduce工作，并处理它的查询。 执行引擎 HiveQL处理引擎和MapReduce的结合部分是由Hive执行引擎。执行引擎处理查询并产生结果和MapReduce的结果一样。它采用MapReduce方法。 HDFS 或 HBASE Hadoop的分布式文件系统或者HBASE数据存储技术是用于将数据存储到文件系统。 Hive工作原理下图描述了Hive 和Hadoop之间的工作流程。 下表定义Hive和Hadoop框架的交互方式： Step No. 操作 1 Execute QueryHive接口，如命令行或Web UI发送查询驱动程序（任何数据库驱动程序，如JDBC，ODBC等）来执行。 2 Get Plan在驱动程序帮助下查询编译器，分析查询检查语法和查询计划或查询的要求。 3 Get Metadata编译器发送元数据请求到Metastore（任何数据库）。 4 Send MetadataMetastore发送元数据，以编译器的响应。 5 Send Plan编译器检查要求，并重新发送计划给驱动程序。到此为止，查询解析和编译完成。 6 Execute Plan驱动程序发送的执行计划到执行引擎。 7 Execute Job在内部，执行作业的过程是一个MapReduce工作。执行引擎发送作业给JobTracker，在名称节点并把它分配作业到TaskTracker，这是在数据节点。在这里，查询执行MapReduce工作。 7.1 Metadata Ops与此同时，在执行时，执行引擎可以通过Metastore执行元数据操作。 8 Fetch Result执行引擎接收来自数据节点的结果。 9 Send Results执行引擎发送这些结果值给驱动程序。 10 Send Results驱动程序将结果发送给Hive接口。 参考资料MapReduceMapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。 概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组。 映射和归纳简单来说，一个映射函数就是对一些独立元素组成的概念上的列表（例如，一个测试成绩的列表）的每一个元素进行指定的操作（比如，有人发现所有学生的成绩都被高估了一分，他可以定义一个“减一”的映射函数，用来修正这个错误。）。事实上，每个元素都是被独立操作的，而原始列表没有被更改，因为这里创建了一个新的列表来保存新的答案。这就是说，Map操作是可以高度并行的，这对高性能要求的应用以及并行计算领域的需求非常有用。 而归纳操作指的是对一个列表的元素进行适当的合并（继续看前面的例子，如果有人想知道班级的平均分该怎么做？他可以定义一个归纳函数，通过让列表中的奇数（odd）或偶数（even）元素跟自己的相邻的元素相加的方式把列表减半，如此递归运算直到列表只剩下一个元素，然后用这个元素除以人数，就得到了平均分）。虽然他不如映射函数那么并行，但是因为归纳总是有一个简单的答案，大规模的运算相对独立，所以归纳函数在高度并行环境下也很有用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于月度总结的几个问题]]></title>
      <url>%2F2018%2F01%2F21%2F%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%2F%E5%85%B3%E4%BA%8E%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98_20180121%2F</url>
      <content type="text"><![CDATA[关于月度总结的几个问题 【SCQA】 $\to$ 【SCA - WKO - RR - P】 关键的触发器：S - W - R - P $\to$ 【Sword】 S-C-A：当时是一个什么样的（S）场景 [where/when/who/what]，产生了这个方案/行为/问题/疑问 （Action / Answer） Why：这个方案/问题的最终目的是？（一种状态 Be） One：为了达成XX目的，最重要的一件事是什么？当前状态下能做的最重要的一件事又是什么？ Key：达成这个目的/状态的关键问题是什么 Reverse：这个方案/行动能解决真正的问题吗？为了解决问题，还需要什么内容？ Role：你扮演的角色是？ Defend：保护你的预留时间不被侵害 【S-C-A】：发现自己的月度总结只是事件的堆砌，并没有实质性的总结与指导作用。这个体会之前就会，但一直没有去做改变。直到写2017年12月月度总结的时候，才准备做一些改变。那是因为，准备重新整理自己的博客； 【W】：(1) 记录并回顾过去一个月自己所经历的事情； (2) 对未来的行动方向做出调整 【O】： (1) 及时记录； (2) 花足够的时间去重新梳理浪，并进一步思考；同时将待调整的行动具化到可执行的行动上。 【o】：预留足够多的时间来给自己写总结 【R】：两个O只能达成一部分目的；另一部分是要确定如何来梳理同一类别下不同的事件（这个具体行动的时候可以在调整） 【R】：自我观察者 【D】：保护你的预留时间不被侵害 对SCQA的思考【原先的设定】 在什么样的场景（S &amp; C）下，得出了这样的一个结论/方案（A），它的目的（Why）是达成什么样的一个状态（Be）或解决什么问题（Q）； 【疑惑点】 对于SCQA与Why的两种提问方式的不和谐感。因为其实这两个都是为了得到同一个目的：界定问题，但采取两种不同的表达方式。所以，当你同时采用的时候，总觉得会有一种不顺畅的感觉。 另外，实践才能检验。的确，必须要实际行动一遍，才能知道好用不好用。——浦东图书馆 2018.01.21 17:52 【优化】 对SCQA提问的思考：分开提问 S-C-A：当时是一个什么样的场景，产生了这个方案/行为/问题/疑问 W ：这个方案/问题的最终目的是？ 通过SCA中自己发现的 [目的] 去与对方确认；同时明确对方的真正目的 One：为了达成XX目的，最重要的一件事是什么？当前状态下能做的最重要的一件事又是什么？ Key：达成这个目的/状态的关键问题是什么 Reverse：这个方案/行动能解决真正的问题吗？为了解决问题，还需要什么内容？ Role：你扮演的角色是？ Defend：保护你的预留时间不被侵害]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间的朋友2017:中国式机会_罗辑思维]]></title>
      <url>%2F2018%2F01%2F11%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B%2F%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B2017-%E4%B8%AD%E5%9B%BD%E5%BC%8F%E6%9C%BA%E4%BC%9A_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_20180111%2F</url>
      <content type="text"><![CDATA[六个问题 2017年哪一天、哪一个时刻你认为很重要？ 不是强者，还能不能登上舞台？ 刚刚进场者，能不能找到玩法？ 如果跟不上变化，会不会被淘汰？ 中国经济增长会不会遇到天花板？ 中国经济增长有没有可持续性？ 中国能否赢得良性的全球发展环境？ 六个脑洞1.动车组脑洞 不是强者，还能不能登上舞台？ 平凡创新的动车组时代 2.热带雨林脑洞 刚刚进场者，能不能找到玩法？ 新连接、小生态 核心：超级用户思维 一旦有人不断地涌入了互联网，就一定需要一个全新的连接器。 新物种，往往是高价值的连接器； 零零后，区别就是有钱； 老玩法：流量思维（一代商业思维；公平对待）；新玩法：超级用户思维 （区别对待） 优酷视频，一个会员对这家公司的贡献是免费用户的二十倍；资源肯定向你倾斜；但它目前的识别方式就是交费；是不是会员用户； 【瓶盖测试：不管你对陌生普通用户有多好，请先关照你身边的超级用户的感受。】 你跟你的女朋友一起去看电影，旁边一个姑娘想请你帮她拧开矿泉水瓶； 会员经济，最重要的是在企业和消费者之间建立了一种可持续信任的正式关系； 超级用户思维，我希望你以我为荣；（用户以你们为荣，但同时我们也以用户为荣）。面朝超级用户，才能春暖花开。 做给用户长脸的事情 绝不做给用户丢脸的事情（这个是克制本能冲动的事情） 企业的使命，创造且留住顾客。——德鲁克 3.比特化脑洞 如果跟不上变化，会不会被淘汰？ 比特世界和我们想象的不一样；原来我们要费劲力量穿越进去，要转型，因此很焦虑。但真实的比特世界是一种席卷一切的力量，你想逃都逃不掉。 做最好的自己，以最高的效率最最好的自己。 小米：认知战。不是价格战；它是干掉你的选择，不是让你去评估选择。”闭着眼睛买东西” 互联网会变成一种基础设置；之前从无到有，之后三十年会是从有到无（无处不在的无）； 互联网革命，是一场裹挟一切的变革；（不要低估革命的力量；或者那些力量微小的就根本不是革命；） 你说，我就站着不动，他们就有能力把你生拉上船；你不能，他们就有本事让你能。 未来战争，不在于你拥有多少资源，而在于你能调动资源； 做最好的自己，同时保持开放。—— 90分旅行箱 你不用急着出发，因为你会被抵达。 你不需要以互联网为彼岸，那不是你要穿越过去的，而是他们会来找你的。 效率越来越高，分工越来越细。 只要你的方式是推动效率，你不用关系什么转型； 4.拔河脑洞 中国经济增长会不会遇到天花板？ 我们不能再中国国土框架内思考的，必须在全球框架内思考这个问题。 人们用两种范式来思考世界：自然地理、地缘政治 物理距离，并不是真实的距离 地缘政治把世界分割成地图上的样子 基础设置把世界连接成另外一个样子 世界不再是块与块的拼图，还是基础设施连成的电线网 城市化，把平摊的 “面” 变成聚拢的 “点” 只拥有，不连接，就是一个资源孤岛 拔河游戏，是所有人都参与的游戏，希望所有人都参与。拳击比赛，是强者的比赛，是有准入门槛的； 拳击比赛的逻辑不可持续，因为已经很难找到具体的人 ； 【启示】一切的边界都在被模糊 拔河游戏，只关心价值移动的方向；中国一家公司想创新的时候，它的创新能力会结合这个国家的规模，在世界上拔河，把这些价值向我们拉过来 一个深刻的真理的反面，可能是一个更深刻的真理。 —— 玻儿 5.终点站脑洞 中国经济增长有没有可持续性？ 雁阵模型：产业会进行转移； “比较理论” 在中国上失效了。 产业更新换代的速度太吓人了。 我们并没有错做什么，但是不知道为什么，我们输了。 —— 诺记亚 自有生产线的速度跟不上产业创新的速度 从 “工厂外包” 到 “风险外包” （苹果公司的创新速度） 高效率 VS. 高弹性 高效率来自分工；分工越细，越高效；但弹性与专业化是矛盾的；专业化带来的低弹性 动态重组的供应链网络（积木） 中国的超大规模性。规模本身就是一种能力； 中国是这一轮全球产业转移的终点站 6.枢纽脑洞 中国能否赢得良性的全球发展环境？ 中国未来的全球角色？中国是世界秩序的自变量； 世界对中国的一个需求，把我们塑造成的一种角色； 双循环 结构。中国成为一个不可缺少的节点；是世界的十字路口； 西方通过中国投放秩序；欠发达国家通过中国发展繁荣 历史上的国家和衰败，只是影响到自己；今天任何一个国家的衰弱， 都可能影响世界上其他地方；—— 《枪炮病菌与钢铁》 西方不输出繁荣和秩序，就会被输入贫穷和动乱 西方渴望帮助非洲，结果反而摧毁了非洲的经济 【共鸣】援助是没有办法真正改变贫穷的； 建立秩序，必须把简单的援助转化为具体的经贸过程； 摘抄 大者越大，强者恒强 “黑洞效应”：一家公司有两个特点：网络协同 + 数据只能 快：小米步枪（吃鸡游戏）；第三天网易发布两款同类游戏；一周内腾讯发布游戏；网络市场，先发优势很重要。小米步枪占领Apple Store 中国第一名，就省去了几百万美元的推广费； 机器快、公司快、市场快、用户快 一家游戏公司，在未取得授权之前在网络发布，等到第二天从市场数据的反馈告诉你哪个明星是有效的，立马与对方的经纪人联系。 玩家迭代的方向，就是产品迭代的方向。 【启发】想起这样一句话，每个人都在问什么在变，我们要知道的是什么没有在变。客户对于简答的需求没有在变，那就是我们要做的方向。 豌豆公主效应：体验是一种可训练的能力；一旦达成，就再也退不回去了。 音频的二倍速、三倍速、五倍速； 竞争是过去的商业关键词；现在是我们必须追赶用户。 你必须不停地奔跑，你才能留在原地。 ——《爱丽丝》 创新，就是解决问题的能力。—— 熊彼特 人生算法 算法 VS. 规律 即使机会相同，算法不同，结果就不同； 一个按钮得100万美元；一个按钮一半得一亿美元，一半是什么都没有。 人生算法，不断提高达成目标的概率的过程； 人生的一切结果本质上都是概率问题；所有的人生的选择和目标，都是那个一亿美元； 算法就是在连续性基础上运行的原则； 所谓的人生算法，就是在漫长的过程中不断找到那个最初的原则。 当成功概率很高的时候，下最大的赌注；其余时间按兵不动； 人生就是滚雪球，找很多很湿的雪，加上一道很长很长的坡，然后把自己那个最原初的算法，那个雪球一直滚下去 —— 巴菲特 成就 = 核心算法 $\times$ 大量重复动作$^2$ 找到那种值得不断重复下去的最基本的套路； 抓住它、重复它、强化它 算法的力量，把一切软肋变成铠甲； 岁月不饶人，我亦未曾饶过岁月。—— 木心 ​ 启发 罗胖的内容很正能量，很有感染力；同时也会营销；（拿出你的手机，拍照照，发个朋友圈，说我相信） 罗胖，一直不忘记他的用户；也不忘记他的赞助商；他真诚，这个也是我所需要的。 视频160分处 对时间的掌控能力，尤其是最后一段时间；真厉害； 书籍推荐 《超级版图》：真实的世界什么样？ 《枢纽》 《原则》Ray Darial]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书籍_2017年度]]></title>
      <url>%2F2018%2F01%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB_2017%E5%B9%B4%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[2017年共阅读8个大类，共计38本+2场Live，读书笔记22篇；罗辑思维音频若干（含1场时间的朋友）； [TOC] 类别 《书名》_作者 / 阅读时间 - 读书笔记链接 《原名》 - 原作者 一句话概括整本书的核心内容，最多不超过三句话。这个是原则。 关于一本书的概括，暂未做补充。 心理学、社会认知与发展史 《理性乐观派》_[英]马特.里德利 / 2017-04 Matt.Ridley 从经济学的角度解释了整个社会的发展。 《未来简史》_[以色列]尤瓦尔•赫拉丽 / 2017-04 Yuval Noah Harari 《文明是副产物》_郑也夫 / 2017-05 《代价论》_郑也夫 / 2017-06 《信任论》_郑也夫 / 2017-06 ​ 数据分析 《Python编程：从入门到实践》_[美] Eric Matthes / 2017-05 《利用Python进行数据分析》_Wes McKinney / 2017-05 《Python核心编程》_[美] Wesley J. Chun / 2017-12 《统计学习导论：基于R应用》_[美] 加雷斯.詹姆斯 &amp; 丹妮拉.威滕 / 2017-09 《An Introduction to Statistical Learning : with Application in R》_Gareth James &amp; Daniela Witten 《数据的本质》_车品觉 / 2017-10 《数学之美》_吴军 / 2017-11 《大数据时代》_维克托.迈尔.舍恩伯格 &amp; 肯尼斯.库克耶 / 2017-11 Viktor.Mayer.Schonberger &amp; Kenneth.Cukier 《智能时代》_吴军 / 2017-11 《精益数据分析》_[加] 阿利斯泰尔.克罗尔 &amp; 本杰明.尤科维奇 / 2017-11 Croll, A. &amp; Yoskovitz, B 从商业运作的角度阐述了不同行业运作的规则，并针对性地给出不同行业中所关注的核心指标。 ​ 思维意识与生活态度 《断舍离》_[日] 山下英子 / 2017-10 《怦然心动的人生整理魔法》_[日] 近藤麻理惠 / 2017-10 《人活到极致一定是素与简》_[日] 山口势子 / 2017-12 《麦肯锡教我的思考武器》_[日] 安宅和人 / 2017-12 《最重要的事只有一件》_[美] 加里.凯勒 &amp;杰伊.帕帕森 / 2017-12 Gray Keller &amp; Jay Papasan 《精要主义》_[英] 格雷戈.麦吉沃恩 / 2017-12 Grey Mckeown 《专注力：化简为繁的惊人力量》_[英] 于尔根.沃尔夫 / 2017-12 Jurgen Wolff 《每天最重要的2小时》_[美] 乔西.戴维斯 / 2017-12 Josh Davis 工作与学习方法 《读书经验分享 - 知乎Live》_李笑来 / 2017-04 《如何自学计算机专业课程 - 知乎Live》 / 2017-06 虽然标题是关于自学计算机课程，但很大部分内容是关于大脑对记忆与学习的机理。包括工作记忆与长期记忆，包括学习的过程是建立新知识与已有知识网络的连接，是重组神经元的过程。知识，必须形成网状结构的知识，才是有效的知识。这一部分对于更好地利用大脑特性学习新知识有很大帮助。 《麦肯锡方法》_艾森.拉塞尔 / 2017-07 （二刷） 《金字塔原理》_巴巴拉·明托 / 2017-06 （二刷） 《学习之道》_芭芭拉•奥克利 / 2017-06 Barbara Oakley 《刻意练习》_[美] 安德斯.艾利克森 &amp; 罗伯特.普尔 / 2017-07 Anders Ericsson &amp; Robert Pool 《练习的心态》_[美] 托马斯 M. 斯特纳 / 2017-07 《The Practicing Mind》_ Thomas M. Sterner 《麦肯锡精英的48个工作习惯》_[日] 户塚隆将 / 2017-07 《麦肯锡精英的39个工作习惯》_[日] 大岛祥誉 / 2017-07 《习惯的力量》_[美] 查尔斯.杜希格 / 2017-11 《The Power of Habit》_ Charles Duhigg 《思考，快与慢》_丹尼尔.卡尼曼 / 2017-10 ​ 企业发展与管理 《浪潮之巅》_吴军 / 2017-11 讲述了在美国硅谷从 19世纪的 IBM 到 21世纪的Google 百年多来各个世界巨头企业的发展史，深入剖析了各个巨头在发展、兴盛与衰亡的过程中的内外部环境及原因，是一部非常宏伟的历史长图。 经济类 《货币金融学》_费雷德里克.S.米什金 / 2017-07 （未完） Frederic S. Mishkin 人物传记 《你好，我是费曼》_理查德.费曼 / 2017-07 [美]Richard P. Feynman 《向死而生：我修的死亡学分》_李开复 / 2017-11 讲述的是李开复在诊断出患有癌症后，在治疗中关于对待人生的感悟，对于在事业、家人与生活之间的关系有了新的认识。 ​ 文学小说 《离开前请叫醒我》_卢思浩 / 2017-03 《局外人》_[法] 加缪 / 2017-12 《看见》_柴静 / 2017-10 （未完）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018年新年目标：做一个精要的人]]></title>
      <url>%2F2018%2F01%2F02%2F%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%2F2018%E5%B9%B4%E6%89%93%E7%A0%81%E8%AE%B0%E5%BD%95%20-%20%E5%81%9A%E4%B8%80%E4%B8%AA%E7%B2%BE%E8%A6%81%E7%9A%84%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[思考2018年应该做的一件事。应该做，而不是可以做；是一件，而不是很多件；是至始至终，而不是始乱终弃； 2018年新年目标：做一个精要的人 所谓精要，即精简扼要，永远意识到最重要的一件事；优先定义问题与确定关键问题，并将最大的资源用于解决关键问题上。 #以下打码记录# a - 表示早睡早起且进行了精要之事的记录； b - 表示晚睡晚起有记录； c - 晚上补写日志； 空白 - 未写日志 不能因为是周末，就可以晚睡晚起，甚至熬夜； 1月 2月 3月 4月 5月 6月 1.1-b 2.1-a 3.1-a 4.1-b 6.1-b 1.2-c 2.2-a 3.2-a 4.2-a 5.2-a 1.3-b 4.3-b 5,3-b 1.4-b 4.4-a 5.4-a 6.4-b 1.5-b 2.5-a 3.5-a 4.5-b 2.6-a 3.6-a 4,6-b 5.6-b 1.7-b 2.7-a 3.6-a 4.7-b 5.7-b 1.8-b 3.8-a 4,8-a 5.8-b 6.8-a 1.9-b 4.9-a 5.9-b 6.9-a 1.10-b 4.10-a 6.10-b 1.11-b 3.11-c 4.11-c 5.11-b 6.11-a 4.12-b 6.12-a 4.13-b 5.13-b 6.13-b 3.14-a 4,.14-a 5.14-b 6.14-b 1.15-b 3.15-a 4.15-b 5.15-b 6.15-b 1.16-b 4.16-a 5.16-b 6.16-b 1.17-b 4.17-b 5.17-b 6.17-b 1.18-b 4.18-b 5.18-b 6.18-b 1.19-b 4.19-b 5.19-b 6.19-b 1.20-b 3.20-c 4.20-b 5.20-b 6.20-b 3.21-b 6.21-b 2.22-a 3.22-b 6.22-b 1.23-b 2.23-b 3.23-b 4.23-a 1.24-b 3.24-b 5.24-b 6.24-b 5.25-b 1.26-b 2.26-b 3.26-a 6.26-b 2.27-b 2.27-b 3.27-a 4.27-b 6.27-a 2.28-a 3.28-b 4.28-b 5.28-b 6.28-b 1.29-b 3.29-a 5.29-b 6.29-b 1.30-b 3.30-a 5.30-b 1.31-b 3.31-a 4.30-b 5.31-b 7月 8月 9月 10月 11月 12月 8.1-b 7.2-b 8.2-b 7.3-a 8.3-b 7.4-b 7.5-b 7.6-b 8.6-b 8.7-b 8.8-b 7.9-b 8.9-a 7.10-b 7.11-b 7.12-b 7.13-b 7.14-b 7.15-b 7.16-a 7.17-a 7.24-b 7.25-b 7.26-a 7.27-a 7.31-b 7.18-7.22 : 参加字节跳动《渠道年中交流会》]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2018%2F01%2F01%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FMarkdown%2F%E7%A9%BA%E7%99%BD%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[主题]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2018%2F01%2F01%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%2F%E3%80%8A%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%5B%E7%BE%8E%5D%E5%BD%BC%E5%BE%97.%E8%80%83%E5%A4%AB%E6%9B%BC%2F</url>
      <content type="text"><![CDATA[《穷查理宝典》 - [美] 彼得.考夫曼 | 《English name》Author | 2010.10 《》 - [美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 AI Ries &amp; Jack Trout | 2011.09 01 【初始疑问与目的】 S：想要学习理财的知识，不仅仅是方法，更重要的是理念的学习。于此一起买的书还有《财务自由之路》博多.舍费尔 W：关注并记录重要的投资方法与理念 02 【作者关注的问题】 what： 03 【文章展开的方式】 文章脉络如何展开： 作者的原文回答： 其他人的观点： 作为读者，你怎么看： 04 【对我的指导意义与行动】 对我生活与工作的指导意义： 准备具体怎么去做： 05 【总结回顾】 回答自己的问题： 作者简介与著作背景： 一句话概括：]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2018%2F01%2F01%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%2F%E3%80%8A%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%8D%9A%E5%A4%9A.%E8%88%8D%E8%B4%B9%E5%B0%94%2F</url>
      <content type="text"><![CDATA[《book name》 - [美] author | 《English name》Author | write_time 《》 - [美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 AI Ries &amp; Jack Trout | 2011.09 01 【初始疑问与目的】 S： W： 02 【作者关注的问题】 what： 03 【文章展开的方式】 文章脉络如何展开： 作者的原文回答： 其他人的观点： 作为读者，你怎么看： 04 【对我的指导意义与行动】 对我生活与工作的指导意义： 准备具体怎么去做： 05 【总结回顾】 回答自己的问题： 作者简介与著作背景： 一句话概括： 总结、思考与行动，永远比阅读更为重要，也比做完读书笔记重要。所以，做完读书笔记之后，重新再次思考；回答一下所有的问题。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2018%2F01%2F01%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E3%80%8A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_xxx%2F</url>
      <content type="text"><![CDATA[《book name》 - [美] author | 《English name》Author | write_time 《》 - [美] 艾.里斯 &amp; 杰克.特劳特 | 《Horse Sense》 AI Ries &amp; Jack Trout | 2011.09 01 【初始疑问与目的】 S： W： 02 【作者关注的问题】 what： 作者的原文回答： 03 【文章展开的方式】 文章脉络如何展开： 其他人的观点： 作为读者，你怎么看： 04 【对我的指导意义与行动】 对我生活与工作的指导意义： 准备具体怎么去做： 05 【总结回顾】 回答自己的问题： 作者简介与著作背景： 一句话概括： 阅读不会让你成长，思考与行动才会。所以，做完读书笔记之后，重新再次思考；回答一下所有的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《精要主义》读书笔记_格雷格.麦吉沃恩]]></title>
      <url>%2F2017%2F12%2F31%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%E3%80%8B_%E6%A0%BC%E9%9B%B7%E6%A0%BC.%E9%BA%A6%E5%90%89%E6%B2%83%E6%81%A9_Grey.Mckeown%2F%E3%80%8A%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%A0%BC%E9%9B%B7%E6%A0%BC.%E9%BA%A6%E5%90%89%E6%B2%83%E6%81%A9_20171231%2F</url>
      <content type="text"><![CDATA[《精要主义》_格雷格.麦吉沃恩 《Essentialism : The Disciplined Pursuit of Less》_ Grey.Mckeown 目的：精要，即重要的事。懂得如何识别与运用；强化思维；为2018年成为一个精要的人做理论研究 导读 如果你不能安排自己生活的优先次序，就只能任由别人来替你安排。 If you don’t prioritize your life, someone else will. 精要主义是对 “更少，但更好” 的不懈追求。这意味着不是偶尔为之，而是把追求 “更少，但更好” 当做行事的铁律。 不断停下来反问自己 “这件事值得我投入时间和精力吗？” 精要主义不是如何完成更多的事，而是如何做好对的事。它不是为了提倡少做而少做，而是主张做必做之事，尽可能做出最明智的时间和精力投资，从而达到个人贡献峰值； 成功的悖论：社会中我们因为正确的行为（说 “不”）而受到惩罚，因不正确的行为（说 “好”）而受到奖赏。因为前者往往会令当时的气氛变得尴尬，而后者通常受到赞美； 第一阶段：如果我们真的有清晰的目标，它有助于我们取得成功 第二阶段：当我们成功时，被冠以 “可以去找的人” 的称号，成为老好人。只要你需要，就总能找到这个人。这样，我们就能得到更多的选择和机会 第三阶段：当我们拥有了更多的选项和机会，实际上就被要求付出更多的精力和时间，这样便会导致精力的分散 第四阶段：因为精力分散，我们无法实现原本可以实现的个人贡献峰值；成功所带来的后果最终瓦解了最初指引我们走向成功的那个真正清晰的目标 成功会让我们偏离最本质的事情，这些事情最初曾是成功的源泉。 选择的数量呈指数级增长：这是历史上第一次，拥有选择的人的数量有了极大的增加，而我们的社会却还未完全准备好这一切； Part 1 精要主义者的核心思维模式 时间与精力只用于有意义的事 选择 $\to$ 甄别 $\to$ 取舍 摆脱三种错误的想法 我必须做 这些都重要 我能二者兼顾 拥抱的三条核心真理 我选择我要做的事 只有小部分事情是重要的 我能做任何事但不是所有事 选择：一种战无不胜的力量 选择：选择如何支配自己的精力和时间； 非精要主义：我必须做 （丧失选择权） ​ 精要主义：我选择做 （运用选择能力） 选择是成为精要主义者的核心所在。必须高度重视选择能力，把它视为一种战无不胜的力量，它的存在独立于其他任何事物、任何人以及任何力量； 一旦我们放弃自己选择的能力，别的力量或别人就会替我们做出选择； 人们常把选择视为一种事物，但它不是事物。我们面临的选项也许可以算做事物，但选择是一个行为动作。 我们也许无法完全左右自己会有哪些选项，但可以永远掌握自己如何从中选择； 选项（事物）会被拿走，但进行选择的核心能力（自由意志）却不会 选择能力不会被夺走，不会被丢弃，只会被遗忘； The ability to choose cannot be taken away or even given away —— it can only be forgotten. 习得性无助； 强迫自己去做更多的方式不过是一种障眼法；这样的人不相信自己可以选择机遇、任何和挑战，而是认为自己 “必须什么都做” 。 甄别：几乎一切都是噪声 几乎一切都是噪声，只有少数事情有非凡价值。应该努力去辨别什么才是最重要的 非精要主义：认为几乎一切都重要，将所有机会视之等同 ​ 精要主义：认为几乎一切都不重要；区分重要的少数和不重要的多数 真正重要的是时间与结果之间的关系。 重要少数法则（现代管理之父 - 朱兰）：人们可以通过解决问题中一个微小的部分来极大地提供产品的质量 幂次定律：某种努力与其他努力相比，确实会使成果呈指数级增长 最优秀的软件工程师的开发效率比一般的软件工程师不是强10被或100倍，甚至不是1000倍，而是10000倍； 我们生活的世界中几乎一切都是无价值的，仅有极少的事物例外；几乎一切事物的次要性再怎么高估都不够。 精要主义者用更多的时间来辨别，以便花更少的时间来做。 取舍：我要的究竟是什么 取舍：接受取舍的现实 你必须审视每一个机会，然后说， “不，我很抱歉。我们不想做那么多件不同的事情，如果它们对我们努力要实现的最终结果没有太大贡献的话” （Relevant） 在现实中，接受任何一个机会都无疑需要你舍弃其他几个机会。 我们要么自己做出艰难的选择，要么允许其他人替我们做出决定 【反思】价值观的体现，是在冲突中表现出来的； 当一个人面对不用的情况如何做选择时，才真正体现了他的价值观； 精要主义者不问 “我应该放弃什么？” 而是问 “我要大干一场的是什么？” ； 这样小小的改变，日积月累会产生意义深远的影响； Part 2 第一步：探索 区分；区分无意义的多数和有意义的少数 精要主义者花更多的时间用于探索、倾听、辩论、质问和思考。但是，探索本身不是他们的目的，真正的目的在于将有意义的少数从无意义的多数中甄别出来。 精要主义实际上会探求更多的选项。他们在行动之前会系统地探索和评估多个选项，因为他们会在一两个大的项目上大干一场，所以一开始就会慎重地探索更多地选项，来确保自己做出的选择是正确的； 几乎所有的事情都会引起非精要主义者的兴趣，也会引起他们的反应。但是，正因为如此忙于追逐每一个机会和每一种想法，他们实际上在选项探索上花费的精力少之又少。 抽离：为探索和思考留出空间 非精要主义：忙得无暇顾及人生 ​ 精要主义：抽身而退，探索人生 人们习惯将 “焦点” 视为一种事物。焦点的确是我的拥有物，但它同时也是我的行为。 为了找到焦点，我们需要抽身而退，全力聚焦； In order to focus we need to escape to focus. 有意识地留出没有分心物的时间、没有分心物的空间，除了思考，绝不做任何别的事情 向对方解释，在完成本书之前，都不要来打扰我；这种 “修行模式” 带给我的自由，怎么高估都不为过； 重要的是你要创造一个空间，让自己从忙碌的生活中抽身而退。 审视：关注真正重要的事情 非精要主义：注意最大的声音；听所有说出来的话；被海量信息压垮 ​ 精要主义：关注声音传递的信号；听么有说出来的话；审视查找信息的精华 要理解这篇新闻到底意味着什么，以及它为什么重要。新闻记者的价值在于发现那些对人们真正重要的东西； 写日志，成为自己人生的记者；并且每隔一段时间来回顾； 要捕捉标题，寻找自己每天、每周生活中的导语。 实地探索，认清问题本质 把自己置身于场景中；关键在于接触实际发生的那个场景 捕捉不正常与不寻常 要汲取故事的精华，需要深刻理解它的主题和语境，需要将它放在一个更宏大的图景中去俯仰观察，需要找出他和其他领域的关联 走出推诿逃避的怪圈 培养 “新闻记者” 的四种方法 游戏：拥抱内心孩童的智慧 不要把游戏定义为仅仅是电子游戏；自己不爱电子游戏，但喜欢其他互动类的游戏； 学校在一定程度上是在扼杀创意。我们把自己卖给了一种快餐式的教育模式，它使我们的精神和活力日渐枯竭，就像快餐侵蚀我们的身体。想象力是人类一切成就的源泉。 那种 “游戏不重要” 的想法跟随我们。这是因为现在公司诞生于工业革命时期，那时它们存在的全部理由就是提高大规模生产产品的效率。而且，这些早期的管理者还把眼光朝向了军队。 【反思】：理解一件事情，必须要去理解他的场景；SCQ在什么样的场景下产生了什么冲突，产生了什么行为，目的是什么 当我们玩的时候，人性得到了最纯粹的表达，个性得到了最真实的展现； 睡眠：保护你的身心资产 每晚，当我入睡时，我死去；次日，当我醒来时，我重生。—— 甘地 每个人的头等大事，是确保自己有能力决断什么才是头等大事； Our highest priority is to protect our ability to prioritize. 精选：只接受前10%的机会 非精要主义：接受一切要求和机会；运用宽泛的、盲从的标准（如果我认识的人在做，那我也应该做） ​ 精要主义：只接受前10%的机会；运用挑剔的、明确的标准（这确实是我所追求的吗） 如果答案不是一个确定的 YES，那么就应该是一个确定的 NO。 90%法则：在做每一项决定或每一次选择的时候，评估每一项时，考虑一个最重要的决定标准，然后在0~10分之间为这个选项打分。如果得分低于9分，那就自动把它降为0，并且果断淘汰它。 如果某物/某事刚刚好或者差不多，正好是7分或8分，那么结果就是淘汰；这大大简化了问题。 这种精挑细选的方法有着显而易见的好处：如果我们的选择标准过于宽泛，就会发现自己要面对的选项太多太多。更重要的是，对选项的价值进行评分，能让我们更自觉、更有逻辑、更加理性地做出选择，而不是听凭一时的兴趣或情绪所支配。 【关键】明确的标准；非精要主义运用的是一种盲从的、无法明确表达的标准； Part 3 第二步：排除 行动；摆脱无意义的多数。当我们丧失选择权的时候，别人会替我们做出选择。所以，要么慎重地有所不为，要么不由自主，任人摆布。 澄清：明确的目标 $\to​$ 边界：设定标准 $\to​$ 勇气：选择项目 $\to​$ 放弃：已有项目及时终止 人们往往高估自己已经拥有东西的价值。于是扔掉这些东西就更难。问你一个问题（假设你还没有拥有它） “如果没有它，我愿意花多少钱去买它” “如果没有这个机会，我愿意做什么来得到它” 澄清：做一个以一当千的决定 从 “很清楚” 到 “真的很清楚” 目标SMART原则 边界：设定界限会带来自由 “不”， 是一个完整的句子。 非精要主义：认为如果有界限，自己将受到限制；视界限为约束 ​ 精要主义：懂得如果有界限，自己将不受限制；视界限为自由 界限的丧失是非精要时代的典型特征；并且问题不仅在于界限已经模式，还在于工作的界限已经恶意侵蚀了家庭生活的领地； 精要主义者视界限为一种授权。界限保护了他们的时间，使之免受劫持。界限让他们摆脱了对有利于实现他人目标而非自身目标之事说 “不” 的负担。（因为他们知道，清晰的界限能让他们积极主动地淘汰各种要求和累赘之事） 设定边界，才能获得自由。If you have limits you will become limitless. 免受他人事务烦扰的方法 别人的问题不是你的问题（如果把别人的问题变成我们的问题，那么我们就不是在帮他们，而是在纵容他们） 【反思】这一点上，自己做的还是不错的；80分 没有界限，就没有自由； 找到自己的坏事者（如果你不能和自己、和别人说清楚这些界限，那么你就不要期待别人能够尊重或者找到你的边界） 【反思】这一点上，工作中，自己是有明确的边界 指定契约/规则 勇气：优雅说”不”的力量 非精要主义：为了避免社交尴尬和压力而不说 “不”；应承一切事 ​ 精要主义：勇于坚定地、决绝地，优雅地说 “不”；只答应真正的要事 尽管拒绝别人时如此艰难，但如果不这样做，我们就会错过重要地多的东西； 我们分不清什么才是重要的事情。所以当事情发生时，我们变得毫无防御能力。 【反思】必须提前明确什么是重要的事，而不是当事情发生的时候在去考虑；当事情发生的时候，我们要做的仅仅是根据之前的标准去判断这件事 优雅说 “不” 的六大原则 把决定和关系分开来。（当别人让我们做什么的时候，我们往往会把这个要求和自己同他们的关系搅在一起） 并不代表一定要 “No” （我很想帮你，可是我已经力不从心了；但是我现在真的没有时间和精力） 关注权衡取舍（在答应的时候，对自己将要牺牲什么考虑得越多，拒绝就会变得越容易） 如果我们不能清晰地认识到机会成本（我们所放弃东西的价值），那么会很容易跌进非精要主义的陷阱 接受自己不能始终让所有人都喜欢的现实；受人尊重比被人喜欢重要的多 一个明确的 “不” 比一个模糊的 “是” 更优雅 （延迟说那个最终还是要说的 “不” ，只会让它更难说出口） 有效的说 “不” 的方法 委婉的说 “不，但是” 我现在在忙事情；但是我可以在后天的时候跟你聊一聊；到时如果你有时间的话 “好的。那我要取消的是什么” 对于来自重要人物的需求，告诉他们当前你正在负责的内容，以及如果你答应这件事，那么你将无法做其他事，让他们来解决这个取舍问题； “这个我做不了，但是XX可能对此感兴趣” （提供其他人的解决办法） 人们在提出要求的时候，通常并不在乎帮助他们的究竟是不是我们，只要有人帮忙就行了。 学会慢一点说 “好” ， 快一点说 “不” 放弃：止损就是最大的赢 人生中一半的麻烦源于答应得太快，拒绝得太慢。 非精要主义：”为什么现在要停止这个项目，我已经在这上面投入了这么多” ​ 精要主义：”如果不是之前已经有投资，我现在愿意在这个项目上投入多少” 陷阱1：禀赋效应（The Endowment Effect）：当一个人没有某件物品时，他就倾向于低估这件物品的价值；而当他一旦拥有该物品，就会倾向于高估它的价值； 生活中，一旦你想放弃它们的时候，它们就会显得更加有价值；想象一下，一本闲置在书架上多年未翻的书，一个仍未开封的笔记本； 对策1：假装未曾拥有它 问 “如果手头没有，我愿意花多少钱来得到它” （而不是 “这件物品估值多少”） 问 “如果没有这个机会，我愿意花多大的代价去得到它” 问 “如果我不是已经参与了这个项目，我愿意花多少代价参与其中” 陷阱2：对浪费的恐惧 选择真正想去做的，忽视沉没成本 对策2：承认失败，让成功开始 （承认错误，没有什么可羞耻的。因为我们真正承认的，现在的自己比过去更明智了） 陷阱3：害怕过错 对策3：逆向试行 最小可行性产品；反向应用，检验取消一项尝试或活动是否会产生负面效应； 编辑：看不见的艺术 非精要主义：认为改善就意味着要增加；对每个词、形象和细节都恋恋不舍； ​ 精要主义：认为改善就是需要删减；删减分散注意力的词、形象和细节 剪辑，就是严格淘汰那些无意义的、不重要的或不相关的内容。它是一种精要工艺。 编辑人生的原则 删减，自律地抛弃 精缩，有有意义的活动取代无意义的活动（你能不能只用一个句子，而不是两个，就把意思说清楚？现在用两个词的地方能不能只用一个词） 用更少的词表达同样的思想，用更小的空间获得同样的功用，或者用更小的努力获得同样的成就。 纠正，反观核心，调整方向 Part 4 第三步：执行 让有意义的少数做起来毫不费力； 关于执行，非精要主义者通常用蛮力执行；精要主义者则通过淘汰无意义之事来节省时间，并设计一套体系，让执行变得毫不费力。 即一旦确定了哪些行为和努力在人生中加以保留，就必须/应该要设计一套体系来执行。 扫除：扫除目标上的主要障碍 $\to$ 进步：最低可行性进步&amp;准备 $\to$ 心流：触发器 - 程序 - 习惯 $\to$ 专注 缓冲：充足准备带来优势 通常会议的最后10分钟被用于提问和评论，但他却坚持留出整整一个小时 出发前，提前一周就开始打包。 提前打包；说不定期间你会突然想起什么 设置缓冲区 做完善的准备 比预计时间多留50% 规划谬误（丹尼尔.卡尼曼）：人们倾向于低估任务完成所需的时间，即便是在以前已经承担过相同任务的情况下也是如此 做好情景规划 扫除：锁定你的”最慢行进者” 锁定你的 “最慢行进者” 之后，想尽一切办法来提高它的速度（不同于木桶理论；在完成一项事的过程中，用一切办法来克服，而不仅仅是通过自身的努力，完全可以是借助他人的力量或寻求他人的帮助） 现状：一群人向山顶走去，但速度有快有慢； 起初的办法让走在前面的人停下来等待，但只能用于一时；很快就又会产生差距 之后按速度排列：从最慢到最快；但劣势是以最慢的那个人的速度在前进 对策：想尽一切办法为走在第一个最慢的人减负（因为走的最慢的那个人决定了整个队伍的速度；哪怕是任何一点加速，都会对整个队伍的行进速度产生影响） 扫除 “最慢行进者” ：精要主义者不关注需要增加哪些精力和资源，而是关心哪些限制和障碍需要连根拔起； 弄清核心目标，确定要扫除的障碍是什么； 锁定障碍，但不要试图一下子扫除所有障碍； 目标：完成报告的草案； 因此任何延缓此目标执行的活动都是值得怀疑的； 妨碍目标实现的障碍会有很多。然后在任何一个特定的时间，有且只有一个重要事件。 扫除障碍，从小处开始； 目标：完成报告的草案 考虑：完成比完美更重要 进步：小胜的价值 鼓舞进步所具有的力量。 小小的但实实在在的胜利能够创造推动力，并让人们对自己未来的成功持肯定的信念。 成就 和 对成就的认可，是人类行为两大主要的内在驱动力。 要真正做好重要的事情，必须从小处着手，创造动力。 （To really get essential things does we need start small and build momentum. ） 然后，运用这种动力创造下一个胜利，长此以往，直至取得重大突破。 一种错误的逻辑：要干大事，就必须从大处着手； 鼓励小胜 关注最低可行性进步 （完成比完美更重要） 做最低可行性准备：早而小 “早而小” ，意味着以尽可能少的时间投入，尽可能早地开始 有一位领导者，他非常善于发表激动人心的演说；他解释说自己的秘诀就是在演说的6个月前就开始为这些内容做准备。但不是准备整个讲稿，只是开始而已。 如果未来几个星期有一个重大报告要做，那么你现在就打开文件，花4分钟时间，想到什么就写什么。然后关闭文件；无需太长时间，开始就够了。 任何时候安排了会议或有电话要打，精确地花15秒钟备忘一下那个会议的主题；这样开会当天，只需要参考这个备忘录就可以了。 应对一个重要目标：早动手，小步前进；并且质量/效果往往更佳（因为大脑需要时间去吸收、整理；） 直观地嘉奖进步 直观地看到自己正朝着目标进步，会产生一种巨大的力量。 人是会被机制/制度/环境所影响的。不要高估自己的意志力。 改变孩子爱看电视的行为：每周一开始，孩子们可以领到10个代币。每个代币可以换30分钟屏幕时间，或者在周末的时候换50美分；如果哪个孩子读书30分钟，那他就可以获得一个额外的代币；结果是一夜之间，屏幕时间下降了90%，读书时间上升了同样的百分比； 心流：常规造就天才 非精要主义：凭蛮力执行重要任务；让非重要事物成为默认选项 ​ 精要主义：设计一种处理重要事务的常规，让重要事务处于默认状态，让执行毫不费力； 大脑中进行假想演练，是会非常有效的方法；（菲尔普斯每天都在脑中假想自己的动作） 因为大脑中的神经元之间的联系得到了加强 释放常规的力量 彻底检修你的触发器 《习惯的力量》：每一个习惯都是由 “刺激、常规、激励” 组成；如果想改变自己的常规，并不需要真的去改变行为。 创建新的触发器 通过设置场景（物理上的提醒更加有效）来创建触发器 并且充分利用已有的习惯， 而不是费力去创建新的习惯 有人养成了每天在固定时间写下内容的习惯；虽然听上去很容易，但我们知道自己 [需要某种刺激物来提醒] 自己在每天特定时间内写作，否则会像以前那样拖延； 因此，开始把日记本放在包里，紧挨着手机；这样，每天晚上当我把手机从包里拿出来充电时，我就会看到日记本，它会提醒我在上面写东西； 先做最困难的部分 运用上述方法建立一种常规，让攻克一天中最困难的任务成为每天早上的第一件事。找到一种刺激物 （可以是出现在写字台上的第一杯橙汁，还是手机上的闹铃，或是任何一件你已经习惯一大早就最先做的事情）来出发你坐下来，把精力集中到最难的事情上去 建立混合型常规 逐个击破 专注：当下最重要的是什么 专注于最重要的东西，就是专注于此时此刻。 全身心投入吃饭的这一刻：当我缓慢地吃下第一口食物时，变化出现了。我注意到了自己的呼吸。觉得全身心地融入了此处。； 看他做食物，发现他整个人都沉浸进去了 在担心过去或未来上花费的任何一秒钟，都在分散抽离着你对此时此刻地重要事务的关注。 同时做两件事轻而易举，但同时专注于两件事是几乎不可能的； 活在当下 想清楚当下最重要的是什么 当你面临很多任务，以至于不知该从何下手时，停下来，深呼吸；投入到当下，问问自己此时此刻最重要的是什么。不是明天，甚至也不是一小时后最重要的是什么。如果不确定，那就把所有争抢你注意力的事情都列出来，然后划掉此时此刻不重要的事情 把未来清除出去，会更加专注于当下 把出现的想法记录下来，写下来；但这个清单并不是记录承诺的，只不过把这些想法从大脑中清除出去，留在本子上而已； 保证了不会忘记这些想法，他们也许将来会被证明有用 减轻了大脑的负担；减轻了必须现在就去执行的那种压迫感和分心的危险 排列优先次序 凯洛斯时刻：用来更新的停顿（他只是停顿一会儿，闭上眼睛，缓慢地深呼吸一次） 这更像是一种仪式，一种触发器；告诉自己，那个已经过去了。（在走入家门前，他这这种停顿的方式把工作的事情抛在脑后） 结语 存在，设计你的精要人生 把精要主义作为处理所有事情的生活方式；过一种有目的、有意义的生活； 出差时，不要电视或电影，以便有时间思考和休息 经常一整天都在做当天最重要的事，哪怕这意味着做不了其他任务 “成功的悖论” 。我们有明确的目标，它能指引我们走向成功。但是，成功给我带来了新的选项。这听起来很美妙。但要警惕，这些选项会在无意间分散我们的注意力，引诱我们偏离正确的轨道； 当你感受到这些想法的真实性时，它们就拥有了改变你的力量。 As these ideas become essentially true, they take on the power to change you . 在合适的时机向适宜的对象传递恰当的信息 Communicating the right information to the right people at the right time. 【反思】不要给接受信息者无谓的干扰信息；你要对你要传达的信息做选择 精要领导者 对人才招聘挑剔地近乎荒谬（一次错误招聘的代价要远远大于一个人手短缺） 在真正明确核心意图之前，不要停止争论 支持极端授权（授权的关键在于明确性。它不会让角色定位过于原则性和模糊性。它会保证让团队中的每个人都清楚自己改做出什么贡献，以及其他员工都在贡献什么） 在合适的时机合适的人传递恰当的信息 “世界上有一种东西比所有的军队都要强大，那就是恰逢其实的一种理想。” By 维克多 $\cdot$ 雨果 - 法国作家]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《专注力》读书笔记_于尔根.沃尔夫]]></title>
      <url>%2F2017%2F12%2F31%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A%E4%B8%93%E6%B3%A8%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%BA%8E%E5%B0%94%E6%A0%B9.%E6%B2%83%E5%B0%94%E5%A4%AB_Jurgen.wolff%2F</url>
      <content type="text"><![CDATA[《专注力：化简为繁的惊人力量》（第2版）_于尔根.沃尔夫 《Focus : Use the power of targeted thinking to get more done》_Jurgen.wolff 本书是关于 “怎样做” 的内容；而非关于 “什么” 找到专注的焦点 80%的时间里我们都在关心哪些事情没做好；若将注意力集中在我们做好了什么上才是加速进程的关键； 《改变你看待事物的方式》 凯萨琳.克拉默 注意他人所做的积极而有价值的事情，花点时间去赞美。优秀的项目经理知道培训员工的最好方式是强化他们的有效行为； “零容忍” 策略：假装自己还未拥有/投入 如果我当时没有开始看这本书，我现在还会继续看吗？（当你看了一半的时候越看越觉得这本书没意思） 如果我当时没有买这个，现在会愿意花多少钱去买？ 实现目标的过程 设定一个SMART目标 开始做一切你认为可以帮助你实现目标的事情 对过程效果进行监控；如果你做的事情并没有给你带来想要的结果，那就需要赶快调整，找到替换措施做些改变 坚持战略（若无法坚持时，考虑如下原因） 对策略尝试了很长时间，但并不奏效；此时需要头脑风暴，设想一个新的策略并开始 仅仅是忘记了而没有执行，说明这个策略不太方便；因此你需要一个更轻松、更容易上心的方式来做这件事 重复第3和第4，直至实现你的目标（可能失败的唯一原因就是你的自我放弃） 你无法专注于看不见的事物：若要保证每天花时间做对你最重要的事，那就在身边确保一个与此相关的视觉或听觉符号（照片或图画、单词、短语或一段音乐）； 并且定期改变这个符号，这能帮助你更新其力量以提醒你行动 【共鸣】必须要定期改变符号，否则很容易忽视；因为人的大脑就是习惯于忽略不变的内容 专注策略 当你识别出消极模式，要弄清楚这一模式给你带来了什么 想要跳槽却从不才行动的人所收获的，是永远不必被拒绝的风险； 只要是一直在计划，那就不会失败 关键要找出对你有用的方式，这是不断尝试的过程；不要指望你试着做的第一件事会有一个完美的解决方案；（这才是普遍现象） 分配任务：评估哪些工作是可以分配给其他人去做的。你的目标是尽可能多地把时间利用在能给你带来最大价值的事情上； 【反思】：知行合一；你没有这么去做，是因为你没有真正理解这件事情的价值 我们往往没有去做真正要做的事；因为很多时候，做其他事比做我们必须要做的事情更有趣。 低附加价值活动倾向于那些容易的、不会给人带来恐慌甚至可能是让人身心愉悦的事 迈出第一步：分解任务，去做真正要做的事 很多时候，因为事情本身无趣或者困难使我们根本不愿意去做；换个视角，不要去想找个任务会怎么样，而是想想你会怎么样。 （比如一旦你打完这个电话，你将会感觉多轻松？不用为这件事烦恼将会有多美好？） 选择你觉得做起来有趣的部分开始； 这么做的同时你已经为剩余的工作准备好了冲动。 如果你正在写一篇销售，你可能已经对最后的场景做了设想。那么完全可以也应该先写下这一部分的内容 通常发现给你带来最多价值的那20%的事情你已经在做了，只是你做的还不够而已。 专注工具 信息处理 - 选择与忽略 在接触新信息时，先快速提醒自己此时对自己最有吸引力的话题、和你目标最重要的话题 如果你知道这条信息并不相关，那就不要去看它，直接丢弃或者将它放置一边，直到它所包含的信息可能更加相关时再去看。 先洗出所有可能会做的事情（待办清单），再从中自己筛选并排序对你来说最重要的任务 首先处理真正有价值的任务会让你这天的时间感觉轻松很多 休息和反思 这两项不应该成为首先被牺牲的选项 在处理完一件事情之前，不要收邮件，不要看RTX，不要看微信；直至完成这件事为止； ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《每天最重要的2小时》读书笔记_乔西.戴维斯]]></title>
      <url>%2F2017%2F12%2F31%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A%E6%AF%8F%E5%A4%A9%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%842%E5%B0%8F%E6%97%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%B9%94%E8%A5%BF.%E6%88%B4%E7%BB%B4%E6%96%AF%2F</url>
      <content type="text"><![CDATA[《每天最重要的2小时》 - 乔西.戴维斯 《Two Awesome Hours》 - Josh.Daivs 目的：了解如何塑造最重要的2小时 前言 一个错误的方向：在更短的时间里做到更多。只有当我们错误地以为完全依赖于挤出足够多的时间，我们才会面对这种选择的压力。 具身认知：身体影响思维的方式的总称；说明身体上的动作会极大地影响到你的思维。 要想实现真正高产，最好的方法可能是抛弃 “效率” 这个念头，转而创造条件，让自己在每天当中都能拥有极为高效的量2小时。 意识到你的觉察点。 只要你开始一项任务，基本上就会处于自动工作的状态，这就很难改变你工作的方向。因此，要利用好不同任务交接时的那一刻，在这种时候你能够选择下一步该做什么，然后把精力放在接下来最重要的事情上面。 管理你的心理能量 不要与分心做无意义的斗争；了解你大脑的工作方式 利用你的身心联系：运动和饮食 让你的工作环境为你所用 策略一：在日常工作中，认清最重要的事 意识到并抓住觉察点 意识到每天的关键时刻 —— 觉察点 我们一旦开始了一项神经性常规活动，就会像电脑程序一样一直运行下去，直到完成任务或者被打断。 我们的习惯很有必要，因为它们能够节省大脑的能量。（生物进化论的角度） 必须学会意识到 “觉察点” ，只有在这种时刻你才有机会也有能力决定自己如何度过接下来的时间。这种时刻就是你完成或者中断了任务的那个时刻； 我们会如此频繁地进入自动模式，那么每天并没有那么多机会让我们有意识地决定下一步该做什么。因此意识到这些觉察点并抓住它们就显得极为重要。 【原因】 大家习惯于这种时刻（觉察点）匆忙略过，好去做某些让自己觉得 “很高效” 的事。匆忙略过一个觉察点（即不同任务的间隙）也许能给你省出5分钟的时间，但是完成不该完成的任务可能会消费掉1个小时。这5分钟的确会让你不安。因为在这种时候，我们能够非常清楚地意识到每一秒的流逝，而在那浪费掉的一小时中因为名为基本上处于自动模式，所以不会察觉也不会觉得难受。 做出最恰当的选择 “认知上的懒惰者” ：在其他条件完全相同的情况下，我们倾向于选择在思维层面阻力最小的那条路。正因为那些无意识的、已经很熟练的神经性常规程序相对而言更容易完成，所以作为认知上的懒惰者，只要有可能就会更倾向于依赖自动的神经性常规行为，而不是有意识的选择；【原因】 在一步步完成神经性常规程序时，人们会进入一种 “忘我” 的状态。在此状态下，你意识不到周围发生的事。但当常规程序结束时或者被打断之后，自我意识就会浮现出来。从沉溺于神经性常规程度到停止这一程序，这之间的转变很可能让你感觉不适。 两类思维：有目的、有意识的行为；自动的、无意识的行为； 意识最主要的功能就是在我们的自动式神经常规活动遇到困难的时候做出决定。尤其是当不同的刺激性神经常规活动指导我们去做相互矛盾的动作的时候。 觉察点通常 作为冲突的结果 而出现。（无意识的自动行为之间相冲突、行为和目标之间相冲突） 两种行为（盯着电脑 VS. 转过去面对我朋友）是互相矛盾的，才需要这种有意识地评估并做出决定 【反思】解释了觉察点出现的原因以及场景 你越是需要注意自己的思绪、情感和行为，你就越觉得时间流逝得慢。然后，这种不够 “高产” 的时间流逝，并不意味着你浪费了很多时间。这只是意味着我们恰巧更能意识到时间的存在而已。 而恰好正因为觉察这点会让人不舒服，所以我们往往才选择尽快跳过它们。 充分利用觉察点 珍惜每一个觉察点；提前为觉察点做好相应计划；不要随便开始一项新任务 珍惜每一个觉察点：意识到觉察点的出现，并尽力抓住它； 觉察点能够让你与眼下最关注的时拉开一定的距离； 【共鸣】心理学中，两个自我：一个是正在做事的自我；一个是正在观察当下自我的那个自己；你只有意识到它，才有可能去改变它； 提前为觉察点做好相应计划； 可能没办法知道被打断的确切时间，但我们知道这些情况发生的概率很大，而每一次打断都会创造一个觉察点 [ IFTTT ] 可以提前决定：当你被打断的时候，把那一刻变为觉察点； 这些打扰你的情况帮你从忘我状态中走出来，让你重新评估一下自己是否需要切换任务 Eg：对他而言，工作方面的突发奇想往往是在他完全放松的时候出现，特别是在与家人共进晚餐的时候；于是，他提前为这个场景做了计划：如果当他陪着家人时突然灵关一现，那么就花2分钟评估一下这个想法的重要性 【思考】面对不同情境，提前设置规则，提前想象与演练；可以为一般情况建立规则，也可以每天为特定情况临时建立这种规则； 研究表明，当我们在脑中设想某一行动时，所利用的神经回路其实和真正去做这件事时的神经回路是相同的； 不要随便开始一项新任务， 除非已经有意识地决定了它确实值得做 当你完成一项任务的时候，不要去想接下来做什么，而是把一刻标记为觉察点 Eg：当我结束了一节课之后我会对自己大声说 “现在就是个觉察点” 。这句话足够让我真个人停下来 再考虑一下自己目前的身体状态 （是否疲劳、需要休息、喝水、食物），接下来有没有其他事情需要你花更多的能量去做以及你会在什么样的环境下工作 策略二：管理你的心理能量 必须把有限的心理能量全部留给今天最重要的内容 让你心理疲惫的事物 进行自我控制会削弱我们的自控力； 做决定（即使是一些典型的、日常的决定）也会导致心理上的疲惫，由此降低我们做出最佳表现； 【思考】先做最重要的事；知行合一；原因在于此 管理心理能量 重视你身体的信号。 如果在做完某项任务之感觉很累，很可能就是它消耗了大量的自控力；导致疲惫的活动： 不断从一个任务转换到另一任务 交际、与人聊天 做计划、做决定等 我们不需要完全避开这些活动，因为我们不需要每时每刻都处于最佳状态，因为这是不可能做到的；但是，我们可以策略性地安排待办事项的完成顺序，就能够分配出高效的2小时； 早上第一件事就是完成你最重要的工作，不要让你的大脑能力一开始就被几十个小决定消耗殆尽 考虑一下今天所有的待办事项，分类为 “重要的、创造性的、其他” 在第二天有重要活动时，前一天晚上提前做一些决定，不要把它们留到第二天来浪费你的能力 不要轻易承诺做完清单上的每一件事，因为这会浪费掉你本该用在最重要的事情上的能量 必须把有限的心理能量全部留给今天最重要的内容 策略三：无须对抗分心也能更专注 从进化的角度来讲，人的大脑天生就不是为了无限专注于任何事；大脑的构造决定了它会不断在不同的注意点之间来回切换；如果做不到这一点，人类就很难生存下来；想象一下，当你正在采果子的时候也必须要时刻警惕有没有危险接近； 大脑从一个注意点切换到另一个注意点时，它会对那些不变的东西习惯性地视而不见； 可以把那些没有必要存在和让你分心的东西都拿开； 在一段时间内，拿开、关闭或忽视 那些会令你分心的东西（某件物品、手机、即时通讯软件等） 当你在做一件事的时候，不要去看手机、邮箱、即时通讯软件；当你完成的时候在去看。在不同事物之间来回切换注意力，本身就很耗费能量 不要指责自己没有专心致志，不妨静静旁观自己的思绪；只要能避免因无法专注而变得沮丧、疲惫或更加不专心，就能把注意力再次带回到手中的任务上来 把无法长久维持注意力的问题归咎于我们个性上的缺陷，这是一个明显的误区 策略四：掌握运动和饮食的诀窍 当你发现自己头昏脑涨、太过焦虑或者压力重重时，你应该换一种方式利用自己的身体（走动、跑步或做其他事），让自己 “重启” 一下。 不要在桌子边坐得太久。当你意识到这一点，就站起身来走动一下。 策略五：让工作环境为你服务 声音、光线 声音 虽然背景音乐通常能够提升积极的情绪，提高运动方面的表现，并让人们做事更加迅速，但同时它对阅读有着干扰效果。 比起有白噪声的环境，安全的环境对提高效率更有益； 如果能在安静的环境下工作，成效只会更出色 内向的人容易被各种刺激影响，所以对噪声干扰也更加敏感； 对于那些需要运用知识才能完成的任务来说，安静的环境几乎无疑地优于有噪声的环境 背景音乐对创造性工作，有一定的促进作用； 光线 蓝白光对需要专注力和逻辑思考的分析性任务更有利 暗淡光线对创造力更为有利]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《最重要的事只有一件》读书笔记_加里.凯勒]]></title>
      <url>%2F2017%2F12%2F29%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%8A%A0%E9%87%8C.%E5%87%AF%E5%8B%92_Gray.Keller%2F</url>
      <content type="text"><![CDATA[《最重要的事只有一件》 - [美] 加里.凯勒 &amp; 杰伊.帕帕森 《The One Thing: The Surprisingly Simple Truth Behind Extraordinary Results》 - Gary Keller &amp; Jay Papasan 目的：加强意识，促进行为的改变；为2018年成为一个精要的人做理论研究 导言 只做一件事；多米诺效应；成功有迹可循 聚焦目标：意味着你要摆脱所有可以做但不是必须做的事，专注于你应该做的事；必须从中找出最重要的事，这样你的目标和行动之间才有更紧密的联系； 多米诺骨牌：完成最重要的事就像推倒第一块多米诺骨牌，接着来的问题就会迎刃而解； 完成这一件事，其他事情就会自然而然地解决；（理解这个事情的重要性以及效益） “从这里开始发力”。真正的成功人士深知这一点，所以它们都会为当前要处理的事情安排优先次序 【反思】：自己虽然列了任务，但只是简单的罗列清单，并没有对其进行排列，也没有按照这个先后顺序去执行 谎言：误导并阻碍成功 每件事都很重要；你可以同时处理多件事；过上有规律的生活；意志力触手可及；平衡工作与生活；大即不佳； 每件事都很重要 缩减：每天的工作应该围绕着终极目标展开 极致：一旦你意识到什么是重要的，就要继续追问更重要的是什么，直至找到最重要的事。将主要精力放在成功清单的第一项上； 别掉进 “ 待办事项 “ 的陷阱：区别对待每件事，而且要真正做到。 成功人士，在做出决策之前，会充分思考。直至找到主要任务，并以此为轴心再去做其他事。 成功人士对待办事项的认识清醒到位，所以排序正确 帕累托法则（80/20法则）；朱兰定律； 对成功而言，分配也不是不公的；小因成大果的事是很常见的； 绝大部分所得恰恰是靠较少部分付出而获得的； 待办事项清单：只是 [可以做] 事项的堆砌，无法带来成功 清单上靠前的事项不过是你先想到的事务而已；即清单并不具有成功导向性 列清单嫩帮助集中注意力，但往往被它限制。因为不得不去完成清单上的每一件事； 成功清单：[应该做] 事项的基础上，再进行排序 先列出待办事项（可以做、应该做的事情） 挑选出 [ 应该做 ] 的事情 再对事情进行排序 极端的帕累托法则：缩小范围找出你的20%，继续在这20%里面缩小范围，找出关键中的关键； 付出与收获不对等的现象随处可见；【反思：强化这个观点，进而改变思维与行为】 你可以同时处理多件事 我们不是时间太少、事情太多，而是一直在暗示自己要同时做更多的事； 切换任务是要消耗成本的 重新着手某项任务再回到原始任务总会耗费时间与精力；更糟的是，这个衔接的程度不好把握； 我们可以同时做两件事，但同时 [专注于] 两件事是不可行的； 过上有规律的生活 我们需要的不是坚持，而是习惯；要养成习惯，我们就需要自律； 自律不是获得成功的必要条件；去做对的事而不是做对每件事，才是获得成功的方法； 成功的诀窍是选准一个正确的习惯，训练自己，养成这个习惯；我们无需方方面面都自律，你只要挑选最有用的那件事，坚持下去就可以了。 不要试图成为一个完全自律的人；一次养成一个习惯；耐心培养每个习惯；平均需要66天 意志力触手可及 古希腊神化中的奥德赛明白意志力是靠不住的，所以当船驶经塞壬女妖的魅惑之地时，他让船员把他绑在了桅杆上。 如果你想让一天的收获达到峰值，那就必须在意志力消亡之前向目标冲刺。 意志力不是随时都有的；意志力并非取之不尽用之不竭 先做最重要的事，那是因为你的意志力是有限的；当我们体力不支/意志力薄弱时，便会开始陷入 “ 默认选项 “。 消耗你的意志力的事情： 屏蔽干扰 尝试引起他人的注意 抵制诱惑；压抑情绪；防止冲动 做不喜欢的事 在不同事件之间做选择 不要和意志力作对。应该根据它的习惯安排你的生活，而不是反其道而行。 【反思】注意身体的信号，并重视它。而不是忽略它。 平衡工作与生活 平衡的生活就是一个谎言； 失去平衡并不是问题所在，真正的问题是你该如何来调整：短线 or 长线调整 工作的制衡：分成两部分 - 最重要的事 和 其他事 生活的制衡：保持关注，关注每一个元素（心灵和身体、个人需求、家庭、健康、朋友、诚信），一个都不能少； 非凡的成就需要专注和时间，但专注在一件事情上就意味着减少其他事情的时间，集中精力只做这一件事。因此，保持平衡将会困难； 关于 “ 工作和生活的平衡 “ 的文章近年来呈现激增的趋势；并不是因为它是正确的，而仅仅是这是我们所期望的与所追求的，即使它实际上是不可能的或是错误的 我们不应该追求平衡，是因为奇迹不会在中间点发生；奇迹只有在追求极致的过程中才会发生。 追求极端也会带来一系列问题；中庸有时是可取的，有时却不行。要懂得什么时候该选择中庸，什么时候要追求极致。究其本质，这便是智慧真正的开端。 追求平衡的生活意味着无法在任何事情上追求极致； 【反思：场景-时机的选择，衡量了是否真正理解一种方法，是否真正懂得的关键方法】 失衡感：在最重要的事情没有做好之前，你总会觉得事情还没有结束。 通过制衡来进行调节：工作、生活 失去平衡并不是问题所在，真正的问题是你该如何来调整：短线 or 长线调整 在生活中，所有要素一个都不能少，都需要顾及。我们的生活需要严格的制衡。 在工作中，取舍是常态 工作：制衡的秘诀就是 [ 时间上的专注和专研 ]； 需要 [ 长线调整 ]； 若要在事业中做出成就，你就会长期处于失衡状态。长线调整能确保你专注于最重要的事，即使代价是牺牲那些相比之下没那么重要的事情。 生活：制衡的秘诀就是 [ 关注 ]。关注你的心灵和身体，关注你的家人和朋友，关注你的个人需求；需要 [ 短线调整 ] ； 在生活中，所有要素一个都不能少，都需要顾及；既不能为了工作牺牲其中一项，也不能为了某一项而放弃其他要素。 可以将生活的重心在这些要种快速地调整同时兼顾不同的要素，但是不能长时间地对某一种要素置之不理。 生活中你要随时保持短线调整，避免长时间处于失衡状态。短线调整能够让你顾忌所有重要的因素，不至于顾此失彼。 《苏珊日记》中对生活与事业的权衡及重心做了一个比喻：如果把生活想象成一场五球杂耍游戏，五个球分别是工作、家庭、健康、朋友和诚信。你把球抛到空中，游戏就开始了。有一天，你会发现工作是一个橡皮球，如果掉到地上，它会弹回来；而其他的四个球都是玻璃做的，一旦掉了下来，就会磨损、破裂甚至摔个粉碎，到时再后悔也来不及了。 大即不佳 志存高远很重要。因为取得成功要求有所行动，而采取行动需要你首先有想法。但关键问题是，那些成为成功之跳板的行动都是始于远大的理想。 每个人都拥有相同的时间，而且你在工作中所做的事情决定了你能收获什么。而你做的事情取决于你的思考。 成功必然要建立在失败之上。因为失败时，我们就会停下来，问问自己需要做什么才能取得成功。 真理：提高效率的极简之道 关键问题；成功的习惯；如何找到正确答案 成功的定义：那就是在你的生命中，如果你能诚实地说 “ 我 目前 所处的位置就是我 应该达到的地方，我正在做我 应该做的事情 “，那么你的生命将充满无限可能。 关键问题 超越别人的秘诀在于开始行动。怎么开始呢？要把复杂而浩大的工程分解成小的、能够处理的事情，然后 选准 其中一件事下手。 关于大局的问题：我要做的那件最重要的事是什么？ 关于焦点的问题：我现在要做的那件最重要的是什么？ 任何答案的质量都是直接由问题的质量所决定的； 只有问对了问题，才能得到正确的答案。如果你提的问题非常有深度，那么得到的答案将改变你的一生； 伏尔泰曾经写到，” 判断一个人，要从他提出的问题而不是给出的答案出发 “ 培根曾说, “ 谨慎的问题里有一半是智慧 “ 甘地认为, “ 人类在任何方面的进步都是基于问题的力量 “ 反思关键问题的两个时机：停下来 行动开始之前（最佳） 遇到困难或感到疲惫时，停下来 关键问题能让你看清大局，又能帮助你决定下一步往哪里走； 问题解剖：如何找到关键问题。（方法）关键问题将所有问题归纳为一个问题 “ 我能做的最重要的事是什么？为何做这件事就会让其他事都变得更简单或不必要了呢？ “ 第一部分：我 能做 的 最重要的事 是什么？ 这个问题激发你去行动。“ 最重要的事 “ 意味着答案是一件事，而不多件事，你必须想着某件具体的事。 尽管你可能有很多选择，但你要做出判断，否则你就无法继续去做第二件事。你必须做出选择，而且只能选择一件最重要的事。 [ 能做 ] 这个词其实是告诉你要采取可能的行动。很多事情我们必须做、可能做、将会做，但却永远不去做。你因为 “ 能做 “ 而去做，这种力量比意念上的 “ 想做 “ 要大得多 【反思】当下的那一个时刻，你只能专注去做一件事，而不是两件事；如同文字表达只能通过线性的方式来表达，一句话一句话地来描述，而不是同时表达多个事情 第二部分：做了这件事就会 …… （你的答案必须达到一个标准） 这个标准让你从 “ 随便找件事做 “ 转化为 “ 为了某个明确的目标而去做某件事 “。 “ 做了这件事就会 …… “ 告诉你，你必须深挖下去，因为做了这件事之后，就会有另一件事随之发生 第三部分：…… 让其他事变的更简单或不必要了 这件事就像是多米诺骨牌的第一张。做了这件事之后，你就会发现为了实现目标而要做的其他事情其实少花点力气就可以做成，或者压根没有必要去做； 你必须找到第一张多米诺骨牌，然后把全部心思花费在它上面，直到你推倒了第一张牌； 成功的习惯 关键问题很重要，但并非在所有的事情上都会考虑关键问题，而是在相对重要的方面； 【策略】可以预先设置场景，IFTTT；这样就容易触发；因为神经元已经有过刺激 对于要做的事，先做归类，然后在提问题，最后加上 “ 做了这件最重要的事之后就会让其他事情都变得更简单或不必要了 “ ；之后就是花全部的时间与精力在这个事情上面 工作：我做了哪件事之后就可以实现本周的目标，并让其他事情变得简单或不必要了？ 身体：我做了哪件最重要的事，才能释放压力？ 【强调】这个思维很重要（” 做了这件最重要的事之后就会让其他事情都变得更简单或不必要了 “），有助于你去梳理最重要的事 成功的习惯 理解并坚信你要做的那件最重要的事。 （第一步要理解那件事是什么。并 要相信 做好那件最重要的事，你的人生就会因此而改变/其他事情就会变得简单，如果你既不理解也不相信，你也就不会采取任何行动） 把那件最重要的事利用起来。每天问自己 “ 要做哪件最重要的事 “，并把它变成习惯 每天早上醒来问自己 “ 今天，我做了哪件最重要的事之后就会让其他事变得简单或不必要了？” 弄清楚之后，效率就会提高 变成习惯之后，就会把所有的潜能都激发出来 不断提醒自己。 把笔记本、电脑屏保、日历提醒都利用起来，（把所有可以利用的工具都利用起来，强制唤起，短期强化），帮助自己养成习惯 最好的方法，写个纸条 “ 在最重要的事面前，其他事都不重要 “。 “ 完成了最重要的事等于获得了令人满意的结果 “ 寻求支持；组成互动小组，分享 “那件最重要的事” 如何找到正确的答案 我们不能决定未来，但我们可以决定养成什么样的习惯，正是这些习惯决定了我的未来。 提出一个好的问题（SMART原则），就向你的目标前进了一步。（因为它迫使你认清什么事才是最重要的） Special - 具体的； Measure - 可衡量的； Attainable - 可实现的； Relevant - 相关的；Time based - 时限性 相关的：指实现此目标与其他目标的关联情况；如果实现了该目标，对其他目标完全不相关或相关度低，那这个目标即使达到了意义也不是很大； 找到正确的答案（三种答案：可行性的答案、延伸答案、可能的答案） 可行性答案：能获得的最简单的答案在你的知识、技能和经验范围之内的答案；你可以已经知道该怎么做，并且不用太花心思就能找到的答案 延伸答案：在你的范围之内，但需要花很大力气才能获得 可能的答案：存在于已知的领域之外（步骤如下：） 第一件事：寻找可以为你指明方向的线索和榜样，并提出这样一个问题 “ 是否有其他人研究过或获得了类似的成就？ “； 研究其他人的成功之道。其他人的研究和经验是你寻找答案的最佳出发点 。 设立基准，跟随趋势 倘若你真的渴望找到答案，你就必须知道这个答案存在于你的舒适区之外。一个正确的答案从来都不是显而易见的； 一个正确的答案实际上也是一个全新的答案，它能超越当前所有的答案； 成就卓越：释放潜力 找到生活的目标；确定优先事务；高效的生活；三个承诺；四个小偷；生命的旅程 生产力、优先事务、目标，这三个看成冰山的三个部分；优先事务和目标是在水面之下的。这看不见的部分才是呈现在你眼前的事物的先决条件 找到生活的目标 生活的目标不在于找到自己，而在于创造自己。 幸福诞生于圆梦的征途中 勿问结果，只看方向 确定优先事务 只有一件事 $\to$ 用倒推法设立目标 $\to$ 写下来 将所有目标一个个联系起来，直到你找到最重要的那件事。 若直接问自己 “ 为了长期目标，我现在应该做的最重要的一件事是什么？ “ 这样是行不通的。因为现在离将来太遥远，你无法准确地找到关键的优先事务； 你可以在今天、本周、今年的计划中不断添加，但只有完成了所有的添加步骤，才能显示出 “ 优先事务 “ 的威力 “ 为了长期目标，未来5年应该做的最重要的一件事是什么？ 为了5年目标，今年做的最重要的一件事是什么？ 为了今年目标，本月最重要的一件事是什么？为了本月目标，本周最重要的一件事是什么？为了本周目标，今天最重要的一件事是什么？ “ 把今天和明天关联起来，这一点很重要。 有人问我他们应该做什么，我会反过来问他们的方向和长远目标是什么。然后再了解他们当前的场景是什么？ 最后一步，把自己的回答写下来。 高效的生活 注重效率不是永远忙碌，而是明白何为优先事务、何为计划，并且要捍卫自己的私人时间； 为优先事务预留时间，并且 [ 保护 ] 这个时间段 如果优先事务是一次性的，就为它安排几个小时或几天； 如果优先事务是重复性的，就每天腾出几个小时，把它变成一个习惯；其他的事都必须等待；如果将时间这样安排，它或许会成为你余生的时间管理模式； 大多数人认为要取得成功，时间似乎永远都不够，但如果你预留出时间，那时间就够了。预留时间段是一种以结果为导向来看待和使用时间的观点。 每天都 要问 自己这个问题：” 今天我要做的最重要的一件事是什么？ “。一旦找到了答案，就要开始最优化你的工作。 需要预留时间的三件事 预留空闲时间；（休息与工作一样重要） 预留做优先事务的时间（最重要的事排在了第二，因为若你忽视了自己的休息时间，那就无法保持良好的状态） 关键在于 尽早规划 自己的时间；一天规划4个小时比较好 成功人士每天最重要的约会就是与自己相约，并且从不爽约； 高效的人都是以 “ 事件 “ 计时，他们会一直努力，直到完成优先事务 预留做计划的时间 （这是反思自己目前所在位置和目标的机会） “ 根据我现在的情况，我本周有什么样的优先事务才能保证实现我的当月目标？ “ （计划是基于当前所作出的将要采取的行为） 每周预留一小时反思自己的月目标和年度目标 保护你的时间 拥有坚定的意志，抵制打扰与诱惑 来自重要的人的需求，明确截止时间（通常情况下，他们的要求更多是让你立刻去做某项任务，但不需要马上完成，所以提出要求的人需要的答案大多是 “ 这件事我会完成的 “） 【强调】：不惜任何代价维护预留时间； 只有当自己下决心说 “ 我要专注于最重要的那件事，其他任何事、任何人都不能让我分心 “ 这句话时，预留时间才能起作用。 三个承诺 有关最重要的一件事的三个承诺 达到 精通 （把精通当做通往成果的必经之路；并且你对某项技能的精通会随着时间的投入而不断提高） 从 活力四射 到 目标明确（从 Energetic 到 Purposeful） 前者采取的方法：看到想要的事或需要做的事，精神百倍地去将它完成，而不管这个任务是什么 遵循问责周期（责任感，勇于承担责任） 【反思】有一个很奇怪的现象，越是精通的人就越会愿意找相关的老师来指导他们；而门外汉则很少这样做； 找到一位人生导师 四个小偷 专注就是决定什么不要去做。 降低效率的4个小偷：不会说”不”；害怕混乱；糟糕的健康奇怪；逆境 必须要学会说 “不”，你不可能取悦所有人。 你若想要明白自己需要什么，就要明白自己必须放弃些什么； 对自己的长远目标说 “是” 才是重要的。只要记住这一点，就其他干扰项说 “不” 就容易了。 我们都可以采用双方都接受的方式来拒绝。 可以尊重的拒绝 可以在拒绝的同时建议他们去找能够说 “是” 的人；（他们只关注能否解决他们的问题，而对于是谁帮助的并不关心） 我们并不需要达到完美，但每天都要保持能力充足 没有人可以独自生活或工作。每一天，你都与其他人产生关联，并受到他们的影响。你周围的人比你想象的重要。 态度是会传染的。你可能认为自己很强大，但没有人可以强大到永远不受消极态度的干扰。 没有人会独自取得成功。注意观察你周围的人，让他们支持你，为你指明方向。你生命中的很多人都会影响你，这种影响力或许比你想象的大得多，你要尽快去寻求正向的影响力。 剧作家利奥 $\cdot$ 罗斯滕 曾说，” 我认为人生的目的不是幸福，而是有意义、有责任和常葆激情。最重要的是去做事，让世界因为而改变。 “ 生命的旅程 我们有很多方法可以衡量自己的生活是否有价值，其中最显著的途径就是去看看自己是否一生无悔； 让你觉得更失望的不是你做过的事情，而是那些你没有做过的事情 我们最大的遗憾就是：没有鼓足勇气去做另一种生活 当人们回顾一生，那些没完成的事情最让他们感到遗憾…… 虽然他们做过的一些让自己懊恼的事，但最终让他们后悔、受尽煎熬的还是那些没有做过的事情 后记 重要的是要去这样的意识，并时常反问 [ 验证] 关键问题的方法，在每个问题之后加上一句 “ 这使得其他事情变得简单或不再必要了 “ 对每一个模块（个人、家庭、工作、工作团队），通过反问自己 “ 我应该做哪一件最重要的事，来达成 XXXX “ 关于个人 如果我每天挤出20分钟来练习吉他，那么我应该只做哪一件最重要的事？ 关于家庭 我们应该做哪一件最重要的事，来改善我们的婚姻生活呢？ 我们应该做哪一件最重要的事，来辅导孩子的功课呢？ 关于工作 如果想在下一次述职前得到提拔，我要如何坚持只做一件最重要的事？ 若要提前完成工作，我要如何坚持只做一件最重要的事？ 应该如何坚守 “ 只做一件最重要的事 “ 的原则，才能高效完成工作 关于工作团队 在会议上，可以提问 “ 我们只做哪一件最重要的事，才能尽快完成任务，早点结束这个会议 “ 建立自己的团队时问自己，在接下来的6个月里，应该只做哪件最重要的事来挖掘培养那些关键的人才？ 关于慈善事业、关于学习、关于社区、关于地位与名望]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《数学之美》读书笔记_吴军]]></title>
      <url>%2F2017%2F12%2F09%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F110_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E3%80%8A%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%90%B4%E5%86%9B_201711%2F</url>
      <content type="text"><![CDATA[《数学之美》_吴军 阅于2017年11月 相关性（概率）、权重 是核心 理解当前网络机理的同时，也深刻认识到自己在数理知识与编程上的不足。不应该在这个方向深入太久； 语言处理 第1章 ~ 第7章 第1章 文字和语言 Vs. 数学和信息 数学、文字和自然语言一样，都是信息的载体。区别只是信息编码的不同单位而已； 数学和语言的产生都是为了同一个目的：记录和传播信息 直到香农博士提出信息论，人们才把数学和信息系统自觉地联系起来。 信息传播的模型： $$ 信息源 \to 编码 \to 信道 \to 解码 \to 接收者$$ 翻译这件事之所以能达成，仅仅是因为不同的文字在记录信息上的能力是等价的。 文字只是信息的载体，而非信息本身 那不用文字，而用其他载体（比如数字）也是可以存储相同意义的信息 古印度人发明了0 - 10 个 阿拉伯数字 象形文字到拼音文字是一个飞越；因为人类在描述物体的方式上，从物体的外表进化到了抽象的概念 第2章 自然语言处理 任何一种语言度是一种编码的方式；而语言的语法规则是编解码的算法。这是语言的数学本质； 图灵测试（Turning Test） 从规则到统计 原先都是通过定义语法的方式去进行自然语言识别 之后是基于有向图的统计模型 第3章 统计语言模型 从数学的方法描述语言规律：贾里尼克 一个句子是否合理，就看它的可能性大小 可能性用概率来衡量 假设$S$ 表示一个有意义的句子，有一连串特定顺序排列的词 $w_1, w_2, …, w_n$ 组成，$n$ 是句子的长度； 现在想知道 $S$ 在文本中出现的可能性，即概率 $P(S)$ $S = w_1,w_2,…$ 即 $P(S) = P(w_1,w_2,…)$ 利用条件概率公式，展开为 $$P(S) = P(w_1) P(w_2|w_1) P(w_3|w_1,w_2) … P(w_n|w_1,w_2,…)$$ $P(w_1)$ 表示第一个词 $w_1$ 出现的概率； $P(w_2|w_1)$ 表示在已知第一个词的前提下出现的概率；以此类推， $w_n$ 的出现概率取决于它前面的所有词 安德烈.马尔科夫 ( Andrey Markov ) 19世纪 俄国数学家 假设任意一个词 $wi$ 出现的概率只同它前面的词 $w{i-1}$ 有关；即马尔科夫假设 $$P(S) = P(w_1) P(w_2|w_1) P(w_3|w_2) … P(wn|w{n-1})$$ 也可以假设一个词由前面 $N-1$ 个词决定；则称为 $N$ 元模型 问题转化为如何估计条件概率 $P(wi|w{i-1})$ $$P(wi|w{i-1}) = {P(w_{i-1},wi) \over P(w{i-1})}$$ 若有大量机读文本（即语料库），只要做统计即可得出相应的概率 延伸阅读 高阶语言模型：实际应用中最多选取 $N=3$ 的三元模型，更高阶的很少使用； 当模型从3到4时，效果的提升不显著，但资源的耗费量却增加地很快 模型训练、零概率问题和平滑方法 统计中若 # $(w_{i-1},w_i)$ 的次数等于0，但并不意味着出现的概率为0 古德 - 图灵估计 ( Good - Turning Estimate) ：对于没有看见的事件，我们不能认为它发生的概率为零；因此需要从概率的总量中分配一个很小的比例给这些没有看见的事件。 第4章 分词 分词的一致性：统计模型被广泛应用后，不同的分词器产生记过的差异远远小于不同人之间看法的差异 词的颗粒度与层级：不同的应用中要选择不同的颗粒度标准 “清华大学” 可以看做一个整体，也可以看做由2个词组成的 在机器翻译中，一般颗粒度大的翻译效果好； 在网页搜索中，小的颗粒度效果比大的好 当用户查询 “清华” 时，若使用较大的颗粒度，是找不到清华大学的 第5章 隐含马尔科夫模型 美国数学家 鲍姆 ( Leonard E. Baum )等人在20世纪六十七年代提出的 马尔科夫假设与马尔科夫链 一个状态到另一个状态是有一定概率的，并且只与前一个状态有关 隐含马尔科夫假设 任意时刻 t 的状态 $s_t$ 是不可见的；观察者没办法通过观察到一个状态序列 $s_1, s_2,…$ 来推测转移概率 但是，会在每个时刻t 输出一个符号 $o_t$ ，且仅跟 $s_t$ 相关；即独立输出假设 因此，通过计算出某个特定的状态序列所产生的输出符号 $o_1, o_2,…$ 的概率 来推测 $s_1, s_2,…$ 发生的概率 【精】第6章 信息的度量和作用 信息熵不仅是对信息的量化度量，而且是整个信息论的基础； 信息熵的物理含义是对一个信息系统不确定性的度量 信息熵 信息量等于不确定性的多少； 一条信息的信息量与其不确定性有着直接的关系； 我们对一件事一无所知，就需要了解大量信息；如果了解很多，不需要太多信息就能把它搞清楚 香农用 “比特” (Bit) 来度量信息量 一个比特是一位二进制数 信息量的比特数 和 所有可能情况的对数函数 $log$ 有关 （$log_232=5$） 一共32个球队，哪个球队会获胜？这条消息的信息量是5比特 用二分法，先猜在1-16号中，若正确则继续二分；若错误则跳到另一半进行二分；最后需要用5次即可获得正确答案； 当每个球队获胜的概率不等时，“谁是冠军” 的信息量比5比特少 准确的信息量 ： $$H = -(p_1 log_2{p_1} + p_2 log_2{p_2} + …)$$ 信息熵的概念 ： $$H(X) = - \sum_x P(x) log_2{P(x)}$$ 变量的不确定性越大，熵就越大 有了熵的概念，就可以回答这样一个问题 “一本50万字的中文书平均有多少信息量” 常用的汉字大约有7000个；若每个概率相等，则需要约13比特 $2^{13} = 8192$ 表示一个汉字 但汉字的使用频率是不相等的；一般前10%的汉字占常用文本的95%以上 假设每个汉字的信息熵为 9 比特；在考虑上下文关系，每个汉字的信息熵就只有 5 比特 结论：一本50万字的中文书有大约250万比特，大约2M的内容 汉语是最简洁的语言；一本英文书，如果字体大小相同，那么中译本一般都会薄很多 ​ 信息的作用 信息的作用在于消除不确定性 自然语言处理的大量问题就是寻找相关的信息 信息是消除系统不确定性的唯一办法；在没有获得任何信息前，一个系统就像一个黑匣子，不确定性为$U$；需要引入的信息量$I$ 取决于这个不确定性的大小 当 $I &gt; U$ 可以完全消除 当 $I &lt; U$ 可以消除部分不确定性 相关性能够消除不确定性； 在自然语言的统计模型中，一元模型就是通过某个词自身的概率分布来消除不确定性；二元即高阶的语言模型还使用了上下文的信息 联合概率分布是小于等于单一概率的；即 $P(X|Y) \leq P(X)$ 可以证明条件熵 $H(X|Y) \leq H(X)$ ； 即由于多了 $Y$ 这个信息，关于 $X$ 的不确定性下降了 当增加的信息是完全无关的时候，等号成立； 互信息 相关性的度量 $ I(X;Y) = \sum_{x,y} P(x,y) log_2 {P(x,y) \over P(x)P(y)} $ $$I(X;Y) = H(X) - H(X|Y) $$ 互信息是的取值 在 0 到 min( (H(X), H(Y)) 之间 当X和Y 完全相关时，它的取值为 H(X) ；此时由于Y的出现，使得条件信息熵 H(X|Y) = 0 当两者挖暖无关时，它的取值为 0 相对熵 用来衡量两个取值为正的函数的相似性 对于两个完全相同的函数，它们的相对熵等于零 相对熵越大，两个函数的差异越大；反之则越小 对于概率分布或者概率密度函数，如果取值均大于零，相对熵可以度量两个随机分布的差异性 第7章 贾里尼克和现代语言处理 去思索作为一个孩子，他应该有的时间分配；尤其在学习上；为自己的孩子做思考 贾里尼克教授告诉吴军最多的是：什么方法不好；（避免走弯路） 巴菲特和那些投资人讲，你们都非常聪明，不需要我告诉你们做什么，我只需要告诉你们不要去做什么；这是巴菲特从一生的经验教训中得出的； 网络搜搜 第8章 ~ 第13章 第8章 简单之美：布尔代数与搜索引擎 布尔代数 与 搜索引擎 牛顿：（人们）发觉真理在形式上从来都是简单的，而不是复杂和含混的； ( Truth is ever to be found in simplicity, and not in the multiplicity and confusion of things) 布尔代数 布尔代数将我们对世界的认识从连续状态扩展到离散状态，它对数学的意义等同于量子力学对物理学的意义； 布尔运算非常简单，但它把数学和逻辑合二为一，而且给了我们一个看待世界全新的视角，开创了数字化的时代； 世界上最简单的计数方法：二进制（0和1） 布尔代数运算的元素：1 （True，真）、0 （False，假） 基本的运算：与（And）、或（or）、非（Not） And ：必须同为一个属性；一真一假，则为假； Or ： 只要一个属性存在即可； 布尔 ( George Boole ) 19世纪英国人； 1854年 《思维规律》 ( An Investigation of the Laws of Thought , on which are founded the Mathematical Theories of Logic Probabilities ) 本书第一次向人们展示了如何运用数学的方法解决逻辑问题 索引 数据库的查询语言（SQL）支持各种复杂的逻辑组合，但它背后的基本原理是基于布尔运算的 计算机做布尔运算是非常快的 第9章 图论和网络爬虫图论 大数学家 欧拉 (Leonhard Euler) ；1973年普鲁士的哥尼斯堡的七座桥，每座桥恰好走过一遍并返回原点；欧拉证明了这种走法是不可能的； 广度优先搜索（Breadth-First Search，BFS）：尽可能 “广” 地访问与每个节点直接连接的其他节点 先访问与之相邻的所有节点，然后在访问与之间接相连的节点 深度优先搜索（Depth-First Search，DFS）：一路走到底，直到找不到更远的节点；再往回找，看是否还有其他尚未访问的节点 先随机选取一个相邻的节点，然后作用为下一个要访问的节点； 网络爬虫 麻省理工的学生 马休.格雷 （Matthew Gray）在1993年 完成第一个网络爬虫；取名为 互联网漫游者（www Wanderer） 把互联网作为一张大图；把每一个网页作为一个节点，把那些超链接作为连接网页的弧；有了超链接，我们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并它它们存起来； 网络爬虫下载互联网的过程 假定从一家门户网站的首页出发，先下载这个网页 然后通过分析这个网页，可以找到里面所有的超链接，就等于知道了其所直接链接的全部网页 接下来访问、下载分析这些门户网站的邮件等网页，又能找到其他相连的网页 同时记录哪个网页下载过了，避免重复；使用一种 “散列表” （Hash Table，哈希表）来记录 构建网络爬虫的工程要点（延伸阅读） 考虑的问题是：如何在有限的时间里更多地爬下最重要的网页 一般情况下BFS由于DFS 第10章 PageRank：Google的民主表决式网页排名技术 Google的民主表决式网页排名技术 PageRank算法的核心思想：在互联网上，如果一个网页被很多其他网页所链接，说明它受到普遍的承认和信赖，那么它的排名就高。 对不同网页的链接区别对待，排名高的网页给予较大的权重（因为那些排名高的网页的链接更可靠） 网页排名算法的高明之处：它把整个互联网当做一个整体来对待。这无意中符合了系统论的观点；以前的信息检索大多把每一个网页当做独立的个体对待，大部分人当初只注意了网页内容和查询语句的相关性，而忽略了网页之间的关系； 第11章 确定网页和查询的相关性：TF-IDF 度量网页和查询的相关性的简单方法：直接使用各个关键词在网页中出现的总词频； 例如查询 “原子能的应用” 如果一个查询包含 N 个关键词 $w_1, w_2,…$ ，它们在一个特定网页中的词频分别是 $TF_1,TF_2,…$ （TF : Term Frequency ，词频） 这个查询和该网页的相关性 = $TF_1 + TF_2 + …$ 优化：权重的设定 对于不同的词设定不同的权重；一个词预测主题的能力越强，权重越大；（例如 ”原子能“ 应有较大的权重；”应用“ 的权重较小） 停止词的权重应为零 （例如 ”的“） 若一个词在很少的网页中出现，通过它容易锁定搜索目标，它的权重应该越大；如果一个词在大量网页中出现，看到它仍然不清楚要找什么内容，权重应该更小； 信息检索中常用的权重：逆文本频率指数 （Inverse Document Frequency，IDF） $$IDF = log {D \over D_w}$$ D 所有网页的数量；$D_w$ 该词频出现的网页数量； 若中文网页的数量为D=10亿，而“的“出现的次数 $D_w$ =10亿；则 IDF = log(1) = 0 TF - IDF ：衡量最终的相关性（即加权求和）；被公认为信息检索中最重要的发明 $$TF_1\cdot IDF_1 + TF_2 \cdot IDF_2 + …$$ ​ 第12章 有限状态机和动态规划：地图与本地搜索 第13章 Google AK-47的设计者：阿米特.辛格 Google内部的排序算法 Ascorer 中A便是他的名字首字母 辛格做事情的哲学：先帮助用户解决80%的问题，再慢慢解决剩下20%的问题，是在工业街成功的秘诀； 很多人失败并不是因为他们不优秀，而是做事情的方法不对。一开始追求大而全的解决方法，之后长时间不能完成，不了了之； 分类 第14、15章 第14章 余弦定理和新闻的分类 分类就是把相似的内容归入同一类中 向量：实际上是多维空间中从原点出发的有向线段； 如果两个向量的方向一致，则说明响应的新闻的用词比例基本一致 可通过计算两个向量的夹角来判断对应新闻主题的接近程度（涉及到余弦定理） 新闻分类的过程 已有一些新闻类别的特征向量：进行的是分类； 对于任何一个要被分类的新闻Y，计算它和各类新闻特征向量的余弦相似性，并进行归类 缺少新闻类别的特征向量：进行的是聚类 计算所有新闻之间两两的余弦相似性，把相似性大于一个阈值的新闻合成一个小类；N篇新闻被合并成 $N_1$ 个小类 把每个小类作为一个整体，计算小类的特征向量，在计算小类两两之间的余弦相似性，然后合并成大一点的小类，即$N_2$ $N_2 &lt; N_1 &lt; N$ 这样做下去，类别越来也少，每个类越来越大；当某一类太大时，这一类里的新闻之间的相似性就很小了，这时就要停止迭代的过程。至此，自动分类完成； 其他内容 无法进行划分的内容 第16章 信息指纹及应用 找到一个函数，将5000一个网址随机映射到128位二进制（即128比特，即16个字节的整数空间）；这16个随机数被称为该网址的信息指纹；可以证明，只要产生随机数的算法够好，就能保证几乎不可能有两个字符串的指纹相同； 伪随机数产生器算法（Pseudo-Random Number Generator，PRNG） ： 它将任意很长的整数转化为特定长度的伪随机数 最早的PRNG由 冯 $\cdot$ 诺依曼 提出。他将一个数的平方掐头去尾，取中间的几位数；例如一个四位的二进制数1001（相关于十进制的9），其平方为01010001（十进制的81）；掐头去尾剩下中间的4为0100；当然这种方法产生的不很随机 常用的是梅森旋转算法（Mersenne Twister） 从十进制的理解看二进制：333（虽然3个数字都是3，但表达的含义是不同的） 最后一个3 ：表示这个数中有3个 $10^0$ ； 第二个3 ： 表示这个数中有3个 $10^1$ 第三个3 ：表示这个数中有3个 $10^2$ $333 = 3 \times 10^2 + 3 \times 10^1 + 3 \times 10^0$ $01010001 = 0 \times2^7 + 1\times2^6+ 0 + 1\times2^4 + 0 + 0 + 0 + 1\times2^0 = 64 + 16 + 1 = 81$ 信息指纹的特征是不可逆性；即无法根据信息指纹推断出原有的信息；这种性质正是网络加密传输所需要的 第17章 谈谈秘密学的原理 当密码之间分布均匀并且统计独立时，提供的信息最少； 均匀分布使得无法统计 统计独立使得即使知道了加密算法，并且看到一段密码和明码后，也无法破译另一段密码 第18章 搜索引擎反作弊和搜索结果权威性问题 在原始信号中混入了噪音，在数学上相当于给两个信号做了卷积。噪音消除的过程就是一个解卷积的过程。 如果在发动机很吵的汽车里打电话，对方可能听不清楚。但如果知道了发动机的频率，加上一个与之频率相同、振幅相反的信号，就能够很容易消除发动机的噪音 消噪：首发动机的频率是固定的；其次这个频率的噪音重复出现；因此只要采集几秒钟的信号进行处理就能做到 广义上讲，只要噪音不是随机并且相关的，就可以检测到并消除；（事实上，完全随机不相关的高斯白噪音是很难消除的） 度量搜索结果的权威性：提及 （若一个词 作为信息源被多次 “提及”，那么我们有理由相信它是这个主题的权威机构） 第20章 最大熵模型 不要把鸡蛋放在一个篮子里，是最大熵原理的一个朴素说法；即当我们遇到不确定时，就要保留各种可能性 最大熵的原理：保留全部的不确定性，将风险降到最低； 最大熵原理指出：对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件；而对未知的情况不要做任何假设。 在这种情况下，概率分布最均匀，预测的风险最小；因为此时概率分布的信息熵最大，成为最大熵模型 一个骰子 “每个面朝上的概率分别是多少？” ；等概率的1/6 为什么这么回答，因为我们对这个 “一无所知” 的骰子，假定它每个面超上的概率均等是最安全的做法 从信息论上看，这是保留了最大的不确定性，即让熵达到最大 继续说，对整个骰子做过处理，“ 已知4点朝上的概率是1/3 ， 这种情况下每个面朝上的概率是多少？” ；4点的概率为1/3，其他的为2/15 因为已知的条件必须满足（4点的概率为1/3），其余的点仍然未知；所以不过任何假设，因此只好认为它们均等； 第21章 拼音输入方法的数学原理输入法与编码 对于汉字最直接的编码方式： 让26个字母对应拼音 用10个数字键来消除歧异（汉字一音多意的问题） 对汉字的编码分为如上两部分：对拼音的编码、消除歧异的编码 这决定了一个汉字编码的长度 拼音法早期出现的是双拼，原因是为了缩短对拼音的编码；这些输入法看似节省了一点编码长度，但输入一点也不快，因为它们只是局部优化，而伤害了整体； 双拼增加了编码上的歧异性：键盘只有与26个字母，但汉语得到声母和韵母有50多个；结果是很多韵母必须共享一个字母键；增加歧异性的结果就是要从更多候选字中找到想要输入的字 增加了每一次击键的时间。因为双拼的方法不自然；研究表明，在脱稿输入时，拆字的思维过程会使思维变慢。（这也是自己之前觉得打字用双拼累的原因） 双拼的容错性不好 语言和文字作为通信的编码手段，一个重要的目的是帮助思维和记忆。 一个汉字要敲多少个键盘 香农第一定律指出：对于一个信息，任何编码的长度都大于等于它的信息熵；任何输入法都不可能突破信息熵给定的极限 平均编码长度的最小值就是汉字的信息熵 第23章 布隆过滤器 布隆过滤器只要 散列表 1/8 ~ 1/4的大小就能解决同样的问题 伯顿$\cdot$布隆（Burton Bloom）于1970年提出 实质是一个很长的二进制向量和一系列随机映射函数 工作原理 假定存储1亿个邮件地址，先建立一个16亿个比特位（即2亿字节）的向量，然后将其全部清零 对每一个邮件地址X，用8个不同的随机数产生器 ($F_1,F_2,…$) 产生8个信息指纹($f_1, f_2,..$) 再用一个随机数产生器G把这8个信息指纹映射到1-16亿中的8个自然数 $g_1, g_2,…$ 现在这8个位置的比特位全部变为1 第24章 马尔科夫链的扩展：贝叶斯网络 马尔科夫链（Markov Chain）描述了一种状态序列：每个状态的取值取决于前面有限个状态； 当假定每个状态只与其直接相连的状态有关，而与它间接相连的状态没有直接关系，那么它就是贝叶斯网络。 马尔科夫链是贝叶斯网络的特例，而贝叶斯网络是马尔科夫链的推广 相同点：均值考虑了前面一个状态 区别：贝叶斯网络的拓扑结构比马尔科夫链灵活，它不受马尔科夫链的链状结构的约束 从数学层面来讲，贝叶斯网络是一个加权的有向图，是马尔科夫链的扩展；从认识论的层面看，贝叶斯网络克服了马尔科夫链的线性约束，它可以把任何有关联的事件统一到它的框架下面； 第25章 条件随机法、文法分析 条件随机场是一个特殊的概率图模型； 它遵从马尔科夫假设：每个状态的转移概率只取决于相邻的状态 与贝叶斯网络的区别在于，它是无向图 先验概率 与 后验概率 先验概率：从原因到结果的论证，是先验的；即根据以往的经验和分析得到的概率；即固定的和已知的； 后验概率：从结果到原因的论证，是后验的；即在得到结果的信息之后，重新修正的概率； 第27章 期望最大算法：上帝的算法 期望最大化和收敛的必然性 如果我们的距离函数足够好，它能保证同一类相对距离较近，而不同类的相对距离较远 最终结果：相近的点被聚集到了同一类，同一类中各个点到中心的平均距离$d$ 较近；而不同类中心之间的平均距离$D$ 较远； EM算法中，若目标函数是凸函数，一定能够得到全局最优解； 熵函数一个是凸函数（即向上凸）；如果在N维空间以欧氏距离做度量，聚类中试图优化的两个函数也是凸函数 文本分类中的余弦距离不是凸函数，可能得到局部最优解 以最大化(Maximization) 期望值(Expectation) 的算法：EM算法 因为它只需要一些训练数据，定义一个最大化函数，剩下的事情交给计算机；经过若干次迭代之后，我们需要的模型就训练好了；这太神奇了，所有称它为上帝的算法 第28章 逻辑回归和搜索广告 搜索广告的三个阶段 竞价排名 根据哪个广告可能被点击，综合出价和点击率（Click Through Rate：CTR）来决定 全局最优 逻辑回归模型：将一个事件出现的概率逐渐适应到一条逻辑曲线（Logistic Curve）上，其值域在[0,1]之间 逻辑曲线是一条 $S$ 型曲线 特点：一开始变化快，逐渐减慢，最后饱和 优点：将值域限制在 [0,1] 之间 $$f(z) = {e^z \over e^z+1} = {1 \over 1 + e^{-z}}$$ $ z= \beta_0 + \beta_1x_1 + …$ 逻辑回归模型，一种将影响概率的不同因素结合在一起的指数模型； z 可以是用线性的办法将各个因素组合起来 第29章 各个击破算法与云计算 云计算的关键之一：如何把一个非常大的计算问题，自动分解到许多计算能力不是很强的计算机上面来共同完成 分治算法的基本原理：将一个复杂的问题分成若干个简单的子问题进行解决；然后对问题的结果进行合并，得到原有问题的解。 第30章 Google大脑和人工神经网络人工神经网络 大多数与 “智能” 有点关系的问题，都可以归结为一个多维空间进行模式分类的问题； 人工神经网络所擅长的正是这种分类； 它的模式分类的能力等价于最大熵模型； 如果把不同输出节点上的值看成是一个概率分布，那人工神经网络就等价于一个概率模型 本质是一种有向图，但是一种特殊的有向图； 图中的所有节点都是分层的； 每一层节点可以通过有向弧指向上一层节点，但同一层节点之间没有弧相连接，并且每个节点不能约过一层连接到上上一层的节点上 每个弧上有一个值（权重），根据这些值可以用一个非常简单的公式算出所指节点的值 通过输入层进行输入，通过中间层，最后到达输出层，输出结果 人工神经网络（总结）：一个分层的有向图； 第一层输入节点$X_1, X_2, ..$ 接受输入的信息； 来自这些点的数值 ($x_1,x_2,…$) 按照它们输出弧的权重($w_1,w_2,…$)，根据公式 $G = w_0 + x_1w_1+…+x_nw_n$ 进行线性加权（得到G） 然后再做一次非线性变换 $f(G)$ ，赋值给第二层的节点 $Y$ 第二层的节点将此数值向后传递，直至第三层节点，直到输出层 在模式分类时，最后在输出层哪个节点的数值最大，输入模式就被分在哪一类 需要设计的部分只有两个： 它的结构：即网络分几层、每层几个节点、节点之间如何连接（权重） 非线性函数$f(G)$的设计：常用的是指数函数 $f(G) = e^G = e ^{w_0+x_1w_1+…}$ 训练人工神经网络 确定弧上的权重 w 人工神经网络的训练可以分为监督训练、无监督训练 监督训练：在训练之前需要先取得一个批注好的样本（训练数据），有输入数据和输出数据；训练的目的是找到一组参数w，使得模型给出的输出值的函数（$y(w)$ ）和这组训练数据中的输出值尽可能地一致 即得到一个成本函数$C$ ，使得得到的结果与真实的结果的差距最小化； 例如可以定义 $C = \sum(y(w)-y)^2$ （即欧几里得距离） 现在就变成了一个最优化问题：找最值； 梯度下降法（Gradient Descent）：每一次向 “最陡” 的方向走一步，使得最快达到山顶 无监督学习：没有输出数据；所以要设计一个成本函数 成本函数遵从的原则：既然人工神经网络解决的是分类问题，那么希望分类之后，同一类样本（训练数据）之间的距离尽可能的近，不同类的样本应该尽可能的远 人工神经网络与贝叶斯网络 共同点 都是有向图，每一个节点的取值只取决于前一级的节点，而且与更前一级的节点无关；即遵从马尔科夫假设 训练方法相似 对于很多分类问题，两者在效果上也是相似的；但效率可能不同 计算量都比较大 不同点 人工神经网络在结构上是完全标准化的，而贝叶斯网络更灵活；Google大脑选用人工神经网络就是因为看重它的标准化这一特点 人工神经网络虽然神经元函数是非线性的，但各个变量只能先进行线性组合，最后对一个变量（即前面组合出来的结果）进行非线性变换，因此计算机比较容易实现；贝叶斯网络中变量可以组成任意的函数，在获得灵活性的同时也增加了复杂性 人工神经网络的输出相对孤立，它可以识别一个个字，但内难以处理一个序列；因此主要用于估计一个概率模型的参数（语音中声学模型参数的训练、机器翻译中语言模型参数的训练）；贝叶斯网络更容易考虑前后的相关性，因此可以解码一个输入的序列（比如将一段语言识别为文字，或将一个英语句子翻译成中文） Google大脑 Google大脑本质是一种大规模$^1$并行处理$^2$的人工神经网络$^3$。 选用人工神经网络的原因 理论上讲可以在多维空间画出各种形状的分类边界，有很好的通用性 在过去20多年里，人工神经网络的算法非常稳定，几乎没有改变；google希望自己开发的工具能够设计一次，长时期使用 人工神经网络的算法简单，容易实现并行化 Google大脑的实现 Google大脑中每一块的计算并不是完全独立的，而是要考虑周边的很多块，当切的块数比较多以后，相互的关联总数大致跟块数的平方成正比；而MapReduce中每块的计算是独立的； 这让块与块之间的计算变得复杂，但是能把一个原本无法在一台服务器上完成的大问题分解成大量可在一台服务器上完成的小问题 两点改进 降低每一次的迭代量：采用随机梯度下降法（Stochastic Gradient Descent）：在计算成本函数时只需要随机抽取少量 的数据来计算，而非像梯度下降法那样对所有的样本都计算一遍，可以大大减少计算量但会牺牲一点准确度 由于训练的数据量非常大，综合考虑时间与准确性之后，采取了相对较快的这种算法 减少了训练的迭代次数；采用 L-BFGS（Limited-memory Broyden Fletcher Goldfarb Shanno Method） 比一般梯度下降收敛法更快 原理与随机梯度下降相似，但它能根据离最后目标的 “远近” 调整每次迭代的步长；这样经过很少次的迭代就能收敛，但它每次的计算量会增加一点；并且L-BFGS更容易实现并行化 Google大脑中的存储：输入数据存储在本地、模型参数存储在服务器 在生活中，真正能够通用的工具在形式上都是简单的。 第31章 数据的重要性 在Google内部，产品经理都遵循：在没有数据之前，不要给出任何结论。 对常识/常规现象的理解 对未知事件的估计 【共鸣】因为很多基于直觉的并不一定是真实的； 在搜索行业容易形成一种马太效应；即搜索量不足的搜索引擎因为用户点击数据量的不足，搜索质量会越来越差。相反，搜索质量好的会越来越好。一些公司做出了激动的办法：通过搜索条、浏览器、甚至是输入法来搜索用户的点击行为；这些做法的好处在于不仅可以收集到使用该公司搜索引擎本身的点击数据，还能得到用其他搜索引擎的数据。搜索质量的竞争变成了浏览器或者其他客户端软件市场占有率的竞争； 医疗 - 世界性难题：(1) 不同人的细胞&amp;体制 是不同的；(2) 疾病的阶段是不同的；(3) 病毒的变异性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《智能时代》读书笔记_吴军]]></title>
      <url>%2F2017%2F11%2F30%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F110_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E3%80%8A%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%90%B4%E5%86%9B_201711%2F</url>
      <content type="text"><![CDATA[《智能时代》_吴军 第一章 数据 数据是基础； 数据 $\to$ 信息 $\to$ 知识 信息：关于世界、人和事的描述，比数据更加抽象；信息可以是人类创造的（两个人的通话记录） 也可以是客观存在的（一个物体的质量） 数据 Vs. 信息：最大的区别在于 并非所有的数据都承载了有意义的信息 相关性：使用数据的钥匙； 我们无法直接获得信息（比如疫情传播情况），但我们可以将相关联的信息（比如各地搜索情况）量化，然后通过数学模型，间接得到所要的信息； 统计学： 采集数据的两个要点：量 和 质 量：足够多的数据 质：有代表性，随机的 数学模型：数据驱动方法的基础 人们通常考虑用多个简单的模型取代一个复杂的模型；（并且这种效果可能是更佳） 第二章 大数据和机器智能机器智能是什么 大量数据的使用，最大的意义在于它能让计算机完成一些过去只有人类才能做到的事情（并且以更低的成本），这最终将带来一场变革； 判断机器是否智能：图灵测试（Turing Test） 让一台机器和一个人坐在屏幕后面，让一个裁判同时与幕后的人和机器进行交流； 如果这个裁判无法判断自己交流的对象是人还是机器，这就说明这台机器有了和人同等的智能 计算机若有智能，应该要实现的事情： (1) 语音识别； (2) 机器翻译； (3) 文本的自动摘要和写作； (4) 战胜人类的国际象棋冠军； (5) 自动回答问题 传统的人工智能：首先了解人类是如何产生智能的，然后让计算机按照人的思路去做； 当我们回到图灵描述机器智能的原点时就能发现，机器智能最重要的是能够解决人脑所能解决的问题，而不在于是否需要采用和人一样的方法； 大数据 核心是变智能问题为数据问题 Google翻译：数据创造的奇迹，从量变到质变； （弗朗兹.奥科 (Franz Och) 用了半年的时间 2004.7 - 2005.2 ，就超过了所有的科研机构） 大数据的三大特征：大量、多维度、全面性 及时性不是必须的，但若有了及时性可以做到更多的事情 机器解决人类问题的核心：变智能问题为数据问题 1996年 IBM深蓝Deep Blue 战胜国际象棋冠军 卡斯帕罗夫；（包括当下的 AlphaGo）【它们从来都没有像人一样思考，它们做的只是数据处理，求解概率，获取最优值】 深蓝团队只是把一个机器智能的问题转变成一个大量数据的问题和大量计算的问题； 通过计算机来回答复杂问题（比如天为什么是蓝色的）：本质上还是数据问题 （做法是从现有的数据中挑选答案，但这些数据也是由人产生的） 第一步，根据网页确定哪些用户在Google问过的复杂问题可以回答，哪些回答不了；研究发现，70%-80%的问题在Google第一页搜索结果中都有答案 第二步，把问题和网页中的每一句话匹配，挑选出可能是答案的片段 第三步，利用自然语言处理技术，把答案的片段合成一个完成的段落 第三章 思维的革命 因果关系 $\to$ 相关关系 在无法确定因果关系时，数据为我们提供了解决问题的新方法。数据中所包含的信息可以帮助我们消除不确定性，而数据之间的相关性在某种程度上可以取代原来的因果关系，帮助我们得到我们想知道的答案，这便是大数据的核心。 思维方式决定科学成就 从欧几里得、托勒密到牛顿 机械思维的核心思想概括为：确定性（或可预测性）和 因果关系 牛顿通过自己的伟大成就宣告了科学时代的到来。作为思想家，他让人们相信世界万物的运动变化规律是可以被认识的。 世界万物是运动的，而且这些运动遵循着确定性的规律，这些规律又是可以被认识的。 任何正确的理论从形式上都是简单的，且有非常好的通用性； 机械思维（通过牛顿的方法论来概括）的核心： 世界变化的规律是确定的 因为有确定性做保障，因此规律不仅是可以被认识的，而且可以用简单的公式或者语言描述清楚 这些规律是通用的；可以应用到各种未知领域指导实践 机械思维的应用（分析找到原因，根据原因得到结果） 制药行业：研究病理找到真正致病的原因，然后针对整个原因找到解决方案 世界的不确定性 世界上很多事情都是难以用公式或者概率来表示的；但是它们并非没有规律可寻，通常可以用概率模型来描述。 世界不确定性的来源 影响世界的变量非常多。已经无法通过简单的办法或者公式算出结果，因为我们宁愿采用一些针对随机事件的方法来处理它们 客观世界本身。在宏观世界，可以画出行星的运动轨迹；在微观世界，不可能同时准确测出某一时刻的位置和运动速度 因为测量活动本身影响了被测量的结果 无法获得某一时刻的精准信息，但可以获得在某一时间段内可能出现结果的概率 例如电子的运动，无法确定电子的准确位置和速度；但可以知道在一定时间内在核外空间各处出现的概率 熵：新的世界观 熵：代表无序状态 鲁道夫. 克劳修斯 (Rudolf Clausius) 提出了 “熵” 的概念：来描述一个系统中趋向于恒温的程度。当这个系统达到恒温时，就无法做功了，此时熵最大。 玻尔兹曼把熵和封闭系统的无序状态联系起来。 封闭的系统中，熵永远都是朝着不断增加的方向发展的； 从微观上来说，这个系统越越来越无序，从宏观上越趋于恒温 香农，在信息论中提出了信息熵来描述一个信息系统的不确定性； 信息量的度量 = 不确定性的所少 消除系统内的不确定性就要引入信息 信息论是完全建立在不确定性基础上的。 互信息：解释为什么信息的想关心可以帮助我们解决问题 香农第一定律：对于信源发出的所有信息设计一种编码，该编码的平均长度一定大于该信源的信息熵，还指出并且存在一种编码方式，使得编码的平均长度无限接近于它的信息熵； 香农第二定律：信息的传播速率不可能超过信道的容量。 最大熵原理：当我们对未知的事件寻找一个概率模型时，这个模型应当满足我们所有已经看到的数据，但对未知的情况不做任何主观假设。 交叉熵：反映两个信息源之间的一致性；或者两种概率模型之间的一致性；（库尔贝克 Kullback-Leibler Divergence） 当两个数据源完全一致时，它们的交叉熵等于零 大数据的本质 大数据的三个特征：数据量大、多维度、完备性 大数据的科学基础是信息论，它的本质就是利用信息消除不确定性 从因果关系到强相关关系 一种新的思维方式：从大量的数据中直接找到答案，即使不知道原因 因果关系 Vs. 相关关系 传统的做法：通过因果关系推导出结果； 强相关关系：先现有结果再反推原因 更重视会发生什么，而不是为什么会发生 在电影租赁和收看视频的网站上，放上零食的广告；在咖啡评论和销售网站上，放信用卡和房贷的广告； Google的搜索算法 在所有的数据中，与搜所质量相关性最高的就是大量的点击数据 根据用户的点击数据进行排序 存在的两个风险：(1) 用户点击容易形成马太效应；排在前面的结果即使不相关也容易获得更多的点击； (2) 单纯依靠点击，排名很容易被被使用者操纵 加入点击模型：度量用户点击数和搜索结果相关性的模型 在今天的搜索引擎中，搜索算法是占整体排名权重的70%~80%；即因果关系已经没有数据的相关性重要了 Google广告系统每次播放的内容，不是由任何规则决定的，而完全是利用数据、挖掘相关性的结果 第四章 大数据与商业 在未来我们可以看到，大数据和机器智能的工具就如同水和电这样的资源一样，由专门的公司向全世界提供使用； 原有的思维：假设—求证—再假设—再求证 亚马逊：由商品直接推荐商品（Item to Item） Google：两个不同的用户，在输入一半关键词之后，给他们的提示常常是不同的 大数据商业：数据流 无目的的收集原始数据 $\to$ 筛选、处理后的数据 $\to$ 数学模型 首先必须完成数据的收集 常规数据的流向是从枝末的局部到整体；利用大数据指导时，数据的流向是从整体到局部 大数据商业中，数据需要完成两个方向的流动 从每一个细节到整体 （得出统计规律） 从整体到每一个细节 （将统计规律与每一个细节做对比） 从历史经验看大数据 新技术 + 原有产业 = 新产业 现有产业 + 蒸汽机 = 新产业 现有产业 + 电 = 新产业 电改变的不仅仅是经济，还改变了国家的政治形态、生活方式和社会结构； 电对世界的影响还在于各种电器的发明 现有产品 + 摩尔定律 = 新产业 现有产业 + 大数据 = 新产业 现有产业 + 机器智能 = 新产业 安迪 - 比尔定律：软件功能的增加和改进要不断吃掉硬件性能的提升 GE + 大数据思维的实际应用：在电冰箱中安装Wi-Fi 将Wi-Fi设备装到电冰箱和其他设备中，用来提示用户更换冰箱取水器的滤芯等耗性材料；这些材料通常半年更换一次，但大部分客户都很难更换 连上Wi-Fi之后，通过手机APP来提醒用户及时更换，并且整个购买流程在手机端完成 通过Wi-Fi 还可以获得用户使用电器的情况，为之后推销产品提供支持 第五章 大数据和智能革命的技术挑战信息的四个方面 在面对数据时，可以从 产生、存储、传输和处理 四个角度去分析，做场景还原 数据的产生 电脑 传感器：无源的射频识别芯片（RFID）等 信息数字化：将原有的信息以数字化的形式进行存储；例如图片、语言、文档、书籍等 信息的存储 由于摩尔定律导致各种存储器的量成倍地增加，同时价格迅速下降，使得原本不得不丢弃的一些数据现在有条件存储起来 传输的计数 信息的处理 并行处理 + 云计算 的实现 数据收集：看似简单的难题 传统的数据方法通常先有一个特定的目的，然后开始收集数据； 在真实世界中，获得足够量的具有代表性的数据远比我们想象的难得多 对于长尾搜索，搜索结果的概率分布比真实情况相差一两倍是很常见的情况 大数据则是不假思索地收集所有数据 在收集数据时，是无意识之间完成的。因为若带有目的的收集数据，很多情况下可能收集数据这一行为就影响了数据原本的样子 因为在收集数据时没有前提和假设，大数据分析才给我们带来了很多意外的惊喜 数据存储的压力和数据表示的难题 数据量增长的速度可能超过摩尔定律增长的速度 解决数据存储的办法： 存储同样的信息占用的空间小；（并不是简单的数据压缩；从信息论的角度，就是去除数据的冗余，并在相应的数据读写处理做改变） 数据安全（指的是数据不丢失、不损坏，而不是指数据被盗） 信息存储不仅局限在节省存储量上，还需要研究怎样存储才能便于使用 过去：结构化数据 大数据时代，数据量与维度都剧增 对于富媒体数据的大量出现，随机访问就很难；比如要从视频中找出一个画面就非常复杂。因为即使找到了视频每一个主帧，也很难根据那些画面所所有的视频建立索引 如何标准化数据格式，以便共享（大数据公司都有自己的数据格式，并只在自己的领域中使用） ​ 并行计算和实时处理：并非增加机器那么简单 影响并行处理效率的两个问题： 任何一个问题总有一部分计算是无法并行处理的，这类计算占比越大，并行处理的效率就越低；（木桶效应） 无法保证每个小任务的计算量是相同的；最终的计算速度取决于最后完成的子任务 对实时数据的挑战 一些看似简单的操作一到大数据上就会特别费时间；解决实时处理大数据的问题，需要从根本上改变系统设计和算法； 数据挖掘：机器智能的关键 信号与噪声比来度量信息质量；数据的信噪比越高，数据就越可靠； 机器学习：一个不断迭代、不断进步的过程；期望值最大化：事先设定一个学习的目标，这些算法就会不断优化模型，让它越来越接近真实的情况 数据量大，但采用比较简单的模型，而且比较少的迭代次数；即用大量的数据做一个浅层的机器学习 数据量小，但采用比较复杂的模型，而且经过多次迭代训练出准确的模型参数 一般情况下，由大量数据、较少迭代训练出的模型效果较好； 数据安全的技术 尽量将敏感信息放到不同的地方，一面多种敏感数据同时丢失；但这项事情执行起来很难，因为如果一项安全措施操作麻烦，很多人就不会遵守；比如在很多公司里，操作人员为了方便，通常习惯把分开存放的数据又拷贝到一个地方处理； 计算机系统的设计与高楼设计的不同：前者事先并不考虑安全的隐患，后者在每一个环节都要考虑安全的问题； 利用大数据本身的特点来保护数据的安全 通常一家机构里的业务流程是固定的，被授权操作员的使用习惯是可以学习的；那么不符合这些习惯的操作可能来自非法的闯入者； 假如有外来人员拿到密码进入了系统，由于他对内部的业务流程不了解，他的操作可能直接从A点绕到C点，然后跳到E点；因此可以通过大数据发现并制止异常操作； 利用大数据分析来防范黑客攻击，要比传统的在防火墙设置各种规则的做法有效5倍； 保护隐私：靠大数据的必要条件 大数据具有多维度和全面的特点，它可以从看似支离破碎的信息中完全复原一个人或一个组织的全貌； 在大数据中，匿名并不能使你得到真正的保护； 隐私 Vs. 便利性：大部分人在思考时会选择隐私；但在真正做行动时，会更倾向于放弃隐私以换取便利性； 保护隐私的新技术 从收集信息的一开始就对数据进行一些预处理；预处理后的数保留了原有的特性，使得使用者能够处理数据，却”读不懂” 数据的内容 双向监视：当使用者看计算机时，计算机也在盯着使用者； 大部分人喜欢偷窥别人的隐私；如果有人在刺探隐私时它的行为本身暴露了，那么他就会多少约束自己的行为 如果给窥视着一个选择，输入自己的真实信息后才能窥视他人，很多人会选择直接离开 第六章 未来智能化产业 第七章 智能革命和未来社会精细化社会 追踪每一次交易：区块链 如果每一件商品被制造出来时产生一个区块链，并且在它被运输和交易时利用区块链记录全过程，那么这个商品的整个流通过程是可以追踪的；这样就可以杜绝假货，因为区块链与商品是一一对应的； 区块链（Block Chain） Block：模块、单元的意思；它像一个账户存储信息 Chain：链条的意思；表示一连串的交易；交易的细节就存储在Block中 比特币被挖矿者挖出来时，就产生一个带有特殊随机数的Block，当这比特币通过交易转到第二个人的手中，在该Block中就记录了交易的信息，这个过程本质上是一个加密的信息传输过程 从标准化到个性化 工业化的一个结果，就是靠批量生产的效率让个人性化从大众市场消失；不仅产品是标准化的，服务也是标准化的 在工业革命以前，人类使用的产品、享受的服务都是有细微差别的；近代医学开始之前，每个人的用药都是不用同的； 在医疗方面，医生宁可治不好病，也不能违背流程 无隐私社会 隐私就像自由，只有当人们失去它的时候，才知道它的可贵； 今天很多人忽视大数据对个人隐私的潜在威胁，原因在于： 对整个问题缺乏认识，他们并不知道多维度的信息凑到一起就能够得到一个人的完整画像 低估了机器智能的力量 一厢情愿地把个人隐私寄托在数据拥有者的善意上 机器抢掉人的饭碗 解决问题只有靠时间 ；每一次重大的技术革命都需要很长的时间来消除它所带来的负面影响；至少需要一代人以上； 技术革命会使很多产业消失，或者产业的从业人口大量减少，释放出来的劳动力需要寻找出路 我们必须承认一个不愿承认的事实：被淘汰的产业的从业人员能够进入新行业中的其实非常少 虽然各国政府通过各种手段帮助失业人员掌握新技能，但收效甚微；因为上一代的人很难适应下一代的技术发展；事实上，消化这些劳动力主要靠的是等待他们逐渐退出劳务市场，而并非他们真正有了新的出路。 其他摘抄 科学研究发展的四个范式 描述自然现象的实验科学 以牛顿定律和麦克斯韦方程等为代表的理论科学 模拟复杂现象的计算机科学 数据密集型科学 工业革命 以蒸汽机的发明为标志以机械化为特征的第一次工业革命 以点的发明为标志以电气化为特征的第二次工业革命 归纳法的隐含假设：未来将继续和过去一样；即连续型假设]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《大数据时代》读书笔记_维克托&肯尼斯]]></title>
      <url>%2F2017%2F11%2F29%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F110_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E3%80%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%BB%B4%E5%85%8B%E6%89%98%26%E8%82%AF%E5%B0%BC%E6%96%AF_201711%2F</url>
      <content type="text"><![CDATA[《大数据时代》_维克托•迈尔-舍恩伯格 &amp; 肯尼斯•库克耶 Viktor Mayer-Schonberger &amp; Kenneth Cukier why ：我为什么读这本书，想解决什么问题？ 从追求因果关系转而向追求相关关系的发现和使用。 即只需要知道是什么，而不需要知道为什么；（这一概念的深入阐述，可阅读《智能时代》-吴军） 不再需要在还没有收集数据之前，就把我们的分析建立在早已设立的少量假设的基础之上。让数据发声，我们会注意到很多以前从来没有意识到的联系的存在。 因果关系很难找到，因为它的发生（结果），本身就置于一个非常复杂的背景中；结果只有一个，但因素却又无穷多个； 数据当前还没有被列入企业的资产，但这只是一个时间问题。 我们怎么看待使用所有数据 和 使用部分数据的差别，以及我们怎样选择范松要求并取代严格的精确性，将会对我们与世界的沟通产生深刻的影响。 【精确性的选择，对结果的准度要求】 应该更多地考虑：当数据说话时会发生什么； 大数据只能基于现有的，而创造性却是突破规则的； 如果亨利.福特问大数据顾客想要的是什么，大数据将会回答 “一匹更快的马”。 大数据4V Volume：大量 Velocity：快速 Variety：多维度 Value：价值 第一部分 大数据时代的思维变革 主要讲述了什么是大数据这一概念，以及它的特点 1. 更多 - 不是随机样本，而是全体数据 利用所有数据，而不再仅仅依靠一小部分数据 数据统计中选择数据的两个标准：量与质 质：选择样本的随机性（这个比量的要求更难达到）；并且，采样分析的精确性随着采样随机性的增加而大幅提高，但与样本数量的增加关系不大； 量：要求一定数量的样本；但当样本数量达到某个值之后，我们从新个体上得到的信息会越来越少； 采样忽视了细节考察，但我们别无选择； 样本 = 总体 大数据采用的是所有数据； 2. 更杂 - 不是精确性，而是混杂性 我们怎么看待使用所有数据 和 使用部分数据的差别，以及我们怎样选择范松要求并取代严格的精确性，将会对我们与世界的沟通产生深刻的影响。 允许不精确； 即容错性； 大数据通常用概率说话，而不是用确定无疑的态度； （整个社会习惯这种思维需要一段时间） 大数据的简单算法比小数据的复杂算法更有效 案例：Google的翻译软件 的正确率大于其他任何的软件；但Google的研究时间仅2年左右，远远低于其他公司；唯一的区别是数据量级上的不同； 大数据时代要求我们重新审视精确性的优劣； 大数据不仅让我们不在期待精确性，也让我们无法实现精确性； 错误并不是大数据固有的特性，而是一个急需我们去处理的现实问题，并且有可能长期存在； 拥有更大数据量所带来的利益远远超过增加一点精确性； 除一些高精度的设备与行业必须要求数据精准（金融、精密仪器制造） 非关系型数据库的诞生（NoSQL）：它不需要预先设定记录结构，允许记录与处理各种不同的数据； 大数据让我们更加真实与全面地认识这个世界； ​ Hadoop：与Google的MapReduce系统相对应的开源式分布系统的基础架构。通过把大数据变成小模块然后分配给其他机器进行分析，最后将结果汇总来实现对大量数据的处理； 3. 更好 - 不是因果关系，而是相关关系 知道 “ 是什么 “ 就够了，没必要知道 “ 为什么 “ 通过去探求 “ 是什么 “ 而不是 “ 为什么 “ ，相关关系帮助我们更好地了解这个世界； 知道 “ 是什么 “ 就够了，没必要知道 “ 为什么 “ 亚马逊的推荐系统：它并不知道为什么喜欢海明威作品的客户会购买菲茨杰拉德的书。但这似乎并不重要。【关键是确定核心思想：预测 or 推断 or 分类/聚类】 相关关系通过有用的关联无来帮助我们分析一个现象，而不是通过揭示内部的运作机制；相关关系没有绝对，只有可能性。【转变到概率性思维】 我们找到一个现象的良好的关联物，相关关系可以帮助我们捕捉现在和预测未来 如果A和B经常一起发生，我们只需要注意到B发生了，就可以预测A也发生了；这有助于我们捕捉可能和A一起发生的事情，即使我们不能直接观察到A 【这种思维方式的转变很重要】 相关的相关关系的应用在之前就已经存在。【常规的分析方法：假设-收集数据-验证-修正】 统计学家喜欢找到一个关联物，然后收集与之相关的数据进行相关关系分析来评测这关联物的优劣；并且专家们还会使用一些建立在理论基础上的假想来指导自己选择关联物。这些理论就是一些抽象的观点，关于事物是怎样运作的。然后收集与关联物相关的数据来进行相关分析，以证明这个关联物是否真的合适；如果不是合适，人们通常会固执地再次尝试，因为担心可能是数据收集的错误，而最终却不得不承认一开始的假想甚至假设建立的基础都是有缺陷和需要修改的。 这种假设的反复试验促进了学科的发展。 我们理解世界不在需要建立在假设的基础上，这个假设是指针对性现象建立的有关其产生机制和内在机理的假设 建立在相关关系分析法基础上的预测是大数据的核心； 实验是通过是否有诱因这两种情况，分别来观察所产生的结果是不是和真实情况相符；如果相符就说明确实存在因果关系；这个衡量假说的验证情况控制得越严格，你就会发现因果关系越有可能真实存在； 若要找出相关关系，我们可以用数学方法；但如果是因果关系，这是行不通的 第二部分 大数据时代的商业变革 4. 数据化 - 一切可量化 数字化：把模拟数据转换成 0 和 1 表示的二进制码；成果是给机器阅读； 数据化：把现象转变为可制表分析的量化形式的过程；成果是给人看的； 5. 价值 - 用之不竭 数据通常是为了某个特定的目的而被收集； 不同于物质性的东西，数据的价值不会随着它的使用而减少，而是可以不断地被处理； 数据的价值并不局限于特定的用途，它可以为了同一目的而被多次使用，也可以用于其他目的； Google的拼写检查，不同于其他公司的就是它没有排除错误的内容；Google的拼写检查系统显示，那些 “不合标准、不正确、有缺陷” 的数据也是非常有用的； 当用户输入 “流行学病” 时，用户可以通过点击正确的术语明确地告诉Google需要重新查询的内容 6. 角色定位 - 数据、技术与思维 大数据价值链的三个构成 基于数据本身的公司 ： 拥有大龄数据或者至少可以搜集到大量数据，却一定有从数据中提取价值或者用数据催生创新思想的技能 基于技能的公司： 咨询公司、技术供应商、分析公司；掌握了技能但并不 基于思维的公司： 创新思维；他们思考的只有可能，而不是所谓的可行； 第三部分 大数据时代的管理变革 7. 风险 匿名化对大数据是无效的； 收集的数据越来越多； 结合越来越多不同的来源； 8. 掌控 个人隐私保护：从个人许可到让数据使用者承担责任； 数据使用者比任何人都明白他们想要如何利用数据；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《统计学习导论_基于R应用》]]></title>
      <url>%2F2017%2F10%2F30%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F10_%E7%BB%9F%E8%AE%A1%E5%AD%A6%2F%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA-%E5%9F%BA%E4%BA%8ER%E5%BA%94%E7%94%A8%E3%80%8B%2F</url>
      <content type="text"><![CDATA[《An Introduction To Statistical Learning 》 - Gareth.James、Daniela.Witten、Trevor.Hasie、Robert.Tibshirani 不仅介绍了统计学的基本概念，而且从其内在本质的角度进行阐述，并对各种模型与算法进行了比较，总结了各自的优劣势。 统计学习的三类应用 预测 分类 聚类 （不输出预测变量） 第二章 统计学习 整体上介绍了统计学习的几种方式，并给出了评价模型的维度 2.1 统计学习统计学习，是关于估计 $f$ 的一系列方法。 $$ Y= f(x) + \xi$$ $f$ 表达了 X 提供给 Y 的系统信息。是 x 的函数 $\xi$ ，随机误差项；均值为0，且与 X 独立 预测 &amp; 推断 - 估计 $f$ 的两种场景面对一个问题，首先要做的是对其目的 进行判断：预测 or 推断 预测通过现有的输入集 X ，获取输出 Y $$\hat{Y} = \hat{f}(X)$$ $\hat{f}$ 表示$f$ 的预测， $\hat{Y}$ 表示 $Y$ 的预测值。 在这个式子中，$\hat{f}$ 是黑箱。表示一般意义下，如果该黑箱能够提供准确的预测 $Y$， 则并不十分追求 $f$ 的准确形式。 $\hat{Y}$ 作为 $Y$ 的预测，精确度取决于两个量：可约误差、不可约误差$\xi$ $\xi$ 包含了对预测 $Y$ 有用但却不可直接观测的变量信息：由于没有测量它们，所以 $f$ 不能使用这些变量去预测。 例如：某个病人不良反应的风险也许会在一天内很不一样，比如药物的药效本身在设计上随着一天内服药环境的温度和湿度的不同而不同，或者风险与病人当天服药的情绪状态有关。 推断对 $X$ 变化是 对 $Y$ 产生怎样的影响比较感兴趣，我们的 目的是获得 $X$ 和 $Y$ 的关系，而不是为了预测 $Y$； 去理解 $Y$ 作为 $X$ 的函数是怎么变化的。可能涉及： 哪些预测变量与响应变量有关？ 通常情况下用于预测的变量中只有一小部分与 $Y$ 充分有关，从一大组可能的变量中根据应用的需要识别一些重要的预测因子是很有必要的。 响应变量与每个预测变量之间的关系是什么？ $Y$ 与每个预测变量的关系能否用一个线性方程概括，还是它们的关系需要更复杂的形式？ 参数 &amp; 非参数 - 估计 $f$ 的两种方法确定目的之后，选择合适的估计方法：参数方法 &amp; 非参数方法 参数方法 what：基于模型的方法统称为参数法。 why ：把估计 $f$ 的问题简化到估计一组参数。（优势） 对$f$ 假设一个具体的参数形式将简化对 $f$ 的估计；因为估计参数更为容易 how ： 假设函数 $f$ 具有一定的形式或形状；常用的线性假设 $f(X) = \beta_0 + \beta_1X_1 + …$ ； 此时估计 $f$ 的问题被简化为估计一组参数 $\beta$ 用训练数据去拟合模型 不足：选定的模型可能与真正的 $f$ 并不一致，这个时候的效果会很差 解决办法：尝试选择光滑(felexible)模型拟合不同形式的函数$f$ ；但拟合光滑度更强的模型需要更多的参数估计。并可能出现过拟合现象。 非参数方法 what：不需要对函数的形式做事先明确的假设，追求的是接近数据点的估计。 how ：估计函数在去粗和光滑处理后尽可能与更多的数据点接近 优势：不限定函数的具体形式，可以在更大的范围内选择更适合$f$形状的估计 不足：无法将估计$f$的问题简化到仅仅对少数参数进行估计的问题，所以为了获得对$f$更精准的估计，往往需要大量的观测点（远远超出参数方法所需要的点），并且无法对模型进行合理的解释 预测精度 &amp; 模型解释性 - 基于目的的权衡通常情况下，当一种方法的预测精度增加时，它的模型结实度则减弱。 但事实是更精确的预测常常在欠光滑度的模型上取得。原因在于高光滑度的模型有过拟合的问题存在。 推断：更需要模型解释性，倾向于选择参数方法 预测：更需要高预测精度，倾向于选择非参数方法 指导学习 &amp; 无指导学习 指导学习：对每一个预测变量观测值 $x_i$ 都有对应的相应变量的观测 $y_i$ ；建模的目标是通过建立预测变量和响应变量之间的关系，精准预测响应变量或更好地理解两者之间的关系。 无指导学习：只有预测变量的观测向量 $x_i$ ，这些变量没有对应的响应变量 $y_i$ 与之对应。 这类问题拟合线性模型是不可能的，因为缺乏响应变量用于预测 回归 &amp; 分类 2.2 评价模型 目的是选择最适合的统计方法。 偏差 - 方差的权衡，以及测试误差产生 $U$形曲线都使建模成为一项苦难的任务 通过 [均方误差] 检验拟合效果 涉及MSE、自由度、过拟合 均方误差 均方误差（Mean Squared Error , MSE）：（真实值 - 预测值）平方的均值 $$MSE = \frac 1n \sum_i^n(y_i - \hat{f}(x_i) ) ^2$$ 训练均方误差、测试均方误差； 在应用中不在意是否 $\hat{f}(x_i) \approx y_i$ ，而是关心一个新的观测点 $(x_0, y_0)$ ，是否有 $\hat{f}(x_0) \approx y_0$ ；所以，选择的标准的是使得 测试均方误差 最小，而不一定是训练均方误差最小。 一般情况下，一个模型的训练均方误差最小时，并不能保证模型的测试均方误差同时会很小。两者之间更像是 U 型的关系。 [自由度与均方误差(训练&amp;测试)] ####自由度 描述曲线光滑度的量。 当拟合函数的光滑度增加时，训练均方误差单调递减，但测试均方误差成 $U$ 型分布； 模型越光滑，偏差越小； ####过拟合 当所建的模型产生一个较小的训练均方误差，但却得到一个较大的测试均方误差，该模型就是过拟合了。 过拟合，表示对已有的训练数据有非常精准的估计，但是对新的不属于原来训练数据集的观测点的估计偏差很大。 但无论过拟合是否发生，我们总是期望训练均方误差比测试均方误差要小，原因是许多统计学习方法直接或者间接，其目标函数都是训练均方误差最小。 Why：在于暗示降低模型的光滑度，减小测试均方误差 偏差 - 方差权衡 模型选择的两个指标，但是它们是负相关的。 使用光滑度更高的方法，所得模型偏差会减少，方差会增加 虽然两者是负相关，但变化的幅度是不一样的；有的时候，提高一种方法的光滑度，偏差减小的速度要比模型方差增阿基的快，这时期望测试均方误差就会下降 目标：使得（方差 + 偏差$^2$ ) 最小化 偏差 - Bias为了选择一个模型逼近真实函数而被带入的误差，其构成可能非常复杂。即预测值与真实值之间的差值。 一般来说，光滑度越高的方法产生的偏差越小； ####方差 - Variance 代表用一个不同的训练集估计 $f$ 时，估计函数的改变量。 一般来说，光滑度越高的统计模型有更高的方差。 分类模型的评价 通过错误率去进行评价 训练错误率：衡量估计 $\hat{f}$ 精度的方法 $${1\over n} \sum_i^n I (y_i \neq \hat{y_i}) $$ ( 2.8 ) $I(y_i \neq \hat{y_i})$ 表示一个示性变量；当 $y_i \neq \hat{y_i}$ 时，值等于1；否则等于0； 若值等于0，表示第$i$个观测值用分类模型实现了正确的分类。上式计算了误分类的比例。 与之对应的为 测试错误率 贝叶斯分类器 贝叶斯分类器将产生最低的测试错误率 设计一个简单的分类器将每个观测值分配到它最大可能所在的类当中，将这个类作为它的预测值；即将一个$x_0$ 分配到下式最大的那个$j$ 类上是合理的： $$Pr (Y=j | X=x_0)$$ ( 2.10 ) 这是一个条件概率。给定了观测向量 $x_0$ 条件下 $Y=j$ 的概率。 在一个二分类问题中，只有两种可能的响应值1或2；若 $Pr (Y=1|X=x_0) &gt; 0.5 $ ，贝叶斯分类器将其预测为1，否则为2； 贝叶斯决策边界：表示那些概率为0.5的点所组成的边界。 贝叶斯分类器将产生最低的测试错误率，称为贝叶斯错误率。因为贝叶斯分类器总是选择使 ( 2.10 ) 最大的类。 在 $X = x_0$ 处的错误率是 $1 - max_j Pr (Y=j | X=x_0)$ 整个贝叶斯错误率 $$ 1 - E (max_j Pr (Y=j | X) ) $$ ( 2.11 ) 期望平均了所有$X$ 上可能的概率 贝叶斯错误率类似于不可约误差 K 最邻近分类器 实际情况是一般很难知道给定 $X$ 后 $Y$ 的分布，所以很多时候计算贝叶斯分类几乎是不可能的；所以常常 先给定 $X$ 后估计 $Y$ 的条件分布 然后将一个给定的观测值分类到估计的分布概率最大的类别中 KNN (K - Nearest Neighbors )分类器 - 步骤 给一个正整数 K 和一个观测值$x_0$ 从训练集中找出 K 个最靠近$x_0$ 的点集开始，用 $N_0$表示这个K个点的集合 对集合中每个类别$j$ 分别估计它的条件概率 $Pr (Y= j | X=x0) = \frac 1n \sum{N_0}I(y_i = j) $ 最后运用贝叶斯方法将测试的观测值$x_0$ 分到概率最大的类中 例如，目标是对黑色十字标记的点作出预测；选取K=3； 首先识别出靠近该点最近的3个观测值；其中2个点位蓝色，一个点位橙色；所以蓝色的估计概率为 2/3，橙色点的估计概率1/3； 因为蓝色点的概率最大，所以最后把该十字标记点分类为蓝色 K的选择对获得KNN分类器有根本性的影响。 K = 1 时，决策边界很不规则；此时偏差最低，但方差往往很大； K = 100 时，模型的光滑性减弱， 得到一个接近线性的决策边界； 第三章 线性回归 简单线性回归、多元线性回归、多项式回归 ##简单线性回归 根据单一变量 $X$ 预测定量 响应变量 $Y$ 的方法。 $$ Y \approx \beta_0 + \beta_1X$$ ( 3.1) 估计系数 目的是估计 $\beta_0 , \beta_1$ 残差（Residual） = （预测值 与 实际值） 之间的差值；即偏差； 残差平方和 - RSS ( Residual Sum of Squares ) $$RSS = \sum_i^n (y_i - \hat{y}_i) ^2$$ ( 3.3 ) 最小二乘估计（Least Squares Coefficient Estimate）：选择使得 RSS最小的参数； 最小二乘直线：找到一条直线，使得RSS最小 评估估计的准确性 介绍了样本均值、标准误差、置信区间、零假设、t统计量、p值 目的是确保单个模型中系数的准确性 总体回归直线 Vs. 最小二乘直线 总体回归直线：真实的回归直线，一般是无法获得的 最小二乘直线：拟合的回顾直线，尽量逼近真实的回归直线 两者之间有细微的差别，这是基于对标准统计方法的延伸（即利用样本信息估计一个较大总体的特征） #####样本均值 样本均值：随机抽取10个样本集，每个集中有100个观测值，每个样本自身的均值，组成一个集合（共10个元素）；该组集合的均值即为样本均值； 例如我们对随机变量$Y$的总体均值$\mu$感兴趣。问题在于 $\mu$ 是未知的，但我们有 n 个关于 $Y$ 的观测值，即为$y_1, y_2 ,… , y_n$ ，可以用它来估计$\mu$ 。 一个合理的估计是 $ \hat{\mu} = \overline y $ ，其中 $\overline y = \frac 1n \sum_i^n y_i$ 对一组特定的观测值$y_1, …,y_n$ 可能会高度或低估均值 $\mu$ ，但如果对大量观测数据集中得到许多对 $\mu$ 的估计，则它们的均值正好等于$\mu$ ； 因此一个无偏估计不会系统地高估后低估真实参数。这种无偏性同样适用于最小二乘参数估计。 标准误差 样本均值的标准误差 - SE (Standard Error)：衡量估计值 $\hat{\mu}$ 与真实均值的偏离程度 $$Var(\hat{\mu}) = SE (\hat{\mu})^2 = {\sigma^2 \over n} $$ ( 3.8 ) $$SE(\hat\mu) = {\sigma \over \sqrt{n} }$$ 标准误差 $SE(\hat{\mu})$ 衡量了估计$\hat{\mu}$ 偏离 $\mu$ 的实际值的平均量，也告诉我们这种偏差随着n的增大而减小。 方差：随机变量与数学期望（均值） 之间的偏离程度 $$Var(x) = \frac 1n \sum (x_i - \mu) ^2$$ #####置信区间 置信区间 - CI (Confidence Interval) ：通过标准误差来估计算置信区间 95%的置信区间：被定义为真实值有95%的概率落在该区间；或许说该范围有95%的概率包含未知参数的真实值 对于线性回归模型，$\hat\beta_1$ 的95%的置信区间约为 （基于经验原则） $$ \hat\beta_1 \pm 2 SE(\hat\beta_1)$$ ( 3.9 ) #####零假设 标准误差对系数进行假设检验：零假设 与 备择假设 零假设： $H_0 $ : X 和 Y 之间没有关系； 备择假设： $H_a$ : X 和 Y 之间有一定的关系； 为了检验零假设，需要确定 $\hat\beta_1$ ($\beta_1$的估计值) 距离零是否足够远，从而能够确信 $\beta_1$是非零的； 足够远的评判，取决于 $\hat\beta_1$ 的准确性；即依赖于 SE($\hat\beta_1$) ； 如果 SE($\hat\beta_1$)很小，那即使 $\hat\beta_1$ 较小，也可能为 $\beta_1 \neq 0 $提供强有力的证据，证明X 和 Y 是相关的； 如果 SE($\hat\beta_1$)很大，那 $\hat\beta_1$ 的绝对值必须很大才能拒绝零假设。 #####t 统计量 t 统计量：衡量了$\hat\beta_1$ 偏离0的标准偏差 （即若为零假设时， $\beta$ 应为0） $$t = {\hat\beta_1 - 0 \over SE(\hat\beta_1) } = {\hat\beta_1 - 0 \over {\sigma / \sqrt{n} } }$$ t 分布有钟形结构；当n &gt; 30时，类似正态分布； #####p 值 $p$ 值 ：假设 $\beta_1=0$ 时，计算任意观测值大于等于|t|的概率； $p$值的解释：在接受原假设为真的情况下，该组样本量中的值出现的概率； 若这个概率 $p$ 非常小，但现在的这个统计量却出现了，表明在预测变量和响应变量之间的真实关系未知的情况下，不太可能完全由于偶然而观察到预测变量和响应变量之间的强相关。 系数 标准误 t统计量 p值 Intercept 7.0325 0.4578 15.36 &lt;0.0001 Tv 0.0475 0.0027 17.67 &lt;0.0001 表明，该 t 统计量（15.36）出现的概率为 &lt;0.0001，但现在却出现了。所以我们拒绝 $\beta_1=0$ 的原假设，认为两者之间是有关系的。 评价模型的准确性 目的是选择合适的模型；在此之前必须保证每个模型中系数的准确性 评价线性模型的拟合度常用：残差标准误、$R^2$ 统计量 残差标准误残差标准误 - RSE (Residual Standard Error ) ：残差本身的偏离程度； $$RSS = \sum_i^n (y_i - \hat{y}_i) ^2$$ $$RSE = \sqrt{ {1 \over (n-2) }RSS}$$ 当模型拟合越好，RSE则越小； 不足：但这是一个绝对值的度量，以Y的单位进行衡量；所以偏差的大小会根据原本统计单位的不同而不同； 一个是渠道的数量，单位个；一个是金额的数量，单位万元；会有很大的不同 $R^2$ 统计量表示被解释方差的比例，值在 [0 , 1]之间；测量的是 Y 中的变异中能被 X 解释的部分所占的比例；越接近1，说明回归可以解释越多的变异性 $$R^2 = {TSS-RSS \over TSS } = 1- {RSS \over TSS}$$ ( 3.17 ) $TSS = \sum(y_i - \overline y) ^2 $ ：总平方和，测量的是响应变量 Y 自身的总方差，可以认为在执行回归分析之前响应变量中的固有变异性； $TSS - RSS$ ：测量的是响应变量进行回归之后被解释的变异性； 不足：当更多的变量进入模型时，即使新加入的变量与响应变量的关联很弱， $R^2$也一定会增加；这是因为在最小二乘法中添加变量必然会使我们更准确地拟合训练数据； 多元线性回归多个预测变量$X_i$ 预测 定量 响应变量 $Y$ $$ Y = \beta_0 + \beta_1X_1 + … + \beta_nX_n + \xi$$ $X_i$ 代表第 $i$ 个预测变量，$\beta_i $代表第 $i$ 个预测变量与响应变量之间的关联； $\beta_i $ 解释为在所有其他预测变量保持不变的情况下，$X_i$增加一个单位对 $Y$ 产生的平均效果； F 统计量 - 预测变量与响应变量是否有关系 所有预测变量中是否至少有一个可以用预测响应变量。 $H_0 : \beta_1 = \beta_2 = … = \beta_n = 0 $ $H_a : 至少有一个 \beta_i 不为0$ $F$ 统计量： $$F = {(TSS-RSS)/p \over (RSS/(n-p-1))}$$ F统计量 越接近1，表示预测变量与响应变量无关； F统计量 大于1，表示两者有关系，则拒绝零假设； F统计量越大，越能表明两者之间是相关的； F统计量接近1，是否拒绝零假设取决于n和p的值； 若n很大，即使F统计量只是略大于1，可能仍可提供拒绝零假设 若n较小，需要较大的统计量才能拒绝零假设； 同时可以根据 $p$ 值来进行判断 回归模型中的其他问题 涉及定性预测变量、模型的扩展、潜在的异常值 定性预测变量 - 构造哑变量二值预测变量一个定性变量只有2种可能的取值；只需要给二值变量创建一个指标/哑变量； $x_i$ = 1，表示女性； $x_i$ =0 ，表示男性 $y_i = \beta_0 + \beta_1x_i + \xi_i$ $\beta_0 + \beta_1 + \xi_i$ ； 女性 - $x_i =1$ $\beta_0 + \xi_i​$ ； 男性 - $x_i =​$0 $\beta_0$ 解释男性的平均债务水平 $\beta_0 + \beta_1$ 解释女性的平均债务水平 $\beta_1$ 表示男性与女性之间债务的平均差异； 也可以使用 $x_i$ = 1，表示女性； $x_i$ = -1 ，表示男性 ；对结果并不影响，区别仅在于对系数的解释不同； 两个水平以上的定性变量给每一个水平创建一个哑变量；而不是对整个变量创建哑变量； 没有相对应的哑变量的水平，被称为基准水平； $x{i1} $ = 1，表示高中； $x{i1}$ =0 ，表示非高中 $x{i2} $ = 1，表示大学； $x{i2}$ =0 ，表示非大学 $x{i3} $ = 1，表示硕士； $x{i3}$ =0 ，表示非硕士 $y_i = \beta_0 + \beta1x{i1} + \beta2x{i2} + \beta3x{i3} +\xi_i$ $\beta_0 + \beta_1 + \xi_i$ ； 高中 $\beta_0 + \beta_2 + \xi_i$ ； 大学 $\beta_0 + \beta_3+ \xi_i$ ； 硕士 $\beta_0 + \xi_i$ ；初中 线性模型的扩展 可加性假设：预测变量$X_i$变化对响应变量$Y$ 产生的影响与其他预测变量的取值无关； 线性假设：无论 $X_i$ 取何值，$X_i$变化一个单位引起的响应变量 $Y$的变化是恒定的 去除可加性 - 交互项 实验分层原则：如果模型中含有交互项，那么即使主效应的系数 p 值不显著，也应该包含在模型中； 所以，要优先检查交互项的系数的零假设 非线性关系 - 多项式引入高次方，即多项式； $ Y = \beta_0 + \beta_1x + \beta_2x^2 + \xi$ 潜在的异常值 数据的非线性、误差项自相关、误差项方差非恒定、离群点、高杠杆点、共线性 线性回归 Vs. KNN 参数方法在建模的过程中对 $f(X)$ 的形式提出了很强的假设； 当选定的参数形式接近 $f$ 的真实形式，参数方法会优于 非参数方法 维度的增加给线性回归的MSE带来的影响较小，而对KNN的影响较大； 若每个预测变量仅有少量的观测值，参数方法往往会优于非参数方法 若需要更高的模型结实度，则倾向于参数方法；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《断舍离》读书笔记_山下英子]]></title>
      <url>%2F2017%2F10%2F09%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F30_%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F%2F%E3%80%8A%E6%96%AD%E8%88%8D%E7%A6%BB%E3%80%8B_%E5%B1%B1%E4%B8%8B%E8%8B%B1%E5%AD%90%2F%E3%80%8A%E6%96%AD%E8%88%8D%E7%A6%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%B1%B1%E4%B8%8B%E8%8B%B1%E5%AD%90%2F</url>
      <content type="text"><![CDATA[《断舍离》 - 山下英子 [日] 断舍离，表达了通过 [ 断 ] 与 [ 舍 ] 两种行为，去达到 [ 离 ] 这一状态的目的。 通过《断舍离》，认识了自己与物品对话的两个非常重要的角度 我与物品的关系：从 [ 以物品为中心 ] 向 [ 以我为中心 ] 的视角转变 时间维度 以 [ 当下 ] 为核心； 断，停止负面的思考模式；断绝想要进入自己家的不需要的东西。 舍，顺从自己的心，割舍既有；舍去非当下的、不适合自己的物品，舍去家里到处泛滥的破烂儿 离，达到一种释怀的状态，摒弃 “多就是好” 的观念；脱离对物品的执念，处于自在的空间 断舍离的主角不是物品，而是自己。这是一种以 “物品和自己的关系” 的核心来进行取舍物品的技术。你要做到的思考方式并不是 [ 这东西还能用，所以要留下来 ]，而是 [ 我要用，所以它很必要 ]。主语永远都是自己，而时间轴永远都是现在。 物品要用才有价值； 物品在此时、当下，应出现在需要它的地方 物品处于恰当的位置，才能展现美感。 why - 为什么要读这本书 对当下生活以及精神状态的梳理 what - 这本书在讲什么 围绕两个核心观点：(1) 我与物品的关系 - 以我为中心； (2) 时间维度：时间轴 How - 如何依次发展这个观点的 what - 什么是断舍离，以及行为(do)进行简单描述 why failed - 为什么失败的集中原因 should do - 应该怎么做 just do - 实际的行动方法 what - 对生活的指导意义 重新认识了对物品以及家居整理的思维方式 How - 具体怎么做 通过整理自己的房间来落实到行为 第一章 断舍离的机制 what 在考虑如何处理物品时，我们把轴错位在了物品与他人、不确定的未来和已经成为过去的过去上面。 断舍离的主角不是物品，而是自己，考虑的是 “我自己” 还需不需要它。“扔了很可惜，还是留下来吧” 这种想法，就是拿物品当主角。 要得出 “ 这种东西与当下的我很相称，对当下的我来首是必需品 “ 这样的判断，我们就必须清楚地了解自己。通过不断地筛选物品，当下的自我就会越来越鲜明地呈现在自己眼前，人也就能以此判断出准确的自我形象。 一个人所使用的物品，能够反映出自我形象。认识到了自我形象，反过来就会开始想要把现在用的东西替换掉。 断舍之后，才是整理。 在达到 “ 舍 “ 之前就是整理物品是没有意义的。毕竟跟没用的东西说话是根本没有用的。 东西要用才有价值；或者说，物品全部的价值在于使用。 仅特殊的物品有收藏、回忆的价值。 物品应该以必要的量出现在必要的地方，这才真正有意义。 通过有意识地选择让物品回归到它应该在的地方，回归到需要它的地方。这就是断舍离要做的。 断舍离 Vs. 收纳术 断舍离 收纳术 前提 代谢与替换 保管与维持 主角 自己 物品 焦点 关系性 物品或自己或赠送物品的对象 核心轴 感性、适宜、需要、合适、舒服 物质、可惜、能用或不能用 时间轴 现在、当下 过去、未来 意识 选择、决定 回避 手续 少 多 不需要 需要 收纳物 不需要 需要 第二章 无法丢弃的理由 why failed 物品本来就是为了让人使用才被生产出来的。 入口是 “ 断 “ 的闸门，出口是 “ 舍 “ 的闸门。我们会在不知不觉中掉进折扣的陷阱，完全忘记了 “ 东西是不是适合自己的品味 “。 【对于这一点，自己做得还是比较好的；购物的时候比较理性】 **扔不掉东西的三种人： 逃避现实型：太过忙碌，几乎没有时间待在家里 执着过去型：活在过去的生活当中，不愿丢弃以往的物品 担忧未来型：缺乏安全感；致力于投资不知何时回发生的未来的不安要素 扔不掉 = 不想扔 可以丢弃的三类物品 不用的东西：漫不经心地保存或放着不管的东西，甚至已经忘记了它的存在；只因为一想到扔掉就有所不安所以一直拖延没有扔 还在用的东西：东西可以用，但并不喜欢，所以就随便用着。因此我们会随意地乱放，也不会珍惜。【警惕这类物品；这类是与自己不相配的东西】 充满回忆的东西：充满了回忆与怀念，所以扔不掉 物品本来就是为了让人使用才被生产出来的。如果站在物品的立场上去看的话，它们会说 “我好寂寞呀；用用我吧；你如果不用的话就把我送到一个能派上用处的地方吧。” 【物品就像你的朋友，如果TA被忽略和遗忘，那会是什么感受】 当杂物占据了空间，其实是把时间轴错位到了过去与未来。 家里放着的东西，有80%都是时间错误的。在断舍离中，比起凌乱，堆积了聚焦于过去和未来的物品才是问题的关键。 “ 买的时候花了10万日元，这个事实总是涌上心头，把自己完全逼回到过去。” 聚焦于现在的物品分类两类：日常 &amp; 非日常 要把重点放在日常上 ​ 第三章 断舍离的思考法则 should do 以自我为轴心，把时间轴放在当下。 能用的东西 Vs. 我用的东西 是不同的；在考虑物品是否被留下时，思考的主语是 “ 我 “，而不是物品。 整理 $\ne$ 收拾； 收拾：筛选出必需的物品；数量上有所变化 整理：调整物品的位置；数量上保持不变 第四章 断舍离的实践方法 Just Do 充分理解并利用 [ 七五一 ] 的总量限制原则，并且伴随着替换原则（由于总量的限制，当你购入新的物品时，就必须放弃旧的物品；） 聚焦于某一个场所，然后开始收拾。即便只是一个抽屉，甚至夸张一点，即使是一个塞满了购物小票的钱包也可以。 储备物品是人类的本能。为了未来可能会到来的危机而提早做足准备的想法总是不断浮现在我们的意识里。不过，如今这个时代我们搜储备的东西早就远远超过了必须量。 把东西送给别人时，不要给对方负担；要询问对方是否真的需要，并要表明若不需要就扔掉的态度；把自己用不着的东西送给有需要的人时，要说 “ 请收下 “，而不是说 “ 给你 “。 分类按照 分成三类 的原则逐步进行，而不是一次就进行到底； 大分类：餐具、烹饪器材、食材 中分类：（盘子、容器、杯子）、（电器、水槽周边、炉子周边）、（冷冻室、蔬菜保鲜、冷藏室） 小分类：（大盘子、小盘子、其他）、（加热用、烹饪准备用、其他）、（已烹饪过、未烹饪、冰淇淋） 七五一的总量限制原则 看不见的收纳空间：放满70% 柜子里的东西、抽屉里的东西；留出30%的空间，是因为这会让人有把它手机整齐的欲望和心情，并且空出来的空间能成为物品出入的通道 看得见的收纳空间：放满50% （书架、CD架之类兴趣的东西除外） 给别人看的收纳空间：只能放10%（最低限度地放东西） 比如美术展览馆中，名画多半是单独挂在一面很宽的墙上 伴随总量限制原则的替换原则； 由于总量的限制，当你购入新的物品时，就必须放弃旧的物品； 尽量减少把东西拿出来的压力；摆放物品的时候，遵从一个动作原则；即一个动作就能够取出所要的物品。 核心在于 物品摆放的方式是不是便于选择。 第五章 看不见的世界在变化 试着使用高于自我形象的物品。因为人是很容易根据外界变化做出自我调节适应的；你会尽量努力去让自己配得上你所拥有的物品。 好不容易能拥有一件物品，与其觉得 “ 算了，就它吧 “ ，不如觉得 “ 必须要这个不可 “；因为后者更能让人在维护管理这件东西的时候保持愉悦的心情。【购买单肩包，自己也是换了又换；十一购买外套，为了能够买到它，特意去了多个地方，最后终于顺利买到仅剩一件的合适尺码】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘_核心思想&基本概念]]></title>
      <url>%2F2017%2F09%2F30%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F30_%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98_%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%26%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[核心目的 分类 预测 推荐 #核心思想 数据挖掘-DM（Data Mining），贯穿的主要的思想有四个：关联，分类，回归分析和聚类。 前两条是为了寻找差异基因 后两条是预测差异基因的可能的属性。 关联原则表型的差异往往是和基因间的差异紧密联系的。内在的基因产生了表达的差异，才会导致外在的表型有变化，而外在的表型不同，往往是由于基因表达不同产生的。 分类比较基因和表型之间有关联性，那我们只要把可区分的表型进行分类，那是不是就能锁定到与表型一样有差异的基因了？分类的关键就是为了形成比较。有了表型的差异，才能够分类，有了表型的分类，才能找出基因型的差异。 我们为啥要把样本分成肿瘤和正常组织呢？就是为了比较肿瘤和正常组织间的差异，找出与表型相关联表达不同的基因。 回归分析 回归的目的是进行预测； 根据自变量预测因变量。 聚类 根据未给定的规则进行划分类别； 通过确定类别的数量来确定如何划分；而分类是根据已知的规则进行分类，类别的数量是确定的。 分类 Vs. 聚类聚类和分类的最基本区别。 分类：就是根据文本的特征或属性，划分到已有的类别中。也就是说，这些类别是已知的，通过对已知分类的数据进行训练和学习，找到这些不同类的特征，再对未分类的数据进行分类。 聚类：就是你不知道数据会分为几类，通过聚类分析将数据或者说用户聚合成几个群体，那就是聚类了。聚类不需要对数据进行训练和学习。 分类属于监督学习，聚类属于无监督学习。常见的分类比如决策树分类算法、贝叶斯分类算法等；聚类的算法最基本的有系统聚类，K-means均值聚类 基本概念 1. 数据挖掘 What：在大型数据库中自动地发现有用信息的过程。 KDD(Knowledge Discovery in Database)：数据库中发现知识；KDD是将未加工的数据转换为有用信息的过程。数据挖掘是KDD中不可缺少的一部分； Why : 发现先前未知的有用的模式； 预测未来观测值； 2. 分类 What：通过学习得到一个目标函数，把每个属性集映射到一个预先定义的类标号（分类属性）； 适合离散型变量；但并不适合序数类离散型变量； Why ：（1）作为解释性工具，区分不同类别中的对象；即用于概括数据，说明哪些特征决定该记录属于哪一个类标号；（2）用于预测未知记录的类标号； How ：解决分类的一般步骤 确定一种学习算法，以此来确定分类模型 数据集划分为训练集、测试集 训练集（Training)：由类标号已知的记录组成；用于拟合模型 测试集(Test)：由类标号已知的记录了组成，用于检验模型的泛化能力 用该学习算法，在训练集中拟合模型 把分类模型运用到测试集中，用于评估模型的泛化能力；应用混淆矩阵，得出模型预测的准确率、错误率等； 根据评价情况，选择不同的模型 2.1 数据集的划分R - createDataPartition() - car包 123456&gt; set.seed(1234)&gt; inTrain &lt;- createDataPartition(data$y, p=0.75, time=1, list=FALSE)&gt; training &lt;- data[inTrain, ] # 将75%的训练样本添加到data&gt; test &lt;- data[-inTrain, ] # 将25%的测试样本添加到data&gt; print(table(data$y)) # 输出分割后的数据行&gt; &gt; data$y， 目标变量 p=0.n， 划分为p%的训练数据的百分比；(1-p)%为测试样本的百分比 time=n， 要创建的分区的数目 list=FALSE 2.2 混淆矩阵 What：提供了实际的类 vs 预测的类的分布情况，以此来评价模型的泛化能力； 预测-类别1 预测-类别0 实际-类别1 $f_{11}$ $f_{10}$ 实际-类别0 $f_{01}$ $f_{00}$ 准确率 = ($f{11}$ + $f{00}$) / ($f{11}$+$f{10}$+$f{01}$+$f{01}$) 错误率 = 错误预测数 / 预测总数 R - confusionMatrix() 123&gt; logit.pred &lt;- predict(logit, hr_good_test, type="response") # 用predict得出模型的预测值&gt; confusionMatrix(hr_good_test$left, logit.pred) # 将实际值与预测值组成混淆矩阵&gt; 2.3 决策树[what] - 通过一系列关于检验记录属性的问题，解决分类问题；每当一个问题得到答案，后一个问题随之而来，直到得出记录的类标号； 根结点：起始位置 内部结点：包含属性测试条件，用以对记录进行分类 叶结点：终点位置，每个叶结点有一个类标号 [why] - 适用特点 非参数方法，即不需要先验假设 在有噪声情况下也可得出可接受的结果 冗余属性不会对准确率造成不利影响 冗余：即在一个数据集中，一个属性与另一个属性是强相关的，就是冗余的；在两个冗余属性中，如果已经选择其中一个，另一个会被忽律 学习离散值函数的典型代表 当数据太少时，无法做出有统计意义的判决；可设置当样本个数小于某个阈值时停止分裂 [how] - 建立决策树 Hunt算法：将训练记录划分成较纯的子集，以递归方式建立决策树； 若子集D中所有记录属于同一个类，则t是叶结点 若子集D中包含属于多个类的记录，则选择一个属性测试条件，将记录划分成较小的子集 设置的两个问题 如何为不同类型的属性指定测试条件 需有一个结束条件 [how] - 模型选择-评估 保持方法 将被标记的原始数据分为训练集、测试集。 在测试集上评估模型的泛化性能 交叉验证：[what] - 每个记录用于训练的次数相同，并且恰好检验一次； 选择一个子集作为训练集，另一个作为测试集； 交换两个集的角色； 总误差为对各个误差求和； 二折交叉验证、k折交叉验证 自助法：[what] - 训练记录采用有放回抽样；即等几率的被重复抽取 2.4 SVM 支持向量机[what] - 通过寻找最大边缘超平面，来划分数据； [what] - 最大边缘超平面； 可找到这样一个平面，使得所有的方块数据位于这个超平面的一侧，而所有的圆圈数据在另一侧 它们的训练误差为零，但这样的平面有无穷个 平行移动一个和决策边界平行的超平面，直到触到最近的圆圈，两个超平面之间的距离为分类器的边缘； 选择分类器边缘最大的超平面，即最大边缘超平面 [why] - 因为边缘较小，决策边界的轻微扰动都可能对分类产生显著的影响；故边缘越大，泛化能力越好； [why] - 适用特点；可很好地用于高维数据 3. 关联 What：用于发现数据集中有意义的联系；并用关联规则或频繁项集的形式表示 Why ：通过发现有意义的联系来指导行为； 3.1 二元表示 What：每行对应一个事务，每列对应一个项；项可以用二元(binary)变量来表示，如果项在事务中出现，值为1，否则为0； 非对称的二元变量：通常认为项在事务中出现比不出现更重要，故项是非对称的(asymmetric)； 3.2 项集和支持度计数项集 What：在关联分析中，包含0个或多个项的集合称为项集(itemset)；如果一个项集包含k个项，称为k-项集； 例如3-项集：{啤酒，尿布，牛奶} 支持度计数 What：所有事务中包含该特定项集的事务个数； 3.3 关联规则、支持度与置信度关联规则 What：形如 X$\to$Y的表达式，X和Y是不相交的项集； How ：关联规则的强度可以用支持度和置信度来度量；但并不表明一定存在因果关系； 支持度 What：支持度计数的百分比形式；所有事务中包含同时包含(X∪Y)的个数/总事务数 Why ：（1）可以删去无意义的规则；（2）关联规则的有效发现； 置信度 What：所有事务中同时包含(X∪Y)的个数 / 所有事务中包含X的个数；也可以看做Y在给定X下的条件概率； Why ：度量通过规则进行推理的可靠性； 关联规则的发现：给定事务的集合T，发现支持度 $\ge$ 指定阈值并且置信度 $\ge$ 指定阈值的所有规则 3.4 频繁项集 What：满足最小支持度阈值的所有项集； 3.4.1 原始方法格结构：枚举所有可能的项集； 候选项集：即X 过程：确定格结构中每个候选项集的支持度计数；这就需要候选项集去每一个事务中进行比较，若包含在事务中，则支持度计数增加； 3.4.2 先验原理 What：如果一个项集是频繁的，则它所有的子集也一定是频繁的；并且一个项集的支持度$\le$它的子集的支持度 {c,d,e}， 它的子集为{c},{d},{e},{cd},{ce},{de} What：如果一个项集是非频繁的，则它的超集也一定是非频繁的； {a,b}，它的超集{a,b,c},{a,b,c,d,},{a,b,c,d,e} Why ：当发现某个项集是非频繁的时候，可以立刻剪去它的超集，这样使得所需要搜索的空间大大减少； 3.5 规则产生 What：在发现的频繁项集中提取所有高置信度的规则，这些规则称为强规则； How ：将项集Y划分成两个非空的子集 X 和 Y-X； 3.5.1 基于置信度的剪枝 What：如果规则X$\to$ Y-X 不满足置信度阈值，则形如 $X’$ $\to$ Y - $X’$的规则也一定不满足置信度阈值；其中，$X’$是X 的子集； 若{bcd}$\to${a}具有不满足置信度阈值，则可以剪枝掉后件包含a的所有规则：{cd}$\to${ab},{bd}$\to${ac},{bc}$\to${ad},{d}$\to${abc} 4. 聚类 What：根据在数据中发现的描述对象及关系的信息，将数据对象分组，使得组内的相似度大于组间相似性；一种非监督学习； Why ：旨在发现有用的对象组/簇 有效发现最近邻 数据汇总；为数据分析技术（回归、PCA）提供可用的数据集 数据压缩； 4.1 聚类类型4.1.1 层次/划分聚类 划分聚类：将数据对象集划分成不重叠的子集（簇），使得每个数据对象恰好在一个子集中； 层次聚类：允许簇具有子簇，是一种嵌套的集组，最后形成一棵树；除叶节点（终节点）外，树中每一个节点（簇）都是其子女（子簇）的合并，二树根是包含所有对象的簇； 4.2 簇类型 明显分离的：每个对象到组内每个对象的距离 &lt; 到组间任意对象距离 基于原型的：每个对象到组内原型的距离 &lt; 到组间原型的距离； 原型可以是质心（簇中所有点的平均值） 原型可以是中心点（簇中最有代表性的点） 基于图的 基于密度的 共同性质的（概念簇） 4.3 K均值[what] - 基于原型的、划分的聚类技术；它试图发现用户指定个数K的簇 - K均值：用质心定义原型，质心=一组点的均值 K中心点：用中心点定义原型，中心点=一组点中最后代表性的点 [how] - 基本算法 选择K个初始质心；（K是用户指定的个数） 每个点指派到最近的质心，并集为一个簇； 重新计算新的簇的质心 重复指派和更新质心，直至质心不再发生变化；或者用较弱的条件替代算法-eg:直到仅有1%的点改变簇 4.4 凝聚层次聚类[what] - 邻近性 MIN-单链；不同簇的两个最近点之间的邻近度 MAX-全链；不同簇的两个最远点之间的邻近度 组平均；不同簇的所有点对邻近度的平均值 [how] - 从个体点作为簇开始，相继合并最接近的簇；直到只剩下一个簇 计算邻近度矩阵 合并最接近的两个簇 更新邻近矩阵，以反映新的簇与原来簇之间的邻近性 直至剩下一个簇 数据预处理聚集[what] - 将两个或多个对象合并成单个对象 [why] 范围/标度转换，得到高层数据视图 - eg:从天到月 群的行为比单个对象的行为更加稳定 进一步分析的处理前提 抽样[what] - 选取数据子集，但必须是有效抽样，即样本是有代表性的； [why] - 压缩数据 维归约[what] - 通过创建新属性，将旧属性合并到一起来降低数据集的维度 [why] - 降低维数，提高数据挖掘的效果 删除不相关的特定并降低噪音 避免维灾难 易于模型更容易解释 特征子集选择 特征创建 离散化和二元化 变量变换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hive_查询整理]]></title>
      <url>%2F2017%2F09%2F15%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FHive%2FHive_%E6%9F%A5%E8%AF%A2%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[关于Hive的常用查询 日期 时间戳转日期格式（15位） 1Select from_unixtime(cast(cast(time as bigint) / 1000 as BIGINT) ) 获取当前日期时间 1select from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') 返回日期部分; to_date() –返回日期部分（字符串格式） 1select to_date() 日期增减 1select date_add(string startdate, int days)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编码介绍]]></title>
      <url>%2F2017%2F09%2F05%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[编码介绍 各个编码格式介绍 GB2312 / GBK / GB18030 / Unicode / UTF-8 GB2312 “对任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示” GB2312是中华人民共和国国家汉字信息交换用编码，全称《信息交换用汉字编码字符集——基本集》。1981年5月1日实施，通行于大陆。新加坡等地也使用此编码。 GB2312收录简化汉字及符号、字母、日文假名等共7445个图形字符，其中汉字占6763个。 GB2312 仅收汉字 6763 个，这大大少于现有汉字 GB2312 规定 “对任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示”，习惯上称第一个字节为“高字节”，第二个字节为“低字节”。 GB2312的编码范围为2121H-777EH，与ASCII有重叠，通行方法是将GB码两个字节的最高位置1以示区别。 GBK GBK亦采用双字节表示，即不论中、英文字符均使用双字节来表示 GBK向下与GB2312 完全兼容，向上支持ISO 10646 国际标准， 在前者向后者过渡过程中起到的承上启下的作用。GBK亦采用双字节表示，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1，总体编码范围为8140-FEFE之间，首字节在81-FE 之间，尾字节在40-FE 之间，剔除 XX7F 一条线。 GBK 共收入21886个汉字和图形符号，包括：* GB2312中的全部汉字、非汉字符号； * BIG5中的全部汉字； * 与ISO 10646相应的国家标准GB13000中的其它 CJK 汉字，以上合计20902个汉字； * 其它汉字、部首、符号，共计984个； GB18030 GB18030 是最新的汉字编码字符集的国家标准，向下兼容 GBK 和 GB2312 标准。 GB18030 编码是一二四字节变长编码。 GB18030编码在码位空间上做到了与Unicode标准一一对应，这一点与UTF-8编码类似。 Unicode Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。 Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符。 Unicode只是一个符号集, 它只规定了符号的二进制代码, 却没有规定这个二进制代码应该如何存储。 比如UTF-8、UTF-16、UTF-32都是Unicode编码的实现方式，不过UTF-8是使用最多的实现。 UFT-8 UTF-8：Unicode Transformation Format-8bit，允许含BOM，但通常不含BOM。是用以解决国际上字符的一种多字节编码，是在互联网上使用最广的一种unicode的实现方式。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，因此可以节省存储空间。 它对英文使用8位（即一个字节），中文使用24为（三个字节）来编码。 UTF-8包含全世界所有国家需要用到的字符，是国际编码，通用性强。UTF-8编码的文字可以在各国支持UTF8字符集的浏览器上显示。如果是UTF8编码，则在外国人的英文IE上也能显示中文，他们无需下载IE的中文语言支持包。 UTF-8的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的； 对于n字节的符号，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的二进制位，表示为这个符号的unicode码； ​ 另外像ASCII只用于英文字符编码，BIG5编码是通行于台湾、香港地区的一个繁体字编码方案，虽然存在一些瑕疵，但广泛应用于电脑行业，尤其是互联网中，从而成为一种事实上的行业标准。 总结 ASCII用于表示英文字符，是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符； GB2312简体中文的编码格式， 只支持6763个常用汉字； GBK是GB2312基础上扩容后兼容GB2312的标准，包含全部中文字符，支持简体中文及繁体中文； GBK通用性比UTF8差，不过UTF8占用的数据库比GBK大； GB2312、GBK到GB18030都属于双字节字符集 (DBCS)； 从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0； GBK和UTF-8的相互转换 一般来说UTF-8可应用于大多数场景，尤其是互联网上，而中文编码主要使用GBK编码，因此这就有了GBK、GB2312和UTF-8的相互转换需求。 GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换 GBK、GB2312 —&gt; Unicode —&gt; UTF-8 UTF8 —&gt; Unicode —&gt; GBK、GB2312 GBK和UTF-8编码的检测 但如果给定一个字符串，能够检测出其编码是什么吗？ 比如对于“中国.北京”，检测出其为GBK或GB2312，而对于 ”涓浗.鍖椾含“检测出其为UTF-8。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_文档输出_rmarkdown]]></title>
      <url>%2F2017%2F09%2F01%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA_rmarkdown%2F</url>
      <content type="text"><![CDATA[rmarkdown &amp; knitr R Markdown文件借助于R扩展包knitr的帮助， 可以把Markdown格式的源文件中插入R代码， 使得R代码的结果能够自动插入到最后生成的研究报告中。 这种格式称为R Markdown格式， 相应的源文件扩展名为.Rmd。 还有一个R扩展包rmarkdown也可以用来把R Markdown格式的文件转换为各种报告格式， 如HTML、docx、pdf、beamer等。 knitr的详细文档参见网站knitr文档。 RStudio是一个集成的R软件环境， 可以用来编辑和执行R程序， 这个软件也可以用来编辑和编译R Markdown格式的文件， 使得R Markdown格式的文件变得容易使用。 在RStudio中可以直接用一个快捷图标一次性地把R代码结果插入内容中并编译为HTML或MS Word docx格式， 还支持Markdown中LaTeX格式的数学公式。 建议使用RStudio软件作为R Markdown文件的编辑器。 输出文档在RStudio软件中，用菜单“File–New File–R Markdown”新建一个R Markdown文件，扩展名为.Rmd。 如果不借助于RStudio软件， 可以用R软件、knitr包、rmarkdown包、pandoc软件来完成R Markdown源文件的编译。 比如，假设test.Rmd是一个这样的R Markdown格式的文件， 在不使用RStudio软件时， 可以在R中运行如下命令以生成含有运行结果的html文件: 123library(knitr); library(markdown)knit('test.Rmd', encoding='UTF-8')markdownToHTML(file='test.md', output='test.html', encoding='UTF-8') 其中调用knit()函数会把.Rmd文件转换为.md文件， 调用markdownToHTML()函数会把.md函数转化为.html文件， 产生的HTML文件带有图形、支持数学公式。 在R中可以用如下命令把.md文件转化为MS Word docx格式: 1system('pandoc -o test.docx test.md') 这里用system()命令从R内部调用了Pandoc.exe可执行程序。 需要把Pandoc.exe的位置加入的操作系统的Path环境变量中。 1234567---title: ''output: word_document: default pdf_document: default html_document: default--- 文本样式1234567891011121314151617181920212223242526链接: 图片： ![Title](URL) ：本地或网络链接均可 网址： http://example.com [RMarkdown初试](http://example.com)加粗:**Bold**或--Bold-- 斜体字:*Italics*或--Italics-- 删除线:~~text~~ 段落: 段落之间空一行 换行符: 一行结束时输入两个以上空格 列表: 无序列表： * Item 1 * Item 2 + Item 2a + Item 2b 有序列表： 1. Item 1 2. Item 2 3. Item 3 + Item 3a + Item 3b 引用:&gt; 引用内容画水平线或分页:三个'-'以上,如:--- 上标：a^2^ 下标：a~1~ 公式12##行内公式： $公式$ ##行间公式： $$公式$$ 在R Markdown文件中插入R代码插入的R代码分为行内代码与代码块。 行内代码的结果插入到一个段落中间， 代码以`r开头，以` 结尾， 如sin(pi/2)在结果中会显示为1。 代码块则把结果当作单独的段落， 按照Markdown格式的规定， 代码块的前后需要有空行， 但是R Markdown实际上放松了这个要求， 允许前后不空行。 R代码段以单独的一行开头， 此行以三个反单撇号开始， 然后是{r}。 代码段以占据单独一行的三个反单撇号结尾。 如 1234​```&#123;r&#125;1:5sum(1:5)​ 12345结果将变成```r1:5 1## [1] 1 2 3 4 5 1sum(1:5) 1## [1] 15 可以看出，代码段程序会被插入到最终结果中， 代码段的文本型输出会插入到程序的后面。 代码块也可以嵌入到引用、列表等环境中。 代码块中作的图将自动插入到当前位置。 下面的程序： 1234​```&#123;r&#125; plot(1:10) hist(rnorm(1000)) ​ 12345结果将显示为:```rplot(1:10) 1hist(rnorm(1000)) 为了将这样的R代码段包括首尾标志原样显示， 需要将代码段整体地缩进4个空格， 并在开始的三个反单撇号前面加上r‘’``， 即生成一个空字符串的行内R代码， 原来的三个反单撇号的标志变成了 1r`''` 1234567891011121314151617181920212223242526272829303132333435363738394041在RStudio中， 可以用**Insert快捷图标**插入代码段， 还可以用**Ctrl+Alt+I快捷键插入代码段**。&lt;br&gt;## 输出表格knitr包提供了一个 `kable()` 函数可以用来把数据框或矩阵转化成有格式的表格， 支持HTML、docx、LaTeX等格式。- **knitr::kable(x, format)**：&gt;format = c(&quot;latex&quot;, &quot;html&quot;, &quot;markdown&quot;, &quot;pandoc&quot;, &quot;rst&quot;) ；一般会自动进行调整&gt;&gt;digits = 最大的有效位数（对于数字列）；也可以用一个向量，长度为`ncol(x)` 为单独的列设置有效位数&gt;&gt;&gt; digits=2 (同一设置有效位数为2)&gt;&gt;&gt;&gt; digits=c(1,1,1,2,2) ；表示共有5列，为每一列指定&gt;&gt;row.names = T/F &gt;&gt;col.names =c(&quot;&quot;)； 一个字符串向量用来指定列&gt;&gt;align = c(&quot;&quot;) ；对齐方式；默认时文字左对齐，数字右对齐；若align=NULL，则按照默认来对齐；&gt;&gt;&gt; l = left ; r = right ; c = center; &gt;&gt;&gt;&gt; **当 lenght(align)==1L，字符串会被解释为每个列设置方式的向量； 例如 &quot;clc&quot; 会被解释为c(‘c&apos;, &apos;l&apos;, &apos;c&apos;)**&gt;&gt;caption =&quot;&quot; ；标题&gt;&gt;format.args =list() 一个列表list形式的参数传递给format函数&gt;&gt;&gt; ```r&gt;&gt; # format numbers using , as decimal point, and &apos; as thousands separator&gt;&gt; x = as.data.frame(matrix(rnorm(60, 1e+06, 10000), 10))&gt;&gt; kable(x, format.args = list(decimal.mark = &quot;,&quot;, big.mark = &quot;&apos;&quot;))&gt;&gt; [1] &quot;| V1| V2| V3| V4| V5| V6|&quot;&gt;&gt; [2] &quot;|-----------:|-----------:|-----------:|-----------:|-----------:|-----------:|&quot;&gt;&gt; [3] &quot;| 997&apos;476,8| 995&apos;812,9| 994&apos;992,8| 1&apos;000&apos;122,4| 981&apos;053,9| 988&apos;843,5|&quot;&gt;&gt; &gt; format函数 ： trim = F/ T; 若为FALSE，进行右对齐； digits= NULL；表示有效位数 justify = c(“left”, “right”, “center”, “none”) width= NULL na.encode = TRUE scientific = NA ；科学计数法 big.mark = “” ； 千分位分隔符 big.interval= 3L small.mark=”” ；小数中的分隔符 small.interval=5L decimal.mark=”” ；小数与整数的分隔符 zero.print=NULL 123&gt;&gt; kable(c(1.23241415), format.args = list(small.mark = ","))&gt;&gt; | 1.23241,4|&gt;&gt; &gt; longtable = T/F 例如，计算线性回归后， summary()函数的输出中有coefficients一项，是一个矩阵， 如果直接文本显示比较难看： 123x &lt;- 1:10; y &lt;- x^2; lmr &lt;- lm(y ~ x)co &lt;- summary(lmr)$coefficientsprint(co) 123## Estimate Std. Error t value Pr(&gt;|t|)## (Intercept) -22 5.5497748 -3.964125 4.152962e-03## x 11 0.8944272 12.298374 1.777539e-06 可以用knitr包的kable函数来显示: 1knitr::kable(co) Estimate Std. Error t value Pr(&gt;\ t\ ) (Intercept) -22 5.5497748 -3.964125 0.0041530 x 11 0.8944272 12.298374 0.0000018 R扩展包xtable提供了一个xtable()函数， 也可以用来生成HTML格式和LaTeX格式的表格， 但是需要指定要输出的格式。 xtable对比较多的R数据类型和输出类型提供了表格式显示功能， 包括矩阵、数据框、回归分析结果、方差分析结果、主成分分析结果、 若干分析结果的summary结果等。 例如，上面的回归结果用xtable()函数显示如: 1print(xtable::xtable(lmr), type='html') Estimate Std. Error t value Pr(&gt;\ t\ ) (Intercept) -22.0000 5.5498 -3.96 0.0042 x 11.0000 0.8944 12.30 0.0000 这个代码段用了选项results=&#39;asis&#39;， 因为xtable生成的是直接用来插入到结果中的html代码。 注意这里指定了输出为HTML类型。 如果将本文件转化为docx, xtable的结果不可用。 格式转换其他方式： scales包的函数：在传入kable之前进行修改 comma() ：在千、百万、十亿等位置向数字添加逗号 dollar()：添加一个美元符号并舍入到最近接的美分 percent()：乘以100，舍入到最接近的整数值，并添加一个百分号 scientific()：对大数字和小数字给出科学计数法都表示， 如3.30e+05 12345within(head(mtcars),&#123; wt &lt;- round(wt, 2) # 小数为2位 percent() # 百分次 comma() # 千分位符&#125;) 图形选项 fig.path: (‘figure/’; 字符)：图片路径，支持前缀模式(‘figure/prefix-’)fig.keep: (‘high’; 字符)：保存图形类型，高级图形(‘high’)、不保存(‘none’)、所有图形(‘all’)、第一张(‘first’)、最后一张(‘last’)fig.show: (‘asis’; 字符)：展示方式，紧随代码输出(‘asis’)、最后统一输出(‘hold’)、动画输出(‘animate’)dev: (LaTeX 为’pdf’, HTML/markdown 为’png’; 字符)：输出设备，knitr 支持很多种设备fig.width, fig.height: (7; 数值)：图片文件的宽、高(英寸2.54cm 为单位)out.width, out.height: (NULL; 字符)：图片在输出文档中的宽、高fig.align: (‘default’; 字符)：对齐方式，不做调节(‘default’)、左(‘left’)、右(‘right’)、居中(‘center’)interval: (1; 数值)：动画参数，切换画面时间，单位为秒 图形大小 - fig.width/height 用fig.width=指定生成的图形的宽度， 用fig.height=指定生成的图形的高度， 单位是英寸（1英寸等于2.54厘米）。 两者默认为7 (英寸) fig.width =10 ；刚好扩展到全部宽度 可在最初的knitr::opts_chunk$set(echo = FALSE, fig.width = 10) 中设置 下面给出一个长宽都是10厘米的图例。 1234​```&#123;r fig.width=10/2.54, fig.height=10/2.54&#125;curve(exp(-0.1*x)*sin(x), 0, 4*pi)abline(h=0, lty=3)​ 123456结果为:```rcurve(exp(-0.1*x)*sin(x), 0, 4*pi)abline(h=0, lty=3) fig.width=和fig.height=规定的是生成的图形大小， 实际生成图形的显示大小会受到dpi（分辨率）影响， 默认dpi是72（每英寸72个点）， 也可以用dpi=选择分辨率。 转化后的HTML文件显示时不一定按原始大小显示。 用out.width=和out.height=可以指定显示大小， 但是可以是最终文件格式承认的单位， 比如HTML的图形大小单位是点（平常说屏幕分辨率的单位）。 例如在上面的例子中加上输出长宽都是600点的选项： 1234​```&#123;r fig.width=10/2.54, fig.height=10/2.54, out.width=600, out.height=600&#125;curve(exp(-0.1*x)*sin(x), 0, 4*pi)abline(h=0, lty=3)​ 123456注意所有选项都要写在一行中，不能换行。 结果为:```rcurve(exp(-0.1*x)*sin(x), 0, 4*pi)abline(h=0, lty=3) 在knitr的LaTeX版本（扩展名为.Rnw）中， 连续两个图形如果指定的宽度加起来比行宽窄会自动并排显示， R的bookdown扩展包提供了R Markdown格式的扩展， 其中的图形可以变成浮动图， 而且很容易并列放置。 图形结果选择用fig.keep=选项可以选择保留哪些R代码生成的图。 缺省是fig.keep=&#39;high&#39;, 即保留每个高级图形函数的结果图形， 低级图形函数对高级图形函数的更改不单独保存而汇总到高级图形函数结果中。 如 123par(mar = c(3, 3, 0.1, 0.1))plot(1:10, ann = FALSE, las = 1)text(5, 9, "Testing low level graphics") 其中text()函数的结果与高级图形函数plot()的结果一起显示。 fig.keep还可以取：all, 会把低级图形函数修改后的结果单独保存； last, 仅保留最后一个图形；first, 仅保留第一个图； none, 所有图都不显示出来。 代码段选项独立代码段以三个反向单撇号和{r}开头， 在大括号内还可以写一些选项， 选项与开始的r用空格分隔， 选项之间用逗号分隔, 所有选项写在同一行内。 选项都使用“选项名=选项值”的格式， 选项值除了使用常量外也可以使用全局变量名或表达式。 在大括号内除了开头的 r 写一个不是选项名的名字， 就作为代码段的标签。 如 12345678​```&#123;r firstCode&#125; cat('This is 第一段, 有标签.\n') ​``` # 只显示结果，不显示代码​```&#123;r echo=FALSE&#125; 1:5​ 123456&lt;br&gt;### 代码和文本输出结果格式R代码块和R代码块的运行结果通常是代码块原样输出， 运行结果用井号保护起来， 这样有利于从文章中复制粘贴代码。 如： ​1234s &lt;- 0for(x in 1:5) s &lt;- s + x^xs​ 12结果为: s &lt;- 0for(x in 1:5) s &lt;- s + x^xs12 [1] 341312345678910111213#### highlight选项转化后的R代码块缺省显示为彩色加亮形式。 用选项`highlight=FALSE`关闭彩色加亮功能。#### prompt和comment选项如果希望代码用R的大于号**提示符开始**， 用选项`prompt=TRUE`。 如果希望结果不用井号保护， 使用选项`comment=&apos;&apos;`。 例如：```r​```&#123;r prompt=TRUE, comment=&apos;&apos;&#125;sum(1:5)​ 12345结果为:```r&gt; sum(1:5) 1[1] 15 echo选项 - 代码显示echo = TRUE - 同时显示代码块 + 结果 echo = FALSE - 不显示代码块，但显示结果 如果希望不显示代码， 加选项。 如 123​```&#123;r echo=FALSE&#125;print(1:5)​ 12345结果为:```r## [1] 1 2 3 4 5 eval - 仅显示加选项eval=FALSE, 可以使得代码仅显示而不实际运行。 这样的代码段如果有名字， 可以在后续代码段中被引用。 include - 仅运行加选项include=FALSE， 则本代码段仅运行， 但是代码和结果都不写入到生成的文档中。 tidy选项加选项tidy=TRUE可以自动重新排列代码段， 使得代码段格式更符合规范。例如： 1234​```&#123;r tidy=TRUE&#125;s &lt;- 0for(x in 1:5) &#123;s &lt;- s + x^x; print(s)&#125;​ 123456789结果为:```rs &lt;- 0for (x in 1:5) &#123; s &lt;- s + x^x print(s)&#125; 12345## [1] 1## [1] 5## [1] 32## [1] 288## [1] 3413 child选项加选项child=&#39;文件名.Rmd&#39;可以调入另一个.Rmd文件的内容。 如果有多个.Rmd文件依赖于相同的代码，可以用这样的方法。 collapse选项 - 文本块输出一个代码块的代码、输出通常被分解为多个原样文本块中， 如果一个代码块希望所有的代码、输出都写到同一个原样文本块中， 加选项collapse=TRUE。 例如， 没有这个选项时： 1234​```&#123;r&#125;sin(pi/2)cos(pi/2)​ 12345结果为：```rsin(pi/2) 1## [1] 1 1cos(pi/2) 1## [1] 6.123032e-17 代码和结果被分成了4个原样文本块。 加上collapse=TRUE后，结果为： 1234sin(pi/2)## [1] 1cos(pi/2)## [1] 6.123032e-17 代码和结果都在一个原样文本块中。 results选项 - 文本结果类型用选项results=选择文本型结果的类型。 取值有： markup, 这是缺省选项， 会把文本型结果变成HTML的原样文本格式。 hide, 运行了代码后不显示运行结果。 hold, 一个代码块所有的代码都显示完， 才显示所有的结果。 asis, 文本型输出直接进入到HTML文件中， 这需要R代码直接生成HTML标签， knitr包的kable()函数可以把数据框转换为HTML代码的表格。 例如：results=&#39;hold&#39;的示例: 1234​```&#123;r collapse=TRUE, results='hold'&#125;sin(pi/2)cos(pi/2)​ 12345678结果为:```rsin(pi/2)cos(pi/2)## [1] 1## [1] 6.123032e-17 缓存(cache)选项当R Markdown文章比较长，包含的R代码比较多， 或者代码段运行需要比较长时间时， 反复编译整篇文章会造成不必要的计算， 因为有些代码段并没有修改， 依赖的数据也没有改变。 knitr提供了缓存功能， 代码段选项cache=TRUE对代码段打开缓存， 允许暂存上次运行的结果（包括文本结果和图形） 而不需要重复运行代码段。 当代码段被修改时， 缓存被放弃， 编译时重新运行代码段。 缓存这种功能需要慎重使用， 免得错误地使用了旧的结果。 当后面的代码段需要使用前面代码段结果时， 如果前面结果改了， 后面的代码段就不能使用缓存的结果而必须重新计算。 为此， 在后面的代码段中应该加上dependson=选项， 比如dependson=c(&#39;codeA&#39;, &#39;codeB&#39;)， 其中codeA和codeB是前面的代码段的标签， 其结果会用在本代码段中。 也可以使用代码段选项autodep=TRUE， knitr试图自动确定前后代码段之间的依赖关系， 每当前面的代码段改变时， 后面的用到其结果代码段也自动重新计算而不使用缓存的旧结果。 建议仅对计算一次需要较长时间的代码段使用缓存功能， 后面依赖于其结果的代码一定要加上dependson=选项。 输出格式设置在R Markdown格式的文件开头， 可以有用两个仅由三个减号组成的行包围的元数据段， 其中使用YAML格式， 使用冒号表示属性名与属性值， 用缩进表示属性值。 属性中， output选择输出的格式， 如html_document是HTML输出， pdf_document是PDF输出， word_document是docx格式的Word文件输出， 等等。 在每种输出格式后面还可以继续添加该输出特有属性。 如： 12345output: html_document: toc: yes word_document: toc: yes 上例中，output属性的值是两项， 两项用缩进表示； html_document又有自己的属性toc， 属性值yes表示要自动生成可点击的目录。 设置某种输出格式的属性nuber_sections为yes可以自动对章节编号。 章节目录链接对于英文文件， R Markdown基于的pandoc软件可以自动从标题生成适当的链接标签， 对于中文文件的支持差一些， 所以中文文件要自动生成可点击的目录， 需要在每个标题行的末尾，空格后添加{ #label}， 其中label是自己指定的标签内容， 但是建议仅使用英文字母、数字、减号。 如 1### 第三章第一节标题 &#123;#c3-s1-int&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《练习的心态》读书笔记_托马斯.M.斯特纳]]></title>
      <url>%2F2017%2F08%2F23%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F40_%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F%E3%80%8A%E7%BB%83%E4%B9%A0%E7%9A%84%E5%BF%83%E6%80%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%89%98%E9%A9%AC%E6%96%AFM.%E6%96%AF%E7%89%B9%E7%BA%B3%2F</url>
      <content type="text"><![CDATA[《练习的心态》 - 托马斯 M. 斯特纳 Thomas M. Sterner 你不可能改变你不知道的东西； 给每个场景设定 “触发警示信号” 的场景；即当做XX的时候，出现XX情况的时候，触发警示信号，让自己去思考应该有的行为； 如果你知道自己正在做的任何事情，意味着涉及两个存在： 一个是正在做某件事情的那个你 ； ——这个是你的自我或个性 一个是正在了解或观察你做那件事的那个你 —— 观察者 你越是与静静的观察者更加密切地保持一致，你的主观判断便会越少；你开始真正地用一种客观的视角来观察你的内心独白 你不可能控制你甚至不知道的东西。意识一定是第一位的； 缺乏自我控制，不论你想实现什么样的目标，你都不会有真正的力量；如果你不知道自己每时每刻都在想些什么，那你便没有拉紧思维的缰绳，对自己前进的目标便没有了掌控的能力。 如果我们不将日常的思考过程分隔开来，便不能能优化那些过程中的任何一部分 当我们说某一件事是一个习惯时，就是说这是我们做某件事情的一种自然方式。我们从直觉上来做事，根本不必去想它。 在较短的时间内，有意识地反复做某件事，将使你培养新习惯； 通过 “扣动扳机” 的方法 来阻止旧习惯的势头； 给自己的每个场景设定触发警示信号的行为；当做XX的时候，跳出XX的想法； 所谓扳机，指的是一种帮助我们启动新习惯养成过程的设备；它类似于一声哨响或者一声钟鸣，当你恰好处在想用原来的方式行动时，向你发出警示信号； 扳机的功能时阻止你在某种局面下产生的情绪响应，并且将你带入当前这一刻，带入一种客观的姿态，以便你能控制自己的行为； 想象练习是很有效的一种方法； 在训练过程中，飞行教练把油门关死（通常情况下你是没有料到是因为你他将油门关死了）并且说：”动力没有了，你打算怎么做？“ 你打算做的事情，就是教练教你的程序，成为你自然而然的习惯的那些程序。 一位飞行教练曾告诉我，希望我每次登上飞机，首先思考一下 ”失去动力“ 的紧急情况的应对程序；她还教我，每次下飞机之前，也要再思考一遍； 我们对理想和完美的概念总是不断变化的。我们自己认为好的或坏的东西，不会一成不变； 如果你知道自己正在做的任何事情，意味着涉及两个存在： 一个是正在做某件事情的那个你 ； ——这个是你的自我或个性 一个是正在了解或观察你做那件事的那个你 —— 观察者 你越是与静静的观察者更加密切地保持一致，你的主观判断便会越少；你开始真正地用一种客观的视角来观察你的内心独白 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《信任论》读书笔记_郑也夫]]></title>
      <url>%2F2017%2F08%2F20%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F20_%E7%A4%BE%E4%BC%9A%E8%AE%A4%E7%9F%A5%2F%E3%80%8A%E4%BF%A1%E4%BB%BB%E8%AE%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%83%91%E4%B9%9F%E5%A4%AB%2F</url>
      <content type="text"><![CDATA[《信任论》_郑也夫 ；写于1999年 作者首先从定义上去解释 “信任”；接着描述信任的表现形式： “利他” ，然后进一步解释 “利他” (信任)产生与形成的原因、发展历程； (1) 人性 - 利己； 规范 - 利他；(2) 文化力量的加入 + 漫长的幼儿成长期 + 模仿；使得利他得以持续 信任始于亲族中，产生于领地上； 之后作者解释信任的重要功能：简化思想；并接着讨论它的社会功能、不同环境中的表现差异 最后单独讨论了两种信任系统：货币系统、专家系统； 货币系统的最终逻辑：市场社会；专家系统的最终逻辑：社会学历 两者共同开辟了陌生人的天地 信任的两种结构：人格信任、系统信任； 人格信任：对某个具体人物的信任，包括亲族、领地、同乡会的信任 系统信任：对匿名人组成的制度系统的信任 信任的特性：(1) 时间差与不对称性；(2) 不确定性； (3) 属于主观的意识 诺言与兑现之间存在无法跨越的时间差；承诺人与选择相信的人在信息上有着无法跨越的不对称性 未来本身有着不确定性 “三军可以夺帅，匹夫不可夺志。”对一些事，自己心中必须要有自己的态度，在事物的两极之间，否能坚定自己的意志。但这也取决于首先你对这件事情要有先验知觉。 均衡从来不是源于自我约束，而是靠着其他力量对某一势力的无限扩张的抵抗。 若要取得平衡，或者推动事物的发展，都可以从其他力量会采取的行动来进行思考，以此来促进均和或者推动行为的落地； 每个人、群体、民族、语言、想法都会在一定程度上的自我膨胀，这是生命体及其承载的一切事物的本性。 权利不可能自我约束的，对它的有效约束只能来自其他力量。 “合作的基础不是真正的信任，而是关系的持续性” 。在持续关系与合作之间还有一个环节——信任。即持续关系产生信任，信任导致了合作。 持续关系（即多次博弈）是合作，乃至一切复杂关系的基础 人类行为的动因：个人物质利益（个人取向） + 追求承认（他人与群体取向） 领地是产生和发展复杂而稳定社会关系的重要因素； 认识到基本上所有的制度都是简化复杂的机制； 语言、金钱、权利、权威、标签、声誉、考核、分数 信任（简化机制），是凭借过去进行简化的； 信任增加了不确定性的宽容，从而增加了人们行动的勇气和可能性 货币是一种媒介，而信任是这一媒介中的关键。 货币通过数量差别取代质量差异，抹去了任何事物的特殊性，以自己的度量为一切事物完成了换算；凭借着这种 “变质为量” 的本领，货币获得了一种其他事物都不具备的渗透力； 学历社会带来的不是 “机会的平等”，而是 “游戏规则的平等” ；这才是科举与现代教育制度的贡献；人类更热爱的是差异的刺激。平等并不是人们真正的目标，平等不过是反对成员间地位差距过大的策略和说辞；文明的进步其实只是努力保障失败者或位卑者的尊严 第一章 信任：溯源与定义 信任，名词；表达静态的属性，即可信任的；信任，动词，出发点是主体，即判断对方有信用与否 信任关系具有的性质： 时间差与不对称性。行动和兑现较之诺言和约定必然是滞后的。承诺与兑现之间存在着时间差，信任者与被信任者之间存在某种不对称性 不确定性。具备了确定性，就不存在风险与应对风险的这一特定方式了。 因为没有足够的客观依据，信任属于主观的倾向和愿望。 第二章 人的本性 描述了三种 “利他” 的类型 自然选择是这样进行的：某一种群内的成员们身上带有可遗传的不同变异特征，当选择压力出现的时候，种群内那些拥有有利于存活和繁殖的特征的个体的百分比将增长。 基因像程序一样决定了它的携带者的行为方式，并靠着急眼的传递和遗传的稳定性，将这一行为特征传递给下一代。 假设一个群体中有一些带有无条件利他基因的个体，利他行为会使得这些个体牺牲或减少自身生存和繁殖的机会，最后将直至消亡 但实际是仍然存在利他的行为 围绕利他行为存在的原因，有着三种解释：亲族选择、互惠、群体选择 亲族选择：即发生在亲族间的利他行为的自然选择作用 不求回报 如果他的利他行为减少了自己生存和繁衍的机会，但增加了他的同胞得到繁衍，那这种利他行为可以使得它们共同基因的增加，并因为这种基因的传递而使得亲族内的利他行为得以持续 互惠的利他行为：互惠性利他可能在长期交往过程中建立； 要求回报 实例：某只吸血蝙蝠没有吸到血又非常饥饿时，吸到血的蝙蝠会吐给它一点血，靠着互助，蝙蝠们克服了个体不时遇到的捕食失败 很多哺乳动物间互相舔毛，以清洁皮肤 群体选择利他：具有利他性的群体，因为内部的合作而比利己的种群获得更大的生物学上的利益，并因此更有肯能在竞争中生存和繁衍 要保持非血缘群体内部的利他性能够占据上风，需要引入另外一支力量：文化； 规范，是人们制定和共同遵守的行为准则。规范的主要内容：习俗 和 道德； 文化 与 本能的对峙； 道德的使命在于造就一种广泛的利他； 对于本性，人是利己的；归根到底是自私的行为倾向在我们的行为心态的遗传组成中占绝对优势。在人类以前的时代，自私行为是被自然选择极力选中的； 从自然选择（适者生存）的角度阐明了利己存在且不可否认的原因； 文化能在一定程度上重塑基因，并为人类设定行为模式，主要在于： “幼态持续” 为人类提供了独一无二的条件：漫长的幼年成长期 模仿，是这一过程中最重要的手段和力量 生物的复制功能是垂直进行的：以繁衍的形式传递给下一代 文化的复制功能不仅是垂直而且水平：可以在同代人之间复制 第三章 合作的进化 通过 “建立信用” 的方式来克服互惠行为的前提（多次合作） 互惠理论的前提：多次博弈；即 “关系的持续性” （囚徒困境：一次性博弈） “一报还一报” 的策略可以在一个由多种策略构成的多样性环境中获得成功； 首先保持善意对待每一个人 然后根据对方的行为，采取相同的措施 互惠的特点是以重复相遇为前提（即关系的持续性），相反在一次性遭遇时每每背叛；改善的一个办法是重视和建立信用。； 当”好合作、高质量” 的声誉建立和传播时，与你没有联系过的人也增加了对你的信任，与你合作的可能 “合作的基础不是真正的信任，而是关系的持续性” ，这是艾克斯罗德 强调的前提因素。但在持续关系与合作之间还有一个环节——信任。即持续关系产生信任，信任导致了合作。 第四章 理性与习俗 每个人、群体、民族、语言、想法都会在一定程度上的自我膨胀，这是生命体及其承载的一切事物的本性。均衡从来不是源于自我约束，而是靠着其他力量对某一势力的无限扩张的抵抗。 理性：是逻辑指引下的思考，它可以更广义地定义为问题的解决和批判的思考，但只有在强调了逻辑成分时，它才成其为有价值单独讨论的特定的思想方法。无理论知觉、想象、试错法这类活动有着怎样出色的成果，是被排除在理性之外的。——《国际社会科学百科全书》（1968） 人类行为的动因：个人物质利益 + 追求承认 个人物质利益：追求个人的物质享乐；个人取向的； 追求承认：个人的心力满足；他人和群体取向的； 信任不是理性；信任处在全知与无知之间。信任处在理性与非理性之间； 第五章 领地、亲族和共同体 领地：指同物种之间划分出的排外性的势力范围； 领地的重要性：(1)生存需要一定的空间；(2) 这个空间需要稳定的环境；对空间与稳定性的共同需求，导致了对领地的需求 领地提供了稳定的食物资源 领地提供了与配偶交配的场所 领地也是养育幼儿的场所 以领地为基础的社会结构在进化中有很大的优势：可望产生和发展复杂而稳定的社会关系； 领地为成员带来了识别性（外部 + 内部）；识别性是持续关系的基础，而持续关系（即多次博弈）是合作，乃至一切复杂关系的基础 人类很多的本领和规范是靠模仿，而不是单独个体的 “试错” 得到的；领地是模仿的必要条件 当一个领地中物种数量膨胀时，领地中的部分成员会一同移动到其他地域，建立新的领地；这促进了更大范围上的模仿，进而促使了文化的传播和交流 保卫不是领地行为的必要内容，排他才是关键；并且在漫长的进化过程中，灵长目动物基本上选择了回避，放弃了侵略。在面对领地冲突时，更多的是表现为仪式化的战斗，而不是生死的决斗； 边界帮助群体获得其有限性，领地提供了持续的关系，使成员们在其中相互识别，频发交往，进而获得信任，开始合作； 封建、帝国与资本是人类最伟大的三项制度创作。 封建制，帮助人类从血缘走向地缘 帝国，在相当程度上继承了封建制的遗产 资本，帮助人类超越天然的标志，从熟悉的人格关系走向陌生的非人格关系 第六章 信任对复杂的简化 “最优理论” vs. “满意理论” ；生物有足够的本领进行”寻求满意” 的适应，但他们并不 “寻求最优” 语言、金钱、权利、权威、标签、声誉、考核、分数，都是简化复杂的机制； 信任靠着超越可以得到的信息，概括出一中欧冠行为期待，以内心保证的安全感代替信息匮乏； 信任强化现有的认知，简化复杂的能力；强化与复杂的未来相对应的现在的状态 信任增加了不确定性的宽容，从而增加了人们行动的勇气和可能性 靠着简化复杂，信任打开了行动的可能性，没有信任这个行动是不可能和无吸引力的；因为只有在行动之后，可能的成果才会显现。信任为时间问题架了桥，它为成果做了预付； 信任（简化机制），凭借过去进行简化； 过去是确定和不变的；现在是有限和迟疑的；未来是复杂和未知的； 现在靠着与过去的联手，超越未来的不确定性在他们心理上造成的疑惑 第七章 信任与社会秩序 社会秩序的三个来源：强制、互惠、习俗 强制不需要互惠与习俗的帮助，独立就可以造就一种秩序；而互惠与习俗必须依靠国家机器的帮助，才能建议一种社会秩序； 国家机器对外承担着保卫国家领土主权的责任，对内要为经济与社会生活提供一般性的条件（法律、货币、社会福利等）；这些与社会秩序直接或间接相关的功能，都是国家之外的力量难于承担的； 群体间贸易的发明代表了进化中非常稀少的时刻，人类获得了超越动物的比较生态的优势；动物有群体内的分工，但没有一种动物利用了群体间的比较利益； 权利不可能自我约束的，对它的有效约束只能来自其他力量。在民主国家，并非国家机器不想扩张其权力，而是受到了全面的制约——司法、经济、新闻和公民一起抵制国家权力对它们领地的侵犯和干预； 第八章 早期城市化与民间社团 农村是熟人的社会；城市是陌生人的社会； 不同地域表现出来的不同形式：西方的行会；中国的同乡会； 第九章 秘密社会 例如：黑手党、青帮 秘密社会：与主流价值观对立，但不反政府；只寻求一个与主流文化不同的子系统，且这系统是隐蔽的； 秘密社会生存在征服管辖的大系统中，不逃脱在其之外，而是在其内建立自己的与主流价值观对立的小系统，在对立的同时谋求尊严并努力披上合法的外衣 在国家为社会提供充分的服务时，不存在黑社会，因为没有必要；在国家极度衰弱时，自救团体无非法可言，即使使用暴力。只有在两者共存时，才有了秘密社会，或曰 “黑社会” 的称谓；秘密社会产生于权力控制与满足社会需求的双重真空； 这也是辩证的看问题；从一个事物的对立面来看问题； 现象：黑手党对社会富有一定责任，维护一定的社会秩序； 据说在西西里，发生偷到时，如向警方报告，75%是无所作为，15%能找到最烦，只有10%能追回赃物； 若向黑手党调节，只有5%未获成功； 当然被盗人要拿出财产的 1/4 ~ 1/3供调解人 秘密社会中的信任程度高于主流社会，因此才能比社会大系统更强悍；子系统中的信任靠着4个因素来建立与强化 (1) 互利；内部的互利性必然要高于社会大系统；(2) 运行的效率要高于大社会人的保护效率；(3) 对背叛的惩罚极其严厉； (4)靠着仪式、传统、认同和惩罚，将一种特殊的价值系统内化在成员的心中 社会大系统的健全：正当需求可以得到满足，正义可以得到伸张；从这个意义上来说，亚文化是主流文化的某种指标，是主流社会的晴雨表； 第十章 货币与信任 货币是一种媒介，而信任是这一媒介中的关键。一旦失去信任，货币将失效；eg：当爆发战争的时候，若无法判断这一国家是否战败，此时对本国货币失去了信任，会大量购买他国货币/物品；因为一旦国家战败，它的货币是没有任何意义的；因为失去了信任，没有人会愿意为它支付物品； 货币的简化功能几乎是所有媒介中最出色的。货币通过数量差别取代质量差异，抹去了任何事物的特殊性，以自己的度量为一切事物完成了换算；凭借着这种 “变质为量” 的本领，货币获得了一种其他事物都不具备的渗透力； 货币为人们带来了自由；这种自由首先是货币占有者消费机会与可能性上的自由； 庄园领主过去可以向农奴征收一定数量的啤酒、家禽，从而将后者的行为限定在一定的范围内；但是，当他征收货币的那一刻起，农民的自由了。他们可以自己决定是养蜂、养牛，还是做其他的事情； 信任与借贷；借贷必须建立在信任的基础之上；这种信任的判断可以是任何事物：主观信任，其他简化机制的表现 抵押贷款，与信任无关；抵押消除了风险与不确定性，完全不需要借助信任。 一种反文明的观念：利息与有息借贷都是可恶的； 货币中的风险：货币自身、折射在货币上的社会病症、资本流动的 “马太效应” 货币自身：现代货币是人造物，在其数量上不受控制； 折射在货币上的社会病症：伪造货币者与政府；后者可能不正当地印制货币； 马太效应：当私人资本得以自由地越境流动以寻求最佳投资机会时，它们可能被导向依据国际标准最具生产率的领域； 马太福音中的寓言故事： 《新约·马太福音》中有这样一个故事。一个国王远行前，交给三个仆人每人一锭银子，吩咐他们：“你们去做生意，等我回来时，再来见我。”国王回来时，第一个仆人说：“主人，你交给我的一锭银子，我已赚了10锭。”于是国王奖励了他10座城邑。第二个仆人报告说：“主人，你给我的一锭银子，我已赚了5锭。”于是国王便奖励了他5座城邑。第三个仆人报告说：“主人，你给我的一锭银子，我一直包在手巾里存着，我怕丢失，一直没有拿出来。”于是,国王命令将第三个仆人的那锭银子赏给第一个仆人，并且说：“凡是少的，就连他所有的，也要夺过来。凡是多的，还要给他，叫他多多益善。” 第十一章 科举与学历（专家系统一） 科学决定了专家系统的性质。因为科学获得了大众的信任，所以在科学上学有专长的人是值得信任的；学历是此种信任的社会来源，是学有所长、高于常人的证据。同行评议是对每个专家的更准确和权威的评价，并往往以此决定他在这一系统中的地位。科学、学历、同行评议，三位一体，构成了专家系统的信任基础； 人类历史上有两种方式取代封建，建立开放的等级制：(1) 靠市场和货币；(2) 靠科举和文凭； 市场经济的社会中，货币占有的多寡很大程度上决定了人们的社会地位 以科举功名为人们的社会等级定位的机制 考试内容与效度；因为科举的目的是为了评判不同的水平，因此在考试内容上必然是有所倾向的； 八股文的题目出自四书（《大学》、《中庸》、《论语》、《孟子》），八股文在内容上要求 “代圣贤立言”，不允许表达个人的见解；然而从实质上看，考生们角逐的仍然是写作美文的技巧； 我们必须认识到，不是八股文败坏了科举，而是科举创造了八股文。这一悲剧的本质在于考试学的两难：有用的东西未必适合考试，适合考试的东西未必有用。在找不到适宜考试有用的知识时，考试会选择无用但能够评判的技巧； 科举制的建立视为了制约上下层人口比例的失调，但它的功能也仅仅是减缓社会生态失调的速度；当一个制度越来越多成为统计阶级成员晋升的障碍时，它必然会遭到统治阶级的破坏； 人口的增长必然导致考生数量的增加。在落第的比例本来已经越来越大的考生总数中，官宦子弟所占的比例也越来越高。他们最不愿忍受失败，又最有能力和社会关系去破坏规则；（舞弊、买卖官位） 社会生态学，即社会上层人口与下层人口的比例。 关于定额制（配额制），即在录取或录用时为不同的社会群体规定不同的额度； 宋朝司马光 “分路取人”（每十人取一人） Vs. 欧阳修”凭才取人”（唯才是举） 有一年某个考官主持下的北方考生全部落榜，惹起轩然大波，最后被处死 最后设立 “分地而取” 的方针；会式分南、北、中卷；每百名进士中，南取55人，北取35人，中取10人 在现代美国社会，也存在定额制 定额制照顾了弱势群体。在近现代的世界中，它总是与社会公正结合在一起；只有中国当代高考中的定额制是反其道而行，它公然照顾强势群体——大城市中的考生； 学历社会带来的不是 “机会的平等”，而是 “游戏规则的平等” ；这才是科举与现代教育制度的贡献；人类更热爱的是差异的刺激。平等并不是人们真正的目标，平等不过是反对成员间地位差距过大的策略和说辞；文明的进步其实只是努力保障失败者或位卑者的尊严 学历只是某些领域的入场券，”它只说明了最低限度的成就”，高限的成就要通过专家系统中同行的认可才能获得； 第十二章 同行评议与科学（专家系统二） 学历只是进入专家系统或科学共同体的必要条件之一；进入该系统后的学术地位取决于同行的评议； 政治的要害问题是产生领袖。在选民的眼中，竞争者的主要差异不是解决同一问题的理性能力高下，而是优先解决哪些问题的价值观上的区别； “提出一个问题比解决一个问题更重要，因为解决问题也许仅是数学上或实验上的技巧而已；而提出新的问题、新的理论，从新的角度去看旧的问题，却需要有创造性的想象力，而且标志着科学的进步。”——爱因斯坦 第十三章 走向杀熟之路 杀熟，指的是欺诈熟人 生物的世界中存在着两种竞争：种群之间的竞争、种群之内的竞争 种群之内的竞争更加残酷，因为同类间争夺的是同种资源（物质资源、异性资源）； 所有的社会动物都是 “社会地位的追求者”。两个动物在阶级次序中越接近，紧张度就越高； 异类间的竞争有时会转化为同类间的竞争，而同类间的竞争却很难转化为异类竞争 同类件的攻击是对环境的拥挤做出的反映，它会导致物种生存上的合理分布。但攻击需要适度，而非致命性的； 动物的攻击大多是仪式性的；强者的目的适宜威胁吓跑对手，弱者能认识到自己的处境，及时撤退； 当数量超过了自然的限度，空间变得极度紧张，彼此没有了退路，仪式性的攻击就会变成实质性的杀戮；水槽中的鱼类会以极快的速度杀死同类； 杀熟 - 传销；马克思你曾自白，他最可原谅的弱点是轻信。受骗不是大过，更非大恶；受骗只是传销骗局中一个次要的因素；更重要的因素是，受骗者迅速地转变为行骗人。难于退货的高额商品滞留在手中，会使传销信任们立即明白即受骗了。一个善良的人即使自己受骗了，却决不会转嫁他人，甚至会以自己的教训广告四周，骗局因此无法复制和繁衍；传销在中国泛滥的最重要原因是，大批受骗者为了挽回个人利益，如此轻易地越过道德的界限，踏上了杀熟的道路；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对社会的认知]]></title>
      <url>%2F2017%2F08%2F20%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F20_%E7%A4%BE%E4%BC%9A%E8%AE%A4%E7%9F%A5%2F%E5%AF%B9%E7%A4%BE%E4%BC%9A%E7%9A%84%E8%AE%A4%E7%9F%A5_%E9%83%91%E4%B9%9F%E5%A4%AB%E7%B3%BB%E5%88%97%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[简单概括了郑也夫《代价论》《信任论》《文明是副产物》中的内容 （未完） 《代价论》 - 郑也夫 认识到特殊主义存在的必然性；并且当一种信任关系失败时，另一种信任关系必然会出现。 真正的平等是不存在的，人们只能在几种不平等中选择。代价更小的是：在具备完全规则的竞争市场中带来的不平等。“ 真正 “ 的平等可以理解为 “ 机会的平等，公平的竞争。” 竞争的起点从来都是不平等的，大家从未站在同一起跑线上。 在踏上起跑线之前的一切它管不了，但在进入市场竞争后，规则是一视同仁的； 一个健全的标准保证的只是更大概率上的合理； （考试：考试只能保证较大概率上的成功；） 市场的本质就是大众口味，市场上大众口味支配着一切； 如果冲突是客观存在的，无法避免的；使它公开化、明朗化、制度化将是代价最小、收益最大的调节方式； 在一个没有货不充分具备对冲突给予宽容及使之制度化的社会里，冲突总是趋向于负功能。 威胁到一个结构平衡的不是冲突本身，而是僵化。僵化使得敌对情绪积累，以致于一旦爆发只能走上一条分裂的道路。 互训：人类爱征服某样地区/物种的时候，同时也在被它所征服； 每个人都占据着一个他人都无法取代或完全重合的理解视野。 我是以第一人称来经历各种事件这件事，是没有任何人能够替代的； 《信任论》-郑也夫 信任的特性：(1) 时间差与不对称性；(2) 不确定性； (3) 属于主观的意识 诺言与兑现之间存在无法跨越的时间差；承诺人与选择相信的人在信息上有着无法跨越的不对称性 未来本身有着不确定性 均衡从来不是源于自我约束，而是靠着其他力量对某一势力的无限扩张的抵抗。 若要取得平衡，或者推动事物的发展，都可以从其他力量会采取的行动来进行思考，以此来促进均和或者推动行为的落地； 每个人、群体、民族、语言、想法都会在一定程度上的自我膨胀，这是生命体及其承载的一切事物的本性。 权利不可能自我约束的，对它的有效约束只能来自其他力量。 当我们在推动一项事情的时候，也可以从这个角度去思考；需要用什么其他的力量来推动 “合作的基础不是真正的信任，而是关系的持续性” 。在持续关系与合作之间还有一个环节——信任。即持续关系产生信任，信任导致了合作。 持续关系（即多次博弈）是合作，乃至一切复杂关系的基础 人类行为的动因：个人物质利益（个人取向） + 追求承认（他人与群体取向） 认识到基本上所有的制度都是 [ 简化复杂的机制 ]； 语言、金钱、权利、权威、标签、声誉、考核、分数 信任（简化机制），是凭借过去进行简化的； 信任增加了不确定性的宽容，从而增加了人们行动的勇气和可能性 货币是一种媒介，而信任是这一媒介中的关键。 货币通过数量差别取代质量差异，抹去了任何事物的特殊性，以自己的度量为一切事物完成了换算；凭借着这种 “变质为量” 的本领，货币获得了一种其他事物都不具备的渗透力； 学历社会带来的不是 “机会的平等”，而是 “游戏规则的平等” ；这才是科举与现代教育制度的贡献；人类更热爱的是差异的刺激。平等并不是人们真正的目标，平等不过是反对成员间地位差距过大的策略和说辞；文明的进步其实只是努力保障失败者或位卑者的尊严]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《代价论》读书笔记_郑也夫]]></title>
      <url>%2F2017%2F08%2F13%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F20_%E7%A4%BE%E4%BC%9A%E8%AE%A4%E7%9F%A5%2F%E3%80%8A%E4%BB%A3%E4%BB%B7%E8%AE%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%83%91%E4%B9%9F%E5%A4%AB%2F</url>
      <content type="text"><![CDATA[《代价论》_郑也夫；社会行为学；写于1995年 作者通过从事物的两个对立面进行分析与对比，帮助读者相对全面地进行认识； 警惕目的论；不要把事物的目的/结果去解释它的原因； 城市最伟大的价值在于它是人类对话的中心；对此，又该如何指导你的行为？在当前社会的网络中，你获得了对话的平台，那你有什么能拿来对话呢？ 冲突的存在是不可避免的；最有效的方式是将其公开化、明朗化、制度化；威胁到一个结构平衡的不是冲突本身，而是僵化。僵化使得敌对情绪积累，以致于一旦爆发只能走上一条分裂的道路。 如果是一位管理者，一定要认识到这一点； 认识到特殊主义存在的必然性；并且当一种信任关系失败时，另一种信任关系必然会出现。 真正的平等是不存在的，人们只能在几种不平等中选择。代价更小的是：在具备完全规则的竞争市场中带来的不平等。“ 真正 “ 的平等可以理解为 “ 机会的平等，公平的竞争。” 竞争的起点从来都是不平等的，大家从未站在同一起跑线上。 在踏上起跑线之前的一切它管不了，但在进入市场竞争后，规则是一视同仁的； 冲突是无法避免的，因为那是源自人的本性（大自然的物竞天择），伦理道德是抑制贪欲的最佳手段； 一个健全的标准保证的只是更大概率上的合理； 判定一种文化的上限（其发达程度）是看其多样性的丰富程度，判断其下线（满足社会生活的基本要求）是看其是否提供了起码的同一性和相似性； 从事物的两个对立面去看待与理解；辩证矛盾，从辩证的角度去看待问题；eg：歧异 vs. 一致； 确定 vs. 概率 1. 社会行为中的代价 “ 代价 “ 是经济学中的一个核心概念；因为经济学的经典性原理是：人们在经济生活中以最小的 [代价] 谋求最大的利润。 作者从一般意义上讨论代价的理论：是否人类要为它的一切收获付出代价，是否人们的一切分工、合作、竞争中都包含着代价，该如何评社会行为中难于避免的代价？ 本书中的 “ 代价 “ 指的是以人的行动选择为前提的。 ​ 2. 理性、非理性与代价 “ 代价 “ ，必然与一种估算相关联，因而是理性的尺度。 马克思 • 韦伯 最早开始探讨人的行为中的理论与非理性。他把人的行为划分为四种基本类型： 目的取向的理性行为；如工程师造桥 价值取向的理性行为；如教徒为得救而祈祷 情感的行为；如父母责怪孩子 传统的行为； 只有承认目标可以是理性选择的，才能接受韦伯的第一种行为型；只有承认价值观也是理性，才能接受第二种行为型； 作者认为，不是理性，而是感情；是人们的价值观决定着行为的目标。 理性只是一种手段；目标是价值观决定的，而价值观并不是一种理性。判断一种行动是否是理性的，要看行动者是否以一种理性的手段追求他的目标。 情感的行为（如果父母责怪孩子）不是理性，在于它听任感情而不是依靠理性去选择手段。 传统的行为不是理性，因为手段是非自觉的、未经思考的 宗教的行为不是理性，因为从理性出发不可能选择教徒们所认定的赎罪手段 理性是逻辑指引下的思考，它可以更广义地定义为问题的解决和批判的思考，但只有在强调了逻辑成分时，它才成其为有价值单独讨论的特定的思想方法。 3. 决定论批判 决定论即宿命论 宿命论认为一切都是已定的； 虽然宗教多于宿命论有关，但并并不是多数宗教都持极端主义的宿命论。因为，宗教很多时刻并非要人们沉睡、隐秘，而是要他们行动，只不过它要以一种强悍的思想魅力u诱导他们，左右其动作，规定其行止。 哲学家用不同的方式解释世界，但问题在于改变世界。 4. 目的论批判 所谓目的论，就是以结果或目标来解释原因。“ 凡是存在的都是合理的 “ —— 黑格尔；这是最典型的目的论； 传统的观点认为分工的出现是为了创造更多的财富。（目的论；从目的推导原因）但分工的真实原因在于原始社会中人口密度的增大。竞争使一些人迁徙，但当无处可退的时候，就迫使人们改行，于是导致了分工。 我们要把事物的原因和功能区分开。要完全解释社会现象，功能是必定要解释的。但功能绝非事物存在的原因。 不赞同的是为无生命的事物提出一个它所追求的目标，把一事物形成后发挥的某种功能——很可能是其副产品——说成产生的原因，其存在的目的； 人的选择从来不是安全自由的；他达到目标的手段，甚至他为自己设定的目标，都要受到限制： 物质条件，包括生理条件、外部的生态条件和技术条件对他的限制 社会规范、社会价值观和其他观念对他的影响1. 对于人们今日的选择另一个限制就是他们过去的选择；定着它们的全部行为。动物的行为从不越轨，永无失误，这种机制以牺牲发展和变异换来了万事不变的稳定。而人类的命运就是不断选择，也一再失误，它以风险代价换得了发展与创新的机会。 根本上说，选择的自由是人与动物的分水岭；动物的生理机制规定着它们的全部行为。动物的行为从不越轨，永无失误，这种机制以牺牲发展和变异换来了万事不变的稳定。而人类的命运就是不断选择，也一再失误，它以风险代价换得了发展与创新的机会。 5. 合作与团体生活 几乎没有无代价的合作，几乎没有无内耗的团体生活。 关键在于收益是否大于成本； 初等物理学告诉我们，当两匹马拉车的时候，每匹马只能发挥自己力量的90%左右。这是因为套绳在于车的连接点上形成一个夹角，一部分力内耗了；若把两幅套绳平行地连接在车的两边，又因两匹马难以时时等速，不仅增加了车的摇晃，且增加了摩擦力；即两马拉车必然会做出一些无用的功。但人们很少用一匹马拉车。因为多匹马能完成一匹马无法单独完成的工作。因而这些是有意义的代价，是必须付出的代价。 内耗和代价是不可避免，但又值得计算的。 社会关系中，两人组合只是相互依赖，不服从一种超个人的团体意志。在这种关系中，每个人的投入最大，且两人的距离最近。三人组合带来了新的特征：一个人可能被多数否决。这是最简单的群体结构，它带来了群体对个人的压力。从两人到三人组合，意味着增加了伙伴，增加了协调的余地，但也削弱了个人的自由意志； 会议中，最佳的人数是不超过8人；人数较少，每个与会者都可能和可以扮演完整的角色：既是倾听者又是发言者。人数过多，有些人就会沦为单纯地倾听者； 当合作具有一定规模，变得常规化时，也就形成了团体生活。当团体生活复杂到包容了成员的全部生活，且有了严格的结构时，就构成了社会生活。 城市化是当代人类的发展趋势。关键在于城市是一个更大的交际场。它的膨胀为城市人带来了交通的负担和环境的污染，但它的浓缩又跨越了空间，把一个民族的杰出人物聚集在一起，从而减少了从一个村镇到另一个村镇的交通阻塞和信息隔绝。城市是人类对话的中心。 6. 竞争与否认冲突 冲突时一切团体生活、社会生活中内耗的根源之一。但冲突又是源自人的本性，是大自然的法则（物竞天择）在一切生物上的体现。 团体生活中的内耗不仅在于任何一种合作方式都必然会有其结构上的支出（例如两匹马拉车在力学上的损耗，城市的生活产生的交通问题），更在于团体生活中的竞争与冲突； 虽然竞争和冲突必然使人们付出代价，尽管社会可以通过手段去调节，但铲除它们是不可能的。冲突根植在人的本性中： 一方面只有通过合作，通过加入到另一个群体中才能存活，彻底地独自生活一步可能，因为文化手段早已取代个人独立生存的能力； 另一方面他又不可能对合作或团体中分配份额（权利、机会、物质利益等）的大小无动于衷 如果冲突是客观存在的，使它公开化、明朗化、制度化将是代价最小、收益最大的调节方式；在一个没有货不充分具备对冲突给予宽容及使之制度化的社会里，冲突总是趋向于负功能。威胁到一个结构平衡的不是冲突本身，而是僵化。僵化使得敌对情绪积累，以致于一旦爆发只能走上一条分裂的道路。 现代工业社会的进步在于，它使潜在的冲突明朗化、制度化，给予这种冲突一套调节机制，努力使社会组织中的冲突转化为积极意义上的社会变迁。 7. 特殊主义与普遍主义 共存。对立又非对立。 特殊主义：凭借与行为者之间的特殊关系而认定对象身上价值的至上性。 特殊主义标准，是只能应用于与自己有特殊关系的人们身上，不能普遍贯彻到一切人身上的原则。 普遍主义：独立于行为者与对象在身份上的特殊关系。 两者的区别：支配着人们彼此取向的标准是依赖还是不依赖存在于他们之间的特殊关系。 扩大化了的社会交换和社会生活在互换一种普遍主义的尺度和价值观。货币的出现，标志着人们迈出了严格封闭的特殊主义的小圈子；货币是普遍主义价值及其尺度的结晶。 特殊主义与普遍主义分别构成了两种 “ 信任结构 “。 信任是任何规模、任何种类的社会生活的前提。没有最基本的信任就没有社会，丧失掉一切信任就是社会的瓦解。特殊主义与普遍主义在信任结构上的基本差别是：范围的差别；前者是一个较小的信任结构，后者构成了一个相对更大的信任结构。 社会中一个信任系统越大，成员间的信任感越弱、越单一；一个信任系统越小，成员间的信任感越强烈、越全面。 两者之间会产生冲突，一方面特殊主义的信任结构是重交情，是人类群体赖以存在的重要条件之一；另一方面，这种品格的本质注定了它要超越规章的束缚，从而破坏人类社会同样赖以建立的一切制度化的秩序。并且这种冲突的深刻性在于两者谁也无法取代谁。 当一种信任关系失败时，另一种信任关系必然会出现。当金钱（一种力量）不能决定一种物品的购买权时，人际关系上的优势（另一种力量）必将出场。 特殊主义是唯一能取代和补充普遍主义的控制系统。两者之间未必总是对立的，它们的关系远非简单的二分法； 信任系统的扩散，依赖于三个条件： 内部专业化所驱动的向外扩大交换与交流的趋势 一种提供认同感的意识形态 标准与操作手段 8. 经济平等之妄想 完全的平等是不可能的；平等并不能促进发展； 完全的平等是不可能的。 按需分配不可能实现；因为按需分配首先并不是平等，它超越了平等的范畴。 按劳分配也是存在问题的。客观的按劳分配是不存在的，企图按照这一原则去追求平等是不可能的。 “ 劳 “ 是难以度量的；分配所依据的劳动之多少是需要与其社会效益相联系的，但是效率的标准却难以建立。 一个经典的例子是 “ 如果一个钉子工厂的水平评定是根据数量，厂家就会去生产小钉子；如果以质量为准绳，生产就会转向大钉子 “ 体力劳动 vs. 脑力劳动。二者之间比值如何，没有一个客观的依据。在实践中只能凭借市场上的供求关系去决定，不然就是人为主观裁定。 贯彻收入上的平等也是不可行的；即使收入上平等了，但在购买产品/服务的时候却会出现不平等的现象。比如早起的人抢购到产品，稀缺的东西价格更高；平等分配的原则只不过把竞争从生产领域赶到消费领域； 完全的平等是不可取的，它不能促进发展 收入上的平等刺激不了劳动者的积极性，因为它违背了人的本性。 等价交换刺激不了劳动积极性，因而也不是可取的。我们常常认为是等价交换，但实际发生的是不等价交换。 这里的不等价交换，并不是说巧取豪夺多。因为交换本身就带有自愿的内涵。 商人们总是努力在 “ 不平等交换 “ 中占据有利的位置。 一个商人辛苦地把茶叶从农夫运到牧区，是为了卖出好价钱；如果他的所得遵从按劳分配的原则，那他能获取的应该只有本地茶叶的价格 + 运费。 平等分配的批判者认为平等的分配压制和剥夺了强者与能人，并非公正；公正的真正基础是机会的平等，公平的竞争。 但是竞争的起点从来都是不平等的，大家从未站在同一起跑线； 在社会实践的选择中我们只能以代价大小为标准。显然以强调机会平等、公平竞争的思想比强调分配平等的思想付出的代价更小，获得的收益更大。 最终意义上：平等是不存在的。人们只能在几种不平等中选择： 特权身份带来的不平等 具备完备规则的市场竞争带来的不平等； 后者甚至难于避免地带着前者的 “ 胎记 “，比如家庭教育、遗产继承都限定了竞争的公平性。 但两者毕竟有本质的差别：后者把特权从个人权利的意义上铲除了。在踏上起跑线之前的一切它管不了，但在进入市场竞争后，规则是一视同仁的； 9. 男女平等之困惑 平等是权利，而非结果。 男女不平等有两种类型：母系社会 和 父系社会； 虽然有人对是否存在过母系社会表示怀疑，但可以确定的是有过一个不知道父亲的时代； 妇女的统治是建立在这样的基础之上，因此当群婚结束后父亲出现，母系社会遍终结了。 父系社会是因为人类社会固有的竞争性与掠夺性选择了男性占据统治地位； 在人类史中，基本的权利资源不外乎三种：暴力、金钱、知识；在早期历史中，暴力占据支配地位，而男子更有力量。 随着历史的发展，在权利争夺的与社会生产中，力量的作用渐渐让位于智力与知识；结果是男子在两性中的优势渐渐失去，女子的劣势渐渐好转。 这种逆转发生在机器取代了体力的伟大工业革命之后。妇女解放的宣言奏响于18世纪末的法国大革命，妇女解放的大潮在19、20世纪，这都是 “权利的转移” 与 “生产力的转移” 所酿成的。 在权利基础与生产力基础变更之前，父权制度是无可谴责的，它是群体内外残酷竞争的必然结果，是减少内耗增加效率的合作结构。 古代的中国社会建立了最完备的父权制，现代的中国在智力与知识对权利与生产的决定作用上，在社会物质物质上远落后于发达国家时，然而我们的妇女解放、男女平等却走在了世界的最前列：城市中男女拥有一致的就业机会，获取同样的工资；农村中的男女获取同样的分工，等等；这种超前的、动用行政力量造就的妇女解放的直接后果是使得家庭关系紊乱。 我们的妇女解放运动仅仅将妇女推上了社会，却没有未她们提供家庭中的角色模式；家务该谁来做？中国人失去了社会文化的引导，只好听凭当事者去摸索、选择、碰撞与磕打。于是家庭矛盾丛生，角色冲突千奇百怪； ​ 即使打破了旧的性别模式，在新型的社会生产与生活的关系中，通过40余年的实践，却仍然没有找到新的性别分工；究其原因，在于一种强大的政治力量，通过扶助弱者压制强者，干扰破坏着家庭中强者与弱者的正常分工。 甚至使得弱者误以为自己不弱，强者丧失了应有的信心。 在一个正常的社会分配系统中，在体力依然成为生产力基础之组成部分的国情中，一个男子应该能比女子在生产中做出更大的贡献，但我们的分配系统贯彻着 “ 同工同酬 “ 的平均主义原则。当一个男子拿着同样多的工资回到家中时，他失去了往日的尊严。又因为他的体力毕竟由于他的妻子，便只好比工资不少于他的妻子干更多的家务。在一个不受行政力量干扰的分配体系中，强悍的男子外出挣更多的钱，弱小的女子守家做更多的家务。是社会主义对妇女的恩赐，使得中国男子看不到自己的力量，扎进家务中，日益女性化； 美国学者吉尔德对国家福利所做的批判是富有启示意义的：婚姻的解体并不是因为规章决定，而是因为福利水平破坏了父亲在家庭中所起的主要作用和所处的权威地位。 这种政治推动的妇女解放，也使得中国失去了自己的女性。在近40年的妇女解放运动中，女子从来没有认识到自己的独立价值是什么，相反她只是一味地跟从政治的引导，以男性的指标作为自己解放的标志：做女拖拉机手、女飞行员、女勘探队员。似乎完成了这些便是妇女解放的获得，实际上恰恰是这一过程中，男子的价值与特征被前所未有地席卷。”解放” 变成男人，这真实绝大的讽刺。 正是因为这一解放运动是扶持弱者、抑制强者为手段的，它把男子赶进了家务，把女子推向了社会，它使强者不敢相信自己的力量，弱者误以为自己不弱，从而破坏了社会的基本分工，瓦解了社会的效率； 真正的妇女解放不应于干扰市场中自由公平的交换，而恰恰应建立在这种公平交换的基础之上； 因此经历过社会主义的妇女解放，又收到市场挫折的中国妇女将是痛苦看到一代； 因为妇女要生儿育女的生理特征将在一定时间内影响她们从事社会性工作，也因为社会上劳动力的过剩，任何一个国家中都有相当数量的女子或终生或一段时间内做家庭主妇；这本是正常的； 但中国妇女回到家中尤为困难，原因是她们见过了广阔的天地，要她们回到室内格外困难。 父权社会的最大收益在于为性别角色提供了一种模式，使他们免于陷入个体选择的困惑与冲突中，为社会提供了一种分工合作的秩序，使之免于混乱，得到一定的效率；而它最大的代价是压抑个性，不允许一个出类拔萃的女子超越社会对性别角色的规定，从而极大地浪费着女性的才能。 “男女平等” 时期的最大收益是它普及了一种观念：女子拥有与男子同样的权利，从而为女子发展潜能提供了机会。 但它迅速地走向极端，变追求机会平等为完全的平等，以致于造成一种新型的、更为荒诞的不平等：弱者对于强者的剥夺； 真正意义上的妇女解放，应该是认识到平等是权利，而不是结果。女子有权利就学、择业、从商、参政，但能否得到某一职位却是公平竞争的结果，而非社会的恩赐；社会竞争的原则应该是一视同仁，不安地有任何意识形态上的偏见。它对女子的态度应该是：上不封顶，下不保底；即一个成功的女子可能成为学者、教授、主席，社会绝不进行人为的压制，同时也绝不进行人为的扶持，保证她获得某种社会职业； 10. 伦理的诸种得失 冲突时一切团体生活、社会生活中内耗的根源之一。但冲突又是源自人的本性，是大自然的法则（物竞天择）在一切生物上的体现。要使团体生活成为可能，必须借助种种手段抑制贪欲以缓和冲突，伦理道德正是克服贪欲的最佳手段。 “ 道德是个人利益冲突的产物…… 如果人们在生活中毫无冲突，也就不需要任何道德规范了。 “ —— 梯利 欲望是一切生物的本能。并且一切动物的贪欲都是有限的，其生理条件为其贪欲设下了天然的限定：它在饱暖之后自然心满意足；但人类则不然，它所创造出的不会腐烂可以贮藏的身外财富，使它突破了生理机制对欲望的限定，从而在贪欲上超越了一切生物。 在伦理的重压之下，人类不仅可能失去生气，而且可能会扭曲个人；弗洛伊德认为超我（即社会道德）与本我（即人的本性）的剧烈冲突和失调是精神病发作的最主要原因。 道德不应该成为 [一切] 社会行为的尺度。在职务任用时，道德不应该成为唯一标准； 11. 标准之缺憾 一个健全的标准保证的是更大概率上的合理； 过往的一些标准： 王位继承：它限制了选择的范围，不问强弱如何，长子上位；但如果选择王位择优制，那王子们从年幼开始就将明争暗斗；它说明了在古代，社会的安定常常牺牲择优和效率去换得 普选权：普选权的标准是人数，它赋予了每个成年人这种权利。它有很大的进步，优势在于它们明确，它们客观，因而不易被滥用；但也有不足之处 普选权是无偿获得的，又是人人具有的，因此很多选民并不珍惜它；这点上就比较容易受到控制； 选民的教育程度、信息掌握都参差不同；一位深思熟虑的思想家的赞成票会被一位轻率的文盲的否定票抵消掉 普选权以智力意义上的公平（即智者应该有更大一些的权利）为代价，换得了人格意义上的平等 两者都在标准的选择上陷入了困境，都找不到一个合适的人为标准； 普选权找到的是人头加一定的年龄，收获是：它有效阻挡了少数权利者对他人权利的剥夺；代价是：少数杰出人物的意见也能被选民中的多数庸人所击败 体力劳动 vs. 脑力劳动：市场为脑力劳动报酬提供了一个更广泛的操作标准；市场的本质就是大众口味，市场上大众口味支配着一切； 考试：考试只能保证较大概率上的成功； 12. 分工与专业化 分工的缘由是相互交换； 专业化带来的困难：在各自的范围内形成了一种天然的屏障。这种专业屏障造成了不幸的后果。我们的知识是在相对孤立的情况下向纵深发展，而不是一面纵向发展，一面又横向沟通。我们正在得到的不是一幅紧密相连的完整画面，而是许多碎片——细部异常清晰，整体却支离破碎； T 字型学习 仍然是一个重要的发展方向；跨界的作用越来越大； 一个既拥有广博知识又有专长的社会才是健全的社会；要做到这一点，只有在中高等教育中更重视通才的培养。一个人迟早必然会进入专业化的过程，在此之前应给予他更丰富的文化营养； 13. 完善与停滞 完善仅指适应程度； 互训：人类爱征服某样地区/物种的时候，同时也在被它所征服；游牧民族为了在各种不同季节里为他的家畜在草原植被中寻找生活资料，他自己的生活和行为必须准确地按时间表行动； 任何一种过度的适应都要付出沉重的代价；一个物种在既定的进化等级中越是专化和适应，它走向更高等级的趋势就越小； 14. 传统与反传统 传统 $\ne$ 传统主义 “不立不破” 远比 “不破不立” 更有道理；新旧事物应在共存和比较中接受选择，不可以死凭借打击对方来抬高自己； 15. 歧异与一致 人类容纳了自它诞生以来的体制与文化上生长出和积累下的巨大歧异，但仍牢固地保持为同一物种； 语言如此重要，是因为它解释超越了动物生理机制的人的机制的密码； 语言造成歧异的三种原因： 信息传递中的”噪音”；在信息传递过程中，必然会有遗漏、衰减、歪曲某些信息 语言的编码过程；语言（代码）是静态的，现实是动态的；代码是有限的，现实是无限的；代码是抽象的，现实是具体的； 语言的解码过程，即信息接受者对语言的理解； 每个人都占据着一个他人都无法取代或完全重合的理解视野。 我是以第一人称来经历各种事件这件事，是没有任何人能够替代的； 文明的问答不在于它拒绝反而容纳着多样的异质，并能沟通它们，养育它们； 判定一种文化的上限（其发达程度）是看其多样性的丰富程度，判断其下线（满足社会生活的基本要求）是看其是否提供了起码的同一性和相似性； 没有一种文明不致力于谋求基本的一致性，那是便利地生活在一个社会中的基本保障； 市场范围内的一切活动都以金钱尺度来衡量，商品和服务通过标价变得可比了；市场价值的这种扩张性不仅说明了市场的功劳，同时也暴露了它对其他社会领域的威胁，它可能毁掉市场价值之外的所有其他价值——知识、艺术、友情、尊严。正是为了抵御市场价值的泛滥，人们强行或人为规定了一些不可买卖或不受顾客左右的标准。比如个人的权利，运动奖牌，学术荣誉； 16. 顺境与逆境 凡仕宦之家，由俭入奢易，由奢入俭难； 处在顺境和优越条件下的人们往往要为此付出代价，客观的看他们缺少的是适当的压力； 17.风险与保障 风险（个体） Vs. 保障（群体） 风险，是与选择对应的，它意指选择的某种结果的不确定性；如果当事人丧失了选择权，它的行为或被自身的生理本能，或为外部强制力量所决定，其结局如何多称不上风险，而应视为”注定”。 正是因为这个原因，我们很少说动物的行为包含风险； 信息的不完备为决策带来了风险； 棋、牌、人生代表了三种决策方式： 棋，是 “全备信息” 的决策，其 “风险” 只在于一步步对弈构成的 “选择之树” 过于复杂，因智力和时间的限制，存在着失误的决策； 牌，是 “概率信息” 的决策，它呈现出若干信息，但并不完备，只能对不完备的部分作出概率判断，这种判定构成了牌戏决策的基础； 生活中的事物除了包括类似的棋牌行为，还有一些更模糊的事情，以致于连概率都找不到 保险不同于回避风险，它的本质是风险转移；保险业把众人联系在一起，共同承担偶然事件造成的损失。从最广义的保险意义上说，转移风险的可能性允许个人从事冒险活动。 18. 乌托邦——否定代价之代价 乌托邦：可以指任何被渴望不切实际的、不可能实现的想法或方案，它被认为是虚妄的、不合理性的期待，对现存状况的激烈背离；它可以意指很多不同的事物，但当我们说到乌托邦时，是指关于一个完美社会的图景。 乌托邦是不存在的，但同时它给予了人类新的思维角度 蒂里希(Paul Tilich)揭示出乌托邦思想忽视了人类有限性的弱点：乌托邦的根本弱点在于它预先假设了一个虚假的人的形象； 乌托邦思想丰富了人类对自己可能性和潜在力的认识； 人是具有可能性的存在物； 逻辑矛盾 Vs. 辩证矛盾 逻辑矛盾：同一思维（主体）过程中对两个互相矛盾的命题或判断，同时肯定它们都是真的；即自相矛盾；eg ：我认为万事万物都是有矛盾的；但我认为我们班上没有矛盾； 辩证矛盾：客观事物中，事物自身所包含的既对立又统一的关系；它是现实的矛盾，存在于自然界和社会的一切事物和现象以及人的思维中； 19. 代价的界定与比较 人类的一切行为在为他带来收益的同时，也使他付出代价（代价是对收获而言） 代价的大小不仅要比较支出、浪费或牺牲掉的东西的多少，还要甚至更要比较付出了这些代价后收获的大小；令人惋惜的倒不在于浪费的数量的很大，而在于这些浪费的进步意义太少了； 20. 中庸与极 人们在面临的诸多选择之中（合作与竞争、平等与效益、特殊主义与普遍主义、风险与保障），没有一种选择能够最大限度地帮助我们减少代价；最理想的是中庸之途； 中道，是过度和不及的居间者； 如果中庸的理想最终蜕变为宣扬一种单是一的思想和主张，其结果必然是使社会趋向单一，这不仅是中庸的悲剧，也将是中庸的覆灭； 必须理解中庸所依赖的两极间必要的张力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jupyter_设置安装]]></title>
      <url>%2F2017%2F08%2F09%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FJupyter%2FJupyter_%E8%AE%BE%E7%BD%AE%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[给Jupyter安装R Github上的参考文档 通过Anaconda安装R内核123win+r ; cmdconda install -c r r-essentials 手动安装R内核 首先，在R中安装必备包。 之后，启动R控制台，运行下面的语句 1234install.packages('devtools') # devtools::install_github('IRkernel/IRkernel')# or devtools::install_local('IRkernel-master.tar.gz')IRkernel::installspec() # to register the kernel in the current R installation 123456# 在R中安装必备的包install.packages(c('rzmq','repr','IRkernel','IRdisplay'), repos = c('http://irkernel.github.io/', getOption('repos')))# 第二步：连接R与jupyter - 在R Console中输入IRkernel::installspec()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jupyter_设置安装]]></title>
      <url>%2F2017%2F08%2F09%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FJupyter%2FJupyter_%E8%AE%BE%E7%BD%AE%E5%AE%89%E8%A3%85.1%2F</url>
      <content type="text"><![CDATA[给Jupyter安装R Github上的参考文档 通过Anaconda安装R内核123win+r ; cmdconda install -c r r-essentials 手动安装R内核 首先，在R中安装必备包。 之后，启动R控制台，运行下面的语句 1234install.packages('devtools') # devtools::install_github('IRkernel/IRkernel')# or devtools::install_local('IRkernel-master.tar.gz')IRkernel::installspec() # to register the kernel in the current R installation 123456# 在R中安装必备的包install.packages(c('rzmq','repr','IRkernel','IRdisplay'), repos = c('http://irkernel.github.io/', getOption('repos')))# 第二步：连接R与jupyter - 在R Console中输入IRkernel::installspec()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_ggplot2_可视化手册]]></title>
      <url>%2F2017%2F08%2F09%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_ggplot2_%E5%8F%AF%E8%A7%86%E5%8C%96%E6%89%8B%E5%86%8C%2F</url>
      <content type="text"><![CDATA[Rggplot2可视化手册 每一个图层都是按照ggplot对象的先后顺序绘制的；在覆盖的问题上，可参考该顺序 输出图形 输出图形为PDF、矢量图、其他图形 width与height 默认单位为 英寸； ggsave(filename, plot=last_plot, device=NULL, path=NULL, scale=1, width=NA, height=NA, units=””, dpi=300, limitsize=TRUE,…) ：保存图形 使用ggsave时无需打印ggplot对象，并且在创建过程中若出现错误也无需手动关闭设备 filename : 保存的文件名 device ：使用的设备； 可为 &quot;eps&quot;,&quot;ps&quot;,&quot;tex&quot;(pictex),&quot;pdf&quot;, &quot;jpeg&quot;, &quot;tiff&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;svg&quot;, &quot;wmf&quot;(windows only) units = c(“in”, “cm”, “mm”) ：可选的单位；默认为 英寸(in) limitsize= TRUE ：大小限制；若为TRUE，将不会保存大于50 $\times$50 英寸的图形 使用传统方法调用时可能出现的问题 在使用某个脚本来创建图形的过程中抛出一个错误，则R可能无法执行到dev.off() ，并可能停留在设备pdf/png等仍然开启的状态。 当这种情况发生时，直到你手动调用dev.off() 之前，pdf/png文件将无法用程序正常打开 PDF 使用ggplot2的语法ggsave() ：保存使用ggplot() 创建的最后一幅图形 ggsave无法用于创建多页图形 1234ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point()## 默认单位为英寸，但可以修改ggsave("myplot.pdf", width=8, height=8 ,units="cm") 可能会出现字体无法匹配的情况，可通过添加 useDingbats=FALSE 来处理 1234&gt; pdf("", useDingbats=FALSE)&gt;&gt; ggsave("", useDingbats=FALSE)&gt; 打开设备 — 绘制图形 — 关闭图形设备（适用于R中大多数图形，包括ggplot2 和 lattice绘制的图形） 绘制多幅图形，希望每一幅占据一页 对ggplot调用print，确保这段代码即使在一段脚本中也能调用 123456789# 打开设备pdf("myplot.pdf", width=4, height=4)# 绘制图形plot(mtcars$wt, mtcars$mpg)print(ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point() ) # 对ggplot调用print，确保这段代码即使在一段脚本中也能调用# 关闭设备dev.off() 矢量图 eps &amp; svg格式 1234567## 使用ggsaveggsave("myplot.svg", width=, height=, units="")## 常规方法svg("myplot.svg", width=, height=)plot()dev.off() wmf : Windows图元文件 不支持透明 1234567# ggsaveggsave("myplot.wmf")# 常规方法win.metafile("")plot();dev.off() 位图 png / tiff 默认单位为 像素 ，默认的输出分辨率为72像素(pi)；这一分辨率适合在屏幕上显示，但在打印时会显得模糊； 对于高质量的打印输出，分辨率至少应该在 300ppi 使用ggsave()中的参数虽名为dpi， 但它实际上控制的是每英寸的像素数(pixels per inch ,ppi) ，而非每英寸的点数(dots per inch, dpi)。 123456789101112131415161718192021222324ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point()ggsave("myplot.png", width=4, height=4, units="cm", dpi=300)### 传统方法-----------------------------------------------------------# 默认单位为 像素png("filename.png", widht=400, height=400)plot()dev.off()# 输出多幅图形，可在文件名后加入 %dpng("myplot-%d.png", widht=400, height=400)plot()print(ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point() )dev.off()## ----修改分辨率--------ppi &lt;- 300# 计算一幅4英寸 × 4英寸 300ppi图像的高度和宽度（以像素为单位）png("myplot.png", width=4*ppi, height=4*ppi, res=ppi)plot(mtcars$wt, mtcars$mpg)dev.off() 图形的默认属性 参数 默认值 图形 position = “stack” geom_histogram position_dodge() 0.9 position = “dodge” geom_bar width = 0.9 geom_bar size = 5 geom_text size = 2 geom_point scales = “fixed” facet_grid bins = 30 stat_bin2d method = loess stat_smooth level = 0.95 stat_smooth 条形图 width =0.9 position = position_dodge(0.9) 文本标签 size = 0.9； size= rel(0.9) 描述数据分布直方图 geom_histogram()：映射一个连续变量到参数x bins = n；组的数量（即出现n条柱子） binwidth = n ；组距宽度，（看做分隔范围的大小；表示每个柱子的宽度） position = “stack” （默认）；位置调整 position= “identity” ：不做任何调整 position= “dodge” ：避免重叠，并列排放； 12ggplot(mtcars, aes(x=wt)) + geom_histogram(bins=30, binwidth=0.3)# bins=30 （默认）； 分组直方图 多组数据的直方图；geom_histogram() 分面 - facet_grid/wrap faect_grid(smoke.~ , scales = “free”, position=) smoke ~ . ：一列多行，根据变量smoke进行分面为n行 . ~ a # 一行多列，根据变量a进行分面为n列 a ~. # 一列多行，根据变量a进行分面n行 a~b # 多行多列 .~a+b / a+b~. # 多个变量的多个水平在行/列上(或同时) scales = “fixed” (默认) ； 标度控制；即所有面板中x/y标度相同 scales = “free” ；x/y每个面板的标度都可以变化; 自由标度，用于发现更多的细节 scales = “free_x” / “free_y” facet_wrap(~a, ncol=n) 处理单个多水平变量时更适用，因为可以自定义行列数； 此时结合 scales=”free” 更容易看出图形的趋势 ~ a, ncol=n ~a, nrow=n 1234library(MASS) # 为了使用数据# 使用smoke作为分面变量ggplot(birthwt, aes(x=bwt)) + geom_histogram(fill="white", color="black") + facet_grid(smoke~.) 分面标签：分面绘图有一个问题：即分面标签只有0和1，且没有指明这个标签变量smoke的取值；因此需要修改标签，即修改因子水平的名称； 列出现有的因子水平 (因为分面没有指明这个标签的取值，重要) 依据相同的顺序赋予新的名字 1234567891011birthwt1 &lt;- birthwt # 复制一个数据副本birthwt1$smoke &lt;- factor(birthwt1$smoke); levels(birthwt1$smoke);# 依据相同的顺序赋予新的名字birthwt1$smoke &lt;- factor(birthwt1$smoke, levels=c("0","1"), labels=c("No Smoke","Smoke"))## 亦可以用 plyr::revalue 进行library(plyr)birthwt1$smoke &lt;-revalue(birthwt1$smoke, c("0"="No Smoke", "1"="Smoke"))# 重新作图ggplot(birthwt1, aes(x=bwt)) + geom_histogram(fill="white", color="black") + facet_grid(smoke~.) 分面y轴刻度：可选择根据不同面板自动调整标度；选择 scales=&quot;free&quot; 可以单独设定分面y轴/x轴的标度；但这种设定根据分面的形式而有所不同 smoke ~ . ：一列多行，此时x轴是固定的；此时 scales=&quot;free&quot;等价于scales=&quot;free_y&quot; . ~ smoke：一行多列，此时y轴是固定的；此时 scales=&quot;free&quot;等价于scales=&quot;free_x&quot; 12# 因分面的形式为一行多列，故x轴是固定的；y轴标度自由变换ggplot(birthwt1, aes(x=bwt)) + geom_histogram(fill="white", color="black") + facet_grid(race~., scales="free") 分组 - fill 将分组变量映射给 fill；此处分组变量必须是 因子型 或 字符型 向量 12345# 因子化birthwt1$smoke &lt;- factor(birthwt1$smoke)# 将smoke映射给fill，取消条形 [堆叠]，并使图形半透明ggplot(birthwt1, aes(x=bwt, fill=smoke)) + geom_histogram(position = "identity", alpha=0.4) 密度曲线 核密度曲线是基于样本数据对总体分布做出的一个估计。 曲线的光滑程度取决于核函数的带宽：带宽越大，曲线越光滑； geom_density()：映射一个连续变量到x； 绘制的为封闭的多边形 12## 绘制核密度曲线ggplot(faithful, aes(x=waiting)) + geom_density() 开放的密度曲线 geom_line(stat=”identity”)：绘制没有两侧与底部线段的核密度曲线 123# 使用 expand_limits() 函数扩大y轴范围以包含0点ggplot(faithful, aes(x=waiting)) + geom_line(stat="identity") + expand_limits(y=0) 分组密度曲线 频数多边形 频数多边形传递的信息类似直方图 geom_freqploy() binwidth= n ；设定每组的组距（即宽度） 123456# 通过binwidth参数控制频数多边形的组距ggplot(faithful, aes(x=waiting)) + geom_freqploy(binwidth=4)# 通过直接设定每组组距将数据dx轴范围切分为特定数据的组binsize &lt;- diff(range(faithful$waiting))/15ggplot(faithful, aes(x=waiting)) + geom_freqpoly(binwith = binsize) 箱线图 geom_boxplot()：分别映射一个连续型变量 和 一个离散型变量到 y 和 x ； 绘制单组数据的箱线图时，必须给x参数映射一个特定的取值；可以将其设为1 width = ；修改箱线图的宽度 outlier.size = ；设置异常值的大小 outlier.shape = ；设置异常值的形状 notch= TRUE ； 显示槽口（槽口(notch)的目的是易于比较各组数据的中位数的差异；） 1234567library(MASS) # 为了使用数据# 使用factor将数值型变量转为离散型ggplot(birthwt, aes(x=factor(race), y=bwt)) + geom_boxplot()# 绘制单组数据箱线图，可令x=1ggplot(birthwt, aes(x=1, y=bwt)) + geom_boxplot() + scale_x_continuous(breaks =NULL) + theme(axis.title.x=element_blank()) 添加均值 stat_summary()： 123library(MASS) # 为了使用数据ggplot(birthwt, aes(x=factor(race), y=bwt)) + geom_boxplot() + stat_summary(fun.y="mean", geom="point", shape = 23, size = 3, fill = "white") 常规图形 条形图、折线图、面积图、散点图 条形图 geom_bar(stat=”identity”) ：一列数据表示条形在x轴上的位置，另一列数据表示每个条形在y轴上对应的高度 当x为连续型变量，通过factor() 转为离散型变量 当x是连续型（数值型）变量时，ggplot不是只在实际取值处绘制条形，而是将在x轴上结余最大值和最小值之间所有可能的取值处绘制条形 fill = ； 条形的填充色 color = ；添加并框线，并指定颜色 size = ；用来控制边框线宽度的参数，单位是毫米；（当设定了边框线颜色color） position = “” stack - 堆叠；fill - 堆叠并标准化为1； dodge - 分组条形图； jitter - 扰动； identity - 不做调整 width= ；条形的宽度 最大宽度为1 簇状条形图组内的条形间距为0 12library(gcookbook)ggplot(pg_mean, aes(group, weight)) + geom_bar(stat="identity") 条形图 - 簇状条形图 并排展示的条形图； 若分类变量个水平的组合中有确实项，绘图的条形会略去不进行绘制，并将条形自动扩充到相应的位置（即宽度变宽） 将分类变量映射到fill，并运行geom_bar(position=”dodge”) position=”dodge” 是默认参数0.9的position_dodge()的缩写；即默认组间宽度为0.9 12ggplot(cabbage_exp, ase(Date, Weight, fill=Cultivar)) + geom_bar(position="dodge", stat="identity") 条形图 - 频数 geom_bar()，同时不映射任何变量到y参数 当x为连续变量时，会得到一张直方图 stat = “bin” （默认）；该操作会自动计算每组变量对应的频数 12ggplot(diamonds, aes(cut)) + geom_bar()# 等价于使用 geom_bar(stat="bin") 条形图 - 正负分别着色 创建一个对取值正负情况进行标识的变量pos 将该变量作为映射给fill 通过scale_fill_manual(values=c(), guide=FALSE) ：指定正负条形图的颜色，去掉图示 1234567library(gcookbook)csub &lt;- subset(climate, Source=="Berkely" &amp; Year &gt;= 1900)cusb$pos &lt;- cusb$Anomaly10y &gt;= 0 # 创建一个标识变量# 将该变量映射给分组变量fillggplot(csub, aes(Year, Anomaly10y, fill=pos)) + geom_bar(stat="identity", position="identity") # 令position="identity" 可以避免系统因对负值绘制堆积条形图而发出警告信息 条形图 - 宽度与间距 通过geom_bar()的width 控制条形的宽度 运行geom_bar(width=0.9)时，每组条形将在x轴上占据0.9个单位宽度 运行position_dodge(width=0.9)时，会自动调整图形位置，使每个条形的中心恰好位于当每组条形宽度为0.9，且组内条形紧贴在一起时的位置 width=0.9 (默认)；较窄的可设为0.5；最大宽度为1 簇状条形图组内的条形间距为0；若希望增加组内条形的间距 将widht 设定的小一点 并令 position_dodge的取值大于 width； position_dodge(width=0.9) 默认 123# 簇状条形图 - 组内间距ggplot(cabbage_exp, aes(Date, Weight, fill=Cultivar)) + geom_bar(stat="identity", width=0.5, position=position_dodge(0.7)) 条形图 - 堆积条形图 使用geom_bar() ，并映射一个变量给填充色参数fill 通过guides调整图例顺序 通过order=desc() 来调整堆叠顺序 123456ggplot(cabbage_exp, aes(Date, Weight, fill=Cultivar)) + geom_bar(stat="identity") + gudies(fill=guide_legend(reverse=TRUE)) # 调整图例顺序ggplot(cabbage_exp, aes(Date, Weight, fill=Cultivar, order=desc(Cultivar))) + # 调整堆叠顺序 geom_bar(stat="identity") 条形图 - 百分比堆积条形图 先对每组条形对应的数据标准化为100%格式； ddply() 、 transform() 对之后的结果绘制堆积条形图 123library(gcookbook)ce &lt;- ddply(cabbage_exp, "Date", transform, percent_weight=Weight/sum(Weight)*100) # ddply 根据指定的变量Date进行分组，并对各组执行transfrom操作ggplot(ce, aes(Date, percent_weight, fill=Cultivar)) + geom_bar(stat="identity") Cleveland图 使用Cleveland点图来替代条形图以减少图形造成的视觉混乱并使图形更具可读性 geom_point() 通过reorder()：实现排列的自定义 reorder(name,avg) ：该命令会先将name转化为因子，然后根据avg对其进行排序 为了使图形效果更好，可删除垂直网格线，并将水平网格线改为虚线 涉及根据两个及以上变量进行分组与排序时，只能分步实现 12345678library(gcookbook)tophit &lt;- tophitters2001[1:25, ] # 取出前25个数据ggplot(tophit, aes(x=avg, y=name)) + geom_ponit()# 调整因子顺序，并调整外观ggplot(tophit, aes(x=avg, y=reorder(name, avg))) + geom_point(size=3) + theme_bw() + theme(panel.grid.major.x=element_blank(), panel.grid.minor.x=element_blank(),panel.gird.major.y=element_line(color="grey60", linetype="dashed")) geom_segment()：绘制数据点为端点的线段； 需要设定x /y /xend /yend 四个参数 1234ggplot(tophit, aes(x=avg,y=name)) + geom_segment(aes(yend=name, xend=0, color="grey50")) + geom_point(size=3, aes(color=lg)) + scale_color_brewer(palette="Set1", limits=c("NL","AL")) 环状图形 饼图实际上就是柱状图，只不过是使用极坐标而已，柱状图的高度，对应于饼图的弧度 coord_polar(theta = “x”, start = 0, direction = 1)： 非笛卡尔坐标；使用环形图 根据数据源的不同有不同的做法： 长格式，映射的为列中某个变量的频数； 宽格式，映射为某个列中具体的值（同Excel，具体的值已经经过计算） 先制作堆积条形图（1. 堆积条形图； 2. 簇状条形图） theta： variable to map angle to (x or y)start：offset of starting point from 12 o’clock in radiansdirection, 1, clockwise; -1, anticlockwise 长格式 123456789## 数据源为长格式，y值为cyl列的频数，而非cyl中列的值# 堆叠条形图pie &lt;- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) + # factor(1) 表示将y分为1组 geom_bar(width = 1) # width&gt;=1，中心的白点会去掉pie + coord_polar(theta = "y")# 簇状条形图cxc &lt;- ggplot(mtcars, aes(x = factor(cyl))) + geom_bar(width = 1, colour = "black") geom_bar() 中 width&gt;=1，中心的白点会去掉 宽格式 ggplot(x=””) ；x为空，并且不要指定group 若x = colname ，饼图的长度（离圆心的距离）会根据比例不同而不同 1234567891011121314df &lt;- data.frame( variable = c("does not resemble", "resembles"), value = c(20, 80));df variable value1 does not resemble 202 resembles 80ggplot(df, aes(x = "", y = value, fill = variable)) + # x为空，y为具体的值，fill为填充色变量 [x必须为空格，即作为分组变量；使之堆叠在一个系列上] geom_bar(stat="identity",width = 1) + scale_fill_manual(values = c("red", "yellow")) + coord_polar("y") + labs(title = "Pac man") 123456789101112+ coord_polar(theta="x", direction=1, start=0 ) # 绘制饼图/雷达图# direction= 1，顺时针，-1，逆时针 start=0 12点钟弧度的起点偏移量# 地图投影library(mapproj)coord_map# 环形图library(gcookbook)ggplot(wind, aes(x=DirCat, fill=SpeedCat)) + geom_histogram(binwidth=5, origin=-7.5) + coord_polar() + scale_x_continuous(limits=c(0,360)) 原始图形123456library(ggplot2)dt = data.frame(A = c(2, 7, 4, 10, 1), B = c('B','A','C','D','E'))p = ggplot(dt, aes(x = "", y = A, fill = B)) + geom_bar(stat = "identity") + coord_polar(theta = "y") ## 把柱状图折叠成饼图（极坐标）p 去除饼图中心的杂点123456library(ggplot2)dt = data.frame(A = c(2, 7, 4, 10, 1), B = c('B','A','C','D','E'))p = ggplot(dt, aes(x = "", y = A, fill = B)) + geom_bar(stat = "identity", width = 1) + ## width &gt;= 1 时中心的杂点将消失 coord_polar(theta = "y") p 去除饼图旁边的标签、刻度须线12labs(x = "", y = "", title = "") + theme(axis.ticks = element_blank()) ## 把左上角多出来的“小胡子”去掉 图例12345678910111213141516171819# 去掉图例的标题，并将图例放到上面+ theme(legend.title = element_blank(), legend.position = "top") ## 将图例标题设为空，并把土方放在上方# 对图例的标签加上百分比library(ggplot2)dt = data.frame(A = c(2, 7, 4, 10, 1), B = c('B','A','C','D','E'))myLabel = as.vector(dt$B) ## 转成向量，否则图例的标签可能与实际顺序不一致myLabel = paste(myLabel, "(", round(dt$A / sum(dt$A) * 100, 2), "%) ", sep = "") ## 用 round() 对结果保留两位小数p = ggplot(dt, aes(x = "", y = A, fill = B)) + geom_bar(stat = "identity", width = 1) + coord_polar(theta = "y") + labs(x = "", y = "", title = "") + theme(axis.ticks = element_blank()) + theme(legend.title = element_blank(), legend.position = "top") + scale_fill_discrete(breaks = dt$B, labels = myLabel) ## 将原来的图例标签换成现在的myLabelp 按顺时针从大到小的顺序显示 数据源的排列顺序，需要与因子的顺序相同 或者 逆序排列 12345678910111213141516171819202122232425library(ggplot2)dt = data.frame(A = c(2, 7, 4, 10, 1), B = c('B','A','C','D','E'))dt = dt[order(dt$A, decreasing = TRUE),] ## 用 order() 让数据框的数据按 A 列数据从大到小排序# &gt; levels(dt$B)# [1] "A" "B" "C" "D" "E" A B 10 D 7 A 4 C 2 B 1 EmyLabel = as.vector(dt$B) myLabel = paste(myLabel, "(", round(dt$A / sum(dt$A) * 100, 2), "%) ", sep = "") p = ggplot(dt, aes(x = "", y = A, fill = B)) + geom_bar(stat = "identity", width = 1) + coord_polar(theta = "y") + labs(x = "", y = "", title = "") + theme(axis.ticks = element_blank()) + theme(legend.title = element_blank(), legend.position = "top") + scale_fill_discrete(breaks = dt$B, labels = myLabel) p 去掉白色外框上的数字1+ theme(axis.text.x = element_blank()) ## 白色的外框即是原柱状图的X轴，把X轴的刻度文字去掉即可 在图中加百分比12345678910111213141516171819202122library(ggplot2)dt = data.frame(A = c(2, 7, 4, 10, 1), B = c('B','A','C','D','E'))dt = dt[order(dt$A, decreasing = TRUE),]myLabel = as.vector(dt$B) myLabel = paste(myLabel, "(", round(dt$A / sum(dt$A) * 100, 2), "%)", sep = "") p = ggplot(dt, aes(x = "", y = A, fill = B)) + geom_bar(stat = "identity", width = 1) + coord_polar(theta = "y") + labs(x = "", y = "", title = "") + theme(axis.ticks = element_blank()) + theme(legend.title = element_blank(), legend.position = "top") + scale_fill_discrete(breaks = dt$B, labels = myLabel) + theme(axis.text.x = element_blank()) + geom_text(aes(y = A/2 + c(0, cumsum(A)[-length(A)]), x = sum(A)/20, label = myLabel), size = 5) # 在图中加上百分比：## x 调节标签到圆心的距离, y 调节标签的左右位置# cunsum(A) 累计和 # [-length(A)] 删除最后一个元素# sum(A)=24 /20 =1.2p 分面 在ggplot(aes()) 中不要指定group，其他正常即可。 生成饼环12345678910111213141516171819 + geom_bar(stat = "identity", width = 0.2) + ## 当width &lt; 1 时饼图将变成饼环 library(ggplot2)dt = data.frame(A = c(2, 7, 4, 10, 1), B = c('B','A','C','D','E'))dt = dt[order(dt$A, decreasing = TRUE),]myLabel = as.vector(dt$B) myLabel = paste(myLabel, "(", round(dt$A / sum(dt$A) * 100, 2), "%)", sep = "") p = ggplot(dt, aes(x = "", y = A, fill = B)) + geom_bar(stat = "identity", width = 0.2) + ## 当width &lt; 1 时饼图将变成饼环 coord_polar(theta = "y") + theme_bw() + labs(x = "", y = "", title = "") + theme(axis.ticks = element_blank()) + theme(legend.position = "none") + theme(axis.text.x = element_blank()) + geom_text(aes(y = A/2 + c(0, cumsum(A)[-length(A)]), x = sum(A)/24.5, label = myLabel), size = 5) p 去掉饼环之外的框框和中间的坐标线12theme(panel.grid=element_blank()) + ## 去掉白色圆框和中间的坐标线theme(panel.border=element_blank()) ## 去掉最外层正方形的框框 饼环 - geom_rect()123456789101112131415161718library(ggplot2)ad = data.frame(type = c("Poster", "Billboard", "Bus", "Digital"),n = c(529, 356, 59, 81))ad$fraction = ad$n / sum(ad$n)ad$ymax = cumsum(ad$fraction)ad$ymin = c(0, head(ad$ymax, n = -1))ggplot(data = ad, aes(fill = type, ymax = ymax, ymin = ymin, xmax = 4, xmin = 3)) + geom_rect(colour = "grey30", show_guide = FALSE) + coord_polar(theta = "y") + labs(x = "", y = "", title = "") + xlim(c(0, 4)) + theme_bw() + theme(panel.grid=element_blank()) + ## 去掉白色外框 theme(axis.text=element_blank()) + ## 把图旁边的标签去掉 theme(axis.ticks=element_blank()) + ## 去掉左上角的坐标刻度线 theme(panel.border=element_blank()) + ## 去掉最外层的正方形边框 geom_text(aes(x = 3.5, y = ((ymin+ymax)/2), label = type)) 折线图 geom_line()：分别指定一个变量映射给x和y x : 常规为连续变量；（显示为日期，但格式为字符串或因子，则必须转为 as_date() 格式） 若为离散型变量，需要通过factor()进行转换，此时必须使用aes(group=1)以确保知道这些数据点属于同一分组，从而应该用一条折现连在一起； 并且此时x轴的刻度值仅为因子型变量对应的分类值；若分类变量只有[1,2,4]，此时x轴的刻度也仅显示[1,2,4] ，不会出现3 position = position_dodge(0.2)：微调；左右移动0.2，来避免重叠 如果x变量时因子，必须同时告诉ggplot()用来分组的变量 123456789# x 为连续型变量ggplot(BOD, aes(Time, demand)) + geom_line()# x 为离散型变量ggplot(BOD, aes(x=factor(Time), y=demand, group=1)) + geom_line()# 通过expand_limit() 扩展y轴的范围ggplot(BOD, aes(Time, demand)) + geom_line() + expand_limits(y=0) # 等价于 ylim(0,max(BOD$demand)) 折线图 - 多重折线图 在分别设定一个映射给x和y的基础上，再将另一个（离散型）变量映射给颜色(color)或者线型(linetype) 如果x变量时因子，必须同时告诉ggplot()用来分组的变量，否则ggplot()会不知道如何将数据组合在一起绘制折线图 当分组不正确时，折线图会变成锯齿状；原因在于x在每个位置都对应于多个点，ggplot()误以为这些点属于同一组数据而将其用一条折现连接 当你的折线图看起来不太合理或呈现锯齿状时，是由于分组不明确，此时必须要用group明确指定分组变量 若当前数据无法实现，考虑转为长格式的数据结构 12345678910library(plyr) # 便于使用ddply()创建样本数据集tg &lt;- ddply(ToothGrowth, c("supp","dose"), summarise, length=mean(len))# 将supp映射给颜色 colorggplot(tg, aes(x=dose,y=length, color=supp)) + geom_line()# 将supp映射给线型 linetypeggplot(tg, aes(x=dose, y=length, linetype=supp)) + geom_line()## x变量为因子，必须指定分组的变量ggplot(tg, aes(x=factor(dose), y=length, color=supp, group=supp)) + geom_line() 折线图 - 添加数据标记 geom_point()：通过点来添加标记 position = position_dodge(0.2)：微调；左右移动0.2，来避免重叠 size / shape / color / fill ：调整标记样式 1ggplot(BOD,aes(Time,demand)) + geom_line() + geom_point() 折线图 - 线条样式 linetype、size、color 通过将参数传递给geom_line()设置折线图对应的属性 对多重折线图而言，设定图形属性会对所有折线产生影响 将变量映射给图形属性会使折线具由不同的外观。可用scale_color_brewer() 和 scale_color_manual() 来设定 1ggplot(BOD, aes(Time, demand)) + geom_line(linetype = "dashed", size= 1, color= "blue") 折线图 - 实例将数据转为长格式，然后分组作图，再分面 注意：当你的折线图看起来不太合理或呈现锯齿状时，是由于分组不明确，此时必须要用用group明确指定分组变量 1234567891011121314151617181920filter(data_all, 结算日期&gt;='2017-06-23',产品 %in% c('螺纹钢', '铁矿石')) %&gt;% melt(., id=c('结算日期','产品'),measure=c('平仓盈亏','持仓盈亏'), variable.name='盈亏类别',value.name='盈亏金额') %&gt;% ggplot(., aes(x=结算日期,y=盈亏金额, color=盈亏类别,group=(盈亏类别))) + geom_line() + facet_wrap(~产品, nrow=2)# 示例数据结算日期 产品 盈亏类别 盈亏金额2017-06-23 铁矿石 平仓盈亏 1258.4252017-06-23 螺纹钢 平仓盈亏 1453.0102017-06-26 铁矿石 平仓盈亏 285.3902017-06-26 螺纹钢 平仓盈亏 -2260.4402017-06-27 铁矿石 平仓盈亏 2133.4952017-06-27 螺纹钢 平仓盈亏 -2947.1002017-08-04 铁矿石 持仓盈亏 -2781.8702017-08-04 螺纹钢 持仓盈亏 5427.8662017-08-07 铁矿石 持仓盈亏 2444.0152017-08-07 螺纹钢 持仓盈亏 28933.5602017-08-08 铁矿石 持仓盈亏 13062.5652017-08-08 螺纹钢 持仓盈亏 10053.853 日期格式的作图 x轴转为指定的日期形式的字符串格式 通过format 函数可以提取任意部分的日期，包括日期、星期几 format(x, format=””) 123456789with(data_source_zhibo,&#123; data_source_zhibo$日期 &lt;- format(data_source_zhibo$日期,format='%m/%d') # format格式转化为后字符串格式 data_source_zhibo$首席分析师 &lt;- factor(data_source_zhibo$首席分析师, levels=c("黄伟","夏飞龙","陈明燕","王健")) ggplot(data_source_zhibo, aes(x=日期, y =最大并发与IP量之比, color=首席分析师,group=首席分析师)) + # 注意group=xxx geom_line(size=0.7) + theme_classic() + labs(title="最大并发与IP量之比", y=NULL) + theme(axis.text.x=element_text(angle=90, vjust=0.5),plot.title=element_text(hjust=0.5, face="bold"), panel.grid.major.y = element_line(color="grey50"))&#125;) 日期格式 1234library(sacles)ggplot(data_source_zhibo, aes(x=日期, y =最大并发与IP量之比, color=首席分析师)) + geom_line() + scale_x_date(brekas=data_source_zhibo$日期, labels=date_format("%m%d")) 面积图 geom_area()：绘制面积图 默认情况下，面积图的填充色为黑灰色，且没有边框线； 若添加边框线令 color = “black” 会使得底部有一条横线，且在起点和终点的位置有一条垂直线；此时可通过不设定color，并用geom_line()绘制轨迹线 fill / color / alpha ：调整样式 123ggplot(sunspotyear, aes(x=Year, y= Sunspots)) + geom_area(fill="bule", alpha=0.2) + geom_line() 面积图 - 堆积 geom_area()：运行geom_area，并映射一个因子型变量给填充色（fill）即可； 图例翻转：brekas；默认情况下，图例的顺序与面积图的顺序是相反的；通过设定标度中的切分（breaks）参数来翻转堆积顺序 图形堆积翻转：在aes()内部设定order=desc(col) size = 0.2 ；在各个区域之间添加细线 alpha = 0.4 ；将填充区域设置为半透明 123456789101112library(gccokbook) # 为了使用数据ggplot(uspopage, aes(x=Year, y=Thousands, fill=AgeGroup)) + geom_area()# 图例翻转 breaks=rev(levels(data$col))ggplot(uspopage, aes(x=Year, y=Thousands, fill=AgeGroup)) + geom_area(color="black", size=0.2, alpha=0.4) + scale_fill_brewer(palette="Blues", breaks=rev(levels(uspopage$AgeGroup)))# 翻转面积图的堆积顺序ggplot(uspopage, aes(x=Year, y=Thousands, fill=AgeGroup, order=desc(AgeGroup))) + geom_area(color="black", size=0.2, alpha=0.4) + scale_fill_brewer(palette="Blues") 绘制没有边框线的面积图：先绘制一个不带边框线的面积图（color=NA），然后在其顶部添加geom_line() 1234ggplot(uspopage,aes(Year, Thousands, fill=AgeGroup, order=desc(AgeGroup))) + geom_area(color=NA, alpha=0.4) + scale_fill_brewer(palette="Bluese") + geom_line(position="stack", size=0.2) 面积图 - 百分比堆积 先要计算各组对应的百分比，将该百分比列映射给y 12345678library(gcookbook) # 为了使用数据# 将Thousands转化为百分比uspopage_prop &lt;- ddply(uspopage, "Year", transform, Percent = Thousands / sum(Thousands)*100) # 对每一行做运算# 映射与绘制ggplot(uspopage_prop, aes(Year, Percent, fill=AgeGroup)) + geom_area(color="black", size=0.2, alpha=0.4) + scale_fill_brewer(palette="Blues", breaks=rev(levels(uspopage_prop$AgeGroup))) 添加置信域 阴影的置信域：运行geom_ribbon()，之后分别映射一个变量给 ymin 和 ymax 1234567library(gcookbook) # 为了使用数据clim &lt;- subset(climate, Source=="Berkeley", select=c("Year","Anomaly10y","Unc10y"))# 将置信域绘制为阴影ggplot(clim, aes(x=Year, y= Anomaly10y)) + geom_ribbon(aes(ymin=Anomaly10y-Unc10y, ymax=Anomaly10y+Unc10y),alpha=0.2) + geom_line() # geom_ribbon 绘制的顺序在geom_line()之前是为了使折线绘制在阴影区域上面的图层，使折线更清晰 虚线的置信域：运用多个geom_line()，分别将上下边界映射给y 1234ggplot(clim, aes(Year, Anomaly10y)) + geom_line(aes(y=Anomaly10y-Unc10y), color="gery50", linetype="dotted") + geom_line(aes(y=Anomaly10y+Unc10y), color="gery50", linetype="dotted") + geom_line() 散点图 geom_point()：分别映射一个变量到x和y shape = 3；设置不同的的点型 size = 2(默认)； 设置点的大小 color = ；点的轮廓色 fill = ；填充色； 散点图 - 分组 将分组变量映射给点型(shape)和颜色(color)属性 分组变量必须是分类变量（即必须是因子型或字符串型的向量），可用factor转化后进行映射 1234ggplot(heightweihgt, aes(ageYear, heightIn, color=sex)) + geom_point()# 将一个变量同时映射给 shape 和 colorggplot(heightweihgt, aes(ageYear, heightIn, shape = sex, color=sex)) + geom_point() 自定义分组变量的点型与颜色： scale_shape_manual(values=c(1,2)) scale_color_brewer() / scale_color_manual(values=c()) 当填充色为NA时，会形成一个空心的形状 散点图 - 连续型变量 当变量超过2个时，必须将它们映射到其他图形属性上，比如点的大小和颜色； 人类对于感知空间位置的微小变化很擅长，但对于图形颜色和大小的变化不敏感；因此，只有当一个变量不需要高精度的解释时，它才被适合映射给图形的大小和属性 size= 2 ；控制大小；将某个变量映射给size属性时，最好避免将其他变量映射给shape属性；因为不同点型的点大小很难相互比较 scale_size_continuous(range=c())：修改数据点大小的变化范围；默认情况下为1~6ms 当映射给大小(size)属性时，绘制的图形结果往往具有误导性；最大点对应的面积为最小点的36倍，但在数值上仅3.5倍； 即使修改数据点的范围，但由于点的大小与点的直径或面积是非线性的，所以这个表示值依然不精确 color / fill ：对于大多数点型，通过color属性设定颜色 点型21-25 除了实心区域，还有边框线，此时可通过fill来控制 当数据点颜色较浅时，带框线的点型就会很有用 123ggplot(heightweight, aes(ageYear, heightIn, fill=weightLb)) + geom_point(shape=21, size=2.5) + scale_fill_gradient(low="black",high="white", breaks=seq(70,170,20), gudie =guide_legend()) 散点图 - 图形重叠 图形的重叠度较低时 较小(size)的数据点 不会遮盖其他数据点的点形（例如1号空心圆） 图形重叠度较高时 使用半透明(alpha)的点 将数据分箱(bin)，并用矩形表示（适用于量化分析） stat_bin2d() stat_bin2d() 函数分别在x轴和y轴方向上将数据分隔为30个组，总计900个箱子 通过scale_fill_gradient() 设定数据点的颜色，并制定最小色阶low 和最大色阶high 默认情况下，图例中不包括最小值，因为颜色标度的范围不是从0开始，而是以各箱中的最小非零值为起始点；若要包括零值，可调用limits参数手动这顶范围为0到最大值 将数据分箱(bin)，并用六边形表示hexbin::stat_binhex() （需先安装hexbin包） 增加随机扰动： position_jitter() 等价于 geom_point(position=”jitter”) 当散点图的其中一个或两个数据周对应离散型数据时，会出现重叠的情况 默认情况下，position_jitter() 在每个方向上添加的扰动值为数据点最小精度的40%；但可通过width 和 height 进行调整 使用箱线图 当数据集对应一个离散型和一个连续型数据时，箱线图时一种比较好的展示方式 123456789# 分箱 - 矩形sp + stat_bin2d(bins=30) # 默认为30# 分箱 - 六边形sp + stat_binhex()# 添加随机扰动sql &lt;- ggplot(ChickWeight, aes(Time, weight))sql + geom_point(position = position_jitter(width=0.5,height=0)) 散点图 - 回归拟合线 向散点图中添加线型回归拟合线 stat_smooth()：设定method=lm 即可向散点图中添加线型回归拟合线 若散点图进行了分组，并将分组变量映射给color和shape属性，则会分别添加拟合线 method = loess(默认)；设置拟合的模型 loess曲线 ： 局部加权多项式 method = glm, family=binomial ：添加Logistic回归拟合线 lm ，线性回归 se = FALSE ；控制置信区间；若为会TRUE，会添加95%的置信域 level = 0.95 ；控制置信域的水平 color / linetype / size ：控制拟合线的属性 为了突出直线，可设置点的 color 以使数据点不那么突出 fullrange=TRUE；默认为FALSE，支持外推的模型；正常情况下，loess()函数只能根据数据对应的x轴的范围进行预测 123456library(gcookbook)sp &lt;- ggplot(heightweight, aes(ageYear, heightIN))sp + geom_point() + stat_smooth(methdo=lm)# 99%置信域sp + geom_point() + stat_smooth(method=lm, level=0.99) 散点图 - 根据已有模型添加拟合线 我们需要建立自己的模型，再将模型添加到散点图上 无论哪种模型，只要有对应的predict() 方法，都可以用来绘制拟合线 lm() 与 loess() 函数对应的方法分别是 predict.lm() 和 predict.losee() 1234567891011121314151617library(gcookbook)model &lt;- lm(heightIn ~ ageYear + I(ageYear^2), heightweight)model # 查看模型# 创建一个包含变量的ageYear列，并进行插值xmin &lt;- min(heightweight$ageYear)xmax &lt;- max(heightweight$ageYear)predicted &lt;- data.frame(ageYear=seq(xmin, xmax, length.out=100))# 计算变量heightIn的预测值predicted$heightIn &lt;- predict(model, predicted)predicted# 将数据点和模型预测值一起绘制sp &lt;- ggplot(heightweight, aex(ageYear, heightIn)) + geom_point(color="grey40")sp + geom_line(data=predicted, size=1) 散点图 - 添加多个模型的拟合线 散点图 - 添加模型系数 散点图 - 编辑地毯 边际地毯图本质上是一个一维的散点图，可被用于展示每个坐标轴上数据的分布情况 geom_rug()：添加边际地毯图 1ggplot(faithful, aes(eruptions, waiting)) + geom_point() + geom_rug() 散点图 - 标签 散点图 - 气泡图 geom_point() + scale_size_area() ：通过这两者绘制气泡图 若直接将变量GDP映射给size属性，则GDP的值被映射给了点的半径；此时变量增加一倍时，点的面积会变为原来的4倍；这并不是我们想要的 1234567library(gcookbook)cdat &lt;- subset(contries, Year==2009 &amp; Name %in% c("Canda", "Ireland","United Kingdom"))# 绘制气泡图p &lt;- ggplot(cdat, aes(healthexp, infmortality, size=GDP)) + geom_point(shape=21, color="blcak", fill="cornsilk") + scale_size_area(max_size=15) # 得到一个较大的圆 其他用法：当x轴和y轴均为分类变量时，气泡图可以用来表示网格点上变量值 12345678910# 对男性组和女性组求和hec &lt;- HairEyeColor[,,"Male"] + HairEyeColor[,,"Female"]# 转为长格式library(reshape)hec &lt;- melt(hec, value.name="count")ggplot(hec, aes(Eye, Hari)) + geom_point(aes(size=count), shape=21, color="black", fill="cornsilk") + scale_size_area(max_size=20, guide=FALSE) + geom_text(aes(y=as.numeric(Hari)-sqrt(count)/22, label=count), vjust=1, color="grey60", size=4) # 文本是灰色的，为了削弱文本的突出性，避免圆圈的展示 散点图 - 散点图矩阵 数据标签 - geom_text() 运行geom_bar() 和 geom_text() 时，需要分别指定一个变量映射给x、y和标签本身 geom_text() 通过设定y轴的范围，使得标签在绘图区域内；geom_text(aes(y=Weight+0.1, label=Weight)) 当标签被置于顶端上方有可能使数据标签溢出绘图区域。 使用标签数据时，对堆叠顺序的调整最好是通过在计算累计和之前修改因子的水平顺序 x ,y = colname ; 表示范围 label = colmame；显示的标签名 alpha = color = size = 5 (默认)； hjsut /vjust = 0(right/bottom) 和 1(left/top) 0，表示左对齐/底部对齐； 形同PPT的对象对齐；而非表格的左右对齐 1，表示又对齐/顶部对齐； 字符串(“left”,”right”,”middle”,”bottom”,”center”,”top”); 字符串 (“inward”,”outward”) nudge_x=0 ; nudge_y=0 ；x轴方面，微调 12345678910111213library(gcookbook)ggplot(cabbage_exp, aes(x=interaction(Date, Cultivar), y=Weight)) + geom_bar(stat="identity") + gemo_text(aes(label=Weight), vjust=1.5, color="white") # 标签在顶端下方# vjust = -0.2 # 标签在顶端上方 # 设定标签的y轴位置使其略高于条形图顶端 —— y轴范围会自动调整ggplot(cabbage_exp, aes(x=interaction(Date,Cultivaar),y=Weight)) + geom_bar(stat="identity") + geom_text(aes(y=Weight+0.1, label=Weight))# geom_text(aes(label=Weight), vjust=1.5, color="white", position=position_dodge(0.9), size=3) # 保持标签与条形宽度一致；因为分类间距默认为0.9 参数与外观设置 坐标轴、图例、注解、外观、分面、配色 标度 &amp; 主题元素一览标度变换 - scale 位置标度： scale_x_discrete() / scale_x_continuous() 颜色标度：scale_fill_xxx() / scale_color_xxx() 图例标度： 主题元素函数 ?theme 可获得全部的信息 element_text() face=”” # 字体格式 “bold” - 加粗 ；”italic” - 斜体 ；”bold.italic” - 粗斜体；”plain” - 无格式的 color = size = num ; size = rel( n ) 当前字体的n倍 hjust /vjust = [0,1] # 对齐方式类同PPT的根据元素对齐 angle = [0,360] lineheight = num # 行高 element_line() linetype = [0,6] 1- solid 实线； 2-虚线 dashed；3-点 dotted；4 - 破折号 dotdash；5 - 长破折号 longdash；6-双破折号 twodash color = size = element_rect() linetype = size = color = “” fill = “” element_blank() 坐标轴 theme(axis.) 坐标系 翻转 coord_flip() 刻度范围 - 显示域 coord_cartesian( xlim=c(), ylim=c()) 坐标轴 显示名称 + 外观 labs(x=””, y=”” ) theme(axis.title.x = element_text(…) ) # 外观设置 刻度范围 - 定义域 xlim() / ylim() scale_x_discrete() / scale_x_continuous() limits = c(“”) / c(0,10) expand_limits(x=, y=) 刻度标签 - 显示 + 外观 scale_x_discrete() / scale_x_continuous() breaks=c(“”) / c(0,5,10) labels=c(“”) / c() # 若设置了labels，必须同时指定breaks theme(axis.text.x = element_text() ) # 刻度标签外观 刻度标签 - 反转 scale_x_discrete( limits=rev(levels( data$colname ))) # 离散型 scale_x_reverse() # 连续型 scale_x_reverse(limits=c(3,0)) # 反转，并设定定义域 刻度线 theme(axis.ticks = element_blank() ) # 刻度线位置等于标签显示的位置 x / y 轴缩放比例 coord_fix() ：使得x/y轴为1:1 通过scale_x/y_continuous(breaks=seq(0,420,30) ) 坐标轴直线 theme(axis.line = element_line(…)) 交换x轴和y轴 coord_flip() ：翻转坐标轴 坐标轴值域 - 连续型 ylim() 是 scale_y_continuous() 的简便写法，两者应避免同时出现；若要设置除值域外的其他属性，则一定要统计使用scale_y_continuous() ggplot2中有2两种方式修改坐标轴值域 修改标度：任何在范围以外的数据都会被移除；即超出的数据不仅不糊被展示，而且会被完全移出处理的数据范围，并且会使图形改变 ylim() / scale_x_discrete() / scale_x_continuous() 应用一个坐标变换：数据不会被修剪；它只是放大或缩小到指定的范围 coord_cartesian(ylim=c()) 123456p &lt;- ggplot(PlantGrowth, aes(group, weight)) + geom_boxplot() p + ylim(0, 10) # 设置值域的一种方法p + scale_y_continuous(limits=c(0,10), breaks=c(0,5,10)) # 设置值域，并设定了刻度线放置在0,5,10的位置p + expand_limits(y=0) # 通过单向扩展值域，但不能用它来缩减值域 坐标轴 - 项目的顺序 离散型变量排序的翻转：scale_x_discrete(limits=rev(levels(…))) limits= c(“trt1”,”trt2”) ；指定显示的项目与顺序 连续型变量排序的翻转：scale_x_reverse() 123456789# 离散型变量排序翻转p &lt;- ggplot(PlantGrowth, aes(group, weight)) + geom_boxplot() p + coord_flip() + scale_x_discrete(limits=rev(levels(PlantGrowth$group)))# 连续型变量排序翻转p + scale_y_reverse()p + scale_y_reverse(limits=c(3,0)) # 翻转并设定值域 坐标轴 - 缩放比例 x / y 的比例 coord_fixed()：得到x轴和y轴之间 1:1 的缩放结果 所指的1:1缩放是单位长度表示的数值范围是1:1，从而形成正方形的绘图区域 1234567library(gcookbook) # 为了使用数据sp &lt;- ggplot(marathon, aes(Half, Full)) + geom_point()sp + coord_fixed()sp + coord_fixed() + scale_y_continuous(breaks=seq(0,420,30)) + sacle_x_continuous(breaks=seq(0,420,30)) # 使x与y轴两者的刻度线相同 坐标轴 - 刻度线刻度线 - 位置 scale_x_continuous(breaks=)：指定显示的刻度线 breaks=c(“4,4.25, 4.5”) ：离散型 brekas=seq(0,40,10) ：连续型 刻度线和标签 - 移除 对于连续型坐标轴，ggplot()会在每个breaks值的位置放置刻度线、刻度标签和主网格线； 对于离散型坐标轴，这些元素会出现在每个limits的位置 theme(axis.text.y=element_blank())：移除标签 theme(axis.ticks=element_blank())：移除刻度线 坐标轴 - 刻度标签设置与修改文本 通过标度scale_x_discrete/continuous中的breaks和labels进行赋值 随ggplot2安装的scales包自带了一些内建的格式化函数： comma() ：在千、百万、十亿等位置向数字添加逗号 dollar()：添加一个美元符号并舍入到最近接的美分 percent()：乘以100，舍入到最接近的整数值，并添加一个百分号 scientific()：对大数字和小数字给出科学计数法都表示， 如3.30e+05 1234567891011121314151617181920212223242526library(gcookbook)hwp &lt;- ggplot(heightweight, aes(ageYear, heightIn)) + geom_point() + scale_y_continuous(breaks=c(50,56,60,66,72), labels=c("Tiny","Really\nshort","Short","Medium","Tallish"))## 以某种格式存储标签# 身高格式，显示为5'6'',通过自定义函数来完成footinch_formatter &lt;- function(x)&#123; foot &lt;- floor(x/12) inch &lt;- x %% 12 return(paste(foot, "'",inch,"\"", sep=""))&#125;footinch_formatter(56:64)[1] "4'8\"" "4'9\"" "4'10\"" "4'11\"" "5'0\"" "5'1\"" "5'2\"" [8] "5'3\"" "5'4\"" hwp + sacle_y_continuous(labels=footinch_formatter)# 将时间测度转化为HH:MM:SS或其他的格式timeHMS &lt;- function(x)&#123; h &lt;- floor(x/60) m &lt;- floor(x %% 60) s &lt;- round(60*(x %% 1)) # 舍入到最接近的秒数 lab &lt;- sprintf("%02d:02d:02d",h,m,s) # 格式化字符串为HH:MM:SS的格式 lab &lt;- gsub("^00:","", lab) # 如果开头存在00:，则移除 lab &lt;- gsub("^0", "", lab) # 如果开头存在0，则移除 return(lab)&#125; 坐标轴 - 刻度标签的外观 旋转、对齐、大小、颜色等 theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5))：旋转标签 element_text()的其他文本属性 color / size / face / family size = rel(0.8) ：表示当前字体大小的0.9倍; 坐标轴 - 坐标轴标签(名称)坐标轴标签 - 修改 labs(x=””, y=”” ) ：修改坐标轴的标签 xlab / ylab(“”) ：修改坐标轴的标签 坐标轴标签 - 移除 theme(axis.title.x=element_blank())：移除坐标轴标签，且不会为其留出空间 lab(x=””) ：只是将其设置为空白 坐标轴标签 - 外观 theme(axis.title.x = element_text())： 坐标轴 - 直线 theme(axis.line=element_line(clolor=”black”))：沿坐标轴显示直线 lineend = “square” ：可将坐标轴直线边界的末端进行重叠 若最初使用的主体在绘图区域的周边就有一条线（如theme_bw()），需要同时重置参数panel.border 12p + theme_bw() + theme(panel.border=element_blank(), axis.line=element_line(color="black")) 对数坐标轴 scale_x_log10() / scale_y_log10() ：设置对数坐标轴 123456library(MASS) # 使用数据p &lt;- ggplot(Animals, aes(x=body, y=brain, label=rownames(Animals))) + geom_text(size=3)# 使用对数坐标轴p + scale_x_log10() + scale_y_log10() scales包中的 trans_format()：刻度标签使用指数计数法 12345678# 使用指数计数法的刻度标签library(scales)p + scale_x_log10(breaks = 10^(-1:5), labels=trans_format("log10", math_format(10^.x))) + scale_y_log10(breaks = 10^(0:3), labels=trans_format("log10", math_format(10^.x))) # 使用自定义的变换p + scale_x_continuous(trans= log_trans(), breaks=trans_breaks("log", function(x) exp(x)), labels=trans_format("log", math_format(e^.x))) + scale_x_continuous(trans= log_trans(), breaks=trans_breaks("log2", function(x) 2^x), labels=trans_format("log2", math_format(2^.x))) annotation_logticks()：添加刻度 坐标轴 - 日期 ggplot2可以处理两类时间对象：日期对象（类为Date的对象），日期时间对象（类为POSIXt的对象） 使用 日期格式的函数，对象必须为日各 as.Date / as_date()：注意转化为日期格式 scale_x_date()：特定的日期格式坐标轴函数（Date格式） scale_x_datetime()：特定的时间格式坐标轴函数（POSIX格式） scale_x_time() ：特定的时间格式的坐标轴函数（HMS格式） breaks： date_breaks：两者同时出现时，以date_breaks为准； labels = 指定具体的标签内容 date_labels= “%Y/%m/%d %H:%M:S” ：指定标签的格式； 两者同时出现时，以date_labels为准； 123456789101112131415161718192021222324252627282930313233library(gcookbook)ggplot(economics, aes(date, psavert)) + geom_line()# 设置需要的日期序列econ &lt;- subset(economics, date &gt;= as.Date("1992-05-01") &amp; date &lt; as.Date("1993-06-01") ) # 选取子集# 基本图形p &lt;- ggplot(econ, aes(date, psavert)) + geom_line()# 指定一个日期向量为分割点datebreaks &lt;- seq(as.Date("1992-06-01"), as.Date("1993-06-01"), by="2 month")# 使用分割点并旋转文本p + scale_x_date(breaks=datebreaks) + theme(axis.text.x = element_text(angle=30, hjust=1))# 指定格式 - scales::date_formatlibrary(scales)p + scale_x_date(breaks=databreaks, labels=date_format("%Y %b")) + theme(axis.text.x = element_text(angle=30, hjust=1))##----------------------------------#日期格式df &lt;- data.frame( date = Sys.Date() - 0:29, count = runif(30))tu &lt;- ggplot(df, aes(date, count)) +geom_line()## 下面两个语句的画图结果都是同一个图#1、在lables和date_labels同时出现的情况下，系统会优先使用date_labels设置#2、在时间设置方面，date_labels,以及date_breaks 设置要比 labels和breaks设置要简洁得多。tu+scale_x_date(breaks=as.Date(c("2016-06-06","2016-06-13","2016-06-20","2016-06-27")), labels=c("06-06","06-13","06-20","06-27"),date_labels="%y/%m/%d")tu+scale_x_date(date_labels="%y/%m/%d") 结合scales包完成分隔与格式 date_breaks(width=”1 month”) 截断内容除了days，以外还可以用“auto”, “secs”, “mins”, “hours”, “weeks”等对数据进行分割显示。 date_format(format=”%y-%m-%d”) 123456# 时间格式df &lt;- data.frame( date = as.POSIXct(Sys.Date() - 0:29), count = runif(30))tu + scale_x_datetime(breaks=date_breaks("10 days"),labels=date_format("%m/%d") ) 作图指定的坐标轴日期格式 axis.POSIXct {graphics}：Functions to plot objects of classes “POSIXlt”, “POSIXct” and “Date” representing calendar dates and times. axis.POSIXct(side, x, at, format, labels = TRUE, …) axis.Date(side, x, at, format, labels = TRUE, …) x, at：A date-time or date object. side ：See axis.format：See strptime. 坐标轴 - 相对时间 方法一：手动指定跟个点和标签： scale_x_continuous(breaks=c(), labels=c()) 方法二：自定义一个格式刷函数 图例 图例 - 概览；图例是根据aes美学来进行绘制的 theme属性是用来修改外观的 图例的整个控制 存在与否 guides(fill=FALSE) theme(legend.position=”none”) 位置相关 theme(legend.position=”” ) : left / right / bottom / top theme(legend.position=c(0, 1) ) : theme(legend.justification=c(0,1) ) : 整体背景 theme(legend.background = element_rect() ) 图例的细节部分 内部顺序 guides( fill=guide_legend(reverse=TRUE ) scale_fill_discrete(limits=c(“”)) 标题 labs(fill=”name”) / labs(fill=NULL) theme(legend.title = element_text()) / element_blank() 文本标签 scale_fill_discrete(labels=c()) theme(legend.text = element_text()) 图例符号 theme(legend.key = element_rect()) 宽度、列数、方向等 guides( fill = guide_legend( … ) ) keywidth = 5 ；宽度 direction = “horizontal” / “vertical” nrow / ncol = 2 ；图例内部的行列数 图例 - 添加 同一图形中添加图例 不同图形中添加图例： scalexxx 需紧跟在该几何对象geom_之后 若希望图例的合并，则需要使用同一种标度； 123456789101112131415161718192021# 同一图中出现三种颜色，并显示图例ggplot(dd) + geom_line(aes(x=fecha, y=value, colour=variable)) + scale_colour_manual(values=c("red","green","blue"))#----------------------# 不同图形中添加图例ggplot(qian_all_data_top22,aes(x=factor(format(as_date(日期),format="%m-%d")))) + geom_bar(aes(y=IP总量,fill="red"),stat="identity",width=0.5) + scale_fill_manual(breaks="red",fill="#95B3D7") + # scale紧跟在几何对象之后 # ylim(c(2000,max(qian_all_data_top22$IP总量))) + expand_limits(y=0) geom_line(aes(y=最大并发数,group=1,color="black")) + scale_color_manual(breaks="black",values="black") + geom_point(y=qian_all_data_top22$最大并发数,size=1) + geom_text(aes(y=IP总量,label=comma(IP总量)),vjust=-1) + geom_text(aes(y=最大并发数,label=comma(最大并发数),vjust=-1)) + scale_y_continuous(label=NULL) + theme_classic() + theme(axis.ticks.y = element_blank(), axis.line.y=element_blank()) + theme(plot.title=element_text(hjust=0.5, face="bold",size=rel(1.4))) + labs(title="IP量与最大并发数",x=NULL) 图例 - 移除 guides(…=FALSE) ：指定需要移除图例的标度 scale_fill_discrete(guide=FALSE)：在对应的标度中设置为FALSE scale_fill_hue() / scale_fill_discrete() / scale_fill_manual() / scale_fill_grey() / scale_fill_brewer() / scalecolor… / scale_shape_manual / scale_linetype theme(legend.position=”none”)：使用主题系统移除，会移除所有图例 12345678910p &lt;- ggplot(PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot()# 移除标度fill的图例p + guides(fill=FALSE)# 移除标度fill的图例p + scale_fill_discrete(guide=FALSE)# 移除所有图例theme(legend.position="none") 图例 - 位置 theme(legend.position=””) ：选择不同的参数来放置图例的位置 top / bottom / left / right / none theme(legend.position=c(1,1)) ：确定图例的中心放置在给定坐标轴的位置 默认为c(0.5,0.5) theme(legend.justification=c(1,1)) ：指定图例放置在绘图区的位置 图例 - 顺序 反转顺序：guides(fill=guide_legend(reverse=TRUE)) 自定义顺序：scale_fill_discrete(limits=c())将对应标度的参数limits设置为所需的顺序 1234p &lt;- ggplot(PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot()# 修改项目顺序p + scale_fill_discrete(limits=c("trt1","trt2","ctrl")) 图例 - 标题标题 - 名称 labs(fill=””) ：通过labs并指定对应图例的图形属性的值 可同时修改不同图例对应的标题 scale_fill_discrete(name=””) ：在设定标度时设定图例标题 12345p + labs(fill="Condition")p + scale_fill_discrete(name="Condition")# 同时修改不同图例对应的标题p + labs(shape="Male/Female", color="Male/Female") 标题 - 外观 theme(legend.title = element_text(…))：更改图例标题的外观 标题 - 移除 labs(fill=NALL) guides(fill = guide_legend(title=NULL)) scalefill…(guide=guide_legend(title=NULL)) 图例 - 标签文本标签 - 名称 scale_fill_discrete(labels=c(“”)) ：修改图例标签的文本 只修改了图例的标签，并没有修改x轴的因子水平；若修改x轴的因子水平，采用scale_x_discrete 12library(gcookbook)p + scale_fill_discrete(labels=c("Control","Treatment","Treatment 1","Treatment 2")) 标签 - 外观 theme(legend.text = element_text(face=””, color=””, size=14, family=””)) ：修改标签的外观 guides(fill=guide_legend(label.theme= element_text(…))) 标签 - 多行文本 标度中设置 labes 参数，使用\n 表示新行 grid包的unit()函数指定高度：可能出现各行文本相互叠加，通过theme()增加图例说明的高度，并减少各行的间距 123456p + scale_fill_discrete(labels=c("Control","Type 1\ntreatment","Type 2\ntreatment"))# 增加图例高度并减少各行间距library(gird)p + scale_fill_discrete(labels=c("Control","Type 1\ntreatment","Type 2\ntreatment")) + theme(legend.text = element_text(lineheight=0.8), legend.key.height=unit(1, "cm")) 注解注解 - 文本 annotate()：添加一个文类几何对象 “text” x = , y = ； 指定添加的坐标轴位置；若坐标轴是连续型的，可以使用特殊值Inf / -Inf将其放置在区域的边缘 label = “” ；标签文字 1p + annotate("text", x=3, y=48, label="Group 1", family="serif", fontface="italic", color="darkred", size=3, alpha=0.8) 注解 - 数学表达式 annotate(geom=”text”, parse=TRUE) 在R的数学表达式中，不能简单把一个变量直接放在另一个变量旁而不在中间加上任何记号；若要显示两个相邻的变量，需要在中间放置一个星号*；在显示图形时，它会被当做一个不可见的乘号对待； 若要显示一个可见的乘号，采用%*% 1p + annotate("text", x=2, y=0.3, parse =TRUE, label = "frac(1,sqrt(2*pi"))*e^&#123;-x^2/2&#125;")" 注解 - 直线 geom_hline() / geom_vline() ：添加横线、竖线 geom_abline() ：添加有角度的直线 1234567p &lt;- ggplot(heightweight, aes(x=ageYear, y=heightIn, color=sex)) + geom_point()# 添加横线和竖线p + geom_hline(yintercept=60) + geom_vline(xintercept=14)# 添加有角度的直线p + geom_abline(intercept=37.4, slope=1.75) 将值从数据映射到xintercept / yintercept之上，甚至是绘制另一个数据框中的值 123library(plyr)hw_means &lt;- ddply(heightweight, "sex", summarise, heightIn=mean(heightIm))p + geom_hline(aes(yintercept=heightIn, color=sex), data=hw_means, linetype = "dashed", size=1) 当坐标轴是离散型的，必须以数字的形式指定它们 假设坐标轴表示一个因子，第一个水平为数值1，一次类推 1234pg &lt;- ggplot(PlantGrowth, aes(x=group, y=weight)) + geom_point()pw + geom_vline(xintercept = 2)pw + geom_vline(xintercept = which(levels(PlantGrouwht$group)=="ctrl")) 注解 - 线段和箭头 annotate(“segment”)：使用segment grid包中arrow() 函数可向线段两端添加箭头和平头 angle=30(默认) length=0.2 英寸(默认，0.508厘米) 123library(grid)p + annotate("segment", x=1850, xend=1820, y=-0.8, yend=-0.95, color="blue", size=2, arrow=arrow()) + annotate("segment", x=1950, xend=1980, y=-0.25, yend=-0.25, arrow=aroow(ends="both", angel=90, length=unit(0.2,"cm"))) 注解 - 矩形阴影 annotate(“rect”)：使用rect xmin / xmax / ymin / ymax alpha fill = “” 1p + annotate("rect", xmin=1950, xmax=1980, ymin=-1, ymax=1, alpha=0.1, fill="blue") 注解 - 高亮某元素 需在数据中创建一个新列，并将其映射为颜色； 若仅有少量元素要高亮，可以使用原始变量并为每个水平指定颜色，而不必创建新列 12345678910pg &lt;- PlantGrowthpg$h1 &lt;- "no"pg$h1[pg$group=="trt2"] &lt;- "yes"ggplot(pg, aes(x=group, y=weight, fill=h1)) + geom_point() + scale_fill_manual(values=c("grey85","#FFDDCC"), guide=FASLE)# 根据group列设定三个水平ggplot(PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_point() + scale_fill_manual(values=c("grey85","grey85","#FFDDCC"), guide=FASLE) 注解 - 误差线 geom_errorbar()：添加误差线，并将变量映射到 ymin 和 ymax 注解 - 向独立分面添加注解 使用分面变量创建一个新的数据框，并设定每个分面要绘制的值 配合新数据框使用geom_text() 若使用annotate()将在所有分面上显示 12345678910# 基本图形p &lt;- ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + facet_grid(.~drv)# 存有每个分面所需标签的数据框f_labels &lt;- data.frame(drv=c("4","f","r"), label=c("4wd","Front","Rear"))p + geom_text(x=6, y=40, aes(lable=label), data=f_labels)# 如果使用annotate()，标签将在所有分面上出现p + annotate("text", x=6, y=42, label="label text") 图形整体外观 标题 labs(title=””, subtitle=””) theme(plot.title=element_text()) 网格线 theme(panel.grid.major = element_line() ) theme(panel.grid.minor =element_line() ) theme(panel.grid.major.x ) / theme(panel.grid.minor.x) 面板 theme(panel.border = elment_rect() ) # 面板边界 theme(panel.background = element_rect() ) # 面板背景 外观 - 图形标题 labs(title=””)：设置图形标题 将标题移动到绘图区内部 ：使用一个文本注解annotate()，设定其x的位置为x值域的中间，y的位置为Inf；同时需要vjust为正值，使文本完全落入绘图区域 123456library(gcookbook)p &lt;- ggplot(heightwe)# 移动到标题内部 ggtitleggplot(heightweight, aes(ageYear, heightIn)) + geom_point() + annotate("text", x=mean(range(heightweight$ageYear)), y=Inf , label="Age and Height\nof Schoolchildren", vjust=1.5) 外观 - 文本 theme(plot.title = element_text())：完成外观的设置 family ：字体 face(主题元素) /fontface (文本几何对象)： color ：文字颜色；颜色名称，或 “#RRGGBB”形式的十六进制颜色代码 size ：字体大小；（主题元素的单位是磅，几何对象的单位是毫米） size= rel(1.5) ，表示转为当前主题字体大小的1.5倍 hjust ：横向对齐；0=左对齐；1=右对齐 0=左对齐，表示左左侧在同一垂直线；效果等同于PPT中的左对齐 vjust：纵向对齐；0=底部对齐；1=顶部对齐 0=底部对齐，表示最底端在同一水平线；效果等同PPT中的底部对齐 angle：旋转角度，单位为度 lineheight：行间距倍数 外观 - 使用主题 theme_bw() / theme_grey() ：使用主题 theme_grey()：灰色主题；默认 theme_bw() ：黑白主题 theme_classic()：白色背景，无坐标线 theme_minimal() ：无坐标线 theme_get() ：返回当前主题 theme_set(theme_bw())：设置某个主题为当前默认主题 theme_update() ：为之后的图形设置主题 使用一套现有的主题，并用theme()进行微调：theme() 必须接在指定的主题语句之后；因为ggplot根据图层的先后顺序来绘制的； 12345# 默认为灰色主题p + theme_grey()# 在完整的主题使用后，theme()可以正常工作p + theme_bw() + teme(axis.title.x=element_text(color="red", size=3)) 主题 - 自定义 向一套现成主题添加元素的方式来创建自定义主题 将图形使用修改后的主题绘图 1234mytheme &lt;- theme_classic() +theme(plot.title=element_text(hjust=0.5, face="bold")) # 白色背景，无坐标线# 使用修改后的主题p + mytheme 外观 - 面板&amp;网格线 panel.background：面板背景 - rect panel.border：面板边界 - rect panel.grid.major / panel.grid.minor ：控制网格线 - line panel.grid.major.x /y ：控制横向/纵向的网格线 - line 外观 - 边界 随着边界参数值增大，绘图区与边界的距离不断增大，从而在图片上留出更多空白区域 plot.margin = : 依次控制 top/right/bottom/left “lines”的单位距离 小于 “cm” ；即同为1，”cm”的单位大的多 = unit(c(1,1,1,1), “lines”) = margin(1,1,1,1, “cm”) 12theme(plot.margin=unit(c(1,1,1,1,),"lines"))theme(plot.margin=margin(1,1,1,1,"cm")) 分面 分面方向取决于你希望进行比较的类型 横向分布：比较各条形的高度 纵向分布：比较直方图的水平分布 facet_grid()：可以指定一个变量作为纵向子面板分割的依据，指定另一个变量为横向自面板分割的依据 colname ~ colname ； facet_warp(~colname, nrow/nclo=n)：默认使用相同数量的行和列 ~ colname ；分面的分组变量 nrow / ncol = n ； 1234567p &lt;- ggplot(mpg, aes(x=displ, y=hwy)) + geom_point()# 纵向排列的子面板（多行）根据drv分面p + facet_grid(drv ~ .) # 多行一列# 同时根据drv（纵向）和cyl（横向）分割p + facet_grid(drv ~ cyl) 分面 - 不同坐标轴 free_x / free_y / free：标度设置为该值 1p + facet_grid(drv ~ cyl, scales="free_y") 分面 - 文本标签 修改因子各水平的名称 123456mpg2 &lt;- within(mpg, &#123; drv= case_when(drv == "4" ~ "4wd", drv == "f" ~ "Font", drv == "r" ~ "Rear")&#125;)ggplot(mpg2, aes(displ, hwy)) + geom_point() + facet_grid(drv~.) 分面 - 标签和标题的外观 strip.text：控制文本的外观 strip.background：控制背景的外 配色R中的颜色-基本概念 R中有3种方式表示颜色 颜色名字，即上面所显示的那么多种颜色； 颜色编码。每种颜色是RGB形式的，用6位16进制的字符串表示，前面加“#”号！如红色对应的RGB值为”255 0 0”,用16进制表示就是”FF0000”,在R中可以用”#FF0000”表示红色。 调色板中的索引。 R中用palette()表示调色板，默认的是颜色是下面的几种： >palette() [1] “black” “red” “green3” “blue” “cyan” “magenta” “yellow” [8] “gray” 在默认情况下，col=2表示红色。这个颜色会重复利用，如指定col=10同样是红色。 R预设了657种颜色。默认情况下，R中颜色的设置主要需要依靠grDevices包的支持，其中提供了大量的颜色选择函数以及生成函数，以及几种预先设置好的调色板（Palette），用以表现不同的主题。grDevices包中所有关于颜色的函数大致分为三类：固定颜色选择函数，颜色生成和转换函数，特定颜色主题调色板。 固定颜色选择 colors() 、 palette() colors() 123456789# 显示657中颜色的名称colors()# 使用grep()来提取我们感兴趣的颜色colors()[grep("red", colors())]colors()[grep("sky", colors())] # 通过设定为对象，并将其表现出现 a &lt;- colors()[grep("sky",colors())] palette(a) palette(value)：调色板 这个函数用来设置调色板或者获得调色板颜色值； 注意，实际上这个函数的结果可能并非“固定”颜色，但是只要设定好了调色板，它的取值就不会再改变（直到下一次重新设定调色板）。 1234567891011# 恢复调色板palette("defalut")# 查看默认的调色板颜色&gt; palette()[1] "black" "red" "green3" "blue" "cyan" "magenta" "yellow" "gray" # 修改调色板的值（将设定的对象传入到palette()中即可）palette(colors()[1:10]) color &lt;- c("red","green","blue","yellow","cyan"); palette(color) 颜色生成与转换 RGB（红绿蓝三原色混合）、HSV（色调、饱和度、纯度）、HCL（色调、色度、亮度）、灰色 rgb(red, green, blue, maxColorValue=1) alpha = ；透明度；当元素图形重叠时很有用 maxColorValue =1 (默认)；前三者最大的取值范围【0, maxColorValue】；通过将maxColorValue=255，可得到传统rgb颜色的16进制数值 12345&gt; rgb(1,0,0)[1] "#FF0000"&gt; rgb(255,0,0,maxColorValue = 255)[1] "#FF0000" hsv(h, s, v, gamma=1,alpha)：色调(Hue)、饱和度(Saturation)、纯度(Value)来构造颜色 h, s, v 取值 [0,1] gamma=1 ，表示伽马校正(Gamma Correction) 1sv(h=1, s=1, v=1, gamma=1) hcl(h, c, l, alpha)：色调(Hue)、色度(Chroma)、亮度(Luminance)来构造颜色 h，取值[0,360]；可以想象为一个角度，0-红色，120-绿色，240-蓝色；中间都是过渡色 c, l 取值[0,100]，取值越大生成的颜色越亮 fixup= T/F ，表示是否修正的颜色 grey(level)：只有一个参数levle，表示灰度水平。取值[0,1]；0-纯黑；1-白色 level取一个向量，可生成一系列灰色之 rgb2hsv() / clo2rgb() 特定颜色主题调色板 rainbow(n, s=1, v=1, start=0, end=max(1, n-1)/n, gamma=1)：彩虹的颜色（红橙黄绿青蓝紫） n代表调色表里面有几种颜色 heat.colors()：从红色渐变到黄色再变到白色（以体现“高温”、“白热化”） terrain.colors() 从绿色渐变到黄色再到棕色最后到白色（这些颜色适合表示地理地形）。 cm.colors() 从青色渐变到白色再到粉红色。 topo.colors() 从蓝色渐变到青色再到黄色最后到棕色。 123456789101112131415161718# n代表这个调色板里面有几种颜色，# alpha介于【0,1】，反映的是透明度rainbow(n, s = 1, v = 1, start = 0, end = max(1, n - 1)/n, alpha = 1)heat.colors(n, alpha = 1)terrain.colors(n, alpha = 1)topo.colors(n, alpha = 1)cm.colors(n, alpha = 1)# rainbowpie(rep(1, times = 1000), labels = "", col = rainbow(1000), border = rainbow(1000))# heat.colorspie(rep(1, times = 1000), labels = "", col = heat.colors(1000), border = heat.colors(1000))# terrain.colorspie(rep(1, times = 1000), labels = "", col = terrain.colors(1000), border = terrain.colors(1000))# topo.colorspie(rep(1, times = 1000), labels = "", col = topo.colors(1000), border = topo.colors(1000))# cm.colorspie(rep(1, times = 1000), labels = "", col = cm.colors(1000), border = cm.colors(1000)) 其他参数col 绘图使用的颜色，许多函数接受一组颜色，并对不同的数据依次使用颜色。 col.axis 坐标轴字符颜色 col.lab x,y坐标标记颜色 col.main 标题颜色 col.sub 副标题颜色 fg 绘图前景色，包括坐标轴，各类boxes bg 绘图背景色 RColorBrewer包 颜色板被划分为序列性（sequential）离散型（diverging）、分类型（qualitative） RColorBrewer::display.brewer.all() ：调出所有的颜色示例 display.brewer.all(type = “seq”) ：序列性 序列型颜色板适用于从低到高排序明显的数据，浅色数字小，深色数字大。 display.brewer.all(type = “div”)：离散型 离散型颜色板适合带“正、负”的，对极值和中间值比较注重的数据 display.brewer.all(type = “qual”)：分类型 分类型颜色板比较适合区分分类型的数据 brewer.pal(n, name)：来获取该组渐变色的全部n种颜色。 1barplot(rep(1,6),col=brewer.pal(9, "YlOrRd")[3:8]) 离散型 hue 来自HCL色系(Hue-Chroma-Lightness；色相-色度-亮度) 亮度 [0,100]，默认为65 填充色 轮廓色 描述 scale_fill_discrete() scale_color_discrete() 色轮周围均匀等距色 scale_fill_hue() scale_color_hue() scale_fill_grey() scale_color_grey() 灰度调色板 scale_fill_brewer() scale_color_brewer() ColorBrewer调色板 scale_fill_manual() scale_color_manual() 自定义 12library(gcookbook)p &lt;- ggplot(uspopage, aes(Year, Thousands, fill=AgeGroup)) + geom_area() scale_xxx_grey()：灰度调色板 标度范围[0,1] （0-黑色，1-白色） 1p + scale_fill_grey(start=0.7, end=0) 离散型 - 自定义 scale_xxx_manual()：自定义调色板 当未指定时，values 向量中的元素顺序自动匹配离散标度对应因子水平的顺序。 breaks = “” values = “” labels = “” 123456789# 查看因子顺序的方法levels(heightweight$sex)## values的两种用法 # 直接指定颜色scale_xxx_manual(values=c("red","#CC6666")) # 指定对应的颜色scale_xxx_manual(values=c(m="blue", f="red")) 对色盲有好的颜色 连续型 填充色 轮廓色 描述 scale_fill_gradient() scale_color_gradient() 两色渐变 scale_fill_gradient2() scale_color_gradient2() 三色渐变 scale_fill_gradientn() scale_color_gradientn() 等间隔的n种颜色的渐变色 scale_xxx_gradient(low=””, high=””) ：连续型变量的颜色 使用两者渐变色： low=&quot;black&quot;, high=&quot;white&quot; 渐变色中间使用一种颜色划分 ：low=muted(&quot;red&quot;), mid=&quot;white&quot;, higt=muted(&quot;blue&quot;) scales::muted() ，针对颜色输出一个饱和度较低的颜色 n个颜色的渐变色 ：scale_color_gradient(colors=c(&quot;darkded&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;white&quot;)) 根据数值设定颜色 根据范围创建辅助列 将该列映射到填充色上 12345678910111213library(gcookbook)cb &lt;- subset(climate, Source=="Berkeley")# 创建辅助列cb$valence[cb$Anomaly10y &gt;=0 ] &lt;- "pos"cb$valence[cb$Anomaly10y &lt; 0 ] &lt;- "neg"# 将辅助列映射到填充标度上ggplot(cb, aes(Year, Anomaly10y)) + geom_area(aes(fill=valence)) + geom_line() + geom_hline(yintercept=0) + scale_x_continuous(expand=c(0,0)) # 剔除两边空白的部分 上图中会发现在0水平线附近有一些凌乱的阴影。原因在于两个颜色的区域都是由各自的数据点多边形包围而成的，而这些数据点并不都在0上。 通过approx()将数据茶之道1000个点左右来解决。 123456789101112131415&gt; # approx()返回一个列表，包含x和y的向量&gt; interp &lt;- approx(cb$Year, cb$Anomaly10y, n=1000)&gt; # 放在一个数据框中并重新计算valecne&gt; cbi &lt;- data.frame(Year=interp$x, Anomaly10y=interp$y)&gt; cbi$valence[cbi$Anomaly10y &gt;=0 ] &lt;- "pos"&gt; cbi$valence[cbi$Anomaly10y &lt; 0 ] &lt;- "neg"&gt;&gt; # 重新作图&gt; ggplot(cbi, aes(Year, Anomaly10y)) + &gt; geom_area(aes(fill=valence), alpah=0.4) + &gt; geom_line() + &gt; geom_hline(yintercept=0) + &gt; scale_fill_manual(values=c("#CCEEFF","#FFDDDD"), guide=FALSE) + &gt; scale_x_continuous(expand=c(0,0)) # 剔除两边空白的部分&gt; &gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_日期处理_lubridate]]></title>
      <url>%2F2017%2F07%2F31%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86_lubridate%2F</url>
      <content type="text"><![CDATA[R_日期处理_lubridate 基本概念时间概念UTC：（英文“Coordinated Universal Time”／法文“Temps Universel Coordonné”），协调世界时，又称世界标准时间或世界协调时间 最主要的世界时间标准，其以 [原子时] 秒长为基础，在时刻上尽量接近于格林尼治标准时间。 协调世界时把时间分为天、小时、分钟和秒 格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台当地的标准时间，因为本初子午线被定义为通过那里的经线。 理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。但由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，最大误差达16分钟。原因在于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治时间基于天文观测本身的缺陷，已经不再被作为标准时间使用。 现在的标准时间，是由 [原子钟] 报时的协调世界时（UTC）来决定。 R语言中的时间R语言的基础包中提供了两种类型的时间数据 Date类型，仅包括日期数据，它不包括时间和时区信息 POSIXct / POSIXlt 类型，其中包括了日期、时间和时区信息。 日期-时间=不可运算 默认情况下，日期是以/或者-进行分隔，而时间则以:进行分隔； POSIXct / POSIXlt / strptime 的区别 POSXIct ：它存储自UNIX纪元(+其他数据)以来的秒数 ；用数字表示，一个较大的整数，可以存储到数据框中 POSIXlt ：日期时间类，精确到秒，用列表表示，可以更精确地存储日/月/年/小时/分钟/秒等 函数运行 - POSIXlt strptime ：字符向量(各种格式)直接转换为POSIXlt格式的函数 as.POSIXlt：将各种数据类型转换为POSIXlt。 函数运行 - POSIXct as.POSIXct：将各种数据类型转换为POSIXct。 它首先运行strptime，然后从POSIXlt到POSIXct的转换 parse_date_time：将各种类型的数据转为为POSIXct lubridate包主要有两类函数： 处理时点数据（time instants） 处理时段数据（time spans） 时点类 解析与提取日期 - Prasing 解析日期， year(x) 设定日期，通过赋值进行设定 year(x) &lt;- value 解析与转化 解析日期：解析并转化格式 ymd(“…”, tz=NULL) / dmy() / mdy() ：处理不同顺序的日期数据，使之按年月日的形式排列 dym() / ydm() tz = NULL； 或为 指定的时区 locale = Sys.getlocale(“LC_TIME”) ：默认； 123456789# 处理日期，使之按年月日的形式排列&gt; mdy("06-04-2011")[1] "2011-06-04"&gt; dmy("04/06/2011")[1] "2011-06-04"ymd('20170208')[1] "2017-02-08" hms(“…”, roll=FALSE) / hm() / ms() ：处理不同顺序的时间数据 roll=FALSE 默认；若为TRUE，则根据规则进行换算 123456789101112# 处理时间&gt; hms("14:20:01")[1] "14H 20M 1S"&gt; hms("01:59:120")[1] "1H 59M 120S"&gt; hms("01:59:120",roll=T) # roll=T,进行换算[1] "2H 1M 0S"ymd_hms("20161120220000")[1] "2016-11-20 22:00:00 UTC" ymd_hms(“…”, tz=”UTC”, locale=Sys.getlocale(“LC_TIME”), truncated = 0) / ymd_hm / ymd_h ：处理不同顺序的日期时间数据 dmy_hms /dmy_hm /dmy_h mdy_hms / mdy_hm / mdy_h … : 一个字符串向量 in year, month, day, hour, minute, second format tz =”UTC” ：世界标准时间 提取部分值 - 单一 year(“”) / month() / week() / day() / hour() / minute() / second() ：解析日期中的部分值 month(x, label=FALSE, abbr=TRUE) label= FALSE，默认；将月份作为数值进行显示；若为TRUE，则作为字符串 “January.” abbr = TRUE，默认，将月份作为字符串的缩写进行显示”Jan”，当label为FALSE时忽略该参数；若为FALSE，则显示全称 “January.”； (abbreviate ：缩写) yday(x)：一年中的第几天 mday(x)：一个月中的第几天 wday(x)：一周中的星期几 [1, 7] qday(x)：一个季度中的第几天 days_in_month() ：返回所属月份的最大天数 am(x) / pm(x) ：返回逻辑值，判断是否为上午/下午 12:00:00 判断为下午；am(hms(&#39;11:59:59&#39;)) [1] TRUE am(hms(&#39;12:00:00&#39;)) [1] FALSE 1234567891011121314151617181920&gt; year('2017-01-02')[1] 2017&gt; month('2017-01-02')[1] 1&gt; month('2017-01-02', label=T)[1] Jan## 设定日期-----------------------------&gt; x &lt;- ymd('2010-04-08'); x[1] "2010-04-08"&gt; month(x) &lt;- 5 ; x[1] "2010-05-08"&gt; days_in_month(as.Date('2017-05-10'))May 31 转换 时区的概念很重要 用 ymd_hms / as_datetime 创建的时区为 UTC 用as.POSIXct / as.POSIXlt 创你的时区为 CST CST应该是指（China Shanghai Time，东八区时间）UTC应该是指（Coordinated Universal Time，标准时间）所以，这2个时间实际上应该相差8个小时。 使用解析函数进行转换 ymd / ymd_hms 123456789&gt; class(ymd("2017-05-21"))[1] "Date"&gt; ymd_hms("2017-04-21 00:09:21") %&gt;% class()[1] "POSIXct" "POSIXt" # 默认时区为UTC&gt; ymd_hms("2017-04-21 00:09:21")[1] "2017-04-21 00:09:21 UTC" as_date() ：转化为日期格式的数据 format = “ “ 指定转化后的日期格式 as_datetime() ：转化为日期+时间格式的数据 若字符串转为日期+时间格时，若使用as_datetime 时间上会出错，应使用解析函数 或 parse_date_time 原因在于默认的时区为 UTC，而非CST 12345&gt; as_date("2017-08-14 10:01:00 CST")[1] "2017-08-14"&gt; as_datetime("2017-08-14 10:01:00 CST")[1] "2017-08-14 02:01:00 UTC" # 时区被转化为CST as.POSIXct(x, tz = “”, …) ：以一个数值形式进行存储，精确到秒 默认时区为当期的时区；中国为CST tz = “” ；默认为当前的时区 as.POSIXlt() ：以列表的形式进行存储，精确到秒 as.POSIXct 与 as.POSIXlt 默认的时区为 CST 123&gt; &gt; as.POSIXct("2017-04-21 00:09:21")&gt; [1] "2017-04-21 00:09:21 CST"&gt; as.Date()：以数值形式存储，精确到天 【Basic函数】 parse_date_time(x, orders, tz = “UTC”, truncated = 0, quiet = FALSE, locale = Sys.getlocale(“LC_TIME”), select_formats = .select_formats, exact = FALSE)：将向量转换为POSIXct的日期时间格式 parse_date_time 将格式各样的日期时间字符串转换为日期时间类型的数据，并通过orders指定显示的顺序 与strftime的两点区别： 指定一个特殊的排列顺序，而无需使用 % 在处理复合的日期时间数据时，可同时指定多个排列顺序 x ：一个字符串 或数值 向量 order =c(“”): 指定的日期显示顺序 ； 若涉及到日期与时间，将时间的小写改为大写； eg ymd_HMS tz =”UTC” ：世界标准市价 1234567891011121314151617181920212223242526&gt; x &lt;- c("09-01-01", "09-01-02", "09-01-03")&gt; parse_date_time(x, "ymd") # 标准时区UTC[1] "2009-01-01 UTC" "2009-01-02 UTC" "2009-01-03 UTC"## 复合时间 # 处理复合的日期时间数据时，可同时指定多个排列顺序x &lt;- c("09-01-01", "090102", "09-01 03", "09-01-03 12:02")parse_date_time(x, c("ymd", "ymd_HM"))## 不同的排序规则 - 可以同时处理&gt; x &lt;- c("2009-01-01", "02022010", "02-02-2010")&gt; parse_date_time(x, c("dmY", "ymd"))[1] "2009-01-01 UTC" "2010-02-02 UTC" "2010-02-02 UTC"## 季度与部分日期&gt; parse_date_time(c("2016.2", "2016-04"), orders = "Yq") # q 代表季度;[1] "2016-04-01 UTC" "2016-10-01 UTC" &gt; parse_date_time(c("2016", "2016-04"), orders = c("Y", "Ym"))[1] "2016-01-01 UTC" "2016-04-01 UTC"# Y 与 y 的区别 # Y大写表示全称；y表示缩写；&gt; parse_date_time(c("16.2", "16-04"), orders = "yq")[1] "2016-04-01 UTC" "2016-10-01 UTC"&gt; parse_date_time(c("16.2", "16-04"), orders = "Yq")[1] NA NA decimal_date(x)：将日期格式转化为小数格式； x : a POSIXlt/ct or Date object date_decimal(x) ：将小数转化为日期格式 123456date &lt;- ymd("2009-02-10")decimal_date(date)[1] 2009.11date_decimal(decimal_date(date))[1] "2009-02-10 UTC" unclass(x) ： 可以将日期变成以天来计数 ； 可以将时点类根据最基本的组成进行拆解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 x&lt;-as.Date("1970-01-01") &gt; unclass(x) [1] 0&gt; &gt; unclass(as.Date("1970-02-01")) #19700201代表第31天[1] 31# --------对时点类时间进行拆解--------------------------------------## POSIXct 格式；主要特点：以秒进行存储。&gt; unclass(now()) # 等价于 unclass(as.POSIXct(now()))[1] 1501495056attr(,"tzone")[1] ""## POSIXlt 格式；主要特点：以列表进行单独储存格式，可以作为时间筛选的一种&gt; unclass(as.POSIXlt(now()))$sec[1] 18.43142$min[1] 58$hour[1] 17$mday[1] 31$mon[1] 6$year[1] 117$wday[1] 1$yday[1] 211$isdst[1] 0$zone[1] "CST"$gmtoff[1] 28800attr(,"tzone")[1] "" "CST" "CDT" 起始日期为1970-01-01 获取 today( [tz=””])：返回当前系统的日期，不含时间；时区默认为当前计算机的时区 now( [tz=””])：作为POSIXct对象返回当前系统的日期与时间 ；时区默认为当前计算机的时区 12345&gt; today()[1] "2017-07-31"&gt; now()[1] "2017-07-31 15:43:46 CST" 舍入 - Rounding round_date(x, unit = “second”) ：根据unit对x进行四舍五入； unit =”” ：可选的单位 second(s) / mintue(s) / hour(s) / day(s) week(s) / month(s) / quarter() haflyear / year floor_date(x, unit = “second”)：向下舍入； 相当于取整；若unit=”hour” ，则舍去分钟的内容 ceiling_date(x, unit = “second”, change_on_boundary = NULL)：向上舍入； 向上取整； 若后面一位小数大于0，即向前进一位 函数实际运行的三个步骤 转换为表示日期下限的时点：2000-01-01 –&gt; 2000-01-01 00:00:00 向上舍入到下一个最接近的单位边界。 if the rounding unit is month then next boundary for 2000-01-01 will be 2000-02-01 00:00:00. 如果舍入的最小边界单位小于一天，则返回第二步的时点 123456789101112131415161718192021222324252627282930## round_date--------------------------------------------------x &lt;- as.POSIXct("2009-08-03 12:01:59.23"); x[1] "2009-08-03 12:01:59 CST"round_date(x, "minute") # 舍入到分钟[1] "2009-08-03 12:02:00 CST"&gt; round_date(x, "5 minute")[1] "2009-08-03 12:00:00 CST"&gt; round_date(x, "2 months")[1] "2009-09-01 CST"round_date(x, "quarter") == round_date(x, "3 months")round_date(x, "halfyear")round_date(x, "year")## floor_date--------------------------------------------------x &lt;- as.POSIXct("2009-08-03 12:01:59.23")&gt; floor_date(x, "hour")[1] "2009-08-03 12:00:00 CST"## ceiling_date------------------------------------------------x &lt;- as.POSIXct("2009-08-03 12:01:59.23")&gt; ceiling_date(x, "second")[1] "2009-08-03 12:02:00 CST" 设定时点 设定时点的两种方法： 通过解析函数设定 通过时段类函数设定 通过解析函数设定 123456789101112#解析日期year(x)#设定日期，通过赋值进行设定year(x) &lt;- value&gt; l &lt;- today(); l[1] "2017-07-31"&gt; day(l) &lt;- 10; l[1] "2017-07-10"# 不可直接对today()进行赋值day(today())&lt;- 10 # 显示报错 通过时段类函数直接设定 1234567## 通过period来设定时间，一般为unit之后加s； 例如days / months&gt; today() + days(1) [1] "2017-08-01"## 通过 duraction来设定时间，一般period之前加d；即对原始先加s，在加d； 例如 ddays / dyears&gt; today() + ddays(1) [1] "2017-08-01" 时段类 间隔 - Intervals interval：最简单的时段对象，它由两个时点数据构成。 间隔类型： is.intervals &amp; as.intervals interval(start, end, tzone = attr(start, “tzone”))：创建时间间隔 1234## 创建时间间隔x &lt;- ymd('2010-04-08')interval(x,now())[1] 2010-04-08 08:00:00 CST--2017-07-31 16:41:43 CST int_length() ：间隔的长度，以秒来计算 int_start() / int_end() ：返回间隔的起始/结束日期时间 int_shift(int, by)：对间隔两端同时进行转换 by = duration( ): 一段持续时间或周期 1234567## 转换int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))int_shift(int, duration(days = 11))[1] 2001-01-12 UTC--2002-01-12 UTCint_shift(int, duration(hours = -1))[1] 2000-12-31 23:00:00 UTC--2001-12-31 23:00:00 UTC int_flip(int)：翻转；将interval的起始时间与结束时间对调 int_standardize()：标准化；确保间隔是正值，即结束时间大于开始时间；若非标准化，则自动调整 123456int &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))int_flip(int)[1] 2002-01-01 UTC--2001-01-01 UTCint_standardize(int_flip(int))[1] 2001-01-01 UTC--2002-01-01 UTC int_diff(times)：时间间隔对象, 包含 n-1段的时间间隔 times为POSIXct, POSIXlt 或日期格式 123456&gt; dates &lt;- now() + days(1:4); dates[1] "2017-08-01 17:00:07 CST" "2017-08-02 17:00:07 CST" "2017-08-03 17:00:07 CST" "2017-08-04 17:00:07 CST"&gt; int_diff(dates)[1] 2017-08-01 17:00:07 CST--2017-08-02 17:00:07 CST 2017-08-02 17:00:07 CST--2017-08-03 17:00:07 CST[3] 2017-08-03 17:00:07 CST--2017-08-04 17:00:07 CST int_overlaps(int1, int2)：判断int1与int2之间是否有重叠的部分；并返回逻辑值 T/F int_aligns(int1, int2)：判断int1与int2是否对齐，并返回逻辑值 T / F aligns : 对齐 若int1与int2 有相同的起始时间或结束时间，则返回T； 否则返回FALSE 1234567891011int1 &lt;- interval(ymd("2001-01-01"), ymd("2002-01-01"))int2 &lt;- interval(ymd("2001-06-01"), ymd("2002-01-01"))int3 &lt;- interval(ymd("2003-01-01"), ymd("2004-01-01"))int_aligns(int1, int2) # TRUE ## 有相同的结束时间int_aligns(int1, int3) # FALSE ## 判断是否有重叠 int_overlaps(int1, int2) # TRUEint_overlaps(int1, int3) # FALSE 时间间隔 time_length(x, unit = “second”) ：计算两个时间之间的间隔 （自定义间隔单位） x ：a duration, period, difftime or interval unit = c(“second”, “minute”, “hour”,”day”, “week”,”month”, “year”)) difftime(endtime1, starttime2, tz,units=c(“”) ) ：计算两个时间之间的间隔 （自定义间隔单位） time1 - time2 ； 该函数为Base函数 time1 ，常规的时间 units = c(“auto”, “secs”, “mins”, “hours”,”days”, “weeks”)) 判断是否在时间段内 %within%： a %within% b 若a等于b的一端，也返回TRUE a : 可以是时点类，也可以是时段类 b：必须是时段类数据 123456789101112131415161718192021arrive1&lt;-"2011-08-10 13:50:00"leave1&lt;-"2011-08-10 14:00:09"int1&lt;-interval(arrive1,leave1)# 时点类判断&gt; ymd_hms("2011-08-10 13:52:12") %within% int1[1] TRUE&gt; ymd_hms("2011-08-10 13:50:00") %within% int1[1] TRUE# 时段类判断arrive&lt;-"2011-08-10 14:00:00"leave&lt;-"2011-08-10 14:00:05"int&lt;-interval(arrive,leave)[1] 2011-08-10 14:00:00 UTC--2011-08-10 14:00:05 UTCint1 %within% int[1] FALSEint %within% int1[1] TRUE 报错：Argument 1 is not a recognized date-time；表明传入的第一个参数不是时点格式，需要进行转换 持续时间 - Durations duration：去除了时间两端的信息，纯粹以秒为单位计算时段的长度，不考虑闰年和闰秒，它同时也兼容基本包中的difftime类型对象。 期间类型 ： is.duration(x) &amp; as.duration duration(num = NULL, units = “seconds”, …)：创建持续时间 12345678duration(90, "seconds")duration(1.5, "minutes")## 比较判断duration("day 2 sec") &gt; "day 1sec"is.duration(as.Date("2009-08-03")) # FALSEis.duration(duration(days = 12.4)) # TRUE dyears(x) / dweeks(x) / ddays(x) /dhours(x) / dminutes(x) / dseconds(x) ：快速创建持续时间的对象以便于进行日期时间操作 没有dmonths()，因为其以秒为单位来创建，而月度常在30天/31天之间变化；而年度的话此时默认为365天； Durations的函数，以 [秒] 为单位进行创建 minutes(2)函数表示的2个整分钟的概念，而dminutes(2)则是具体120秒 years(1)则是一个整年的概念而dyears(1)表示的365天**而 123456789101112## 规则说明：以 [秒] 为单位进行创建&gt; dyears(1)[1] "31536000s (~52.14 weeks)"&gt; years(1)[1] "1y 0m 0d 0H 0M 0S"## 具体区别&gt; ymd('20160228')+dyears(1) # 以秒为单位进行扩展[1] "2017-02-27"&gt; ymd('20160228')+years(1) # 以年为单位进行扩展[1] "2017-02-28" 周期 - Periods period：以较长的时钟周期来计算时段长度，它考虑了闰年和闰秒，适用于长期的时间计算。 周期类型： is.period &amp; as.period period(num = NULL, units = “second”, …)：创建周期 12345&gt; period(-1, "days")[1] "-1d 0H 0M 0S"&gt; period(c(3, 1, 2, 13, 1), c("second", "minute", "hour", "day", "week"))[1] "20d 2H 1M 3S" years(x) / months(x) / weeks(x) / days(x) / hours(x) / minutes() / seconds(x)：快速创建阶段对象以便于进行日期时间操作 Durations的函数，以 [创建的函数单位] 为单位进行创建 minutes(2)函数表示的2个整分钟的概念，而dminutes(2)则是具体120秒 years(1)则是一个整年的概念而dyears(1)表示的365天而 1234567891011# 规则说明：以[创建的函数单位]为单位进行创建&gt; dyears(1)[1] "31536000s (~52.14 weeks)"&gt; years(1)[1] "1y 0m 0d 0H 0M 0S"# 具体应用&gt; x &lt;- as.POSIXct("2009-08-03");x[1] "2009-08-03 CST"&gt; x + days(1) + hours(6) + minutes(30)[1] "2009-08-04 06:30:00 CST" 时区 - Time Zones 时区索引 tz(x)：提取时间数据的时区 with_tz(time, tz=””)：将时间数据[显示] 为另一个时区的同一时间 force_tz(timez, tz=””)：将时间数据的时区[强制转换] 为另一个时区 1234567891011121314tz(x) &lt;- value # 设置时区&gt; meeting &lt;- ymd_hms("2011-07-01 09:00:00", tz = "Pacific/Auckland");meeting[1] "2011-07-01 09:00:00 NZST"&gt; with_tz(meeting, "America/Chicago") #显示不同的时区相同的时刻[1] "2011-06-30 16:00:00 CDT"&gt; mistake &lt;- force_tz(meeting, "America/Chicago");mistake # 强制转化为另一个时区[1] "2011-07-01 09:00:00 CDT"&gt; with_tz(mistake, "Pacific/Auckland") # 显示转化之后的另一个时间的同一时间，判断是否转换成功[1] "2011-07-02 02:00:00 NZST" 混杂的 - Miscellaneous leap_years(x) : 判断是否为闰年 pretty_dates() : provides a method of making pretty breaks for date-times 时间单位转换 make_difftime(num = NULL, units = “auto”) : 12345make_difftime(3600, units = "minute")# Time difference of 60 minsmake_difftime(second = 3, minute = 1.5, hour = 2, day = 6, week = 1)# Time difference of 13.08441 days %m+% ：由于每个月的最后天数不一样，如果直接在某个月份的最后一天加上指定的月数就会出现错误，这时就得考虑使用%m+%函数了。 12345678x &lt;- as.Date('2015-01-31')y &lt;- x + months(0:11); y [1] "2015-01-31" NA "2015-03-31" NA "2015-05-31" NA "2015-07-31" "2015-08-31" [9] NA "2015-10-31" NA "2015-12-31"&gt; x %m+% months(0:11) [1] "2015-01-31" "2015-02-28" "2015-03-31" "2015-04-30" "2015-05-31" "2015-06-30" "2015-07-31" "2015-08-31" [9] "2015-09-30" "2015-10-31" "2015-11-30" "2015-12-31" 应用选择某个时间/时间段的数据 转为日期格式： as_data() 或 ymd() 1234567&gt; head(date$建仓日期,1)[1] "2017-08-14 10:01:00 CST"filter(date, as_date(建仓时间)==as_date('2017-08-16')) # ----某个时间段filter(data, as_date(建仓时间) &gt;= as_date('2017-08-11') &amp; as_date(建仓时间) &lt;= as_date('2017-08-16')) 转为字符串格式 可以直接用字符串函数进行操作，而无需先转换格式 1234filter(data, str_sub(as.character(建仓时间),1,10) == '2017-08-16')# 等价于如上filter(data, str_sub(建仓时间,1,10) == '2017-08-16') 增减日期 通过持续时间来增减日期 duration：去除了时间两端的信息，纯粹以秒为单位计算时段的长度，不考虑闰年和闰秒，它同时也兼容基本包中的difftime类型对象。 通过周期来增减日期 period：以较长的时钟周期来计算时段长度，它考虑了闰年和闰秒，适用于长期的时间计算。 1234567# 持续时间 --以秒为单位进行扩展&gt; ymd('20160228')+dyears(1) [1] "2017-02-27"# 周期 --以年为单位进行扩展&gt; ymd('20160228')+years(1) [1] "2017-02-28" 新增列，并转化格式12data_source1 &lt;- mutate(data_source, 结算日期 = ifelse(str_sub(建仓时间,12,19) &gt; '15:00:00',as_date(建仓时间) + days(1, as_date(建仓时间))data_source1$结算日期 &lt;- as_date(data_source1$结算日期) 输出格式 - 提取部分值 - format 连续 123as_date("2017-08-30") %&gt;% format(., format="%y%m%d") # format= "%m/%d"labels=format(as_date(""),format="")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《你好，我是费曼》读书笔记_理查德.费曼]]></title>
      <url>%2F2017%2F07%2F26%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F62_%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0%2F%E3%80%8A%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%88%91%E6%98%AF%E8%B4%B9%E6%9B%BC%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%90%86%E6%9F%A5%E5%BE%B7-%E8%B4%B9%E6%9B%BC%2F</url>
      <content type="text"><![CDATA[《你好，我是费曼》_ 理查德.费曼 Richard P. Feynman 从两个部分介绍了费曼。 个人成长过程中的记录 费曼调查挑战者号事件 （火箭”挑战者号”发射失败的事件） 最大的启发：问题的目的在于探索 “x究竟是什么” 这件事本身，而答案是用什么方式找出来的根本就不重要。 一个充满好奇心的人 读到任何内容时都会想想其现实意义，即那到底在讲什么。 知道某个事物的名字与真正了解这一事物，是有很大区别的。 如果你作为一名父亲，不仅要告诉孩子一个名称，而且要解释它的含义。 最终的目的是得出 x 的值，用什么方法其实无所谓； “代数方法”仅仅是一套让人盲目效仿就能得出答案的规则。类似于”方程的两边各减去7，然后同时除以x前面的系数”。这一系列的步骤能帮你得到答案，即使你根本不理解这么做的目的。而发明这些规则的知识为了让不爱学习点数的学生通过考试而已。 问题的目的在于探索 “X究竟是什么？”这件事本身，而答案是用什么方式找出来的根本就不重要。——Richard P. Feynman（理查德 • 费曼） 理解的最高层次就是欢笑和人类的同情之心。我从我的母亲那里懂得。 “莫比乌斯环” 要自己动手去实践。 谁也不知道会发生什么，你所经历的只是生命中的一个偶然。 大脑的思维可以是语言式的，也可以是图像式的； 我们喜欢去不知名的地方，从未听说过的地方，什么都没有的地方。 费曼先生调查挑战者号事件 我认为我们是被叫来解决问题的，理应受到打扰。【费曼先生强烈的目标感】 在科学领域，取得成功的唯一途径就是必须抛开主观感受，小心地描述所得的证据。如果你得出一条理论，你必须公正地说明它的优点与不足。在科学中，你能得到某种诚实与正直。但在其他领域（比如商界），情况就大为不同。你所看到的所有广告都是精心设计的，某种程度上”欺骗”顾客；他们会把不想让客户看到的的东西印地很小； 科学的价值 科学只是给予人们行善或作恶的能力，它没有附赠使用说明书。能力显然是有价值的，即使这种能力可能会因为使用者而受到否定。 虽然科学可能会给世界带来灭顶之灾，但它仍然极有价值，因为它能创造出某些东西。【科学是没有善恶的；利用它的人才有善恶之分】 科学家经常处于无知、不确定和怀疑的状态； 当科学家不知道某个问题的答案时，他是无知的； 当推测出可能的答案时，他是处于不确定的； 当他比较确定答案会是什么时，它仍然存有一些怀疑 人类若要进步，就必须认识到自己的无知，留下怀疑的空间。 科学家的责任在于：懂得伟大的进步源于承认自身的无知，伟大的进步是思想自由的果实，宣扬思想自由的价值；教育人们不要害怕质疑，而是应该欢迎它、讨论它；把维护这种自由看成是我们对子孙后代不可推卸的责任。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_字符串处理_stringr]]></title>
      <url>%2F2017%2F07%2F25%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86_stringr%2F</url>
      <content type="text"><![CDATA[R_字符串处理_stringr stringr：对一个单元格内的 [元素] 进行操作，而非把一个单元格看做一个整体来对待。 文本文件的读写 这里的文本文件指的是非表格式的文件，如纯文本文件，html文件 获取文件目录信息 file.info() dir() 列出指定目录中所有的文件，可选参数recursive=T可递归列出所有的子目录文件 file.exists()：判断文件是否存在 getwd() ：获得当前工作目录 setwd() ：设置当前工作目录 setwd(&quot;C:/data&quot;) 读入 scan(“file.xxx”, what=double(), seq=””, n=-1, nmax=-1, skip=0, encoding=”utf-8”) 读取文本文件，默认情况下读取文件中以[空格分割] 所有[浮点数值] 如果文件中包含非数值，可以字符串形式读入 scan(&quot;a.txt&quot;,what=&quot;&quot;) 指定分隔符为换行，scan(“a.txt”,what=””,sep=”\n”) 返回以换行分割的字符串向量 如果数据为表格形式：因为有表头，用scan不能读入 what：读入的数据类型；The supported types are [ logical, integer, numeric, complex, character, raw and list. ] character(0)：每个单词作为字符向量的一个元素 sep：分隔符，默认为空格&quot; &quot; n = -1：显示至最后一行 nmax = -1：读取至最后一行 skip=0：跳过的行数 encoding=”utf-8” / “Latin1” readline() 可以从键盘读取单行数据，如 age&lt;-readline(&quot;input the age: &quot;) readLines(“file.xxx”, encoding=”utf-8”) ：每一行当做一个字符串。等价于scan中指定分隔符为换行 用于读取字符型的格式文件；常用于文本文件 encoding = “utf-8” / “Latin1” ; Lattin1是[ISO-8859-1]的别名，有些环境下写作Latin-1。ISO-8859-1编码是单字节编码，向下兼容ASCII 写出 cat(x, file=””, sep=””, fill=False, labels=NULL, append=False)：拼接后输出对象，也可以把结果写到指定的文件中 x：R的对象 file：一个连接，或命名的文件打印到一个字符串；默认情况下打印到标准输出连接 sep=” “：每个元素后追加一个字符串的字符向量；默认为空格 append = False 覆盖file内容；若为True，表示附加到file 123456789101112131415&gt; cat(c("AB", "C"), c("E", "F"), "\n", sep="")[1] ABCDEF#----可以把结果写到指定的文件中-----------------#cat("i = ", 1, "\n", file="c:/work/result.txt")# 加上一个append=TRUE参数可以不覆盖原文 件而是在文件末尾附加，这很适用于运行中的结果记录。&gt; cat("hello", "bob", "\b.\n", "Is\'t R", "\t", "Great?\n","!") # 拼接后进行输出hello bob. Is't R Great? !&gt; paste("hello", "bob", "\b.\n", "Is\'t R", "\t", "Great?\n","!")[1] "hello bob \b.\n Is't R \t Great?\n !" writeLines 字符串统计str_length 符串长度 str_length(string) str_count 字符串计数 str_count(string, pattern = “”) string: 字符串，字符串向量。 pattern: 匹配的字符。 若不匹配字符，即等价于 str_length 12345678910111213141516171819&gt; str_count('aaa444sssddd', "a")[1] 3# 对字符串向量中匹配的字符计数&gt; fruit &lt;- c("apple", "banana", "pear", "pineapple")&gt; str_count(fruit, "a")[1] 1 3 1 1# 对字符串中的'.'字符计数，由于.是正则表达式的匹配符，直接判断计数的结果是不对的。&gt; str_count(c("a.", ".", ".a.",NA), ".")[1] 2 1 3 NA&gt; str_count(c("a.", ".", ".a.",NA), fixed(".")) # 用fixed匹配字符[1] 1 1 2 NA&gt; str_count(c("a.", ".", ".a.",NA), "\\.") # 用\\匹配字符[1] 1 1 2 NA 字符串查询str_locate - 位置 找到的模式在字符串中的位置 str_locate(string, pattern) str_locate_all(string, pattern) 以字符串matrix格式返回 123456789101112131415&gt; val &lt;- c("abca", 123, "cba")# 匹配a在字符串中的位置&gt; str_locate(val, "a") start end[1,] 1 1[2,] NA NA[3,] 3 3# 用向量匹配&gt; str_locate(val, c("a", 12, "b")) start end[1,] 1 1[2,] 1 2[3,] 2 2 str_detect - 逻辑值 匹配字符串的字符，返回逻辑值 str_detect(string, pattern) 123456789&gt; val &lt;- c("abca4", 123, "cba2")# 检查字符串向量，是否包括a&gt; str_detect(val, "a")[1] TRUE FALSE TRUE# 检查字符串向量，是否以a为开头&gt; str_detect(val, "^a")[1] TRUE FALSE FALSE 字符串提取strsub - 截取位置 截取字符串 str_sub(string, start = 1L, end = -1L) string: 字符串，字符串向量。 start : 开始位置 (若只出现一个数字，默认为开始位置) end : 结束位置 1234567891011121314151617181920212223242526&gt; txt &lt;- "I am Conan."# 截取1-6的索引位置的字符串&gt; str_sub(txt, end=6)[1] "I am C"# 截取6到结束的索引位置的字符串&gt; str_sub(txt, 6) # 若只出现一个数字，默认为开始位置[1] "Conan."# 通过负坐标截取字符串&gt; str_sub(txt, -3) # [截取] 最后3个字符[1] "an."&gt; str_sub(txt, end = -3) # [截止] 到最后第三个字符[1] "I am Cona"#----对截取的字符串进行赋值-----------------------------------------#&gt; x &lt;- "AAABBBCCC"# 在字符串的1的位置赋值为1&gt; str_sub(x, 1, 1) &lt;- 1; x[1] "1AABBBCCC"&gt; str_sub(x, 1, 1) &lt;- 123; x # [若数量超过截取的位数，则进行填充][1] "123AABBBCCC" str_subset - 提取值 返回的匹配字符串 str_subset(string, pattern) pattern: 匹配的字符 12345678910111213&gt; val &lt;- c("abc", 123, "cba")# 全文匹配&gt; str_subset(val, "a")[1] "abc" "cba"# 开头匹配&gt; str_subset(val, "^a")[1] "abc"# 结尾匹配&gt; str_subset(val, "a$")[1] "cba" str_match - 匹配 从字符串中提取匹配组 str_match(string, pattern) str_match_all(string, pattern) 以字符串matrix格式返回 123456789101112131415161718192021222324252627282930313233343536&gt; val &lt;- c("abc", 123, "cba")# 匹配字符a，并返回对应的字符&gt; str_match(val, "a") [,1][1,] "a" [2,] NA [3,] "a" # 匹配字符0-9，限1个，并返回对应的字符&gt; str_match(val, "[0-9]") [,1][1,] NA [2,] "1" [3,] NA # 匹配字符0-9，不限数量，并返回对应的字符&gt; str_match(val, "[0-9]*") [,1] [1,] "" [2,] "123"[3,] "" #----以字符串matrix格式返回------------------------------------------#&gt; str_match_all(val, "a")[[1]] [,1][1,] "a" [[2]] [,1][[3]] [,1][1,] "a" str_extract - 匹配_Regex 从字符串中根据 [正则表达式] 提取匹配的值 str_extract(string, pattern) str_extract_all(string, pattern, simplify = FALSE) simplify: 返回值，TRUE返回matrix，FALSE返回字符串向量；(默认为False) 123456789&gt; val &lt;- c("abca4", 123, "cba2")# 返回匹配的数字&gt; str_extract(val, "\\d")[1] "4" "1" "2"# 返回匹配的字符&gt; str_extract(val, "[a-z]+")[1] "abca" NA "cba" word - 单词 从文本中提取 [单词] word(string, start = 1L, end = start, sep = fixed(“ “)) start: 开始位置。 end: 结束位置。 sep: 匹配字符。 (默认为 空格) 12345678910111213141516&gt; val &lt;- c("I am Conan.", "http://fens.me, ok")# 默认以空格分割，取第一个位置的字符串&gt; word(val, 1)[1] "I" "http://fens.me,"&gt; word(val, -1)[1] "Conan." "ok" &gt; word(val, 2, -1)[1] "am Conan." "ok" # 以,分割，取第一个位置的字符串 &gt; val&lt;-'111,222,333,444'&gt; word(val, 1, sep = fixed(','))[1] "111"&gt; word(val, 3, sep = fixed(','))[1] "333" 字符串替换str_replace 字符串替换 str_replace(string, pattern, replacement) 替换出现的 [第一个]字符 str_replcae_all(string, pattern, replacement) 替换出现的 [所有]字符 str_repclea_na(string, repalcement= “NA”) 把NA替换为其他字符串 string: 字符串，字符串向量。 pattern: 匹配字符。 replacement: 用于替换的字符。 1234567891011121314&gt; val &lt;- c("abc", 123, "cba")# 把目标字符串 [第一个] 出现的a或b，替换为- &gt; str_replace(val, "[ab]", "-") # 表示或者[1] "-bc" "123" "c-a"# 把目标字符串 [所有] 出现的a或b，替换为-&gt; str_replace_all(val, "[ab]", "-")[1] "--c" "123" "c--"#----把NA替换为字符串------------------------#&gt; str_replace_na(c(NA,'NA',"abc"),'x') # 把NA替换为x[1] "x" "NA" "abc" 字符串拆分str_split &amp; str_split_fixed 字符串分割，同str_split_fixed str_split(string, pattern, n = Inf) str_split()函数操作的结果类型为list &gt; class(s1) [1] &quot;list&quot; str_split_fixed(string, pattern, n) str_split_fixed()函数分割，结果类型是matrix &gt; class(s3) [1] &quot;matrix&quot; pattern: 匹配的字符。 n: 分割个数 1234567891011&gt; val &lt;- "abc,123,234,iuuu"# 以,进行分割&gt; s1&lt;-str_split(val, ",");s1[[1]][1] "abc" "123" "234" "iuuu"# 以,进行分割，保留2块&gt; s2&lt;-str_split(val, ",",2);s2[[1]][1] "abc" "123,234,iuuu" 字符串拼接str_c &amp; str_join 字符串拼接操作，与str_join完全相同，与paste()行为不完全一致。 str_c(…, sep = “”, collapse = NULL) 拼接有NA值的字符串向量时，NA还是NA &gt; str_c(c(&quot;a&quot;, NA, &quot;b&quot;), &quot;-d&quot;) &gt; &quot;a-d&quot; NA &quot;b-d&quot; str_join(…, sep = “”, collapse = NULL) …: 多参数的输入 sep: 把多个 [字符串] 拼接为一个大的字符串，用于字符串的分割符。 collapse: 把多个 [向量] 参数拼接为一个大的字符串，用于字符串的分割符。 12345678910111213141516#----------------示例--------------------------#多个 [字符串] 拼接为一个大的字符串&gt; str_c('a','b',sep='-')[1] "a-b"&gt; str_c(c('a','a1'),c('b','b1'),sep='-')[1] "a-b" "a1-b1"多个 [向量] 参数拼接为一个大的字符串&gt; str_c(head(letters), collapse = ", ")[1] "a, b, c, d, e, f"# collapse参数，对多个字符串无效&gt; str_c('a','b',collapse = "-") [1] "ab"&gt; str_c(c('a','a1'),c('b','b1'),collapse='-')[1] "ab-a1b1" 对比str_c()函数和paste()函数之间的不同点 12345678910111213141516171819&gt; # [字符串] 拼接，默认的sep参数行为 [不一致]&gt; &gt; str_c('a','b') # 默认分隔符为""&gt; [1] "ab"&gt; &gt; paste('a','b') # 默认分隔符为" "&gt; [1] "a b"&gt;&gt; # [向量] 拼接字符串，collapse参数的行为 [一致]&gt; &gt; str_c(head(letters), collapse = "")&gt; [1] "abcdef"&gt; &gt; paste(head(letters), collapse = "")&gt; [1] "abcdef"&gt;&gt;&gt; #拼接有 [NA值] 的字符串向量，对NA的处理行为 [不一致]&gt; &gt; str_c(c("a", NA, "b"), "-d")&gt; [1] "a-d" NA "b-d" &gt; &gt; paste(c("a", NA, "b"), "-d") # 将NA作为一个普通字符串来对待&gt; [1] "a -d" "NA -d" "b -d" &gt; 对比str_c() &amp; paste() 与 cat() 的区别： paste()：转为字符串后进行连接； cat() ：连接后输出为对象 12345678&gt; &gt; paste("hello", "bob", "\b.\n", "Is\'t R", "\t", "Great?\n","!")&gt; [1] "hello bob \b.\n Is't R \t Great?\n !"&gt;&gt; &gt; cat("hello", "bob", "\b.\n", "Is\'t R", "\t", "Great?\n","!")&gt; hello bob.&gt; Is't R Great?&gt; !&gt; &gt; str_conv - 转码 字符编码转换 str_conv(string, encoding) encoding: 编码名。 12345678910111213141516171819#----对中文进行转码处理---------------------------#&gt; x &lt;- charToRaw('你好');x[1] c4 e3 ba c3# 默认win系统字符集为GBK，[GB2312为GBK字集]，转码正常&gt; str_conv(x, "GBK")[1] "你好"&gt; str_conv(x, "GB2312")[1] "你好"# 转UTF-8失败&gt; str_conv(x, "UTF-8")[1] ""#----把unicode转UTF-8------------------------------#&gt; x1 &lt;- "\u5317\u4eac"&gt; str_conv(x1, "UTF-8")[1] "北京" 字符串输出str_trim - 空格 去掉字符串的空格和TAB(\t) str_trim(string, side = c(“both”, “left”, “right”)) string: 字符串，字符串向量。 side: 过滤方式，both两边都过滤，left左边过滤，right右边过滤 “both”（默认） str_to_upper/title - 大小写 字符串大小写转换 str_to_upper(string, locale = “”) ：全大写 str_to_lower(string, locale = “”) ：全小写 str_to_title(string, locale = “”) ：首字母大写 locale:按哪种语言习惯排序 str_pad - 补充长度 补充字符串的长度 str_pad(string, width, side = c(“left”, “right”, “both”), pad = “ “) string: 字符串，字符串向量。 width: 字符串填充后的长度 side: 填充方向，both两边都填充，left左边填充，right右边填充 pad: 用于填充的字符 （默认为 空格） 1234567# 从左边补充空格，直到字符串长度为20&gt; str_pad("conan", 20, "left")[1] " conan"# 从左右两边各补充x字符，直到字符串长度为20&gt; str_pad("conan", 20, "both",'x')[1] "xxxxxxxconanxxxxxxxx" str_dup - 复制 复制字符串 duplicate str_dup(string, times) string: 字符串，字符串向量。 times: 复制数量 123456789&gt; val &lt;- c("abca4", 123, "cba2")# 复制2次&gt; str_dup(val, 2)[1] "abca4abca4" "123123" "cba2cba2" # 按位置复制&gt; str_dup(val, 1:3) # 复制的次数从1次增加到3次[1] "abca4" "123123" "cba2cba2cba2" str_sort &amp; str_order - 排序 字符串值排序，同str_order索引排序 str_sort(x, decreasing = FALSE, na_last = TRUE, locale = “”, …) str_order(x, decreasing = FALSE, na_last = TRUE, locale = “”, …) decreasing: 排序方向。 decrease - 减少 na_last:NA值的存放位置，一共3个值，TRUE放到最后，FALSE放到最前，NA过滤处理 locale:按哪种语言习惯排序 loacle = “en” - ASCII字母 / “zh” - 拼音 123456789101112131415161718192021# 按ASCII字母排序&gt; str_sort(c('a',1,2,'11'), locale = "en") [1] "1" "11" "2" "a" # 倒序排序&gt; str_sort(letters,decreasing=TRUE) [1] "z" "y" "x" "w" "v" "u" "t" "s" "r" "q" "p" "o" "n" "m" "l" "k" "j" "i" "h"[20] "g" "f" "e" "d" "c" "b" "a"# 按拼音排序&gt; str_sort(c('你','好','粉','丝','日','志'),locale = "zh") [1] "粉" "好" "你" "日" "丝" "志"#----对NA值的排序处理------------------------# #把NA放最后面&gt; str_sort(c(NA,'1',NA),na_last=TRUE) [1] "1" NA NA#去掉NA值 &gt; str_sort(c(NA,'1',NA),na_last=NA) [1] "1" 字符串变换str_warp - 格式 控制字符串输出格式 str_wrap(string, width = 80, indent = 0, exdent = 0) string: 字符串，字符串向量。 width: 设置一行所占的宽度。 indent: 段落首行的缩进值 exdent: 段落非首行的缩进值 12345678txt&lt;-'R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。'# 设置宽度为60字符，首行缩进2字符&gt; cat(str_wrap(txt, width = 60, indent = 2), "\n") R语言作为统计学一门语言，一直在小众领域闪耀着光芒。直到大数据的爆发，R语言变成了一门炙手可热的数据分析的利器。随着越来越多的工程背景的人的加入，R语言的社区在迅速扩大成长。现在已不仅仅是统计领域，教育，银行，电商，互联网….都在使用R语言。 参数控制函数 仅用于构造功能的参数，不能独立使用。 regex 定义正则表达式 stringr的API介绍stringr包1.0.0版本，一共提供了30个函数，方便我们对字符串处理。常用的字符串的处理以str_开头来命名，方便更直观理解函数的定义。我们可以根据使用习惯对函数进行分类： stringr包中的函数默认使用正则表达式的函数（pattern） R中的转义字符则是双斜杠：\\ \\d 代表\d 字符串拼接函数 str_c:字符串拼接。 str_join:字符串拼接，同str_c。 str_trim:去掉字符串的空格和TAB(\t) str_pad:补充字符串的长度 str_dup:复制字符串 str_wrap:控制字符串输出格式 str_sub:截取字符串 str_sub&lt;-截取字符串，并赋值，同str_sub 字符串计算函数 str_count:字符串计数 str_length:字符串长度 str_sort:字符串值排序 str_order:字符串索引排序，规则同str_sort 字符串匹配函数 str_split: 字符串分割 str_split_fixed: 字符串分割，同str_split str_subset: 返回匹配的字符串 word:从文本中提取单词 str_detect: 检查匹配字符串的字符 str_match:从字符串中提取匹配组。 str_match_all: 从字符串中提取匹配组，同str_match str_replace: 字符串替换 str_replace_all: 字符串替换，同str_replace str_replace_na:把NA替换为NA字符串 str_locate: 找到匹配的字符串的位置。 str_locate_all: 找到匹配的字符串的位置,同str_locate str_extract: 从字符串中提取匹配字符 str_extract_all: 从字符串中提取匹配字符，同str_extract 字符串变换函数 str_conv:字符编码转换 str_to_upper: 字符串转成大写 str_to_lower: 字符串转成小写,规则同str_to_upper str_to_title: 字符串转成首字母大写,规则同str_to_upper 参数控制函数，仅用于构造功能的参数，不能独立使用。 boundary:定义使用边界 coll:定义字符串标准排序规则。 fixed:定义用于匹配的字符，包括正则表达式中的转义符 regex:定义正则表达式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_数据处理_basic]]></title>
      <url>%2F2017%2F07%2F25%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_basic%2F</url>
      <content type="text"><![CDATA[R_数据处理_basic 数据结构数据结构：向量、矩阵、数组、数据框、因子、列表 向量 用于储存数值型、字符型或逻辑性数据的一维数组。 同一向量中的数据必须为同一模式；例如同为数值型 通过方括号[ ] 给定元素所处位置的数值来访问向量中的元素 标量：只含一个元素的向量 12345a[1]a[2:6]a[c(2,4)] 矩阵&amp;数组 矩阵：二维数组，每个元素都拥有相同的模式（数值型、字符型、逻辑型） 使用方括号[]和下标 来选择矩阵中的行、列或元素； matrix(vector, nrow=n1, ncol=n2, byrow=FALSE, dimnames=list(rnames, cnames)) nrow/ncol = n，表示行列的数量，即维度 byrow = FALSE(默认)， 按列填充 dimanems=list() ： 可选的，以字符型向量命名的行名与列名 12345x&lt;- matrix(1:10, nrow=2)x[2,]x[1,4]x[1,c(4,5)] 数组：任意维度的向量；是矩阵的自然推广 array(vector, dimensions, dimnames=list()) 数据框 data.frame(…, row.names = NULL)：创建数据框 不同的列可以包含不同模式（数值型、字符型等）的数据，通常用data.frame()创建 通过方括号[ ]与 $ 以及 attach()&amp;detach() 或 with()进行选取列 列所处位置的数值 指定列名 运用with()进行数据框绑定，用花括号{ }来指定对数据框执行的语句； 对象仅存在于with()结构以内 若要创建with()结构以外也存在的对象，使用特殊赋值符号&lt;&lt;替代标准的赋值符号&lt; ；可以将对象保存在全局环境中 12345678910111213## 指定 列所处位置的数值patientdata[1:2] ## 指定列名patientdata[c("disbetes", "status")]patientdata$diabetes## --------with()绑定数据框-----------------------#with(mtcars, &#123; stats &lt;- summary(mpg) # 可用全局赋值号 &lt;&lt;- stats&#125;) 创建空数据框：从已有数据中获取，可免去设置格式 12345# 先获取tbl_concurrency &lt;- data.frame(point_time = point_time[1], interval_time=interval_time[1,1])# 再删除第一行tbl_concurrency &lt;- tbl_concurrency[-1,] 列表 列表：任意对象的有序集合；列表允许若干个对象到单个对象名下。（即列表可能是向量、矩阵、数据框，甚至是其他列表的组合） 通过双重括号[[ ]]中指名代表某个成分的数字或名称来访问列表中的元素 list(name1 = object1, name2 = object2) 123mylist[[2]]mylist[['age']]mylist$age 结构判断 str()：返回对象整体的数据结构 class()：返回单个对象格式/类型 mode()：返回对象模式 dim()：返回对象维度 summary()：统计摘要；区别对待不同类型的数据变量- (1)数值型：相关极值等信息；(2)名义型/有序型：显示的是各水平的频数值 ​ 数据类型因子 变量类别型变量（名义型、有序型）和连续型变量； 名义型变量：没有顺序之分的 [类别型] 变量 有序型变量：一定顺序的 [类别型] 变量 连续型变量：呈现某个范围内的任意值，并同时表示了顺序和数量。 [名义型、有序型] 变量在R中称为 [因子] (factor) 函数factor() 以一个整数向量的形式存储类别值，范围为[1..k]（k是名义型变量中唯一值的个数），同时一个字符串（原始值）组成的 内部向量 将映射到这些整数上 facotr(x, ordered=FALSE, levels=c(), labels=c(), exclude=NA)： ordered = FALSE(默认)；若为TRUE，则为有序型变量 对字符型向量，默认顺序按 英文字母顺序创建 [a-z] levels=c()：覆盖默认排序的顺序；保证指定的水平与数据中的真实值相匹配，因为任何在数据中出现而未在参数列举中的数据都会被设为缺失值 labels=c()：将有序型变量转化为名义型变量； 标签的顺序必须和因子水平的顺序相一致； 所有不一致的变量将被设为缺失值NA exclude =NA：转变为因子时排除在外的变量，即不参与有序化； 123456789101112131415161718192021222324252627282930313233&gt; diabetes&lt;- c('type1','type2','type1','type1')&gt; diabetes &lt;- factor(diabetes);diabetes[1] type1 type2 type1 type1Levels: type1 type2# --------有序型因子，order=T------------------------------#&gt; status &lt;- c('poor','improved','excellent','poor')&gt; status &lt;-factor(status, ordered=T);status[1] poor improved excellent poor Levels: excellent &lt; improved &lt; poor# 覆盖原有的因子顺序 -- levels=c()为指定的顺序status &lt;-factor(status, ordered=T, levels=c('poor','improved','excellent'));status[1] poor improved excellent poor Levels: poor &lt; improved &lt; excellent# levels中的值必须在数据中出现； 参数中为出现的值默认被设置NA&gt; status &lt;-factor(status, ordered=T, levels=c('poor','improved','x'));status[1] poor improved &lt;NA&gt; poor Levels: poor &lt; improved &lt; x# 变更为无序因子（名义型变量）&gt; status; [1] poor improved excellent poor Levels: excellent &lt; improved &lt; poorfactor(status, labels=c(1,2,3)) # 标签的顺序必须和因子水平的顺序相一致[1] 3 2 1 3Levels: 1 &lt; 2 &lt; 3# 因子化时排除某个变量&gt; x &lt;- factor(c(1, 2, 3), exclude = 3); x[1] 1 2 &lt;NA&gt;Levels: 1 2 语句diabetes &lt;- factor(diabetes) 将此向量存储为（1,2,1,1）（以一个整数向量的形式存储类别值，范围为[1..k]），并在内部将其关联为 1 = type1 和 2 =type2（具体赋值根据字母顺序而定） 针对向量diabetes进行的任何分析都会将其作为名义型变量对待，并自动选择适合这一测量尺度的统计方法 语句status &lt;-factor(status, ordered=T) 将向量存储为（3,2,1,3)，并在内部关联为 1=excellent, 2=improved, 3=poor 数据类型 &amp; 转换 数值型 - is.numeric() &amp; as.numeric() 整数型 is.integer() &amp; as.integer() 双精度型 is.double() &amp; as.double() 字符串形式 is.character() &amp; as.character() 日期形式：is.Date() &amp; as.Date() ；is.datetime() &amp; as.datetime() 逻辑型 is.logical() &amp; as.logical() 因子型 is.factor() &amp; as.factor() as.factor(x) – 只能对整个数据/列进行转换，其中无法插入其他语法 在作图时因子化需用 factor 向量型 is.vector() &amp; as.vectro() 矩阵型 is.matrix() &amp; as.matrix() 数组型 is.array() &amp; as.array() 数据框型 is.data.frame() &amp; as.data.frame() 123# 多列变更data[,col:col] &lt;- lappy(gb[,col:col], as.numeric)# gb[,c("net_activation","total_income")] &lt;- lapply(gb[,c("net_activation","total_income")], as.numeric) 数据选取元素选取 负号表示排除 123456789101112131415161718192021## 负号：表示排除某一列mtcars[,-1] # 表示排除第一列## 向量的选取# 位置选取a[2]; a[1:6]; a[c(1,4)];# 判断选取a[a&gt;2]; a[a==2]## 矩阵&amp;数据框选取# 位置选取a[1,]; a[,1]; a[1,2]; a[1, c(4,5)]## 数据框选取# 位置选取mtcars[1,]; mtcars[,1]; mtcars[1:2,]; mtcars[,1:2]mtcars[1:2] # 默认选取列，选取1与2列mtcars[1:2, 3:4]mtcars[c('wt')]; mtcars[1:2, c('wt','hp')]mtcars$hp # 运用 $ 进行选取 逻辑选取 逻辑选取，后端运行分为两步 根据已有的条件对每个对象进行判断，结果为TRUE或FALSE 指定某个对象中提取为TURE的值 该对象的类型必须与条件判断的对象类型相同 或者说 前的范围必须 $\le$ 后者； mtcars$wt[mtcars$carb==2] ：选取carb为2的wt列；注意，wt与carb的对象均为列； mtcars[mtcars$carb==2] ：会报错，提示undefined columns selected ；此时前者范围大于后者；因为mtcars有n列，但逻辑为TRUE的只有一列，无法判断应该选取哪一列，故报错。 mtcars$carb[mtcars&gt;2]： 可以运行；不满足的部分用NA显示 123# 逻辑判断选取mtcars[mtcasr&gt;10]mtcars$hp[mtcars&gt;10] 子集选取 - subset subset(x, subset, select, drop = FALSE, …) ： S3 method for class ‘data.frame’ subset ：选取的逻辑表达式；选取条件 select ：选择的列 123subset(airquality, Temp &gt; 80, select = c(Ozone, Temp))subset(airquality, Day == 1, select = -Temp)subset(airquality, select = Ozone:Wind) 删除变量 - rm() 列表的批量操作 do.call(what, arg)：对每个列表中元素进行合并 告诉list一个函数，然后list里的所有元素来执行这个函数。 相当于是列表list的apply函数 what : 一个函数 / 函数的对象名 arg ： 一个列表list 12# 合并list中的所有元素sdo.call(rbind, list) 基础函数数学函数 abs() round(x, digits=2)：代表保留小数位数的位数； signif(x,digits=2)：代表保留的有效位数 123456x&lt;- 1.22341&gt; round(x,2)[1] 1.22&gt; signif(x,2)[1] 1.2 实用函数 length(x)：R的对象、一个向量或因子；对象x的长度 seq(from, to, by)：生成一个序列 rep(x, n)：将x重复n次 cut(x, n)：将连续型变量分为n个水平的因子 ptetty(x, n)：将连续型变量分为n个区间 cat(…, file=”myfile”, append=FALSE)：连接…的对象，并将其输出到屏幕上或文件中 1234&gt; cat("hello", "bob", "\b.\n", "Is\'t R", "\t", "Great?\n","!")hello bob. Is't R Great? ! cat( ) 与 paste( ) 相同与区别 区别： paste( ) 对应的列单独合并 cat( ) 合并为一个单元格 123456&gt; paste(c("X","Y"),1:10,sep="")&gt; # [1] "X1" "Y2" "X3" "Y4" "X5" "Y6" "X7" "Y8" "X9" "Y10"&gt;&gt; cat(c("X","Y"),1:10,sep="")&gt; # XY12345678910&gt; funs的用法 直接在函数中写明需要运行的函数 summarise(., vars(), mean) 结合funs写出调用的函数 summarise(., vars(), funs(mean)) 12345summarise_all(df1[,-1],funs(mean,sum)) # 若出现两个及以上的函数，列名中自动添加后缀summarise_all(df1[,-1],funs(sum(.*2))) # 所有数据用.表示summarise_all(df1[,-1],funs(medi=median)) # 指定得到的列后缀名, 函数仍为miedansummarise_all(df1[,-1],funs("in"=median)) # 或者加引号 (因为in在R中表示其他含义)mutate_all(df1[,-1],funs(.^2)) 控制流重复和循环 若需多个操作，可用大括号 {} 括起来 for结构 ：for (var in seq) statement 循环执行某语句statement，直到某个变量var的值不在包含在序列seq中为止 1for (i in 1:10) print("hello") while结构 ：while (cond) statment 必须确保cond中的条件语句能【被改变】（即它在某个时刻不在为真），否则循环将永不停止 12i &lt;- 10while (i&gt;0) &#123;print("heloo"); i &lt;- i-1&#125; 条件执行 表示相等== R的多条件嵌套，必须要用大括号{}括起来，各条件之间用分号;隔开；而非python的换行缩进即可； 1234567891011121314151617181920212223242526272829303132333435363738&gt; b &lt;- 1723&gt; for (i in 1720:b)&#123;&gt; print(i);print('--');&gt; for (a in (i+1):1723) &#123; # 若写为 i+1:1723 默认为 i + (1:1723)&gt; print(i);print(a);print('==')&gt; &#125;&gt; &#125;&gt; [1] 1720&gt; [1] "--"&gt; [1] 1720&gt; [1] 1721&gt; [1] "=="&gt; [1] 1720&gt; [1] 1722&gt; [1] "=="&gt; [1] 1720&gt; [1] 1723&gt; [1] "=="&gt; .....&gt; [1] 1723&gt; [1] "--"&gt; [1] 1723&gt; [1] 1724 # 这里超出了上限； 可通过if 判断 if (a&lt;=1723) &#123;&#125;&gt; [1] "=="&gt; [1] 1723&gt; [1] 1723&gt; [1] "=="&gt;&gt; # -------------修改后&gt; b &lt;- 1723&gt; for (i in 1720:b)&#123;&gt; print(i);print('--');&gt; for (a in (i+1):1723) &#123; # 若写为 i+1:1723 默认为 i + (1:1723)&gt; if (a&lt;=1723) &#123;&gt; print(i);print(a);print('==')&#125;&gt; &#125;&gt; &#125;&gt; &gt; if (cond) statment if-else结构：if (cond) statement 或者 for (cond) statement1 else statement2 1if (!is.factor(grade)) gerade &lt;- as.factor(grade) else print("Grade already is a factor") ifelse结构：ifelse(cond, statement1, statement2) 12ifelse(sorce&gt;0.5, print("Passed"), print("Failed"))outcome &lt;- ifelse(socre&gt;0.5, "Passed", "Failed") In while (i &lt;= 10) { … :报错：the condition has length &gt; 1 and only the first element will be used 这里你的i应该是个向量，用 i &lt;= 10来做条件的时候会出现很多个TRUE和FALSE，系统选用第一个作为标准 switch结构：根据一个表达式的值选择语句执行switch(expr,...) expr之后的…是expr的可能取值，后接等号（=），表示执行的行为 switch语句中，不同条件末尾要有 [逗号] 若expr为文本形式，输入时需加 [引号] 12345678910feelings &lt;- c("sad", "afraid")for (i in feelings) print( switch(i, happy = "I am glad you are happpy", # 用逗号分隔 afraid = "There is nothing to fear", sad = "Cheer Up", angry = "Calm down now" ) ) 逻辑判断 which()： 返回为真的逻辑对象，允许对数组array使用 应用 下一个值减去上一个值，若差值大于等于x，则把该值为初始值，后续的值减去该初始值 123456789time &lt;- 0base &lt;- 1700for (i in 1700:1723)&#123; if (abs(i-base)&gt;=5)&#123; time &lt;- time+1; base &lt;- i &#125;&#125;print(time) 自编函数 结构 1234myfunction &lt;- function(arg1, arg2, ...)&#123; statements return(object)&#125; 关于报错 This function should not be called directly ：该函数在多个包中有同样的名字 指定某个包的函数 dplyr::summarise() 移除某个包 detach(package:plyr) 需要TRUE/FALSE值的地方不可以用缺少值：if得到的必须是TRUE/FALSE，你可能得到了NA 在写if语句时，可以先判断一下是不是会有NA返回值：识别NaN的方法是：is.na(x) as.POSIXct.numeric(value) : “origin” 一定得给值 ​ 符号的使用基本符号 ( )定义函数的参数 ( )在运算中作为优先级 [ ] 用做对象的元素索引 { } 作为代码段落的起止 %in% 表示包含 用分号;来分隔两个代码； 123&gt; x &lt;- "AAABBBCCC"&gt; str_sub(x, 1, 1) &lt;- 1; x[1] "1AABBBCCC" 常见符号 写正则表达式的pattern时，要用两个转义符来进行转义\\，因为r中一个\本身就是转义符的意思 Windows下路径要用斜杠/或者双反斜杠\\ ，原因同上 名称 作用 示例 &lt;- 赋值符号 \ 转义符 [ ] 给定元素所处位置的数值 a[c(2,4)] ： 用于表示一个数值序列 a[2:6] [i,j] 选择指定的行与列 [i,][,j] [i,j][,] “” 用于目录名、文件名、包 ‘ ‘ 引用双引号的文字为文本时出现 labs(title=’ positon=”fill” ‘) # 用于注释。#之后出现的任何文本都会被R解释器忽视； 并且R只能对单行进行注释，故当出现多条命令符，需在每行前面加上# $ 选取一个给定数据框中的某个特定变量 patientIDdata$age &lt;&lt;- 特殊赋值符 [[ ]] 用于列表中选取对象 mylist[[“ages”]] mylist[[2]] ^或** 求幂 x% %y 求余数（x mod y) 5%%2=1 x% / %y 整数除法。5%/2%=2 == 严格等于（在浮点型数值时慎用==） 2+2==4 != 不等于 !x 非x x∣y x或y x&amp;y x和y isTRUE(x) 测试x是否为TRUE [,-1][-1,] [,c(-2,-3)]/[,-c(2,3)] 删除第一列 删除第一行 删除多列，两种表达方式均可 mydata&lt;-mydata[,-1] mydata&lt;-mydata[,-c(2,3)] “[“ 提取谋而对象一部分的函数，后跟序列数n；1表示该对象的第一部分； 2表示该对象的第二部分； 日期格式 符号 含义 示例 %Y 2007 %y 07 %m 00~12 %d 01~31 %B January %b Jan %A Monday %a Mon R中常见表达式 符号 作用 示例 解释 ～ 分隔符号 y～x+z+w 左边-因变量/响应变量 右边-自变量/解释变量 + 分隔预测变量 ： 预测变量的交互项 y～x+z+x:z * 所有可能交互项的表达方式 y～xzw—y～x+z+w+x:z+x:w+z:w ^ 交互项的某个次数 y～(x+z+w)^2—y～x+z+w+x:z+x:w+z:w 交互项最高次为2次 . 包含除因变量之外的所有变量 y～.—y～x+z+w 当一个数据框包含y,x,z,w这四个变量时 - 减号，从等式中移除某个变量 y～(x+z+w)^2-x:w— y～x+z+w+x:z+z:w -1 删除截距项 y～x-1 拟合y在x上的回归，并强制直线通过原点 I() 【大写的i】 从算术（而非表示式）的角度来解释括号中的元素 y～x+I((z+w)^2) 表示的是x+(z+w)²，而非x+z+w+z:w function 可以在表达式中运用的数学函数 log(y)～x+z+w mpg ~ wt \ cyl 表示按条件（cyl）绘图； 即按cyl的水平为【分组条件】分别绘制mpg和wt的关系图 研究设计表达式 表达式 作用 解释 y～A 单因素ANOVA 1.小写字母，定量变量 2.大写字母，组别因子（若不转换为factor，则默认为定量协变量） 3.Subject，被试者独有的标志变量 4.Error(Subject/A)，表示组内因子 y～x+A 含单个协变量的单因素ANCOVA y～A * B 双因素ANOVA 展开为 ~A+B+A:B y～x1+x2+A*B 含两个协变量的双因素ANCOVA y～B+A（B是区组因子） 随机化区组 y～A + Error(Subject/A) 单因素组内ANOVA y～B*W+Error(Subject/W) 含单个组内因子(W)和单个组间因子(B)的重复测量ANOVA 展开为 ~B+W+B:W 字符规则 引用符 字符 含义 Quotes \n newline；换行 Quotes \r carriage return Quotes \t tab；制表符 Quotes \b backspace；空格 Quotes \a alert (bell) Quotes \f form feed Quotes \v vertical tab Quotes \ backslash \ Quotes \’ ASCII apostrophe ‘（单引号） Quotes \” ASCII quotation mark “（双引号） Quotes ` ASCII grave accent (backtick) ` Quotes \nnn character with given octal code (1, 2 or 3 digits) Quotes \xnn character with given hex code (1 or 2 hex digits) Quotes \unnnn Unicode character with given code (1–4 hex digits) Quotes \Unnnnnnnn Unicode character with given code (1–8 hex digits)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_导入&导出]]></title>
      <url>%2F2017%2F07%2F24%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E5%AF%BC%E5%85%A5%26%E5%AF%BC%E5%87%BA%2F</url>
      <content type="text"><![CDATA[Windows下路径要用斜杠/或者双反斜杠\\ R本身把\ 当做转义符，所以写pattern的时候要用\\进行转义 获取文件目录信息目录操作getwd &amp; setwd getwd()：获得当前工作目录 setwd() ：设置当前工作目录 setwd(&quot;C:/data&quot;) dir &amp; list.files - 获取 dir 与 list.files 功能相同；列出当前目录中所有的文件 dir() ：列出当前目录中所有的文件名 dir(path=”/home/conan/R”, pattern=Null, all.files=False, full.names=Fasle, recursice=Fasle, igonre.case= False, include.dirs=False, no..=False)：查看指定目录的文件 path：查看指定路径下的文件。 pattern ：匹配的正则表达式模式 all.files = False(默认) ；若为True，则列出隐藏的文件名 full.names=False(默认) &quot;我的形状&quot;；若为True，列出含相对路径的文件名 &quot;./我的形状&quot; 1dir(path="/home/conan/R",pattern='txt$') choose.dir - 获取 通过选取的方式获得目录 1a &lt;- choose.dir() system(“tree”) - 获取 通过系统命令以树状结构查看目录结构 file.info() dir.create - 新建 dir.create()：在当前目录下，新建一个目录 dir.create(path=”a1/b2/c3”,recursive = TRUE)：创建一个3级子目录./a1/b2/c3 file.path - 合并 file.path(…, fsep = .Platform$file.sep) file.path(getwd(), dir()) ：当前工作目录下的文件的路径 … : 字符串 fsep : 用于使用的路径分隔符 123456&gt; file.path("C:\\Users\\long\\Desktop","txt") [1] "C:\\Users\\long\\Desktop/txt" #----------------------------------------#&gt; file.path(getwd(),dir())[1] 'E:/Jupyter_notebook/test' 'E:/Jupyter_notebook/test.ipynb' 'E:/Jupyter_notebook/专项分析' 一般用paste来生成系统路径的时候，在最终结果，结合的地方会多一个空格，当然也可以用去空格的方式排除，但是不够好。 用file.path的方式直接生成，比较方便，而且绝对正确。 几个特殊的目录 R.home() 查看R软件的相关目录 .Library 查看R核心包的目录 .Library.site 查看R核心包的目录和root用户安装包目录 .libPaths() 查看R所有包的存放目录 system.file() 查看指定包所在的目录 文件操作 file.exist - 存在 判断文件是否存在 12345678&gt; file.exists(".")[1] TRUE&gt; file.exists("./a1/b2")[1] TRUE# 目录不存在&gt; file.exists("./aa")[1] FALSE file.remove - 删除 删除某目录 file.create - 创建 创建文件 123456789# 创建一个空文件 A.txt&gt; file.create("A.txt")[1] TRUE# 创建一个有内容的文件 B.txt&gt; cat("file B\n", file = "B.txt") # 把字符串输出到file# 打印B.txt&gt; readLines("B.txt")[1] "file B" file.copy - 复制12&gt; file.copy("A.txt", "C.txt")[1] TRUE file.append file.rename - 重命名 对文件重命名 file.rename(“old_name”, “new_name”)：将old_name变更为new_name 压缩与解压 unzip(),zip() 两个函数，可以压缩和解压缩 导入 导入 - 数据表 要导入的数据必须存放在getwd()目录下 Windows下路径要用斜杠/或者双反斜杠\\ readr library(readr) read_delim(“filename.xxx”, delim=””) : 自由分隔符 delim= &quot;|&quot;或其他任何形式 read_csv(“filename.csv”, col_names=T, col_types=NULL, skip = 0, locale(), na=c(“”,”NA”))：分隔符-逗号 col_names = True(默认) / False 或者 c(“”,””) 指定的 [向量]列名 col_types = cols(colname=colcharacter() ) / cols(colename= “c”, colname=”“) ：指定某个列的类型； 可以使用简写 each character represents one column: c = character, i = integer, n = number, d = double, l = logical, D = date, T = date time, t = time, ? = guess, or _/- to skip the column. cols(colname=col_skip() ) 跳过某个列不进行选取； skip = n 跳过的行数 locale= locale(encoding=”UTF-8”, date_format=”%AD”,time_format=”%AT”) (默认为US-centric) encoding=”UTF-8” / “gb2312” na = c(“”, “NA”) ：设置 &quot;&quot; 与&quot;NA&quot; 显示为NA；也可自定义 read_tsv()：制表符 read_csv2()：分号 read_table() read_fwf() readxl .xls和.xlsx格式的Excel工作表 read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = “”, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max)) ：读取xls/xlsx的工作表 path：Path to the xls/xlsx file sheet：Sheet to read；整数或者字符串 range：读取的范围，例如 “B3:D87” col_names：True/Fasle，或者输入自定义的列名，长度需要与col_types相同 col_types： na = “ ”：默认将空格视为NULL skip=0：跳过行数；若给定了range则忽略 excel_sheet(path) ：显示表中的sheet名称 导入 - 非表格式 非表格式的（Non-Tabular）；这里的文本文件指的是非表格式的文件，如纯文本文件，html文件 readr read_file(file, locale=default_locale())：读入为一个单一的字符串 file ： 文档路径，一个连接或一个文本数据 Files ending in .gz, .bz2, .xz, or .zip 将自动被解压 Files starting with http://, https://, ftp://, or ftps:// 将自动被下载 Remote gz files 也能被自动下载 locale=locale() : 默认为US-centric read_file_raw(file)：读入为一个未加工的向量 read_lines(file, skip=0, n_max=-1L, locale=default_locale(), na=character(), progress=interactive())：逐行读入，每一行作为一个单一的字符串 read_lines_raw()：逐行读入，每一行作为一个未加工的向量 read_log(file, col_names=FALSE, col_types=NULL, skip=0, n_max=-1L)：读入日志文档 scan scan(“file.xxx”, what=double(), seq=””, n=-1, nmax=-1, skip=0, encoding=”UTF-8”) 读取文本文件，默认情况下读取文件中以[空格分割] 所有[浮点数值] 如果文件中包含非数值，可以字符串形式读入 scan(&quot;a.txt&quot;,what=&quot;&quot;) 指定分隔符为换行，scan(“a.txt”,what=””,sep=”\n”) 返回以换行分割的字符串向量 如果数据为表格形式：因为有表头，用scan不能读入 what：读入的数据类型；The supported types are [ logical, integer, numeric, complex, character, raw and list. ] character(0)：每个单词作为字符向量的一个元素 sep：分隔符，默认为空格&quot; &quot; n = -1：显示至最后一行 nmax = -1：读取至最后一行 skip=0：跳过的行数 encoding=”UTF-8” / “Latin1” quote =’’ : 若提示 EOF within quoted string可将quote = &#39;&#39; readline 可以从键盘读取单行数据 1age&lt;-readline("input the age: ") readLines readLines(“file.xxx”, encoding=”UTF-8”) ：每一行当做一个字符串。等价于scan中指定分隔符为换行 用于读取字符型的格式文件；常用于文本文件 encoding = “UTF-8” / “Latin1” ; Lattin1是[ISO-8859-1]的别名，有些环境下写作Latin-1。ISO-8859-1编码是单字节编码，向下兼容ASCII 导出 导出 - 数据表readr write_delim(x, path, delim = “ “, na = “NA”, append = FALSE, col_names = !append) ：默认分隔符为 &quot; &quot; write_csv(x, path, na = “NA”, append = FALSE, col_names = !append) ：导出为逗号分隔符的文档 x ：要导出的对象 path：Path or connection to write to. append=False (默认), 覆盖已有的文件；若为True，增加已经存在的文件 col_names = !append 写入的时候不写入列名 write_tsv() ：分隔符为制表符\t write_excel_csv()：导出为csv文档 All columns are encoded as UTF-8 Basic write.table write.csv() 导出 - 文本&amp;文本文件readr write_file(x, path)：导出为字符串文档 write_lines()：导出为字符串向量，每一个元素一行 write_rds()：导出为RDS文档 ​ cat cat(x, file=””, sep=””, fill=False, labels=NULL, append=False)： 拼接后输出对象 把结果写到指定的文件中 x：R的对象 file：一个连接，或命名的文件打印到一个字符串；默认情况下打印到标准输出连接 sep=” “：默认为空格； 每个元素后追加一个字符串的字符向量； append = False 覆盖file内容；若为True，表示附加到file 123456&gt; cat(c("AB", "C"), c("E", "F"), "\n", sep="")[1] ABCDEF#----可以把结果写到指定的文件中-----------------#cat("i = ", 1, "\n", file="c:/work/result.txt")# 加上一个append=TRUE参数可以不覆盖原文 件而是在文件末尾附加，这很适用于运行中的结果记录。 cat vs. paste cat是输出，paste连接成一个字符串 显示结果是：一个没有引号的结果（cat），另一个是有引号的字符串（paste） 12345678910111213141516a&lt;-c(1,2,3,4)b&lt;-c(4,5,6,7)c&lt;-c('hi','hello')&gt; paste(a,b,c)[1] "1 4 hi" "2 5 hello" "3 6 hi" "4 7 hello"&gt; cat(a,b,c)1 2 3 4 4 5 6 7 hi hello&gt; cat(LETTERS, letters)A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z&gt; paste(LETTERS, letters) [1] "A a" "B b" "C c" "D d" "E e" "F f" "G g" "H h" "I i" "J j" "K k" "L l"[13] "M m" "N n" "O o" "P p" "Q q" "R r" "S s" "T t" "U u" "V v" "W w" "X x"[25] "Y y" "Z z" cat vs. print cat被认为是更低级别的print，会识别转义符并进行执行 1234567&gt; x &lt;- "a b\tc\nd"&gt; print(x)[1] "a b\tc\nd"&gt; cat(x)a b cd writeLines 案例 - 获取指定目录下的csv文档，并合并输出 Windows下路径要用斜杠/或者双反斜杠\\ 12345678# 设定指定的路径path_data_source &lt;- c("E:\\my_computer\\1_工作学习\\10_工作文档\\5 银天下-数据分析\\21_查询结果\\2 日报统计\\0712_千股期谈\\数据源_后台数据")# 获取该路径下的文件名，特定的文件名filename &lt;- dir(path_data_source, pattern="webcast-stat-.*\\.csv$")# 把文件名与路径组合在一起path_filename &lt;- file.path(path_data_source, filename) 12345678910111213141516171819202122232425262728#----获取指定目录下的csv文档，并合并输出----------### 获取当前工作目录下所有文件名的路径file.path(getwd(),dir())'E:/Jupyter_notebook/test' 'E:/Jupyter_notebook/test.ipynb' 'E:/Jupyter_notebook/专项分析'path &lt;- file.path(getwd(),dir())[1]'E:/Jupyter_notebook/test'## 获取该路径下的所有csv文件名name &lt;- dir(path, pattern=".*\\.csv$"); name'2016-01-11-IC_1.csv' '2016-01-11-IH_1.csv' '2016-01-12-TF_1.csv' '2016-01-13-T_1.csv'## 合并文件名路径 + 文件名path_name &lt;- file.path(path, name); path_name## 省去定义data.frame的时间，我选择先读入一个文件table0 &lt;- read_csv(path_name[1], locale=locale(encoding='gb2312')) ## 写循环写入该文件中for (i in path_name[2:length(paht_name)])&#123; # 大括号表示代码块的起止 table1 &lt;- read_csv(path_name[1], locale=locale(encoding='gb2312')) table0 &lt;- bind_rows(table0, talbe1)&#125;## 写出文档write_csv(table0, file.path(path, 'test.csv'), append=F)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_数据处理_dplyr&reshape2&tidyr]]></title>
      <url>%2F2017%2F07%2F24%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_dplyr%26reshape2%2F</url>
      <content type="text"><![CDATA[dplyr：轻松地处理data.frame, data.table以及多种数据库为基础的数据，实现选择、变换、分组等 plry：轻松地在vector, list, data.frame之间做分组变换，实现拆分、变换、合并的操作 reshpae2：横向、纵向做数据变换 非特别标注，默认为dplyr包 准备工作 tbl_df(iris) ：数据类型转化 将数据转化为tbl类型，更易于查看 glimpse(iris)：tbl数据的信息密集概括 View(iris)：以电子表格的样式显示数据集 %&gt;% ：管道函数，将左边对象的第一个参数传递到右边的函数中 summary()：数据统计摘要；区别对待不同类型的数据变量- (1)数值型：相关极值等信息；(2)名义型/有序型：显示的是各水平的频数值 重组数据 改变数据集的布局 布局转换 - reshpae2 （数据透视） melt(data, id.vars, measure.vars, factorsAsStrings = TRUE)：以id.vars为基准，转为长格式形式 melt(data, id=c(“”), measure=c(“”) ,variable.name=c(“”),value.name=c(“”)) id=c(“”,””) 或 id.vars=c() 以该变量为 [基准] 进行重构；其他的列均摞起来 measure=c(“”) 或 measure.vars=c() ：组合进id列的变量；若measure缺失，表示所有字段 varaiable.name ，表示将 各个变量的列名 放在这个列下面； value.name，表示对应观测值的具体数值 na.rm = FALSE, factorsAsStrings = TRUE,将因子转化为字符串 12345678910111213141516171819202122232425262728names(airquality) &lt;- tolower(names(airquality))View(airquality)airquality_1 &lt;- head(airquality,3)aqm &lt;- melt(airquality_1, id=c("month","day")) # 以该变量为 [基准] 进行重构；其他的列均 [摞起来]&gt; melt(airquality_1, id=c("month","day")) # measure缺失时，默认选择所有的列 month day variable value1 5 1 ozone 41.02 5 2 ozone 36.03 5 3 ozone 12.04 5 1 solar.r 190.05 5 2 solar.r 118.06 5 3 solar.r 149.07 5 1 wind 7.48 5 2 wind 8.09 5 3 wind 12.610 5 1 temp 67.011 5 2 temp 72.012 5 3 temp 74.0&gt; melt(airquality_1, id =c("month","day"), measure=c("wind","temp")) month day variable value1 5 1 wind 7.42 5 2 wind 8.03 5 3 wind 12.64 5 1 temp 67.05 5 2 temp 72.06 5 3 temp 74.0 dcast(data, formula, fun.aggregate = NULL)：以formula中的rowvar为基准列，重铸为宽格式 [excel统计表单的格式]；若加上FUN，则为 [数据透视表] 的格式 dcast(data, ID~variable, mean) dcast的功能相当于 group_by + summarise 的功能 formula , rowvar1+rowvar2 ~ colvar1+colvar2的格式； rowvar ：以此为基准的id列； colvar ：需要重构的变量列；将该变量中的元素 [分类] 映射到 [列] 上去 运行后的结果：出现的变量，原本为变量的列名，融合后是不参与计算的；参与的是对应的value列 若整个formula表达是中，均没有出现 variable列，默认即对其他所有的列默认做 [统计计数length] 除非指定具体的FUN函数 fun.aggregate（聚合函数）：直接列出聚合函数的名称；默认为计数 [length] margins = NULL；向量形式的变量名字； 若为TRUE，则计算所有的合计 margins= “colname” / “rowname” 即表达式中出现的变量名 subset = NULL；针对特定的变量类别做重铸；但需要加载plyr包去接收函数 选择 行中分类值 或者 variable列中的分类 “length” 进行重铸 subset = .(variable==&quot;length&quot;) 或者 subset = .(month == 5 ) subset = .(time &lt; 10 &amp; chick &lt; 20) fill = NULL； 填充NA的值 drop = TRUE；对缺失值的处理；drop or Not 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556names(airquality) &lt;- tolower(names(airquality))View(airquality)aqm &lt;- melt(airquality, id=c("month", "day"), na.rm=TRUE) # 除了month和day两列，其他列摞起来，为了等长，m和d列循环对齐dcast(aqm, day + variable ~ month) # 保持day和variable不变，按month中的元素 [分类] 映射到列上去(若month有5、6两个月，则分别有2列)dcast(aqm, variable + day ~ month) # 换一下顺序，重复的variable连在一起，对应不一样的day，这样的方式排列dcast(aqm, day ~ variable + month) # 只保留day列dcast(aqm, day+month ~ variable) # 还原为原本的样子# 表达式中均未出现variable列，即默认把其他列的每一行看做一个整体进行计算-#dcast(aqm, day ~ month) # 当整个formula表达是中，均没有出现 variable列，即对其他所有的列默认做长度计算length day 5 61 1 4 3 # 表示day为1，month为5时，共有4个变量2 2 4 33 3 4 34 4 4 3dcast(aqm, day ~ month, mean) # 对所有没有出现的变量做函数mean day 5 61 1 76.35000 124.200002 2 58.50000 123.566673 3 61.90000 108.366674 4 101.12500 93.06667# -------加入计算：等价于group_by + summarise------------------------------### 正常情况下含variable&gt; dcast(aqm , month~variable) Aggregation function missing: defaulting to length # 默认为计数 month ozone solar.r wind temp1 5 26 27 31 312 6 9 29 29 29 &gt; dcast(aqm , month~variable, mean) month ozone solar.r wind temp1 5 23.61538 181.2963 11.62258 65.548392 6 29.44444 191.9655 10.34483 78.96552 # ------加入合计：margins-------------------&gt; dcast(aqm , month~variable,sum, margins = T) month ozone solar.r wind temp (all)1 5 614 4895 360.3 2032 7901.32 6 265 5567 300.0 2290 8422.03 (all) 879 10462 660.3 4322 16323.3 dcast(aqm , month~variable,sum, margins = "month") # --------加入子集的选取subset-------------------library(plyr) # needed to access . functiondcast(aqm, variable ~ month, mean, subset = .(variable == "ozone"))dcast(aqm, variable ~ month, mean, subset = .(month == 5))names(ChickWeight) &lt;- tolower(names(ChickWeight))chick_m &lt;- melt(ChickWeight, id=2:4, na.rm=TRUE)dcast(chick_m, chick ~ time, mean, subset = .(time &lt; 10 &amp; chick &lt; 20)) # 多条件选取 dcast 和 acast区别 12345&gt; dcast(aqm, variable + month ~ day) &gt; acast(aqm, variable + month ~ day) # acast和dcast的功能基本上相同，只是dcast会把 [分组信息] 作为一列或几列显示，而acast会将其作为行名&gt; acast(aqm, day ~ month, mean) # 保留的列作为合并在一起作为列名（少了day列，不建议使用）&gt; acast(aqm, variable ~ month ~ day) # acast 多出来的功能，生成一个三维数组，按照day的值分成31个矩阵&gt; t(x) ：转置 mtcars &lt;- mtacrs[, c(12,1:11) ] ：列重新排序 排序向量 sort(x, decreasing = FALSE, …)：排序，返回值排序后的数值向量 order(…, na.last = TRUE, decreasing = FALSE)：回值是对应“排名”的元素所在向量中的位置 rank(x, na.last = TRUE, ties.method = c(“average”, “first”, “last”, “random”, “max”, “min”))：求秩的函数，返回这个向量中对应元素的“排名” 12345678910&gt; x&lt;-c(97,93,85,74,32,100,99,67)&gt; sort(x)[1] 32 67 74 85 93 97 99 100&gt; order(x)[1] 5 8 4 3 2 1 7 6&gt; rank(x)[1] 6 5 4 3 1 8 7 2 排序 - 数据框 arrange(mtcars, desc(mpg),var) ：根据变量进行排序 arrange(flights, desc(dep_delay - arr_delay))：对计算的数据进行计算 默认为升序，aes reorder(x, y [,FUN]) : 先将x转化为因子，再根据y进行排序； x 与 y两者参数的长度必须一致； FUN，表示将FUN运用于y，根据其结果对x进行排序 order = F/T ；若为T，表示将其转化为有序因子 排序并因子化 12345tophit &lt;- tophitters2001[1:25,]nameorder &lt;- arrange(tophit, lg, avg) %&gt;% dplyr::select(., name) # 获得name变量的排序tophit$name &lt;- factor(tophit$name,levels=nameorder) # 将name转化为因子，且与nameorder一致tophit$name &lt;- reorder(tophit$name, nameorder) # 报错；因为nameorder的长度小于name 返回行/列名 - Basic colnames(object)：返回所有列的名称 names(object) rownames(object)：返回所有行的名称 [二维以上的任何对象] row.names(object) 重命名列变量 rename(tbl, y=year)：将变量名year变更为y 1rename(data, newname=oldname) # 新的列名在前 select(df2tbl, x1 = x, y1 = y)：选择变量时，重命名；x1为新的列名 fix(object)：可以同时改变格式 numeric / character 【Basic】 data_frame(a=1:3, b=3:5)：将向量合并为数据框 合并 &amp; 分割 - tidyr separate(data, col, into, sep=”[^[:alnum:]]+”, remove=TRUE, convert=FALSE, extra=”warm”, fill=”warm”)：将一列分隔为几列 data： col ：待分隔的列 into=c(“”,””)：新的列名 sep：分隔符； 若为字符串，作为正则表达式进行匹配（默认） 若为数值型，则根据位置进行匹配（-1代表最后一位） remove =TRUE，移除原来的待分隔的列 convert=FALSE， 若为TRUE，则进行格式转换 separate_rows(data, …, sep=””, convert=FASLE)：把一列分隔为若干行 unite(data, col, …, sep=”_”, remove=TRUE)：把几列合并为一列 … : 指定需要合并的列名 col=”” :合并后新增的列名 1unite(table, century, year, col="year", sep="") 因子 重编码&amp;排名 - 参见 [创建新变量] 合并数据集合并联接 - Join 等价于SQL中的join联接 inner_join(a, b，by=”x1”) ：内联接 合并数据，仅保留匹配的数据 left_join(a, b, by=”x1”) ：以a表为基准表，加入与a表中x1列匹配的数据集b的记录 right_join(a, b, by=”x1”) ：以b表为基准表，加入与b表中x1列匹配的数据集b的记录 outer_join(a,b, by=”x1”)：保留所有数据，所有行 by = NUll（默认）；表示为 自联接，自动选取 [相同的列] 作为索引 by=c(‘col1’, ‘col2’)：两个表中相同名称列的匹配，必须同时出现两个字段名 by=c(‘col1’ = ‘col2’) ：两个表中不同名称列之间的匹配 copy=False(默认)； 若为True, 当a与b不为同一张表，会自动创建一个y的表 集处理 - 行 intersect(y, z)：均出现在数据集y和z中的记录行 union(y, z)：出现在y或者z中的记录，自动删除重复的值 setdiff(y, z)：仅出现在数据集y 而不在z中的记录行 合并与筛选 仅返回匹配列的记录 semi_join(a, b, by=”x1”)： 数据集a中能与b匹配的记录，以a表中”x1”列的值为索引 anti_join(a, b, by=”x1”) ：数据集a中能与b不能匹配的记录，以a表中”x1”列的值为索引 插入行/列 bind_rows(y, z) ：插入新行；把数据集 z 作为新的行添加到y中，但需要进行赋值 bind_cols(y, z)： 添加新列；把数据集 z 作为新的行添加到y中（注意：数据按所在位置匹配） 1y &lt;- bind_rows(y,z) rbind(a,b)： cbind(a,b)： 数据选取子集观测值 - 行 filter(tbl_df, cond &amp; cond) ：根据逻辑条件选取，使用 &amp;或者| 来进行设置 filter(hflights_df, Month == 1, DayofMonth == 1) filter(tbl_df, x %in% c(“a”,”b”)) ：表示x中包含“a”或者“b”的值，返回为逻辑为真 filter(iris,Species!=”setosa”) / filter(iris,!Species %in% c(“setosa”))：排除某些行 ! filter() %&gt;% select(., var)：选中子集中的特定列 对于多条件的选择，需要完整条件的，然后使用集合运算符将条件拼接起来。 &amp; 、| ==、 &gt;=、&lt;&gt;、!= %in% sample_frac(iris, 0.5, replace=False)：按比例进行随机选取 sample_n(iris, 10, replace=True) ：按数量进行随机选取 1## replace = False(默认)，表示是否替换 slice(mtcars, n:n)： 通过行数的位置进行选取， 等价于data[n:n, ] top_n(mtcars, 1, desc(carb) )：选取并排列前n条记录；相当于先按某变量进行排序，然后选择前n条记录。 top_n(tbl_df, n [,wt]) 若为分组数据，则按组排序 12## wt，用于进行排序的变量，可选；若不指定，默认为最后一个变量## -n，从底部开始选择n个数据 nth()：第n个元素 非缺失值的提取 is.na() &amp; ! 1234mtcars[!is.na(mtcars$hp), ]# is.na(mtcars$hp)，返回逻辑值TRUE / FALSE# ! 反转逻辑值# [n, ] 选择行 满足特定条件的行 字符串函数、is.na() 、 ! 123mtcars[!is.na(str_subset(mtcars$new, "^1.\\d*")),]# str_subset(mtcars$new, "^1.\\d*") 提取出格式为 ^1.\\d 的观测行# !is.na() 将其转为逻辑值，并反转逻辑值 子集变量 - 列 Selection drops variables that are not in the selection while renaming retains them select(mtcars, hp) ：通过列名或帮助函数选取列变量 select(tbl_df, mpg:hp)：；选取在mpg和hp之间的连续多个变量 （包含mpg&amp;hp；用:连接 select(tbl_df, -var) / select(tbl_df, -(var1:var4))：通过-来排除某个变量列 select(tbl, xxx )：通过帮助函数进行选择 starts_with(“x”)：列名中以元素x为首的列 ends_with(“x”)：列名中以元素x结尾的列 contains(“x”)：包含元素x的列 matches(“.t”)：符合指定匹配正则表达式的列 one_of(c(“mpg,”hp”) )：名字在指定组中的列，等价于 select(tbl, mpg, hp) everything()：所有列，一般调整数据集中变量顺序时使用 select(df2tbl,y,everything()) #将变量y放到最前 num_range(“x”, 1:5)：选取名为x1、x2、x3、x4、x5的列 select_if()：选取不同条件的列 hflights %&gt;% select_if(is.factor)：选取hflights数据中为因子的列 / is.numeric hflights %&gt;% select_if(function(col) is.numeric(col) &amp;&amp; mean(col) &gt; 3.5)：选取hflights数据中某一变量列 ？？ 唯一值&amp;重复值 distinct(iris)：删除重复记录 distinct(hflights_df, Month, .keep_all = TRUE) 1## .keep_all = TRUE,指保留除Month以外的其它列的内容。默认的情况是不保存其他列的。 指各个变量列均相同的记录 unique(x)：只对向量可用；或对各行中各变量完全相同的行取一行 duplicated(x)： 判断是否重复，返回逻辑值TRUE/FALSE； x[!duplicated(x)] ：选取不重复值的值 返回data中所有不相同的值，然后在进行行选取data[x, ] 123456789101112&gt; x &lt;- c(1:5, 3:7)&gt; duplicated(x) [1] FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE# 删除各行中变量完全相同的值 = unique(x)data &lt;- data[!duplicated(data), ] --# 返回各列所有相同的值 data[duplicated(test),]# 删除某变量中相同的值data &lt;- data[!duplicated(test[, "var"]), ] # 删除某两个变量完全相同的行 data &lt;- data[!duplicated(test[, c("var1","var2")], ] 创建新变量 根据是否删除原列进行区分 计算并添加新列 若要将多个单元格中的值合并，用stringr包中的str_c() 运用$直接创建 mtcars$new &lt;- sqtr(mtcars$carb) mutate(tbl_df, var3=var1+var2, var4=var3+..)：优势在于可对刚添加的列进行变换 mutate_at(.tbl, .vars, .funs, ..)：对指定的列运行窗口函数 .vars ：用 vars(colname,colname) 表示；也可以是序列的形式；vars(col1:col2)；或者是位置的数量 A list of columns generated by vars(), or a character vector of column names, or a numeric vector of column positions. 12&gt; starwars %&gt;% summarise_at(vars(height:mass), mean, na.rm = TRUE&gt; mutate_all()：对每一列运行窗口函数 mutate_if()：对指定类型的列运行窗口函数 窗口函数: min_rank # 排序，并列时，其他序号延号 dense_rank #无缝排序 row_number # 排序。并列时将并列数在前的序号在前 percent_rank # 把数据在[0,1]中重组，并排序 lead # 把除第一个值以外的所有元素提前，最后一位为NA lag # 把除最后一位以外的所有数据延后，第一个元素为NA between() # 数据在a、b之间 ntile # 把数据分为n分 cute_dist # 累计分布 cummean # 累积mean函数 cumsum # 累积sum函数 cusmax # 累积max函数 cusmin # 累积min函数 cumall # 累积all函数 cumany # 累积any函数 cumprod # 累计prod函数 pmax # 针对元素的max函数；返回输入中最大的值，并将其长度自动扩大到输入中长度最大的那个向量 pmin # 针对元素的min函数 ​ 计算并删除其他列 transmute(df, var3=var1+var2)：该函数扩展新变量的同时，将删除原始变量，仅返回创建的新变量 ；常伴有na.rm=T na.rm= True 计算时排除NA值 1234567891011121314151617&gt; mutate(head(airquality),Temp=Temp - 32) Ozone Solar.R Wind Temp Month Day1 41 190 7.4 35 5 12 36 118 8.0 40 5 23 12 149 12.6 42 5 34 18 313 11.5 30 5 45 NA NA 14.3 24 5 56 28 NA 14.9 34 5 6&gt;transmute(head(airquality),Temp=Temp - 32) Temp1 352 403 424 305 246 34 排名 row_number()：对于相同的值，位置在前的排名在前。 min_rank()：对于相同的值，均显示排名较前的值。 dense_rank()：对于相同的值，类似于min_rank()，均显示排名较小的值；但与后一位之间没有间隔； percent_rank()：将排名缩放为[0,1]之间的值 cume_dist()：累计的分布函数 ntile(x,n)：将x划分为n个组块 123456789101112131415161718&gt; x &lt;- c(5, 1, 3, 2, 2, NA)&gt; row_number(x)[1] 5 1 4 2 3 NA&gt; min_rank(x) # 相同的值，排名较前的值[1] 5 1 4 2 2 NA&gt; dense_rank(x) # 相同的值，排名较前的值，但与后一位没有间隔[1] 4 1 3 2 2 NA&gt; percent_rank(x)[1] 1.00 0.00 0.75 0.25 0.25 NA&gt; cume_dist(x)[1] 1.0 0.2 0.8 0.6 0.6 NA&gt; ntile(x, 2)[1] 2 1 2 1 1 NA 其他 pmin/pmax(.., na.rm=FALSE)：返回输入中最小/最大值的向量组合，并将其长度自动扩大到输入中长度最大的那个向量 min/max()：只返回单一长度的值 12&gt; pmax(5:1,10) [1] 10 10 10 10 10 重编码 if_else() &amp; case_when() 适合进行重编码，但缺少对象的输入，可结合within() 因为recode是面向 [向量] 的函数 常规编码within / $ within(x, {}) ：对x中的对象做运算 within：能对原始数据进行修改，但仍需要赋值 with()：不能对原始数据进行修改，创建的变量只能在花括号之内有效（即使进行赋值也是如此）， 通过换行（而非逗号）来分割 可通过&lt;&lt;-进行全部变量的赋值 若要查看对象，必须在with() 内部进行输出 within(data,{exp}) ：可直接输出对象 with(data,{exp}) ：执行后，没有输出对象 with函数的返回值是原语句的返回值。within跟with功能相同，但返回值不同，within会返回所有修改生效后的原始数据结构（列表、数据框等） 123456789101112131415161718192021222324252627&gt; aq&lt;-with(head(airquality), &#123; + lOzone &lt;- log(Ozone)+ Month &lt;- factor(month.abb[Month])+ cTemp &lt;- round((Temp - 32) * 5/9, 1)+ S.cT &lt;- Solar.R / cTemp + rm(Day, Temp)+ #head(aq)+ &#125;)&gt; aqNULL # 显示为NULL，即aq不存在# 仍需要赋值&gt; aq&lt;-within(head(airquality), &#123; # Notice that multiple vars can be changed+ lOzone &lt;- log(Ozone)+ Month &lt;- factor(month.abb[Month])+ cTemp &lt;- round((Temp - 32) * 5/9, 1) # From Fahrenheit to Celsius+ S.cT &lt;- Solar.R / cTemp # using the newly created variable+ rm(Day, Temp)+ &#125;)&gt; aq Ozone Solar.R Wind Month S.cT cTemp lOzone1 41 190 7.4 May 9.793814 19.4 3.7135722 36 118 8.0 May 5.315315 22.2 3.5835193 12 149 12.6 May 6.394850 23.3 2.4849074 18 313 11.5 May 18.742515 16.7 2.8903725 NA NA 14.3 May NA 13.3 NA6 28 NA 14.9 May NA 18.9 3.332205 recode&amp; recode_factor recode(.x, a= ‘apple’, .default = NULL, .missing = NULL)：保持原有的顺序水平； recode_factor(.x, …, .default = NULL, .missing = NULL, .ordered = FALSE)： .x : 进行处理的向量 对于数值型向量，你可以基于位置替换它 对于字符串，你可以基于字符串的名称来替换它 指定替换的变量为字符串 a = &#39;apple&#39; : a为对象中要变更的值；’apple’为变更后的值 .default=NULL: 对未匹配的值不做变更； .default=NAcharacter ：用NA替换未匹配的值 .default= ‘others’ : 可以指定替换的值 .default = level(x) ：支持对默认的顺序进行因子化 指定替换的变量为数值，需要用点号`` ： 例如： `2` =20 或 20L 指定替换的变量为字符串，则无需点号，也无需引号”” ： x=&quot;d&quot; 若对象x为向量is.vector() ，若不加L，则对于未匹配的值默认用NA替换；加L，对其他未匹配的值不做变更； .missing = NULL(默认) ：对缺失值NA不做处理，默认为NA； .missing = “missing”：指定具体的值对NA进行替换 若不指定替换的变量，默认按照位置顺序进行重编码；但对未匹配的值默认用NA替换 .order=FALSE(默认)：若为TRUE，则创建有序的因子 当输入的向量是可比较的，它的因子会被重新定义为默认的 123456789101112131415161718192021222324252627## 指定替换的变量 - 字符串&gt; x &lt;- sample(c("a", "b", "c"), 10, replace = TRUE)&gt; x [1] "a" "a" "b" "b" "a" "b" "a" "a" "a" "c"&gt; recode(x, a = "Apple") [1] "Apple" "Apple" "b" "b" "Apple" "b" "Apple" "Apple" "Apple" "c" &gt; recode(x, a = "Apple", .default = NA_character_) [1] "Apple" "Apple" NA NA "Apple" NA "Apple" "Apple" "Apple" NA ## 指定替换的变量 - 数值型&gt; x &lt;- c(1:5)&gt; recode(x, '2'= 20L, '4' = 40L) # 加上L之后，对未匹配的值不做变更[1] 1 20 3 40 5&gt; recode(x, '2'= 20, '4' = 40)[1] NA 20 NA 40 NA## 若不指定替换的变量，默认按照顺序进行重编码&gt; recode(x, "a", "b", "c") # 但对未匹配的值默认用NA替换[1] "a" "b" "c" NA NA NA #--------recode_factor------------------------------------------#&gt; recode_factor(factor(letters[1:3]), b = "z", c = "y") # 当输入的向量是可比较的，它的因子会被重新定义为默认的[1] a z yLevels: z y a Recode(var, recodes, as.factor.result, as.numeric.result=TRUE, levels) ：car包中的Recode函数，用法与car包中的recode函数相同；无需通过指定car包来运行； var：字符型、数值型、因子型 向量 recodes：字符串格式的重编码方式；即编码内容需用 引号&quot; &quot;包括起来，多个条件之间用分号;分隔 单个变量：&quot;0=NA&quot; 一组向量：&quot;c(7,8,9)=&#39;high&#39;&quot; 一组序列变量：&quot;7:9=&#39;C&#39;&quot; 未匹配的值： &quot;else=NA&quot; 字符串变量：&quot;&#39;a&#39;=&#39;b&#39; &quot; 若编码的内容为字符串格式，需要用引号括起来；而最外面的引号也是必不可少的 as.factor.result = T/F；当输入的var为因子格式时，默认为TRUE,否则默认为FALSE as.numeric.result=T/F；当输入的var为数值格式时，默认为TRUE,否则默认为FALSE levels：可选的，默认为原本的顺序 条件编码 if_else(cond, true_value, false_value, missing=NULL)：对于逻辑值的重编码 cond : 条件 missing = NULL(默认)； 若对缺失值替换为某个值，需指定 “x” 123456789101112131415## 常规重编码leadership&lt;-within(leadership,&#123;agecat&lt;-NAagecat[age&gt;75] &lt;- “Elder”agecat[age&gt;=55 &amp; age&lt;=75] &lt;- “Middle aged”agecat[age&lt;55]&lt;-“young”&#125;)## 常规单列变化y$new&lt;- if_else(y$new&lt;=1, 10, y$new)# 搭配within使用within(y,&#123; carb &lt;- if_else(carb&lt;=2,20,carb)&#125;) In while (i &lt;= 10) { … :报错：the condition has length &gt; 1 and only the first element will be used 这里你的i应该是个向量，用 i &lt;= 10来做条件的时候会出现很多个TRUE和FALSE，系统选用第一个作为标准 case_when(cond ~ “”, TRUE ~ “”)：多条件的重编码 类同于SQL的case when；多条件之间按顺序进行执行。 Each logical vector can either have length 1 or a common length. ~ ：表示赋值 TRUE ：类同于 Else的功能 配合list() 与 !!!，将语句进行拼接，然后执行 1234567891011121314151617181920212223242526272829303132333435# 多条件重编码within(mpg, &#123; drv= case_when(drv == "4" ~ "4wd", drv == "f" ~ "Font", drv == "r" ~ "Rear")&#125;)x &lt;- 1:10case_when( x %% 3 == 0 ~ "fizz buzz", x %% 5 == 0 ~ "fizz", x %% 7 == 0 ~ "buzz", TRUE ~ as.character(x) )## 创建一个新变量starwars %&gt;% select(name:mass, gender, species) %&gt;% mutate( type = case_when( height &gt; 200 | mass &gt; 200 ~ "large", species == "Droid" ~ "robot", TRUE ~ "other" ) )# 配合list() 与 !!!，将语句进行拼接，然后执行patterns &lt;- list( # 先将语句拼接 TRUE ~ as.character(x), x %% 5 == 0 ~ "fizz", x %% 7 == 0 ~ "buzz", x %% 35 == 0 ~ "fizz buzz")case_when(!!! patterns) # 用 !!! 执行 缺失值 在计算频数时，NA记为一次 检查与判断 is.na(x)：逻辑判断 colSums(is.na(x))：求该列缺失值的数量 mean(is.na(x))：求该列缺失值的比例 is.nan(x)：判断不可能值 is.infinite(x) ：判断无穷值 1234case_when( is.na(colnames) ~ "0" TRUE ~ "1") 移除 na.rm=T：在计算之前将缺失值移除，可用在函数内部 na.omit(x)： 移除所有含缺失值所在的行 [删除整行] 12 # 用来存储没有缺失值的数据newdata &lt;- na.omit(mydata) 缺失值重编码 na_if(x, y)：把对象x中的y替换为NA 12345&gt; x &lt;- c(1, -1, 0, 10)[1] 1 -1 0 10&gt; na_if(x,0)[1] 1 -1 NA 10 coalesce(x,y)：把对象x中的NA替换为y x, y ：均为向量 123456789101112131415161718# 把x中的NA替换为y&gt; x &lt;- sample(c(1:5, NA, NA, NA)); x[1] 5 3 NA 4 2 NA 1 NA &gt; coalesce(x, 0L) [1] 5 3 0 4 2 0 1 0# 将NA匹配为对应位置的值 （y, z 两者长度必须相同）&gt; y &lt;- c(1, 2, NA, NA, 5)&gt; z &lt;- c(NA, NA, 3, 4, 5)&gt; coalesce(y, z)[1] 1 2 3 4 5# 配合list() 与 !!!，将语句进行拼接，然后执行vecs &lt;- list( c(1, 2, NA, NA, 5), c(NA, NA, 3, 4, 5))coalesce(!!! vecs) 概述函数 - summarise 若要根据某个组别进行分组，必须先将data进行分组 group_by ； 或者直接使用plyr::ddply(data, ~var, summarise, newcol=…) summarise(iris, avg=mean(Sepal.Length)) ：对数据进行概述，并创建新的子集 （将数据概括为单行数值） 1summarise(data, newcol = mean(col)) summarise_all(.tbl, .funs, …)：对每一列运行概述概述 summarise_each(iris, funs(mean)) ：对每一列运行概述函数 summarise_at(.tbl, .vars, .funs, …, .cols=NULL)：对指定的列运行概述函数 summarise_at(mtcars, vars(hp,mpg), mean, …, .cols=NULL) vars() : 表示需要进行概述的列 .funs的用法 直接在函数中写明需要运行的函数 summarise(., vars(), mean) 结合funs写出调用的函数 summarise(., vars(), funs(mean)) summarise_if(.tbl, .predicate, .funs)：对指令类型的列运行概述函数 funs的用法 123456&gt; summarise_all(df1[,-1],funs(mean,sum)) # 若出现两个及以上的函数，列名中自动添加后缀&gt; summarise_all(df1[,-1],funs(sum(.*2))) # 所有数据用.表示&gt; summarise_all(df1[,-1],funs(medi=median)) # 指定得到的列后缀名&gt; summarise_all(df1[,-1],funs("in"=median)) # 或者加引号 (因为in在R中表示其他含义)&gt; mutate_all(df1[,-1],funs(.^2))&gt; min / max / mean / median / sd / var / sum / IQR (向量的四分位距离) n （向量中元素的个数）/ n_distinct （不同元素的个数） first / last / nth （向量的第n个值） 12345678910111213141516171819202122232425262728name1 &lt;- c("Bob","Mary","Jane","Kim")weight &lt;- c(60,65,45,55)height &lt;- c(170,165,140,135)weta &lt;- 1:4df1 &lt;- data.frame(name1,weight,height,weta);df1## 需指定要进行计算的列summarise(df1,avg_weight=mean(weight),avg_height=mean(height)) ## 对选出来的 [每一列] 都进行计算summarise_all(select(df1,-1), mean)## 配合vars函数，一次选择多列summarise_at(df1,vars(weight,height,weta),mean) summarise_at(df1,vars(weight:weta),mean)u &lt;- c("weight","height")summarise_at(df1,vars(one_of(u)),mean) # 可以接字符串向量summarise_at(df1,u,mean) # 也可以直接接字符串向量summarise_at(df1,u,mean,trim=1) # mean的参数可以接在后面summarise_at(df1,vars(contains("eig")),mean) # 匹配含有的summarise_at(df1,vars(matches(".t.")),mean) # 使用正则表达式summarise_at(df1,vars(starts_with("w")),mean) # 匹配以此为开头的summarise_at(df1,vars(ends_with("ht")),mean) # 匹配以此为结尾的summarise_at(df1[,-1],vars(everything()),mean) # 选择所有列## 检验出所有是数值的列，全部求均值summarise_if(df1,is.numeric,mean) count(iris, Species [, wt=Sepal.Length]) ：计算变量中每一个特定值的行数/频率/求和 （带或不带权重） 若出现wt，表示进行 [求和] ； 12345678910## wt="" 可选；若缺失，则计算频率count(iris, Species) # 分组计算Species列中各类别的频量；类似于基本函数包中的table函数## wt="",若指定某一列，则会通过计算非缺失值的总和来比对权重(weighted)；# wt = var2 ， 表示按var中的类别来分组，计算var2中未缺失值的对应的 [求和]count(iris, Species, wt=Sepal.Length) # 即按Species分组后，求对应Sepal.Length中的值的总和--等价于 iris %&gt;% group_by(., Species) %&gt;% summarize(., sum(Sepal.Length))## sort = False 计数 length(x)：返回一组向量或因子的长度 12345678## 返回对象的个数 或者 某个列的的观测值行数length(object/data$col)# 返回非空置的行数length(na.omit(object/data$col))# 返回对象的唯一值的行数 length(unique(data$col/object)) # 等价于 n_distinct() nrow() / ncol()：向量、数据或数据框的总行数/总列数 n()：返回观测行的行数，不能单独使用（可被用于 summarise()、mutate()、filter() ） n_distinct(x, na.rm=FALSE)：返回不重复的行数 sum(!is.na())：计算非空值的行数 count() ：[分组] 计数、求和 （参见上一内容） 分布 mean(x, na.rm=FALSE) ：返回均值； mean(!is.na()) ：非空值的均值 median(x, na.rm=FASLE)：返回中位数 sum(x, na.rm=FALSE)：返回求和 range(object)：值域 colSums(x) / rowSums(x)：各列/行求和 colMeans(x) / rowMeans(x)：各列/行求均值 位置与序列 first(x)/last(x)：最前/后的值 nth(x, n)：从开始数的第n个值 quantile(x, probs=seq(0, 1, 0.25), na.rm=FALSE)：显示x中处于[0,0.25,0.5,0.75,1]的值 probs = seq(0,1, 0.25) 或者 = c(0.25,0.5) ：指定要显示的所处位置的值 min/max(x, na.rm=FALSE)：返回最大/最小值 趋势 IQR()：四分位距离 var()：方差 sd()：标准差 mad()：绝对均方差 数字处理 options(digits=7) ：默认有效位数为7位 trunc(x)：取整 trunc(3.531) [1] 3 floor(x)：向下取整 ceiling(x)：向上取整 sigif(x, digits=n)：指定最小值的有效位数 abs(x)：绝对值 x %% y ：求余数 x^n：幂次方 exp(x)：指数 ln(x) / log(x, y)：对数 sqrt(x)：平方根 分组 group_by(.data, …, add=FALSE)：根据Species进行分组 group_by(mtacrs, cyl,vs ) … ： 表示用于分组的列名； add= FALSE(默认) FALSE，表示会覆盖原来的分组，相当于对源数据重新分组； 若为TRUE,则不覆盖，相当于在原来的基础上在进行分组； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; ## 先对mtcars按cyl 进行分组&gt; by_cyl &lt;- mtcars %&gt;% groupby(cyl) &gt;&gt; # --------add=FALSE (默认)-------------------------#&gt; by_cyl %&gt;% group_by(vs, am) %&gt;% # add默认为FALSE，即对 mtcars进行 vs,am 两个变量进行分组；&gt; summarise_at(.,vars(new),funs(mean) )&gt; # A tibble: 4 x 3&gt; # Groups: vs [?]&gt; vs am new&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&gt; 1 0 0 1.737751&gt; 2 0 1 2.115355&gt; 3 1 0 1.404061&gt; 4 1 1 1.177520&gt;&gt; # 与如上等价&gt; &gt; group_by(mtcars, vs,am) %&gt;% summarise_at(.,vars(new),funs(mean) )&gt; # A tibble: 4 x 3&gt; # Groups: vs [?]&gt; vs am new&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&gt; 1 0 0 1.737751&gt; 2 0 1 2.115355&gt; 3 1 0 1.404061&gt; 4 1 1 1.177520&gt;&gt; # --------add=TRUE ----------------------#&gt; &gt; by_cyl %&gt;% group_by(vs, am, add=TRUE) %&gt;% &gt; + summarise_at(.,vars(new),funs(mean) )&gt; # A tibble: 7 x 4&gt; # Groups: cyl, vs [?] # 分组变量有3个&gt; cyl vs am new&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&gt; 1 4 0 1 1.414214&gt; 2 4 1 0 1.276142&gt; 3 4 1 1 1.177520&gt; 4 6 0 1 2.149830&gt; 5 6 1 0 1.500000&gt; 6 8 0 0 1.737751&gt; 7 8 0 1 2.414214&gt;&gt; &gt; group_by(mtcars, cyl,vs,am) %&gt;% summarise_at(.,vars(new),funs(mean) )&gt; # A tibble: 7 x 4 &gt; # Groups: cyl, vs [?] # 分组变量有3个&gt; cyl vs am new &gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;&gt; 1 4 0 1 1.414214&gt; 2 4 1 0 1.276142&gt; 3 4 1 1 1.177520&gt; 4 6 0 1 2.149830&gt; 5 6 1 0 1.500000&gt; 6 8 0 0 1.737751&gt; 7 8 0 1 2.414214&gt; &gt; ungroup(iris)：移除数据框的分组信息 group_by_all()： group_by_at(.tbl, .vars, .funs = list(), …, .add = FALSE)： group_by_at(df, vars(accept,weight)) %&gt;% summarise(., var=mean(height),count=n()) group_by_at() 与 group_by 的区别，仅在与at中将分组的变量用 vars() 包含起来，利于查看 group_by_if()： 分组与概述函数 iris %&gt;% group_by(., Species) %&gt;% summarise(., sum(Sepal.Length))：对每一个分组分别进行概述计算 iris %&gt;% group_by(., Species) %&gt;% mutate(., …)：按组计算新变量 apply函数簇apply函数本身就是解决数据循环处理的问题，为了面向不同的数据类型，不同的返回值，apply函数组成了一个函数族，包括了8个功能类似的函数。这其中有些函数很相似，有些也不是太一样的。 行/列常用的函数 colMeans() / rowMeans() colSums / rowSums() apply apply 函数是代替for循环最常用的函数； apply(x, margin, fun, …)：按行或按列进行循环计算，对子元素进行迭代，并把子元素子元素以参数传递的形式给自定义的FUN函数中，并返回计算结果 apply函数将原本data-time的格式的按行输出后自动变为了字符串格式 X:数组array、矩阵matrix、数据框data.frame MARGIN: 按行计算或按按列计算，1表示按行，2表示按列 FUN: 自定义的调用函数 …: 更多参数，可选 1apply(head(data), 1, print) # 查看数据如何传递 1234567891011121314151617181920212223242526272829# 对一个矩阵的每一行求和&gt; x&lt;-matrix(1:12,ncol=3)&gt; apply(x,1,sum)[1] 15 18 21 24# 按行循环，让数据框的x1列加1，并计算出x1,x2列的均值# 生成matrix&gt; x &lt;- cbind(x1 = 3, x2 = c(4:1, 2:5)); x x1 x2[1,] 3 4[2,] 3 3[3,] 3 2[4,] 3 1[5,] 3 2[6,] 3 3[7,] 3 4[8,] 3 5# 自定义函数myFUN，第一个参数x为数据# 第二、三个参数为自定义参数，可以通过apply的'...'进行传入。&gt; myFUN&lt;- function(x, c1, c2) &#123;+ c(sum(x[c1],1), mean(x[c2])) + &#125;# 把数据框按行做循环，每行分别传递给myFUN函数，设置c1,c2对应myFUN的第二、三个参数&gt; apply(x,1,myFUN,c1='x1',c2=c('x1','x2')) [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8][1,] 4.0 4 4.0 4 4.0 4 4.0 4[2,] 3.5 3 2.5 2 2.5 3 3.5 4 lapply 通过lapply开头的第一个字母”l” 可以判断返回结果集的类型 lapply(x, fun, …)：返回和x等长的列表list作为结果集 x : 列表list、数据框data.frame sapply sapply函数是一个简化版的lapply，sapply增加了2个参数simplify和USE.NAMES，主要就是让输出看起来更友好，返回值为向量，而不是list对象。 sapply(x, fun,…, simplify=TRUE, USE.NAMES=TRUE) X : 数组、矩阵、数据框 FUN: 自定义的调用函数 …: 更多参数，可选 simplify: 是否数组化，当值array时，输出结果按数组进行分组 simplify =FALSE , 则返回列表 USE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置 vapply vapply类似于sapply，提供了FUN.VALUE参数，用来控制返回值的行名 vapply(x, fun, FUN.VALUE=C(“”), …, USE.NAMES=TRUE) X:数组、矩阵、数据框 FUN: 自定义的调用函数 FUN.VALUE: 定义返回值的行名row.names …: 更多参数，可选 USE.NAMES: 如果X为字符串，TRUE设置字符串为数据名，FALSE不设置 12345678910# 生成数据集&gt; x &lt;- data.frame(cbind(x1=3, x2=c(2:1,4:5)))# 设置行名，4行分别为a,b,c,d&gt; vapply(x,cumsum,FUN.VALUE=c('a'=0,'b'=0,'c'=0,'d'=0)) x1 x2a 3 2b 6 3c 9 7d 12 12 tapply tapply(x, index, fun=NULL, …, simplify=TRUE)：用于分组的循环计算，通过INDEX参数可以把数据集X进行分组 X: 向量 (只能是向量) INDEX: 用于分组的索引 FUN: 自定义的调用函数 …: 接收多个数据 simplify : 是否数组化，当值array时，输出结果按数组进行分组 1234# 通过iris$Species品种进行分组&gt; tapply(iris$Petal.Length,iris$Species,mean) setosa versicolor virginica 1.462 4.260 5.552 plyr - 分隔-操作-合并 用来切割、计算、合并数据的包；根据不同的要求进行切割，对特定条件切割后的数据应用函数，并返回结果。 可以理解为对不同条件进行分组，然后计算，并返回结果 在一个函数内同时解决spilt-apply-combine的三个步骤 Spilt：把要处理的数据分割成小的片段 Apply：对每个小片段进行操作 Combine:把片段重新组合 a*plyr(.data, .margins, .fun, …, .progress = “none”) d*plyr(.data, .variables, .fun, …, .progress = “none”) l*plyr(.data, .fun, …, .progress = “none”) 首字母代表输入的待处理的数据格式，第二个字母-输出的数据格式； ddply ddply(.data, .variables, .fun = NULL, …, .progress = “none”, .inform = FALSE, .drop = TRUE, .parallel = FALSE, .paropts = NULL)： ddply()函数会自动的将分割后的每一小部分的计算结果汇总，以data.frame的格式保存。 .data：要操作的原始数据集，比如baby_name .variables ：按照某个变量，对数据集分割 可以是字符串向量形式&quot;cylinders&quot; 或 c(&quot;mpg&quot;,&quot;hp&quot;)，也可以是表达式形式 ~ cylindes 或 ~ cylinders + model_year也可以写成.(year)的形式 .fun ：具体执行操作的函数，对分割后的每一个子数据集，调用该函数 第四个参数可选，表示第三个参数对应函数所需的额外参数 123456## 用transfrom添加一个新列; # 增加一列反映每种车与其他 [所在组] 的油耗均值之间的偏差auto &lt;- ddply(auto, .(cylinders), transform, mpg.deviation=round(mpg - mean(mpg),2 ))## plyr配合summarise使用ddply(auto, .(cylinders), summarise, freq=length(cylinders), meanmpg= mean(mpg)) 控制流重复和循环 for结构 ：for (var in seq) statement 循环执行某语句statement，直到某个变量var的值不在包含在序列seq中为止 1for (i in 1:10) print("hello") while结构 ：while (cond) statment 必须确保cond中的条件语句能【被改变】（即它在某个时刻不在为真），否则循环将永不停止 条件执行 if-else结构：if (cond) statement 或者 for (cond) statement1 else statement2 1if (!is.factor(grade)) gerade &lt;- as.factor(grade) else print("Grade already is a factor") ifelse结构：ifelse(cond, statement1, statement2) 12ifelse(sorce&gt;0.5, print("Passed"), print("Failed"))outcome &lt;- ifelse(socre&gt;0.5, "Passed", "Failed") switch结构：根据一个表达式的值选择语句执行switch(expr,...) 12345678910111213feelings &lt;- c("sad", "afraid")for (i in feelings) print( switch(i, happy = "I am glad you are happpy", # 用逗号分隔 afraid = "There is nothing to fear", sad = "Cheer Up", angry = "Calm down now" ) )## expr之后的…是expr的可能取值，后接等号（=），表示执行的行为## switch语句中，不同条件末尾要有 [逗号]## 若expr为文本形式，输入时需加 [引号] 逻辑判断 which()： 返回为真的逻辑对象，允许对数组array使用 自编函数 结构 ： 用换行进行分割即可；注意同一范围内需要用大括号{}括起来 1234myfunction &lt;- function(arg1, arg2, ...)&#123; statements return(object)&#125; 数据拆分 pretty(x, n) ：将连续型变量x分给为n个区间； cut(x, n,[order_result=TRUE])：将连续型变量x分割成有n个水平的因子 应用判断是否存在 is.element %in%]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《麦肯锡精英的39个工作习惯》_大岛祥誉]]></title>
      <url>%2F2017%2F07%2F23%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F30_%E5%B7%A5%E4%BD%9C%E8%81%8C%E5%9C%BA%2F10_%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%2F%E3%80%8A%E9%BA%A6%E8%82%AF%E9%94%A1%E7%B2%BE%E8%8B%B1%E7%9A%8439%E4%B8%AA%E5%B7%A5%E4%BD%9C%E4%B9%A0%E6%83%AF%E3%80%8B_%E5%A4%A7%E5%B2%9B%E7%A5%A5%E8%AA%89%2F%E3%80%8A%E9%BA%A6%E8%82%AF%E9%94%A1%E7%B2%BE%E8%8B%B1%E7%9A%8439%E4%B8%AA%E5%B7%A5%E4%BD%9C%E4%B9%A0%E6%83%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%A4%A7%E5%B2%9B%E7%A5%A5%E8%AA%89%2F</url>
      <content type="text"><![CDATA[《麦肯锡精英的39个工作习惯》 _ 大岛祥誉 “解决问题的基本在于保持疑问。怀疑这个结论是不是最佳结论。这样一来就能够找到解决问题的线索。” —— 大前研一 重视”成果” 问题究竟是什么？ 掌握真正的问题 对问题进行整理 收集信息 提出假设 验证假设 思考解决办法 实行解决办法 保持”从零开始”。考虑什么才是真正的问题？这项问题今后有没有继续的必要？ 分清”重视效率” 还是 “重视思考”。时常思考，自己需不需要在这个事情上花费这么多时间。 工作能力不强的人，往往本末倒置。在别人看来，往往不理解 “为什么他要在这样的工作上浪费那么多时间”。——思考自己有没有这样的事情 追求效率，指的是那些花费时间毫无意义，越快做完越能够提高生产效率的工作 将要点分为”三部分” 摸清上司的类型。[ 去回顾 《向上管理》] 情感型 or 理智型； 单独型 or 复合型 情感型：直率、感情丰富、重视共鸣；不知追求结果同样重视过程，用自己的感性来描述自己的经验和方法 理智型：自制、重视理论、准备周全、讨厌借口和浪费时间，对逻辑讨论有反应 | | 情感型 | 理智型 || —- | ——————– | —————— || 谈话准备 | 正是开始对话之前，寒暄几句 | 直奔主题 || 谈话节奏 | 把节奏交给对方，配合对方的节奏进行交流 | 自己掌握 || 谈话内容 | 可以坦白说出自己的请求 或者让对方来决定 | 由自己展开内容；插穿假设的方式来沟通 | 第一句话应该表明交谈的主题。 对于这个主题的事项，上司会根据他的理解来安排处理的时间。 关于XX事情，可以占用您一分钟时间吗？ 邮件使用。主题 + 简洁 + 尽快回复 邮件要尽快回复 回复内容需要一些时间考虑，也应该立即回复一封邮件说明 “我要考虑一下，明天给你回复” 明确邮件主题。 邮件要尽可能简洁，为了使对方在最短的时间了解邮件的要点。 将主张放在疑问里 灵活运用面谈、电话和邮件。针对不同的情况选择不同的沟通方式。 负面的 或 紧急的 信息一定要当面沟通，其次为电话。千万不要用邮件。 邮件无法传达紧张感与迫切感 打电话时慢点说话，等待对方的反应。 对方还要讲下一句话，而自己常常却插了进去。以为对方讲完了。 打电话之前思考，”这件事情真的有打电话的必要吗？” 决定打电话之前，自己先理一下思路 等对方把话说完之后，自己再开口。说话慢一点，再慢一点。 将自己的主张放在疑问里，以此引导对方自己说出你要的结果 通过 “提问” 的方式引导对方的思维； 而该 问题的答案是你心里已经知道的结果 认可、共鸣、激励 明确会议的 “目的” 与 “目标状态”。 目的：开展会议的原因(why) 目标状态：会议要达到的结果 将会议的 “目的”与”目标状态” 写在会议的白板上/显眼的地方 控制感情 用5分钟时间自省，最适合用来进行 专注性思考 的训练 5分钟后你等的人出现了，你的思考没有得出任何结论的情况下被中断了。看上去好像浪费了时间，但实际上你的发散思维在后台已经开启。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《麦肯锡精英的48个工作习惯》读书笔记_户塚隆将]]></title>
      <url>%2F2017%2F07%2F22%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F30_%E5%B7%A5%E4%BD%9C%E8%81%8C%E5%9C%BA%2F10_%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%2F%E3%80%8A%E9%BA%A6%E8%82%AF%E9%94%A1%E7%B2%BE%E8%8B%B1%E7%9A%8448%E4%B8%AA%E5%B7%A5%E4%BD%9C%E4%B9%A0%E6%83%AF%E3%80%8B_%E6%88%B7%E5%A1%9A%E9%9A%86%E5%B0%86%2F%E3%80%8A%E9%BA%A6%E8%82%AF%E9%94%A1%E7%B2%BE%E8%8B%B1%E7%9A%8448%E4%B8%AA%E5%B7%A5%E4%BD%9C%E4%B9%A0%E6%83%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%88%B7%E5%A1%9A%E9%9A%86%E5%B0%86%2F</url>
      <content type="text"><![CDATA[《麦肯锡精英的48个工作习惯》_户塚隆将 人际关系 相处时注意变换场合。这样利于加深对彼此的认识。 不管多忙，每周都要跟工作无关的人见一面；和他们交换信息，这是有效拓展视野、扩展人脉的好方法。 如果对对方有好感，一定要约定近期再见面。如果你初次见到对方就对他产生了好感，那就应该在下周或近期在见面。 对交谈抱有诚意，并真诚提问。初次见面时应记住对方的名字，接下来就是努力相互了解。而且你应该采取主动，要首先对对方产生兴趣。 磨炼内在与外在 不要说 “不好意思”， 也不要把 “对不起” 挂在嘴边，要多说 “谢谢你” “不好意思” 的便利之处，在于它既不能充分地表达感激之情，也不能充分地表达歉意 每当你要说 “不好意思” 时，停下来想一想。如果要表示感谢，就说 “谢谢你”。如果要表达歉意，那就说 “对不起” 读书后，花三倍的时间思考。思考的时间一定要大于阅读的时间。 读报的时候，要思考 “大家的反映”。 读完后要思考人们对这则消息的反映； 因为通过这些，你可以预测市场的动态 读新闻，要注意各条新闻的登载方式 至少一次读2份 报纸/网站； 一份作为信息的主要来源，一份找出与他的区别 思考每条新闻给人们带来的影响，努力探寻自己的答案，这样就能渐渐形成自己的看法。 运用图表来整理逻辑，强化结论。 整理想法的三个过程： 先写出头脑中浮现的想法 不要介意逻辑构成、因果关系、先后次序和语言表达 不断审视整理，改写成 “金字塔结构” 的模式 用 “三个关键” 锻炼思考的能力 如果一个内容需要超过3条以上的信息来表达，这个时候你应该思考自己到底要表达的是什么，它的目的与意义是什么。 护理鞋子。出门前把鞋子理干净。 不被时间操纵 无论遇到什么情况，都提前10分钟到场。这个是基本的基本。 根据事项的 [优先程度] 和 [工作所需的时间] 为中心来对工作分类 先做 优先程度 [高]，所需时间 [长] 的项目A 其次 优先程度 [高]，所需时间 [短] 马山能完成的项目B 再次 截止日期延后的 优先程度 [高]，所需时间 [长] 马山能完成的项目A 然后 优先程度 [低]，所需时间 [短] 马山能完成的项目C 最后 优先程度 [低]，所需时间 [长] 的项目D 沟通创造成果 接到任务之后，当场确认任务信息。 接到任务之后，要当前去 [界定问题]。 在什么背景下S提出的任务，目的是为了解决什么问题。5W2H 产出的要求/标准 （可通过类举之前的工作产出来对比，确定产出的要求） 截止时间 接到任务后，5分钟内马上开始安排进程。 目的是确认问题、界定标准、确认是否有遗漏的信息、预估时间。如果目前还有工作在进行，就暂时先放一放。然后抽出5分钟时间，将精力集中在刚刚接到的任务上 再次确认指示；如果工作刚开始时都是疑问，一定要立刻找上司加以确认。 因为工作初期出现的问题，越是尽早确认，越能将问题的影响控制在最小范围内。 如果等到第二天早上再对初期出现的问题确认，对你工作能力的评价就会降低 制定一份工作计划，并对完成工作所需的时间进行预判 将截止日期提前一天；这会使你自觉加快速度。 回复邮件的速度 = 别人对你的评价。这与你设置固定时间接收邮件没有然后进行回复，并不冲突。 把回复邮件的时间当做你的名片；如果对方等了很久还是没有收到回信的话，他就会担心自己之前的邮件是不是么有发送成功，进而去通过其他方式进行确认 当回复邮件需要花费大量时间时，先发送一份言简意赅的邮件告知对方 当需要整理思路时，要敢于搁置一晚再回复 向上司报告、联系、交谈时要先发制人，并穿插假设来说服对方 先报告、联系，然后交谈；报告不是目的，联系也不是目的；报告不是单方面的，在报告的同时还要听取对方的意见、调整工作的方向。 通过假设 “我打算…… 你觉得怎么样” 向上司报告工作要选在第二天一早 挤出泡沫 - 输赌候群症 超出对方的期待值 可以及时调整工作方案；如果等到下午才报告，若要调整方案则时间就很少了。 早晨的环境安静，可以进行充分沟通 对待资料与会议 把自己的资料/产出视为自己的产品。你的作品就是代表了你这个人。 在制作PPT之前，先关掉电脑，在纸上绘制出草图，理顺你的逻辑，构造你的呈现。 把注重细节贯彻到底 注重统一感 最后阶段无视资料内容，只做机械地校对；（一次只做一件事情） 会议上一定要发言，否则就跟缺席一样 出席会议的人不是被赋予了发言的权利，而是被分配了发言的义务。 会议的目的是要求全体出席者对会议作出了某系贡献 职业技能 通过多次 [写下] 相同的目标来进行目标管理；不要将回顾笔记作为目的，而是要重视书写的过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[靠谱和闭环_罗辑思维]]></title>
      <url>%2F2017%2F07%2F21%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E9%9D%A0%E8%B0%B1%E5%92%8C%E9%97%AD%E7%8E%AF_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_201712%2F</url>
      <content type="text"><![CDATA[靠谱，正在替代原来 “善良” 、”能力强” 一些词，来表达对一个人的高度评价； 靠谱和闭环 - 《罗辑思维》 靠谱，正在替代原来 “善良” 、”能力强” 一些词，来表达对一个人的高度评价； 靠谱：凡事有交代，件件有着落，事事有回音； 看似三件事，其实只有一件事，就是你要在协作中完成闭环；即有始有终； 我们可以自省一下：进行一项事情，你不会半途而废吗？一件东西用完之后，你一定放回原地吗？别人跟你说一件事，你办不办得成，都一定会回复吗？如果当时不能及时回复，在你能回复的时候，你会解释一下上次不回复的原因吗？ 靠谱，并不是说你能力很强，而是你和周边的协作网络保持高效的互动。 “靠谱”这种品质正在变得越来越重要。因为衡量人的价值尺度正在发生重大变化。 过去，一个人被高度评价，是因为他个人能力强、品质佳。 现在一个人被高度评价，是因为他能够更顺畅地和网络协同，甚至能够领导和发起网络协同。从网络的角度评估人，而不是孤立地看这个人本身，已经是我们的一种认知习惯。 为什么网络协同这么重要？因为网络效应，是人类财富增长和平等化最重要的工具，也是人类文明发展最基本、最底层的逻辑。 所以这个时代，每个人审视自己的处境，都不再是“学会啥啥啥，就不怕啥啥啥”的模式了，而是要看两点： 第一，你是不是在正确的网络中。 第二，你的行为模式是不是和网络紧密连接，是否成为网络中受益最大的节点。 海尔管理闭环的例子： 比如，在海尔上班的时候，你把椅子从桌子下拖出来，坐下开始工作。但是可能一会儿又要起身去办事，那就一定要把椅子推回去，否则就是犯规。海尔管理员工闭环，是从这么细致的地方入手的。我还记得那位老记者怕我不信，给我现场做了个示范。他抓起电话，给青岛的海尔总部总机拨了个电话，接通之后说，“我找罗振宇。”海尔哪有叫罗振宇的，所以总机就问，罗振宇是哪个部门的？老记者就瞎编了个部门。总机说，您给我几分钟，我来查一下，我让他回电话给您。你想，一般查无此人，不就算了吗？但是过了几分钟，那位总机竟然把电话回过来了，说整个海尔都查过了，确实没有罗振宇这个人。你看，当时已经有电脑了，所以查无此人并不难。但是难在有始有终，把这个动作给闭环了。一个总机接线员，接到一个问询，他不能让这个事耽搁在自己手里，无论如何他都要给出一个结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《麦肯锡方法》读书笔记_艾森.拉塞尔]]></title>
      <url>%2F2017%2F07%2F15%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F10_%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%2F%E3%80%8A%E9%BA%A6%E8%82%AF%E9%94%A1%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E8%89%BE%E6%A3%AE.%E6%8B%89%E5%A1%9E%E5%B0%94%2F</url>
      <content type="text"><![CDATA[《The McKinsey Way》(麦肯锡方法) - Ethan M. Rasiel (艾森 • 拉塞尔) 第一部分 麦肯锡思考问题的方法 第1章 建立解决方案直奔问题的解决方案 —— 初始假设 假设仅仅是有待证明其正确与否的理论，假设本身并不是答案。如果你的初始假设正确，那一段时间之后它将出现在汇报材料的首页上；如果它错误，那么在证明假设错误的过程中，你已经掌握了迈向正确答案的充足信息。 记录你的初始假设，计划你讲如何证明它正误的过程，就是绘制通向解决方案路线图的过程。 分析前，[ 先了解行业的基本情况 ]，利用 项目组 来 生成 [ 初始假设 ] 初始假设产生于事实以及通过事实解决问题的逻辑架构。因此，生成初始假设的第一步，必须要从研究事实开始。然而，在知道该从哪里开始挖掘信息之前，你是不会愿意对信息做大量研究的。 在项目开始时，要尽量多理解事实。花一两个小时来阅读行业内的出版物——不是为了收集事实，而是为了吸取行业内的信息。 生成初始假设时，不需要掌握所有的事实，只要概观行业和所研究的问题即可； 把了解到的事实按照一定的逻辑架构来整理。 项目组创作的初始假设远胜于个人的创作 将问题拆分，发现[ 关键驱动因素 ] 对每个关键驱动因素提出可行性建议 如果行业利润受天气影响很大，那么天气就是一个关键驱动因素。 “我们必须祈祷好天气” ，不是一个可行性建议 “我们必须提供应对气候变化方面的能力” ，一个可行的并且可被写成标题的建议 将建议分解到各个层次的各项议题中，并思考 会产生哪些问题？答案是什么？ 对每个问题，需要怎样的分析来证明假设的正误？ 检验初始假设 当你把问题解决路线图展开准备上路时，要检查一下线路图是否可靠。我们要检验该初始假设是不是你能设计出的最好的假设？ 考虑了所有关键驱动因素？ 考虑了所有议题？ 所有的建议偶读是可行的并且是可证实的？ 第二部分 麦肯锡解决问题的方法 第7章 进行研究专题研究 从年报开始 - 迅速了解一家公司 股东信息 or 董事长寄语，带着一点怀疑仔细阅读这一部分，能发现公司上一年度的表现，管理层对今后的发展方向的期望和战略 财务指标明细 找到公司的业务单元和生产线，公司高管是谁？在哪些地方有办公室和生产设备？ 寻找异常值 - 特别好或特别差的部分 找到特别好/差的部分，这是一个有意义的研究领域 找出各自的原因，并进行对比；你的研究就能走上顺利的轨道 寻找最佳经验 查看其它人/公司处理的办法 向他人请教 - 与行业里的其他人交流：上游（供应商）、下游（客户）等，往往有新的发现 第三部分 麦肯锡推介解决办法的方法第四部分 麦肯锡生存之道]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《刻意练习》读书笔记_安德斯.艾利克森]]></title>
      <url>%2F2017%2F07%2F11%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F40_%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%AE%89%E5%BE%B7%E6%96%AF.%E8%89%BE%E5%88%A9%E5%85%8B%E6%A3%AE%2F</url>
      <content type="text"><![CDATA[《刻意练习》_安德斯.艾利克森 《Secrets From The New Science of Experience》_Anders Ericsson 刻意练习的原则是通过研究杰出人物发现的。 成人最佳的学习方式是在情景中学习，而非独自练习。 年龄越小，大脑的适应性越好。有些能力只能在6岁/12岁/18岁之前培养。 学习中会经历的几个阶段 从0到1：从完全不会，到慢慢掌握技能，并且能够完成 “自动” 地完成，而非刻意的完成。 在球场上你的所有动作都是自动做出来的，你的表现也被人接受，不需要太多的思考。你可以真正在球场上放松。 这个阶段，即使你对自己的水平不是很满意，但你的进步是实实在在的。你已经掌握了容易的技能。 从1到N：提高技能的熟练度，但存在一个上限 你的能力随着练习的增加而增加，但那你很快会发现你依然有一些弱点，不论你多么经常地学习，这些弱点总是暴露出来 这是大多数人会遇到的一个瓶颈。而且很多事情实际上也只需要我们达到中等水平就可以了。 一旦你达到令你满意的技能水平，并能做到自然而然地表现你的水平，你就已经不再进步了。人们通常错误地理解这种现象，认为继续联系就能提升水准 “天真的练习”， 基本上只是反复地做某件事情，并指望只靠那种反复，就能提高表现和水平。 从N到N+1：克服自己的弱点，超越瓶颈，把技能上升到高水平 刻意练习的特点 刻意练习发展的技能，是已经拥有一套有效训练方法的技能。 刻意练习发生在舒适区之外，但并不会太远。并且要持续不断地尝试刚好超出当前能力范围的事物。 在 “舒适区” 做事，叫生活；在“学习区”做事，才叫练习。有效的练习必须发生在“学习区”，一旦你学会了某个东西，就不该在上面继续花时间，要立即转入下一个难度。 心理学家把人的知识和技能分为层层嵌套的三个圆形区域：最内一层是“舒适区”，是我们已经熟练掌握的各种技能；最外一层是“恐慌区”，是我们暂时无法学会的技能；二者中间则是“学习区”。 组块化地学习。 刻意练习需要把训练的内容分成几不同层次渐进提升的小模块，每次针对每一个模块进行重复联系，重复练习正确掌握一个模块后再进行下一个模块的练习。 有明确可衡量的特定目标。 只有结果可控的领域，刻意练习才有用。 需要专注和有意识地行动。 学习时间长不等于用功，决定性因素不是学习时间，而是学习环境。刻意练习不好玩，如果你在打打闹闹中享受练习的过程，那就不是刻意练习。你必须在一个不受打扰的环境中单独学习，调动大量的身体和精神资源，全力投入。特别专注地干一件事才是最酷的。 包含反馈，并且是及时的反馈。 刻意练习的关键是随时获得有效的反馈。你需要一个旁观者，他不见得水平比你高，不需要经常跟你谈心，不用激发你的战斗热情，但他必须给你提供三步反馈：演示一遍正确动作，表现一遍错误动作，再演示一遍正确动作。 有效的反馈，应该满足三个条件： 及时，一旦不对马上就有人给你指出来；超脱，对事不对人，反馈者不把你的错误上升到“你这个人行不行”的层面；试错，你犯错误的代价很小。 刻意练习的原则 确定谁是杰出人物 理想的情况是找到客观的、可复制的测量指标，为了能够一致地从人群中找到最优秀的人 找出杰出人物与其他人物的差别 思考他们都做了什么 思考哪些训练方法帮助他们实现了卓越 最佳方法是找到优秀的导师 摘抄 考试是最好的反馈。熟悉并不等于理解，想要真正理解，唯一的办法是考试和测验。没有经过测验，你的知识只是幻觉。 刻意练习最为关键的一点，是敢于迈出从舒适区往外走的那一步。你不但应该在“学习区”刻意练习，你的研究、工作和娱乐都应该在“学习区”。 遇到瓶颈时，试着从不同角度来里思考/练习，而不是去做更难的事情。 大脑的机制：如果你足够多地练习某件事情，你的大脑会改变某些神经元的用途，以帮助完成那些任务。 记忆是取决于背景的。 *一组句子你可以记忆，但若打乱句子中各个字的顺序，凌乱地排列，可能你就无法记忆了。 于刻意练习，被误读最久的一个概念是“一万小时定律”。事实上，想把自己变成高手，光知道“一万小时”毫无意义，因为真正的关键根本不在训练时间，而是训练的方法 。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《麦肯锡教我的思考武器》读书笔记_安宅和人]]></title>
      <url>%2F2017%2F07%2F09%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F10_%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%2F%E3%80%8A%E9%BA%A6%E8%82%AF%E9%94%A1%E6%95%99%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83%E6%AD%A6%E5%99%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%AE%89%E5%AE%85%E5%92%8C%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[《麦肯锡教我的思考武器》_安宅和人 序 以 “产出真正有价值的成果” 为思考目标 烦恼 与 思考的区别： 烦恼：以 “找不出答案” 为提前 “假装思考” 思考：以 “能够找出答案” 为前提，有建设性的真正思考 导论 一些良好的思考方式 “解决问题之前” ，要先 “查明问题” “提升答案的质量” 并不够，”提升议题的质量” 更重要 与其 “快速做完每一件事”，不如 “删减要做的事” 与其计较 “数字太多”，不如计较 “到底有没有答案” 工薪族、企业人、专业人士的区别 工薪族：以时间为计算基础领取薪资的人 企业人：管理者，以日常商业活动的输出（成果）责任为基础，以此获得报酬的人 专业人士：以提供特定价值为基础，获得报酬的人 对于信息的获取，应该 “掌握第一手资料” + “以自己的方式去感受” 二手资料，往往是经过他人筛选后的信息；也可能是为了支持TA的议题而呈现的信息 很多关键内容，是只有你在现场，以自己的方式去感受，才能获得的信息。 第一章 议题思考1.2 拟定假说 拟定假说 。 假说才能让原本单纯的提问，变成有意义的议题。重要的是 “你的立场是什么？” 单纯的提问：某市场规模现在如何？ 假说：市场规模是否正在逐渐缩小？ [ 这一假说，才会成为可以找到答案的议题 ] 拟定假说，才能第一次明确真正需要的信息，以及要做的分析是什么 让分析结果的解释明确化 强迫自己采取立场；因为信息越清楚，需要分析的内容就越明确 如果无法提出假说，就不会知道 “究竟是以什么样的观点，才能看出哪个才是真正的问题” 用语言或文字表达重点 加入 “主语” 和 “动词”：使得句子简单、清晰 加入比较句型 1.3 成为好议题的三要素 属于本质性的选项 含有深入的假说 可以找到答案 对于某个问题重要性的思考 - “是否需要现在找出这个答案” 第一：思考这个事项的目的/原因是什么，为了解决什么问题 第二：如果解决了这个问题，那又怎么样？对最终目标的影响程度有多大 我们运用时间的方式，才是我们的敌人。而非时间本身。 ——《每周工作4小时》 时间管理计划，并不能真正让我们获得解放。 1.4 信息收集 接触一手信息 二手信息，只不过是现实了从拥有众多层面的复合性质的对象中，巧妙抽取出来的某一个片段式的信息而已 掌握基本信息 ：在深入分析之前，你必须对某个内容的背景信息有基本的了解 不要搜集过多的信息 [知识] 的增长并不一定会带动 [智慧] 的增长；反而信息量在超过某一个程度之后，会阻碍思考。 1.5 确认议题的方法 删减变量：通过考虑极端情况来判断变量的重要性 如果将整个变量的数值放大N倍，对结果会产生多大的影响；以此来判断变量的重要性，并进行删减。 可视化：针对不同的主题类型构建不同的可视化方案 主题与空间有关：空间的平面图/立体图 主题与既定的顺序有关：根据时间/逻辑顺序一一罗列 主题与几个因素有关：运用图表呈现关系 第二章 分解议题并组建故事线 第三章 图解故事线3.2 步骤一：找出”轴” 定量分析的三个模板 比较：关键是选择什么因素进行比较 构成 变化 第四章 进行实际分析 问题的目的在于探索 “X究竟是什么？”这件事本身，而答案是用什么方式找出来的根本就不重要。——Richard P. Feynman（理查德 • 费曼） 4.3 找出答案 从不同角度探寻结果 重视循环次数与速度，而不是追求每一次的高完成度 第五章 整合”传达信息”5.3 琢磨图表 一个图表一个信息；当有两个以上事想说时，就分成两个图表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Anki_使用教程]]></title>
      <url>%2F2017%2F06%2F30%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FAnki%2FAnki_%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[卡片与模板区域（字段）样式 用HTML代码将需要设置的文本包起来 1&lt;div class=我的样式1&gt; &#123;&#123;Front&#125;&#125; &lt;/div&gt; 转到模板之间的样式区，在末尾添加自己的新样式 1234567891011.card &#123; font-family: arial; font-size: 20px; text-align: left; color: black; background-color: white;&#125;.我的样式1 &#123; text-align: center;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《金字塔原理》读书笔记_芭芭拉.明托]]></title>
      <url>%2F2017%2F06%2F29%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F10_%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%2F%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B_%E5%B7%B4%E5%B7%B4%E6%8B%89.%E6%98%8E%E6%89%98%2F%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E8%8A%AD%E8%8A%AD%E6%8B%89.%E6%98%8E%E6%89%98%2F</url>
      <content type="text"><![CDATA[《金字塔原理》_芭芭拉.明托 《The Pyramid Principle》 - Barbara • Minto [ 思考先于写作/表达 ] - 在开始写作前，先将自己的思路组织成金字塔结构，并按照逻辑关系的规则进行检查与修改。 你要强迫自己先想后写、先想后做、先向后说。 1. 表达的逻辑从整体介绍了金字塔结构的运用方式。包括使用金字塔的原因、金字塔的内容与构建方法、序言的撰写以及思维的呈现。 为什么要用金字塔结构归类分组，将思想组成金字塔 大脑会 “自动” 把具有 “共性”的任何事物组织在一起； 共性：具有某种相似的共同点 或 所处位置相近 大脑一次记忆不超过 7 个思想、概念或项目；大脑比较容易记住的是3个，次之5个，绝对不要超过7个 当我们把9个概念分类后提高一个层次变为3个项目时，但闹需要处理的内容就只有3个 因为处于较高层次上的思想总能提示下一层次的意思 自上而下表达，结论先行 清晰的顺序：先提出总结性思想，再提出被总结的具体思想 受众的大脑只能逐句理解作者/演讲者表达的思想。他们会假定一同出现的思想在逻辑上存在某种关系。如果你不预先告诉他们这种逻辑关系，他们会自动从中寻找共同点，将你表达的思想归类组合，以了解各个组合的意义 读者可利用的思维能力有限：(1) 用于识别和解读读到的词语；(2) 找出各种思想之间的关系； (3) 理解所表述思想的含义 通过有效的方法表达你的思想，减少读者在前面两项活动上的时间与精力，从而使读者能够用最少的脑力理解你表达的思想 自下而上思考，总结概括 你的思维总是从最底部的层次开始，将句子按照某种逻辑关系组成段落，然后将段落组成章节，最后将章节组成完成的文章；而代表整篇文章的是金字塔最顶端的一个思想。 仔细回想你的实际思考过程，你在总结主要思想时的确使用了这种自下而上的方式。 假设你要将6个句子组成一个段落。为什么要将这6个句子组织在一起，而不包括其他句子？原因自傲与你认为这6个句子之间有某种逻辑关系。而这种逻辑关系要求所有6个句子共同解释或支持由其组成的段落所表达的单一思想。通过这种方法，你可以把3个段落而不是其他段落组织在一起。将章节组成文章也按照这个思路进行。 每一篇文章的结构必定只支持一个思想。因为你总是要不断地对思想进行概括和归纳，直到没有可以与之关联的思想能继续概括。 思想符合如下规则能实现好的表达==【写作之前，先将你的思路放入到金字塔结构中，并根据如下规则进行检验。若不能符合，说明你的思路存在问题，需要调整思路】== 纵向：任一层次的思想必须是其下一层次思想的概括 横向：每组中的思想必须属于同一逻辑范畴 横向：每组中的思想必须按照某种逻辑顺序组织 横向：同一逻辑范畴 若希望将某一组中思想的抽象程度提高一个层次，那这一组中的思想必须在逻辑上具有共同点 对 “同一逻辑范围” 的具体解释：如果某组思想中的第一个思想时做某件事的一个原因，那么其他思想也必须是做同一件事的其他原因；如果第一个思想是某个过程的一个步骤，其他也必须是步骤； 横向：按某种逻辑顺序组织 必须有明确的理由说明为什么把第二个思想放在第二位 组织思想的4中逻辑顺序 你写作的逻辑顺序展现了你组织思想时的分析过程 演绎顺序：大前提、小前提、结论 时间（步骤）顺序：第一、第二、第三 结构（空间）顺序：波士顿、纽约、华盛顿 程度（重要性）顺序：最重要、次重要 金字塔的内部结构【在开始将思想组织成金字塔之前，首先你必须梳理你想要表达的思想】 金字塔中的子结构，能够加快你树立思想的过程： 主题与子主题之间的纵向关系 (疑问/回答式对话) 各子主题之间的横线关系 (演绎、归纳) 序言的叙述方式 (讲故事 - SCQA) 重要的是，了解读者最早提出的疑问，确保你组织和呈现的思想与读者有关联 纵向关系【金字塔中的 “思想”，指的是向受众发出信息并 “引发疑问” 的语句】 【你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向结构上逐个回答读者的疑问】 一些很明显的事实可能需要经过很长的时间才能被人们所认知；阅读的过程就是一个典型的例子。 文章都是一维的：一个句子接一个句子，在纸面上基本呈现出纵向向下的结构。 这种纵向延伸掩盖了一个事实，即思想时位于不同的抽象层次上的。根据这一事实，大主题下的任何思想都同时与文章的其他思想发生着纵向与横向的联系。 通过 疑问/回答式的对话，能使你的读者按照你的思路产生符合逻辑的反应 金字塔中的 “思想”，指的是向受众发出信息并 “引发疑问” 的语句 表达思想的主要目的，向受众传达新的信息；而这样的标出，必然会使对方就其逻辑性产生疑问。作为文章的作者，你必须在该表述的下一层次上横向地回答读者的疑问。但是，你的回答仍然是向读者传递他所不知道的信息，这又使读者产生新的疑问，于是你又在再下一个层次回答新的疑问。不断按照 “ 引起读者疑问并回答疑问” 的方式写作，直至读者不会再对你的新表述提出任何疑问为止。至此，作者就可以离开金字塔结构的第一个分支，返回关键句 (Key Line) 层次，继续回答由金字塔顶端中思想引发的初初始疑问。 吸引读者的全部注意力： 在做好回答问题的准备之前，避免引起读者的疑问 在引起读者疑问之前，避免先给出该问题的答案 横向关系横向结构上的表述不仅能回答上一层次引起的疑问，而且还必须保证表述符合逻辑。 演绎 第一个思想是世界上某种现象的表述 第二个思想是对第一个思想的 [主语] 或 [谓语] 做出的表述 第三个思想从以上两个思想中得出结论 归纳 组合中的思想相互关联，必须保证逻辑上有共同点，并且可以用一个 [名词] 来表示 序言的结构【序言的目的 $\to$ 确定初始问题】 即促使你思考做这件事的目的与原因是什么。 只有当引发 疑问/回答式对话的话语与读者有关，才能吸引读者的注意力。保证出现相关性的唯一办法，就是使这句子直接回答你所发现的读者头脑中已存在的某一疑问。 读者只有在需要了解问题的答案时才会去找答案； 文章的序言可以通过追溯问题的起源和发展来确定这一问题。 通过 讲故事 的方式进行呈现，读者会更易于理解信息 Situation：背景 Complication：冲突 Question：疑问 Answer：回答 S-背景与C-冲突，是为了说明做这个事情的Why-原因； 可以理解为，通过S与C将Why拆解 通过讲故事的序言模式，会促使你思考做这件事的目的与原因(Why) 叙述式的序言说明了 “冲突” 发生的 “背景” ，以及 “冲突” 引发的 “疑问” ，而这个 “疑问” 正是你的文章将要 “回答” 的。一旦你提出了对该 “疑问” 的 “回答”，就回使读者产生新的疑问，于是你就要在文章结构的下一层次上回答这些疑问 如何构建金字塔当前已经掌握的信息 金字塔顶端有一个包含 主语和谓语 的句子 这个句子的 主语 就是文章的 主题 这个句子是对读者头脑中已经存在的某个疑问的回答 回答这个最初的疑问，就是你写作的动机 自上而下法 先利用序言的结构将头脑中的观点逐个梳理出来 再开始进行书写 目的是为了确保你了解自己将要回答哪些疑问。而一旦确定了主要疑问，其他因素就很容易在金字塔结构中各就各位。 简要步骤 提出主题思想 设想受众的主要疑问 写序言（背景 - 冲突 - 疑问 - 回答） 与受众进行 疑问/回答式对话 对新的疑问重复进行 疑问/回答式对话 具体步骤 画主题方框，填入要探讨的主题 金字塔结构最顶端的结构。 若不确定主题是什么，跳到第2步 确定读者 ，并设想主要疑问 ，然后写出来 确定文章将面向哪些对象？ 希望回答读者关于该主题的哪些疑问？ 若无法确定，跳到第4步 写出对该疑问的回答 若还不清楚答案，请注明你有能力回答该疑问 说明 “背景” 证明现阶段你能够清晰论述该主要的疑问和答案；具体做法： 把要讨论的主题与”背景”相结合，作出关于该主题的第一个不会引起争议的表述。 指出 “冲突” 你作出了第一个不会引起争议的表述，开始了与读者进行 疑问/回答式对话。 考虑 “背景” 中发生了哪些 “冲突”，以致引发读者的 “疑问” 检查 “主要疑问” 和 “答案” 【确定读者的疑问与你之前设想的疑问是否一致】 在对 “背景” 和 “冲突” 的介绍中，应当直接导致读者提出主要疑问（已在步骤2中列出） 否则，必须要重新介绍 “背景” 中的 “冲突”，使之可以直接导致读者提出主要疑问。 若 “背景” 中的 “冲突” 与 主要疑问对不上，则必须重新构思 自上而下构建金字塔 P35 图3-1 金字塔结构中互相关联的各要素 自下而上法 当你无法确定主题、读者心中的疑问，无法构造金字塔的顶端，可以向下移动一个层次，从关键句层次上着手。 步骤 列出向表达的所有观点 行动性思想 描述性思想 找出各要点之间的逻辑关系 得出结论 初学者事项 一定先搭结构，先尝试自上而下法 序言先写背景，将背景作为序言的起点 一旦你知道自己想在序言的主体部分说什么（背景、冲突、疑问和回答），你就可以根据你所希望产生的效果，按任何顺序写出这些内容。选择不同的顺序会影响文章的风格 多花时间思考序言，不要省略 序言是你思考为什么采取行为的原因/目的 将历史背景放在序言中 正文部分应当只包括思想，思想只能以逻辑方式相互联系 序言仅涉及读者不会对其真实性提出质疑的内容 在关键句层次上，更宜选择归纳推理而非演绎推理 序言的具体写法 以讲故事的形式编写序言； 序言应概述读者已知的信息，并将这些信息与文章将要回答的疑问建立联系；然后作者就可以把全部精力放在回答问题上 序言的讲故事结构 讲故事的形式，是为了让读者抛开复杂的思想，专注于你的话题。同时激发读者兴趣，吸引注意力。 “背景” ：一个特定的时间和空间 “冲突” ：能推动情节发展，并引发读者 “疑问” 的因素 （并不是严格意义上的所谓冲突） “疑问” ：读者产生的 “疑问” “回答” ：仅对该疑问的 “回答” ( 为什么 - 回答必须是原因 ) 序言不同顺序的呈现形式 结构必须是 ”背景 - 冲突 - 疑问 - 回答“；但呈现的顺序可以有所变化 标准式：背景- 冲突 -答案 开门见山式：答案 - 背景 - 冲突 突出忧虑式：冲突 - 背景 - 答案 突出信心式：疑问 - 背景 - 冲突 - 答案 关键句要点 不仅回答由文章主题引起的新疑问，还要呈现文章的框架结构。 列出的关键句要点必须让读者在开始阅读的30秒内就能了解你的全部思路。随后的内容只是解释/支持这些观点，就能顺利地将读者请到一个适当的位置上。 关键句要点，必须是完整的思想，完整的句子。而不仅是一个名词。例如，”成功的前提和条件“等 序言与要点 全文序言：提示全主题的信息 要点引言：提示这一主题与全主题的关系 序言的目的是 ”提示“ 读者而不是 ”告诉“ 读者某些信息 序言必须包含讲故事的三个要素，”背景“、”冲突“、”答案“ 全篇文章的中心都依赖于读者提出的第一个疑问，即初始疑问。这种疑问全篇只能有一个，并且是通过序言来引出的。 序言的常见模式常见的4类问题 What - 我们应该做什么？ 不知道做什么？ 有多个可供选择的内容，不知道做哪一个？ How - 我们应该如何做？ Do or not - 我们是否应该这样做？ Why - 为什么会发生这种情况？ 关于解释做法的方式 （我们应该如何做？） 告诉读者他们之前没做过的事 告诉读者如何正确做他们正在做的事 分别列出两个对象之间的流程/因素 两者之间的差异决定了关键句的要点 涉及两个对象之间的比较时 关于比较选择的方式（我们应该做什么） 一旦选择了某种方案，必须回答 ”为什么此方案优于其他方案？“ 当事先没有可选方案时，即回答 ”我们应该做什么“ 最好的方法：围绕评估的标准（即该行为产生的结果）撰写关键句要点。 若有最佳方案，则表明选择方案C的主要原因，放弃方案A与B的主要原因来进行（而非通过否定A与B，来确定C；我们选择C是因为它能解决问题，根本没有必要提及A和B。若读者要求给出可供选择的方案，很可能时因为他的问题没有被清晰地既定，即R2是模糊不清的；这种情况下，读者真正想要的不是所有可选的解决方案，而是可供选择的R2） 如果任何一种方案都无法达到你的目标/无法准确描述目标，此时你的目标是围绕 “替代目标”写作，而不是 “替代方案”； 关键句应该为 ”选择哪种方案，取决于你希望达到的目标“ 各个方案之间相互比较意义不大，重要的是如何与R2比较。由于没有明确而的R2，我们在做的其实是界定它应该是什么 下一层次的关键句应该是各方案产生的结果 “如果你希望取得稳定的销售额，应该选择方案A” 转化为替代目标的写作 P76 图4-11 对”疑问”的回答 关于介绍流程的改进 想象改变前和改变后流程中的每一步，确定这些改变就是你想要的 读者对新旧流程都了解。他的问题：是否应该实施新流程 或 应该怎样实施 读者不了解流程是怎么工作的，更不知道问题所在。他的问题：准备怎么改变，以及为什么要改变 演绎推理与归纳推理 在金字塔横向结构中，同一组的思想之间存在着逻辑顺序，具体的顺序取决于该组思想之间的逻辑关系是演绎推理关系、还是归纳推理关系。 演绎推理：位于演绎推理过程上每个思想均有前一个思想导出，重点是演绎推理过程的最后一步，即由 ”因此“ 得出的结论。 归纳推理：将一组具有共同点的思想、事实归类分组，并概括共同性 演绎推理 演绎推理比归纳推理更容易实现，人们在思维时会更多地使用演绎推理。但在写作时却显得比较繁琐。 在关键句层次上尽量避免使用演绎推理，而用归纳推理取而代之。 演绎推理的步骤 第一个思想是世界上某种现象的表述 第二个思想是对第一个思想的 [主语] 或 [谓语] 做出的表述 第三个思想从以上两个思想中得出结论 也可以是如下三个步骤： 出现的问题或存在的现象 产生问题的原因 解决问题的方案 演绎推理的参照标准 演绎推理的过程不要超过4个步骤 推导出的结论不要超过2个 归纳推理 同一主题的信息都集中在一起，不同主题之间的界限非常明确。 完成归纳推理需要的两项技能： 正确定义该组思想 准确识别并剔除该组思想中与其他思想不相称的思想 通过自下而上提问的方式来检查你的推理；并且概括的思想不能与该层之下的思想抽象层次过多。 归纳推理的步骤： 最重要的是找到一个能够表示该组所有思想的名词； 这个词必须是单一名词 因为所有表示一类事物的词都是名词 该组思想中必定包含两个及以上该类思想 找不出一个与该名词不相配的思想 eg：计划、步骤、损害方式 演绎推理与归纳推理的区别 当你进行演绎推理时，推理过程的第二个思想必须是对第一个思想的主语或谓语的表述； 如果不具有这一特点，就不是演绎推理；而是归纳推理 当你进行归纳推理的时候，同组中的思想具有类似的主语或谓语，同时你应当能用一个单一的名词来概括，以检查你归类是否恰当 归纳过程中，通常需要保持主语不变，谓语改变；或者主语改变，谓语不变 来进行归纳； 不同情况下对 [关键句层次] 选择不同的逻辑方式【对关键句层次，尽量使用归纳推理法】（不包括关键句层次以下的层次） 对于演绎推理 与 归纳推理的争论，常见的问题可能是： 应该先告诉读者为什么要进行改革，然后告诉读者要采取的措施？ 应该先告诉读者必须进行改革及进行的措施，然后再告诉读者为什么要采取这样的改革？ 先说明what再说明why P87 配图 5-5 用归纳法论述更清晰、更简洁 建议最好先说明行动 (what)，后说明原因 (why)； 大部分情况下，采取哪些行动才是读者最关心的； 极少情况下，会关系采取行为的原因 采取演绎推理的两种情况： 当你在金字塔顶端表达的思想与读者期望的或预想的不一样时，建议采取先说明原因，在表述具体行为的方式。即读者更关心”为什么“的情况下，需要使用演绎表达法； 若不先给予解释，读者无法理解需要采取的行动。 商务文章的读者很少属于以上两种情况。 在某个段落中使用演绎法是合适的，读者也是容易理解的；若在较高的层次上，归纳法总是比演绎法更容易理解。 如果读者必须读完好几页才能找到演绎推理的第一步和第二步之间的关系，读者一般是无法理解演绎推理之间的关系的。 2. 思考的逻辑写作时机的掌握： 当你对文章结构的思考已经深入到关键句层次的下一个层次时，你就应该开始写作了。 更低层次的思想不要在构思阶段完成，而应放在实际的写作过程中完成。 罗列并不是一个好的表达方式 罗列似乎已经是一种普遍的倾向。虽然罗列不失为一种将思想排列出来并审视的方法，但我们不能止步于此，应当进一步思考，以保证每组中的各个思想之间确实存在某种内在的逻辑关系，然后明确说明这种逻辑关系的隐含意义。 研究各个组的思想是思考过程的重心，但也是一项艰难的工作，因此经常被忽略。 完成思考需要的两个步骤，这一过程称为 ”冷静思考“ 确定逻辑顺序 概括各组思想 应用逻辑顺序归纳分组活动仅有的3种方式： 前后因果关系（时间/步骤顺序） 将整体分割为部分、或将部分组成整体 将类似事物按重要性归为一组 每个问题都具有一个共性，但所具有的共性的程度各不相同； （如果不存在这种差异，就无法从这方面进行区分） 逻辑顺序呈现的是一个过程，而这个过程取决于你需要回答的问题。 根据逻辑顺序呈现内容 P127 表6-2 需要回答的问题 时间顺序 按照采取行动的顺序依次达到某一结果的行动 根据结果寻找原因 同一组行动是为了达到同一个特定的结果。如果某个过程或流程较长，且包括许多步骤，那就会存在多个层次的原因和结果。事实上，每组思想最好不要超过4个或5个。如果某一组思想超过5个，那么其中某些思想之间很可能缺乏紧密的联系。 即使各个步骤的却应该按照以上顺序进行，但这些步骤可能并不处于同一个抽象层次上。其中一些步骤是为了实现另一些步骤；所以，在总的过程中存在一些具有完整结构的子过程。 检验各行动的因果关系，以此来进行分组：想象采取行动之后产生的结果，这个结果是为了先于另一项行动，还是为了实现另一个行动 结构顺序 结构顺序就是当你使用示意图、地图、图画或者照片想象某事物时的顺序。 某事物可以是概念性的，可以是一个物体，也可以是一个过程。但这个事物必须被合理地划分入不同的部分。 严格遵从 [MECE原则] “创建” 逻辑结构 相互独立 - Mutually Exclusive ； 没有重叠；各个部分之间是否有明显的排他性以及分割点； 完全穷尽 - Collectively Exhaustive ； 没有遗漏；各部分加起来是否能组成整体 当一个事物可以被多种方式划分时，采取哪种划分方式其实是一种倾向性的呈现。 如果划分时强调活动本身，那么各部分展现的是一个逻辑过程（流程），因此采取时间顺序。 如果划分时强调地点，那么各部分展现的是一个地理状态，应采取结构顺序。 如果划分时强调与某一产品或市场有关的活动，那么划分就是一种归类。各部分应按照重要性顺序进行排序。 按照 [自上而下、自左而右] 的方式 “描述”逻辑结构 程度顺序重要性顺序。一组因为具有某种共同特点而被组合在一起的事物所采取的特点； 创建适当的分组 明确指出每组中的所有问题具有共同特性，并确保所有具备该特性的问题被列入该组。 根据重要性程度进行排序，先重要后次要 除非是处于情绪的考虑，采取将最重要的放在最后的方式产生戏剧性的效果 概括各组思想概括各组思想的行为实际上是完成思考的行为。需要确保思想属于同一组，应抽象、提炼、概括思想精华； 总结句避免使用 “缺乏思想” 的句子 “缺乏思想” 的句子不能激发读者往下读，还可能使读者根本无法了解你表达的意思 “缺乏思想” 的句子会掩盖思考不完整的事实，使你错失一个进行有逻辑性和创造性思考的机会 当你得出一个概括性的思想，可用两种方式延续你的思路： 对其做进一步评价（演绎法） 找出与之类似的思想（归纳法） 使用这一过程之前必须确保原有的概括性思想时合理的 思想表达的方式与分组无关， 可以是行动性语句（告诉对方做什么），也可以是描述性语句（告诉对方关于某事的情况） 概括行动性思想 （介绍采取的行动、行为、动作、步骤、流程）时，应说明采取行动后取得的结果（效果、达到的目标） 概括描述性思想（介绍背景、信息）时，应说明这些思想具有的共同点的含义 总结句要说明行动产生的结果/目标，这些结果必须是可衡量的 当你罗列出一系列你认为实现某一目标应当采取的行动时，你必须先指出这些行动应当达到的结果，然后才能判断是否遗漏了任何行动。 理顺思路最简单的办法：想象自己确实采取了这些行动，根据这些行动产生的明确结果，修改行动步骤的措辞 帮助你梳理思路、轻松表达的技巧： 在将各行动（步骤、流程）联系起来之前，先用明确的语句描述各行动（步骤、流程） 找出明显的因果关系组合，尽量将每一组中的行动控制在5个以下 直接从这些行动、步骤，概括行动的结果与目标 总结句要使用明确的词汇/语句 对于要达到的结果，必须是可衡量的。可以用某种明确的方式判断是否实现了这一结果。 对于这个结果，进行反向思考。想象采取了这些行动，这些行动能达到概括的结果吗？ 并以此来修改行动性思考的措辞 eg: (1)为了达到目标X，需要做Y； (2)想象已经做了Y，能达到目标X吗？ 使用明确的语言表达最终结果是非常必要的。除非你使用的语言达到了这一要求，否则你根本无法客观判断你列出的行动、步骤，是否包括了所有应当包括的步骤。 区分行动步骤的层次 两个行动之间，先做哪个是可以选择的，属同一层次 两个行动之间，必须要先做哪个的，属不同层次 对于没有本质区分的各个行动，根据产生的结果进行分类。 直接概括行动的结果 该组行动、步骤之间必须相互独立(不重叠)，完全穷尽(无遗漏) 总结概括性语句，必须说明完成各行动步骤之后导致的直接结果，且是可衡量的； 对于这个结果，进行反向推导。想象采取了这些行动，这些行动能达到概括的结果吗？ 并以此来修改行动性思考的措辞 eg: (1)为了达到目标X，需要做Y； (2)想象已经做了Y，能达到目标X吗？ 使用明确的语言表达最终结果是非常必要的。除非你使用的语言达到了这一要求，否则你根本无法客观判断你列出的行动、步骤，是否包括了所有应当包括的步骤。 可通过分别确定主语、谓语的方式来拆解各个复杂的句子 P148 ​ 找出结论之间的共性 列出一些可能值得思考的思想 （常止于第一步） 找出这些思想之间的共同点，并证明这些思想确实属于同一类，因而有理由与其他思想分开（关键1） 明确说明这些思想之间的共同点所具有的普遍意义，即推出一个新思想（关键2）（至此，才完成思维过程） 结构上的共性 针对同一类主语 针对同一类谓语（动作或对象） 具有同一类隐含的思想 “同一类” 不是指完全相同，而是指属于同一范畴，能够用同一个名词表示的 如果无法在一组被列为”问题”、”原因” 或 “结论” 的思想中找出明确的逻辑关系，这说明其中必定存在问题。你必须重新思考。 【找到概括性语句的主要价值，可以帮助你发现自己的真实思想。 】 完成提炼总结概括的完成思考过程：图7-10 的呈现形式，虽然简单，但简洁地表达了核心思想；“富有思想” 的图表 富有思想的图表 P159 图7-10 有吸引力的市场 不能简单地把一系列思想堆放在一起，并假定读者能够看出其中的意义。每一组思想都隐含着一个总结性的思想，这个思想是能够呈现该组思想之间关系的本质。 进行任何一次分组，都要问自己 “为什么我只列出了这些思想，而不是列出其他思想呢？“ 这些思想都具有某种共性，而且是以这种方式相互关联的仅有的一些思想 在这种情况下，该组的概括性思想应当是该组思想共性所隐含的意义 这些思想都是实现某一结果而必须同时采取的行动 这种情况下，该组的概括性思想应当是表明采取以上行动后产生的直接结果 3. 解决问题的逻辑 序言的作用 $\to$ 对问题定性 金字塔结构的作用 $\to$ 分析问题和寻找解决方案 提高报告的秘诀： 界定问题 有条理地搜集和分析数据，转化为金字塔形式 界定问题存在问题，是因为现状的结果与期望的结果之间有差距； 非期望结果R1 - Undesired Result 期望结果R2 - Desired Result 界定问题的框架要去了解问题存在的背景，以及在其中的发展历史。 问题，是你已有的（现状）与想要的（目标）之间存在的差距。这种差距是来自某一背景，并在一系列特定的条件下产生的。所以，了解在其背景中的发展历史，是确定差距的性质和把握其重要性最基本的过程。 你的解决方案所处的阶段 不知道做什么？ 给出What 不知道这个措施对不对？ 给出 Do or not 不知道怎么做？给出How 做了之后，仍然没有达到结果？Do what, not success 展开问题的各要素4个要素： 序幕 - Opening Scence - 某一特定的场景 困扰 - Disturbing Event - 推动剧情发展的因素，并引发非期望结果R1 某件事情的发生打破了原本稳定的环境 困扰的来源：内部 、 外部因素 现状，非期望结果 - R1, Undesired Result 目标，期望结果 - R2, Desired Result 可衡量的具体目标；若R1是机会，则希望利用它 展开问题的各个部分，目的是搭建一个粗略但清晰的框架，帮助找出你理解问题上的差距，并围绕这些差距写序言 通过各要素界定问题 P168 图8-2 问题源于现有背景 发掘读者的疑问最常见的问题 不知道如何从R1（现状）到R2（目标） - what 知道如何从R1到R1，但不确定是否正确 - do or not 知道从R1到R2的正确方案，但不知道如何实施 - How 最常见问题的变形 知道从R1到R2的解决方案，并且已经实施，但由于某种原因行不通 - do it , not success 确定了好几个方案，但不知道选哪一个 - choice 不常见的情形： 知道R1，但不能具体描述R2，所以无法找到解决方案 知道R2，但不清楚自己是是否处于R1（典型的标杆对比） 初始问题的种类 P177 图8-10 确定读者究竟想找哪些问题的解决方案 开始写序言 结构化分析问题分析问题的方法 提出假设 设计试验，根据产生的结果排除一个/多个假设 通过试验得出明确的结论 采取补救措施 设计诊断框架 根据仅有的3种逻辑顺序来设计 - (1)因果/时间关系；(2)结构顺序；(3)归类分组 寻找因果关系 财务结构 - 涉及数学公式，均可用因果关系归类 eg: 利润 = 收入 - 成本 任务结构 - 结构顺序 归类分组 将所有可能的原因按相似性分类；前提是这种预先的分类有利于综合分析各种事实 4. 演示的逻辑分别介绍了书面呈现、PPT呈现的一些基本原则 书面上呈现金字塔 应该让读者在30秒之内理解作者的整体思维架构，包括序言、中心思想和关键句要点。 突显文章的框架结构 当支持关键句的段落只有1个时，只需使用下划线即可。 当支持关键句的段落超过2个时，有多种方式。 多级标题 一个标题代表的思想是一组思想中的一个，一组中所有思想共同解释/支持该组的整体思想 不同层次的思想，用不同的标记区分 层次越低的思想离左侧越远 同一层次的思想采用同一表现形式 相同的思想应使用相同的句型（同一组内之间） 所谓句型，指需与第一句中第一个词的类型（动词/名词）保持相同 协调各项活动 （第一个词为动词） 实施各项改革 标题与正文应分开考虑 每组标题前应集中提前介绍 大标题下应该有一段话，集中介绍下面标题的主要内容；不要紧接着文章题目写每一章的标题，也不要每一章标题写每一节标题 标题用词应提炼思想的精髓 下划线 下划线是为了方便阅读和提高阅读速度 上下文之间要有过渡 各种不同的过渡方法是为了抓住读者的思想，把他拉回到他应该属于的地方，让读者理解你想说的内容 总结各部分内容 当一个章节特别长或特别复杂时，可以停下来做一个完整的总结后再继续往下写； 说明下一步行动 如果你的文章是建议读者采取一系列你认为他有可能采取的行动那个，你就有必要说明下一步的措施。并且可以以 “下一步措施” 来作为章节的题目； 在PPT演示文稿中呈现金字塔 文字幻灯片应该只包含最重要的、经过适当分组和总结的思想 演示文稿应图文并茂，使用各种图表相配合 文字幻灯片 说明框架结构 强调重要的结论、观点 图表：解释复杂的关系、原因 房间里听众最感兴趣的不是幻灯片，而是你。幻灯片只是视觉上的辅助手段。因为，你说的和你演示的应该有明显的区别 理想的比例，图表90%，文字10% 设计文字幻灯片清楚你要说的内容 不要把文字浪费在那些可以通过口头表达的转折性或介绍性语言上 文字幻灯片最好只用于强调金字塔中的主要论点 清楚你要演示的内容 每次只演示和说明一个论点 除非你想先列出摘要或列表中的一组论点 论点应使用完整的陈述句，而不是 “缺乏思想” 的标题性语言 文字应尽量剪短 使用简单的数字。 数字越简单越好，比如490万美元就比487987美元更容易让人记住 字号应足够大 一次只阐述一个内容 P244 图11-3 用幻灯片呈现金字塔中的主要思想 设计图表幻灯片 图表幻灯片传递的信息应简单易懂。 读者没有几乎对它们自己研究找出各个部分的含义。同时，如果图表过于复杂、详细，就会把大量时间浪费在解释上，而不是用在讨论上 即使使用复杂的图表，一份演示文稿中复杂图表的数量 &lt; 3个 制作图表幻灯的步骤： 问题 $\to$ 答案作为标题 $\to$ 选择图表样式 确定想用图表表达的问题 把答案作为图表的标题 选择最适合表达论点的图表样式 最后一步才是选择图表样式，千万不要本末倒置； 图表的标题一定要直接传递信息 传递更清晰的信息 “各地区利润份额” 所包含的信息比 “西部地区约占利润的一半” 少得多 最大限度减少混淆 把读者的注意力集中在你希望强调的数据 因为观众有不同的观点、背景和兴趣，关注的角度也不同；即使同一张图表，不同的人会有不同的理解； 在字里行间呈现金字塔我们的大脑是通过图像而不是文字来进行理性思维的，因为这样效率更高。图像能把大量的事实综合成简单抽象的概念。 遣词造句要做到条理清晰，必须从 “看见” 你要说的内容开始。有了图像后，只需简单地把它复制成文字；读者反过来也能从你的文字中重新在大脑中化图像，这样不仅理解了你的思想，而且过程本身也是一种享受。 P255 图12-1 图像更易于理解 在大脑中画图像 - 记忆图像记忆图像能在阅读过程中，帮助你逐字逐句记忆段落和从中提取信息。为了理解和记忆，每次阅读时必须在大脑中画图像。 对于一些抽象的观点，可以用骨架结构代替图像来说明。 骨架图。通常仅包括一种或几种几何图形（圆形、直线、矩形、椭圆形等），以程式化/草图的形式编排，加上箭头之类表明方向与相互关系。 把图像复制成文字 做到条理清晰的有效方式，强迫自己想象各种思想之间的内在关系。头脑里有了清晰的图像后，就能立刻把它转换成清楚的句子，并在记忆中以图像的形式储存记忆。 以图像形式储存记忆非常重要，因为阅读是一个逐字逐句的过程，而且我们的头脑只能容纳有限的词汇。通过从文字恢复图像的方法，不仅能大量传递知识，而且能用清晰的图像传递信息，便于回忆。 威廉 • 明托的一段话： 写作时，你好像一位司令官，指挥着千军万马，排队通过一个每次只能通过一个人的狭隘关口；而你读者则在另一边迎接，将部队进行重新编排和重新组织。无论主题多么大或多么复杂，你都只能以这种方式表达。 最终你会发现，这就是我们在顺序和编排上对读者应尽的义务，以及为什么修辞学者们除了强调措辞得体和别出心裁外，还把顺序和编排当做那些给予自己厚爱的人应尽的义务。 对于一些非场景化的表述，可以找出名词以及它们之间的关系，同时把它们看做视觉图像。 把图像复制成文字 P259 图12-4 用图像表示3个名词的联系 其他摘抄金字塔结构总括 金字塔结构组织的思想： 首先表达的主要思想，使受众对表达者的观点产生疑惑 关键是对初始问题的引出与界定 主要思想在下一层次上的思想将回答这些问题 人类只有用某种方式将思想表达出来（说出来/写下来），我们才能够准确把握自己的思想。 针对上一层次的问题，回答必须是对问题的直接指向； “为什么” 之类的问句回答必须是 “原因” 标题应该呈现某种思想、观点或结论，而不是只说明要讨论问题的类别 推理的三种方法 分析问题的方法，是通过了解背景（情况），寻找非期望结果（结果）产生的原因（规则），并检查是否已经找到（情况） 任何推理过程都要涉及的3类实体 规则：关于事物运行所遵循的法则 情况：已知事实 结果：如果把规则用于该情况，预期将发生的事情 有意识地将所认知的信息归类到这3类实体中 演绎推理 1 - 规则 如果价格定的太高，销售将下降 如果A则B 2 - 情况 价格定的太高 A 3 - 结果 所以销售将下降 必然B 归纳推理 1 - 情况 提高价格 A 2 - 结果 销售下降 B 3 - 规则 销售下降的原因可能是价格太高 如果A很可能B 外展推理 1 - 结果 销售下降 B 2 - 规则 销售下降通常由于价格太高 如果A那么B 3 - 结果 检查价格是否太傲 可能A 好的表达是遵从大脑的运作方式 【把这些特点转变为有指导意义的具体行为】 尽量用简单的句子，而不是复杂的结构与修辞 对受众来说，最容易理解的顺序是：先了解主要的、抽象的思想，然后了解次要的、为主要思想给提供支持的思想。 对文章的思想作出 疑问/回答式反应 是人类的一种自然反应 大脑会 “自动” 把具有 “共性”的任何事物组织在一起； 共性：具有某种相似的共同点 或 所处位置相近 大脑一次记忆不超过 7 个思想、概念或项目；大脑比较容易记住的是3个，次之5个，绝对不要超过7个 我们的大脑是通过图像而不是文字来进行理性思维的，因为这样效率更高。图像能把大量的事实综合成简单抽象的概念]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Anaconda_使用指南]]></title>
      <url>%2F2017%2F06%2F16%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FAnaconda%2FAnaconda_%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Conda的包管理12345678# 安装包conda install numpy# 查看已经安装的packagesconda list# 在当前环境下安装anaconda包集合conda install anaconda 从Anaconda.org安装包在浏览器中，访问 http://anaconda.org. 找到名为 “bottleneck” 的包，进入后按左侧的查找包 “Search Packages.” 在那里，你会看到某个包的通道 1conda install -c r rpy2=2.8.5 移除包1conda remove numpy conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本 123456789# 更新conda，保持conda最新conda update conda # 更新anacondaconda update anaconda# 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 Conda的环境管理Conda的环境管理功能允许我们同时安装若干不同版本的Python，并能自由切换。 设置国内镜像123456# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉 # 设置搜索时显示通道地址conda config --set show_channel_urls yes 更改jupyter notebook路径12cd /d D:\1_工作学习\jupyter-notebookjupyter notebook 或者直接将上述代码写入到txt文档，再改为bat后缀；若要变更路径，直接在文本中修改即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《文明是副产品》读书笔记_郑也夫]]></title>
      <url>%2F2017%2F06%2F06%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F20_%E7%A4%BE%E4%BC%9A%E8%AE%A4%E7%9F%A5%2F%E3%80%8A%E6%96%87%E6%98%8E%E6%98%AF%E5%89%AF%E4%BA%A7%E5%93%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%83%91%E4%B9%9F%E5%A4%AB%2F</url>
      <content type="text"><![CDATA[《文明是副产品》郑也夫 why ：我为什么读这本书，想解决什么问题？ what：这本书在说什么？核心观点是什么？ how ：文章的结构与脉络是怎么样的？如何发展这个主题的？ what ：这个对我的生活与行为有什么指导意义？我是不是要做些什么？ how ：具体怎么做？ 回答自己的问题 用几句话来概括这本书；别人问你这本书讲了什么的时候，能够把它说清楚； 第一章 外婚制的起源婚配方式的演变：群婚 $\to$ 一夫多妻制 $\to$ 一夫一妻制 动物的婚配方式 鸟类：固定的一夫一妻制 灵长类体征动物的婚配方式： 哺乳动物四千多种，一夫一妻制约120种，占3% 灵长类动物一夫一妻制比例诶18% 二态性、睾丸比重 身体特征与婚配方式的关系：二态性、 睾丸重量在体重中的比例 【结论】: 二态性大的物种，倾向于群婚 /一夫多妻制；睾丸占体重比例大的，倾向于群婚； 二态性大的物种(黑猩猩)，多采取群婚；二态性小的物种(长臂猿)，多采取一夫一妻制 睾丸占体重比例大的，群婚，因为要考更频繁的交配来获得更多的后代；比例小的，一夫多妻/一夫一妻，一夫多妻靠的是身体与专横来驱赶其他雄性，避免了其他雄性与自己的雌性交配 二态性：两性在性器官之外的身体差异 统计学意义上来说，二态性是性选择的结果；(无论是雄性靠身材高大吸引更多的雌性，还是靠驱赶同行竞争者占有更多的雌性，其结论都是身材高大者拥有更多的雌性，乃至拥有更多的子女。孩子继承父亲的基因也身材高大，如此经一代代的交配权的争夺对物种品行的影响，雄性会越来越高大，最终突出了二态性；) 睾丸与体重的比例： 群婚和一夫多妻制中开展着雄性对性资源的争夺。(黑猩猩睾丸重量占体重的0.27% - 群婚，大猩猩0.02% - 一夫多妻；人类0.08% ) 群婚，发情期每个雄性都未被排斥，疯狂地与雌性交配；谁的性器官更发达，谁就可能维持更频繁的交配，最终拥有更多的后代 一夫多妻制，倚重身体和专横来拥有多个雌性，因为没有其他雄性敢靠近，所以它们的睾丸反而倒很小； 走向一夫一妻制有征兆 - 无征兆 进化论的核心思想：适应与自然选择； 适应性：指的是个体生存和繁衍能力好，说到根本还是后者； 唯有后代多，父母的品性才能被继承下来，于是有助于繁衍的品性将成为该物种的特征 雌性排卵期有征兆的几乎都是群交；无征兆的不一定走上一夫一妻制，但走上一夫一妻制的几乎都是无征兆的； 雌性排卵期有征兆，雄性会疯狂地与之交配 从有征兆到无征兆 演变的原因：“多父理论” 当雌性排卵期有征兆时，未同它发生过性关系的雄性取代了首领的时候，容易杀害它的幼崽 雌性的无征兆，令其主要配偶难以防范她与其他雄性发生关系；且与其私通过的雄性不太可能杀害它的幼崽，因为可能是他的孩子 进一步的意义：“居家父亲理论” 无征兆导致雌性随时可以受孕，于是雄性要不断和一雌性交配，防止它被其他雄性交配。即无征兆容易拴住一个雄性。 一雄一雌长相厮守，一夫一妻家庭呼之欲出 狩猎 与 武器 狩猎很可能是真正走向一夫一妻制的契机，其中的关键又是武器 【结论：武器对外使得人类与野兽攻守关系的转化，对内催化了一夫一妻制，进而促进了高质量的合作。】 狩猎依赖两个条件：合作、武器 合作：需要积极的、主动的、进取心的协作，而不是消极与被迫的 武器：武器助人专守为攻，使狩猎成为常规的生存方式； 武器的作用向外也向内，向内打破了成员间体格的差异。在人类文明史中，武器是最奇妙的力量。在人类成员的力量对比上，武器的作用不是直线的矢量，而是曲线；即在某个时刻它可以减缓双方力量的差异，下个时段会加剧力量的差异，再下个时段再次削弱差异。在动物世界中，身体力量决定了地位的悬殊与性资源分配的不平等，人类也不能例外。而一旦拥有了了武器，一个弱者也可以给最厉害的强者造成极大的威慑；[1]武器的最初发明，削弱了人类成员攻击力的差距；[2]武器的第二阶段则相反，枪炮的发明大大拉开了与只拥有冷兵器民族的差距；[3]武器的第三阶段又回归，不管常规武器差距如何，一旦有了核武器，大家的威慑力又在同一个平台上 当人类拿起武器合作狩猎时，性资源的分配得到改观。在狩猎、合作、武器三个因素中，武器应该是先行的。雌性为保护幼崽免受杀害，进化出了无征兆，瓦解了此前的性垄断；与此同时，武器发挥了决定性的作用，它使得即使身体弱小的人类也有能力去对抗首领。虽然性资源的分配首领是不不愿意的，但强者毕竟是少数；一夫一妻制是首领与多数弱男之间的妥协。弱男们有了性权利和它所连带的地位、心理上的变化后，才会有积极的、有进取心的合作。 狩猎依赖于武器与合作，缺一不可。 族群中的一夫一妻制 现象：一夫一妻制的关系中，鸟类中有91%，灵长目是18%，哺乳类只有3% 一夫一妻制不利于一些物种有效逃避与抵抗天敌 小家庭只有一个成年雄性，在抵抗天敌时，雌性也要上阵，使得雌性的死亡率远高于其他婚配方式的动物。 配偶中只要一个死亡，这一繁殖单位就结束了 灵长类中一夫一妻制的比例高于哺乳类，很可能是树栖方式的安全性所导致的 在结成群体中，利于抵抗天敌；但容易产生内部对性资源上分配的歧义 【现象：在灵长目动物中，人类是唯一将一夫一妻制与群体结合自一起的物种，因而内部的性问题上的冲突称为了人类恒久面对的难题】 “多重社会”：两层或以上的社会关系 第一层：个体组成的家 第二层：由家组成的族 第三层：由族组成的群 外婚制 第二章 农业的起源 第三章 文字的起源 第四章 造纸术的起源 第五章 雕版印刷的起源 第六章 活字印刷的发明 第七章 文明与副产品]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《理性乐观派》读书笔记_马特.里德利]]></title>
      <url>%2F2017%2F05%2F20%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F10_%E5%8F%91%E5%B1%95%E5%8F%B2%2F%E3%80%8A%E7%90%86%E6%80%A7%E4%B9%90%E8%A7%82%E6%B4%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E9%A9%AC%E7%89%B9.%E9%87%8C%E5%BE%B7%E5%88%A9%2F</url>
      <content type="text"><![CDATA[《理性乐观派》_[英] 马特 • 里德利 Matt Ridley 交易（贸易）在人类发展中起的作用 交换，是通往繁荣的道路（而非自给自足）。交换 $\to$ 专业化 $\to$ 劳动分工 $\to$ 集体智慧，使得生产效率发生质的飞越； 自给自足的生活，需要花费大量时间在满足生理需求（即生存上），使得几乎没有时间去发展技术 交换，交换的是不同的东西； 交换实质上是不平等的，但却仍然能让双方都受益 集体大脑。没有集体智慧，很难进行复杂工具的生产。知识，从来都不是以浓缩或者综合的形式存在，而是以不完整甚至往往是自相矛盾的知识比特的形式存在，为不同个体所占有。 要让交换可行，两个人不需要提供同等价值的东西。这是因为，人类往往会自己无法拥有的东西赋予高价值；对交换依赖越多，交换的吸引就越大，就越会促成专业化。 所谓繁荣，是你以同样工作量换取的商品或服务的数量增加了。贫穷与富裕的定义是，以你的时间换取 ( 需要的 /想要的) 产品的价格 消费简单化，生产多样化 $\to​$ 消费多样化，生产简单化 人类会与同类的陌生人和平相处。这是其他动物所没有的。 序 当思想有了性阐述了人类与其他动物有什么区别；以及是什么使得人类有能力以这种疯狂的方式不断改变自己的生活。 集体智慧进化到某个阶段之后，人类的智慧就成了集体性的、积累性的，这种现象并没有出现在其他动物身上。 手斧 vs. 鼠标； 前者是一个人做出来的；后者是上百人甚至上万人做出来的；单独的一个人，没有谁知道该如何制作出鼠标来；即使是在工厂装配鼠标的人，也不知道如何钻探油井和从石油里制造出塑料； 流动的思想文化要转入积累，思想就必须互相接触，互相交流。如果文化值包括学习他人的习惯，那它很快就会陷入停滞。 通过交换，人类发现了 “ 劳动分工 ” ，出于互利的目的，将努力和天赋加以专业化； 更好的今天 相比过去，人类整体水平大大提高；富裕者越富裕，但贫穷者并没有越贫穷 整个世界在进步，虽然贫穷问题仍然存在，但有个无法忽视的现象：当今贫困的生活相比过去的贫困的生活，已经算是很大的进步。 繁荣（定义）：你以同样工作量换取的商品或服务的数量增加了。 衡量繁荣的真正尺度是时间。即你单位工作时间能够获得的收益；因为时间是不变的。 贫穷与富裕的定义：价格 vs. 时间 —— (需要的 /想要的) 服务 贫穷：负担不起以足够高的价格卖掉自己的时间，来购买自己所需要的服务 富裕：不光能买到自己需要的服务，还能买到自己想要的服务 困境：我们的富裕是靠透支着孩子们的未来实现的（国家的养老金都是靠孩子们的缴税来实现的）。但这里有个关键的因素来决定这种透支是否有利：透支资金所进行的活动 ： 为了发明创造&amp;创新，那就是可持续的；因为一旦科技发展，效率会提高，即你单位时间能够实现的收益是更多的，即更加繁荣； 为了维持奢侈的生活，那就是不可持续的； 只要人在创新上分配足够的资金，那信贷危机就不可能长时间地阻挡人类生活水平的不断攀升； ==核心观点：通过【交换、专业化、劳动分工】（集体智慧）的产出，你获得了自己几乎无法生产的东西。但你换取它们的成本却是非常廉价的。== ==自给自足并不是通往繁荣的路线。== 如果你必须在每件事上自给自足，那你一天80%以上的时间都将花在满足自己的生理需求：活下来。 交换和专业化为人类带来了奇迹。 ==知识，从来都不是以浓缩或者综合的形式存在，而是以不完整甚至往往是自相矛盾的知识比特(bit，信息量的最小单位) 的形式存在，为不同个体所占有。== 集体智慧或集体大脑： 例如，制作一支铅笔；随便那一个人都只是贡献了一点点知识。但如果要把铅笔制造出来，需要不计其数的劳动（最开始的石墨提取、木材的采集等）， 但并没有一个全知全能的大脑发号施令做指挥。 劳动的繁殖：所有合作的目的，就是 “ 少量的劳动完成大量的工作 ”。==现在生活标志性特征和生活水平高的核心定义：消费多样化，生产简单化。== 生产一样东西，使用很多东西； 这里有一个奇怪的事实：为了换回为你提供无穷商品或服务，你只生产一种东西。也就是说，你消耗了成千上万人的劳动、享受了他们的发明成果之后，你只生产和出售自己擅长的东西——理发、保险咨询等等； 自给自足的园丁与农民，或者以狩猎采集为生的原始人，则是生产多样化，消费简单化； 为了生存，他们要自己播种，自己制作武器，自己狩猎，自己制作衣服； 比较不同时期的消费组成 | 2000年后普通工薪者 | 18世纪90年代农场的劳动者 | 现代马拉维农村服务 || —————————- | ————– | ———– || 20% - 住房 | 75% - 食物 | 35% - 耕种食物 || 18% - 交通运输 | 10% - 服装和被褥 | 33% - 做饭、清洁 || 16% - 家居用品 | 6% - 住房 | 17% - 取水 || 14% - 食物、饮料 | 5% - 取暖 | 5% - 拾柴火 || 5% - 电影、音乐等娱乐 | 4% - 照明和其他 | 9% - 其他劳动 || 4% - 服装； 2% - 教育； 11% - 养老金； | | | 专业知识的积累，使得我们每个人得以靠着生产越来越少的东西，消费越来越多的东西，，这是人类发展的核心故事。 集体大脑 大多数的演进变化来自物种的后代取代了原先的物种，而不是物种本身的习惯发生变化。而人类则恰恰相反。 旧石器时代制作的工具——手斧，持续了100多万年都没有进展，这是为什么？那是因为，如果没有交流&amp;交换，我们几乎认识不到这个事物有何不同之处。 一代又一代人靠着走路，不可能变得越来越好。对旧石器时代的人类而言，制作手斧就像走路，一种通过实践能做好的事情，但你不会反反复复地思考它。因为它几乎成了一种身体机能。难道你会在身体机能上去创新？？有的也就只是想法而已。 它靠着模仿和学习来部分延续。 智人的出现，第一次使得技术变化的速度 &gt; 构造自己的生理结构的速度。这是一种进步。 基因在人类演进中发挥了巨大的作用，但它更多的是为了响应新习惯，而不是新习惯形成的原因。 熟食选择了小肠道和小嘴巴的基因，而不是小肠道和小嘴巴选择了熟食；基本是根据外在环境而改变的。达尔文《物种起源》 演化过程是从外到内的，而解释往往却是从内到外的。 交换的开始 互惠 vs. 交换：两者有本质的区别 互惠：给予对方的同时，对方给予相同的回报； 交换：给予对方的同时，对方给予不同的回报； 对动物而言，更多的是互惠，往往是平等的；但交换实质上是不平等的，但却仍然能让双方都受益。 如果我今天替你做一件衣服，你明天也替我做一件；这么多，好处是有的，但并不会改变什么； 如果我今天替你做一件衣服，你明天替我去找食物，那这带来的收益是明显递增的。 ==核心观点：要让交换可行，两个人不需要提供同等价值的东西。这是因为，人类往往会自己无法拥有的东西赋予高价值；对交换依赖越多，交换的吸引就越大，就越会促成专业化。== 交换的产生，是促使人类快速进步的重要原因； 以狩猎换采集 性别上的劳动分工与交换 男性：狩猎，提高营养，同时用肉换取其他东西 女性：采集，提供最基本的食物；保证在没有捕捉到猎物的情况下，仍然可以生存； 专业分工带来专业的知识，而专业的知识带来了不断的改进。专业分工还带来了给专家们投入时间、设计 隔绝（自给自足）会导致技术上的退化；一旦缺少了交换与交流，技术的进步就会受到停止，因为缺少了最基本的动因； 人类的成功，极大的取决于数量与联系。寥寥百人无法维持复杂的技术。 人类进步是一项集体性的事业，它需要密集的集体大脑； ​ 其他 比较优势 - 李嘉图：当某一个生产者以比另一个生产者更低的机会成本来生产产品时，我们称这个生产者在这种产品和服务上具有比较优势。 制造美德 钱不是金属，而是信任的结晶。 —— 尼尔 • 弗格森 (Nial Fergson) 《货币崛起》 人类会与同类的陌生人和平相处。而对于任何一种动物，不同群体的成员只要一接触，必然出现暴力行为； 一种设想：起初，人类试探性地开始交换，体会到了比较优势和集体大脑的好处，反过来推动了自然选择偏向那些尤其擅长信任和同情； 我们进化之初，生活在一个零和世界，一方获利意味着另一方的损失； 信任的产生，并没有定论。 养活90亿人 10,000年开始的农业耕作 虽然没有探究农业的起源，但提到了农业给人类带来的变化与好处； 农业耕种传播飞快：最初种下的种子产量很高，也易于生长。 有了农业耕作，社会密集度提高，更好地利用合作、协调和劳动分工的潜能，获得了可观的回报； 繁荣的显著特征是专业化程度不断提高，贫穷则是回归到自给自足的状态； 如果现在，一个人要耕种农业来养活自己的话，至少需要1250平方米的土地； 2004年，全世界5亿公顷的土地种植约20亿吨的农作物：每公顷产量为4吨。这些农作物提供了全世界2/3的粮食，养活了40亿人，故每公顷养活8个人； 但是，他们种植的产量与效率是远远高于你个人去种植的； 化肥的诞生，使得农业的产量可以持续的保持高产； 城市的胜利 5000年前的从城市贸易 自由贸易能实现共同繁荣，而保护主义导致贫穷。 贸易的阐述： 威胁：廉价产品摧毁了国内的产业与工作岗位 机会：替消费者省下钱来购买其他的商品和服务；在国内创造出更多的就业岗位 城市的生活不管多么贫穷，始终充满机会，也有更大的自由。 2008年，全国生活在城市的人口首次超过了总人口的一半； 超过一半的人口脱离了自给自足，去探索以集体大脑为基础的生活所充满的无限可能。 2/3的经济增长都出现在城市； 逃离马尔萨斯的陷阱 1200年之后的人口 马尔萨斯人口陷阱：技术的进步与发展，仅仅早就了人口的增长而没有提高人类的生活水平。 逃离：在1800年开始的工业革命，才使得一些国家人均收入大幅增加，最终跳出马尔萨斯陷阱； 人类人口的反常现象：人口密度达到一定程度之后会崩溃，使得人口大幅减少；但崩溃之后，人口密度仍然会停留在比之前更高的水平上，而最低生活水平不规律却又势不可挡的提高了。 人口过渡阶段，很多国家都采取了措施；（尤其是20世纪70年代的亚洲，很多都采取了强制措施） 人口虽然在增长，但增长率其实是下降的； 几乎任何国家的出生率都是维持在较高水平：(1) 死亡率下降； (2) 人口膨胀； (3) 出生率迅速下降 人类生育能力大幅下降，可能的原因： 婴儿的死亡率大幅降低（因为婴儿/儿童的死亡率越高，家庭就会生得越多） 女性普遍接受教育 奴隶的解放 1700年后的能源 关于能源，每一次改变，单个人能为其他人完成的工作量，都靠着动物或机器放大了。 人类自身劳作 $\to$ 奴隶 $\to$ 牛/马 $\to$ 无生命的动力( 水车 ) $\to$ 化石燃料 我们靠着化石燃料，开始了工业革命，最后才冲破了“马尔萨斯天花板”。经济的快速发展，靠的恰巧是不可再生、不环保、不清洁的能源。 像煤炭这种不可再生资源丰富得足够承受经济活动和人口的双重爆炸，直到它们为地球上的所有人创造财富，但同时又不撞上“马尔萨斯天花板”，之后把接力棒传递给其他能源。 石油、煤炭、天然气的确是有限的，但它们能持续数十年甚至数百年，人们要做的就是在用完它们之前找到替代品。 一个常常被我们忽略的重要事实：化石燃料为工业化腾出了大量土地。没有化石燃料，能源是需要从土地里生长出来的，所以需要大量的面积来进行种植。 “杰文斯悖论”：技术的进步提高了资源的利用率，但同时却增加了对这种能源的需求，实际上该能源的消耗也增加了。 传统意义上，资源利用率高了，获得同等能量所需的资源就少；但因为该资源利用率高，所以大家都来用这种资源了。 发明中的发明 1800年后的收益递增 对于思想与知识来说，你产生的知识越多，就越能产生知识。对于实体上的东西，更多的是符合收益递减的规律。 知识永远不可能聚集在一个单独的地方，它是集体性质，不是个人性质。 创新大历程：1800年- 纺织业；1830年- 铁路；1860年- 化工业；1890年- 电力；1920年- 汽车；1950年- 飞机；1980年- 计算机；2010年- 网络。 19世纪，大量运输物品的新途径（自行车、铁路、汽车、轮船） 20世纪，大量传递信息的新途径（电话、广播、电视、卫星、传真、手机、互联网） 推动创新的动因： 金钱很重要，但不是绝对重要的那个点 知识产权：大多数创新并没有申请专利 政府推动：创新不是一个能预测的产业 技术源自把现有技术汇聚成一个大于部分和的整体。 创新是一种外部力量，是某些经济体比其他地方多出来的一点侥幸。诸如气候、地理和政治制度，决定了创新的速度，而这些东西，人们改变不了太多。 其他 企业最危险的时候，就是它实现成功的那一刻，因为那时候它的创新就停止了。 转折点 1900年以后的悲观主义 所有悲观的预言在真正到来之前就遇到了转折点，原因在于人类的发展是动态的。 悲观主义错用了外推法：他们认为未来无非就是规模和范围更庞大的过去。 悲观主义，能够给世人警示。在这一点上，它的功能远大于它所谓的语言。 当今时代的两大悲观源头 非洲和2010年后的气候 关于贫穷，统计数据和历史案例都表明了一件事情：靠援助是做不到启动经济或加速经济增长的这一事实。 我们不能计划出市场来，因为用一种自上而下的规定来设计一套之下而上的制度，这种尝试必然是要失败的。 是否拥有产权，是一个关键。赋予当地人们以可持续的方式拥有、利用自然资源，并从中获得利润的权利。大多数时候，他们都会保护并珍惜这些资源。若野生动物资源受高高在上的政府的保护 (“控制”)，对当地人没有好处，他们就会忽视它，破坏它。 对于气候，持乐观态度。 当下的创造力前所未有的爆发，未来可能的是：比如在太空架设装备，驾驭太阳风；利用地球的自传能量；在太阳和地球之间的拉格朗日点放上镜子，遮罩地球，减缓变暖的趋势。 其他 人口红利：处于工作年龄的人口相对于需要赡养的老人和小孩的所占比例大。 结语 对2100年的理性乐观态度 在假定技术不发生变化的前提下预测未来，是一种常见的伎俩，它让人觉得未来非常可怕。 未来，智慧越来越走向集体化，创造和秩序越来越自下而上，工作越来越专业化，休闲越来越多样化。用专业的生产交换多元化的消费。 自下而上的世界会成为本世纪最重要的主题。 在当下若要破灭创新的火焰很难，因为在网络化的世界里，它是一种自下而上的演进现象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_数据处理_pandas]]></title>
      <url>%2F2017%2F05%2F17%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_pandas_old%2F</url>
      <content type="text"><![CDATA[pandas 指引 : http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window DataFrame 单独取出一列是 Series 格式 [TOC] 创建与变更格式创建对象 pd.Series( [], index=[], name=’’ )：创建Series pd.DataFrame(np.random.rand(20,5) , index=[], columns=[] )：创建20行5列的随机数组成的DataFrame对象 DataFrame会自动创建索引，且会被有序排列； Index索引对象是不可修改的。除非在第一次写入时缺少索引列，可进行定义。 传入等长的列表或NumPy数组组成的 字典。 若传入的列在数据中查询不到，就会产生NA 1234567891011121314151617DataFrame(obj, colums=[], index=[])# columns 按照指定的列进行显示# index 指定索引的名称，但并不改变行的顺序; 若对已存在的索引（eg:嵌套字典），若index中的索引不存在，则不显示# 创建对象：运用字典--------------------data = &#123;'state': ['Ohi', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]&#125;frame = DataFrame(data, columns = ['year', 'state', 'pop'], index=[1,2,3,4,2]) # 按照指定列进行排序# 创建对象：运用列表pd.DataFrame([[4,7],[5,10]],columns=['a','b'],index=[1,2])# ------嵌套字典-----------pop = &#123;'Nevada': &#123;2001: 2.4, 2002: 2.9&#125;, 'Ohio': &#123;2000: 1.5, 2001: 1.7, 2002: 3.6&#125;&#125;frame3 = DataFrame(pop) 查看数据 df.shape()：查看行数和列数 df.head(n)：查看DataFrame对象的前n行 df.tail(n)：查看DataFrame对象的最后n行 df.describe()：查看数值型列的汇总统计 df.columns ：查看列名 s.value_counts(dropna=False)：查看Series对象的唯一值和计数 df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数 http://df.info()：查看索引、数据类型和内存信息 数据整理重命名 - rename df.set_index(‘column_one’)：更改索引列 df.columns：获取当前列名 df.columns = [‘a’,’b’,’c’]：重命名列名 df.rename( columns = {‘a’ : ‘A’} , inplace = True )：只修改特定的列；将’a’ 改为 ‘A’ df.rename(columns=lambda x: x + 1)：批量更改列名 1234df.rename(columns=&#123;'old_name': 'new_ name'&#125;) # 选择性更改列名df.rename(columns=lambda x: x + 1) # 批量更改列名df.rename(index=lambda x: x + 1) # 批量重命名索引 批量重命名 - 前缀/后缀 DataFrame.add_prefix(prefix) ：将前缀字符串与面板项名称串联在一起。 DataFrame.add_suffix(suffix)：将后缀字符串与面板项名称串联在一起。、 123456789# 分组运算并合并数据df.groupby('key1').transform('mean').add_prefix('mean_') # DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。mean_data1 mean_data20 0.486419 -0.3796531 0.486419 -0.3796532 -0.771562 -0.5620443 -0.771562 -0.5620444 0.486419 -0.379653 排序 - sort_valuese 根据列的值进行排序 df.sort_values(col1)：按照列col1排序数据，默认升序排列 df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据 12df.sort_value(col1, ascendding=False)## ascendding=False，按照列col1降序排列数据；默认按升序排列 根据索引调整 df.sort_index(asix=1, ascending=False) ：根据索引/列名标签对数据结构进行调整 若axis=1，则根据列名的顺序进行调整结构，行不变。 df.reset_index()：重新设置行的索引 s.sort_index() ：根据索引进行排序 s.order() 列/行索引重排 DataFrame.reindex(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)：根据新索引进行重新排序 只显示符合当前索引的值。可加入新的索引值，若不存在则显示为NaN axsi = 1 ，则表示对 [列 Columns ] 进行重排 支持两种形式（建议采用第二种） (index=index_labels, columns=column_labels, ...) (labels, axis={&#39;index&#39;, &#39;columns&#39;}, ...) labels : array-like, optional. New labels / index to conform the axis specified by ‘axis’ to. index： 用作索引的新序列 axis : int or str, optional. Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1). fill_value ：缺失值NaN的替代值 method： = ffill /bfill；向前填充/向后填充；只适用于单调增长/减少的索引 limit： 向前或向后填充的最大填充量； 向前，即正向填充，向后一位数字（数值2位于1的前面） level ： copy： 默认为True，无论如何都复制；若为False，则新旧不相等时复制 1234567891011121314151617181920&gt;&gt;&gt; df http_status response_timeFirefox 200 0.04Chrome 200 0.02Safari 404 0.07IE10 404 0.08Konqueror 301 1.00&gt;&gt;&gt; df.reindex(['http_status', 'user_agent'], axis="columns") http_status user_agentFirefox 200 NaNChrome 200 NaNSafari 404 NaNIE10 404 NaNKonqueror 301 NaN# 将制定的列提到最前面df.reindex(['mean'] + list(df.columns[:-1]), axis=1) df.index.is_unique()：判断索引值是否唯一，若某个索引对应多个值，则返回一个Series，否则返回单个值 排名 - rank df.rank(method = ‘’)：会把对象的 values 替换成名次 排名作用与排序的不同之处在于，它会把对象的 values 替换成名次。 这时唯一的问题在于如何处理平级项，方法里的 method 参数就是起这个作用的 method 排名时处理平级值的方式。 average ：默认，为各个值分配平均排名 min：使用整个分组的 [最小] 排名 max：使用整个分组的 [最大] 排名 first：按值在原始数据中的出现顺序分配排名 max 与 min的区别：相等时，显示的排名按最大/最小排名来显示 12345678910111213141516171819# ------------示例-------------obj = Series([1,2,3,3,4,4,4]) obj.rank(method='max') # 对于3这个值，最大排序为4，所以显示40 1.01 2.02 4.03 4.04 7.05 7.06 7.0obj.rank(method='min') # 对于3这个值，最下排序为3，所以显示30 1.01 2.02 3.03 3.04 5.05 5.06 5.0 格式转换 ​ 布局转换 - 长宽格式 宽格式 $\to$ 长格式 df.melt(id_vars=[‘A’], value_vars=[‘B’, ‘C’]) 1234567891011121314151617181920df.melt(id_ars=[], value_vars=[], var_name='', value_name='')## id_vars，以该变量为基准进行重构## vaule_vars，需要将哪些变量组合进id列的变量，其值自动填充# 示例-------------------&gt;&gt;&gt; df A B C0 a 1 21 b 3 42 c 5 6df.melt(id_vars=['A'], value_vars=['B', 'C']) A variable value0 a B 11 b B 32 c B 53 a C 24 b C 45 c C 6 长格式 $\to$ 宽格式 df.pivot(val1, val2, val3)：将df的val1作为[行]索引的列名，val2为用作[列]索引的列名，val3作为用于[填列值]的列名 层次化索引的重塑 - stack stack()：列转行；将数据的列 “旋转” 为行 unstack()：列转行；将数据的行 “旋转” 为列 stack操作的是对最内层的索引进行操作。 若用字符串表示，则直接输入该索引的名称 .stack(‘number’) 若用数字表示，0 - 第一层索引； 1 - 第二层索引 数据透视表 df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表 格式：数字、时间与日期 pandas库是基于整列的操作 格式转换 - 通用 DataFrame.astype(dtype, copy=True, errors=’raise’, **kwargs) ：Cast a pandas object to a specified dtype dtype dtype : data type, or dict of column name 123456789&gt;&gt;&gt; ser = pd.Series([1, 2], dtype='int32')&gt;&gt;&gt; ser0 11 2dtype: int32&gt;&gt;&gt; ser.astype('int64')0 11 2dtype: int64 # dtype 注意此处 数字操作格式转换 pandas.to_numeric(arg, errors=’raise’, downcast=None) ：将变量转为数值类型 arg : list, tuple, 1-d array, or Series downcast : {‘integer’, ‘signed’, ‘unsigned’, ‘float’} , default None ‘integer’ or ‘signed’: smallest signed int dtype (min.: np.int8) ‘unsigned’: smallest unsigned int dtype (min.: np.uint8) ‘float’: smallest float dtype (min.: np.float32) 数字格式定义 str.format( { : } ) ：格式化输出字符串使用format()函数, 字符串即类, 可以使用方法。可使用 print(&quot;FORMAT&quot;.format(NUMBER)); 来运行示例 http://blog.xiayf.cn/2013/01/26/python-string-format/ 语法是{ }中带 : 号 &#39;{:,}&#39;.format(&#39;str&#39;) 符号 {} 是替换变量的占位符 转义大括号：若你需要使用大括号，只要写两次就可以了 字符串的参数使用 { num } 进行表示 ,0, 表示第一个参数,1, 表示第二个参数 使用“:”, 指定代表元素需要的操作 , 如”:.3”小数点三位, “:8”占8个字符空间等; 添加特定的字母 ‘b’ - 二进制. 将数字以2为基数进行输出. ‘c’ - 字符. 在打印之前将整数转换成对应的Unicode字符串. ‘d’ - 十进制整数. 将数字以10为基数进行输出. ‘o’ - 八进制. 将数字以8为基数进行输出. ‘x’ - 十六进制. 将数字以16为基数进行输出, 9以上的位数用小写字母. ‘e’ - 幂符号. 用科学计数法打印数字, 用’e’表示幂. ‘g’ - 一般格式. 将数值以fixed-point格式输出. 当数值特别大的时候, 用幂形式打印. ‘n’ - 数字. 当值为整数时和’d’相同, 值为浮点数时和’g’相同. 不同的是它会根据区域设置插入数字分隔符. ‘%’ - 百分数. 将数值乘以100然后以fixed-point(‘f’)格式打印, 值后面会有一个百分号. 对齐方式 &lt; （默认）左对齐 > 右对齐 ^ 中间对齐 = （只用于数字）在小数点后进行补齐 12345678910111213141516171819202122# 主要用法 '&#123;:,&#125;'.format('str')# 符号 &#123;&#125; 是替换变量的占位符。若没有指定格式，则直接将变量值作为字符串插入。 "glazed with &#123;&#125; water beside the &#123;&#125; chickens".format("rain", "white")# 可以使用变量的位置数值，在字符串中改变它们，进行格式化时。如果搞错了顺序，你可以轻易地修正而不需要打乱所有的变量。s1 = " &#123;0&#125; is better than &#123;1&#125; ".format("emacs", "vim")s2 = " &#123;1&#125; is better than &#123;0&#125; ".format("emacs", "vim")# 默认顺序为0str = "Oh &#123;0&#125;, &#123;0&#125;! wherefore art thou &#123;0&#125;?".format("Romeo")&gt;&gt;&gt; Oh Romeo, Romeo! wherefore art thou Romeo?# 命名参数：将新的格式字符串用作模板引擎，使用命名参数，这样就不要求有严格的顺序。madlib = " I &#123;verb&#125; the &#123;object&#125; off the &#123;place&#125; ".format(verb="took", object="cheese", place="table")&gt;&gt;&gt; I took the cheese off the table# 转义大括号：若你需要使用大括号，只要写两次就可以了print(" The &#123;&#125; set is often represented as &#123; &#123;0&#125; &#125; ".format("empty")) 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:, } 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 【应用到列】 123456# 定义函数de format_qian(a): b = '&#123;:,&#125;'.format(a) retrun(b) qian_all_data['参与人次'].apply(format_qian) 日期操作格式转换#####转为日期格式 pandas.to_datetime( arg, errors=’raise’, dayfirst=False, yearfirst=False, utc=None, box=True, format=None, exact=True, unit=None, infer_datetime_format=False, origin=’unix’ )：将字符类型转化成时间格式 dayfirst : boolean, default False ; If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10. box : boolean, default True If True returns a DatetimeIndex If False returns ndarray of values. format : string, default None errors : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’ If ‘raise’, then invalid parsing will raise an exception 引发异常 If ‘coerce’, then invalid parsing will be set as NaT If ‘ignore’, then invalid parsing will return the input unit : string, default ‘ns’ unit of the arg (D,s,ms,us,ns) denote the unit 123456789101112&gt;&gt;&gt; df = pd.DataFrame(&#123;'year': [2015, 2016], 'month': [2, 3], 'day': [4, 5]&#125;)&gt;&gt;&gt; pd.to_datetime(df)0 2015-02-041 2016-03-05dtype: datetime64[ns] # 指定格式 &gt;&gt;&gt; pd.to_datetime('13000101', format='%Y%m%d', errors='ignore')datetime.datetime(1300, 1, 1, 0, 0) #####转为日期差值 pandas.to_timedelta(arg, unit=’ns’, box=True, errors=’raise’) ：Convert argument to timedelta timedelta 表示两个datetime之间的时间差。 123&gt;&gt;&gt; pd.to_timedelta(['1 days 06:05:01.00003', '15.5us', 'nan'])TimedeltaIndex(['1 days 06:05:01.000030', '0 days 00:00:00.000015', NaT], dtype='timedelta64[ns]', freq=None) DatetimeIndex.strftime(date_format) ：返回指定格式的字符串格式 Series.dt.strftime(*args, **kwargs) ：单列转为字符串格式，格式化输出 date_format : str ; date format string (e.g. “%Y-%m-%d”) Timestamp.strptime() ：string, format -&gt; new datetime parsed from a string (like time.strptime()). ​ ####基本操作 【选取】 12# 过滤某个时间片的数据&amp;取某个时间片的数据df[df['date']&lt;=pd.datetime(2016,6,10)] 【返回】 1234# 返回某个日期是周几pd.to_datetime(df['date']).dt.weekday_name # 返回星期名；pd.to_datetime(df['date']).dt.weekday # 返回数字； 【判断】 dt.is_month_start ：判断是否为一个月的第一天 dt.is_month_end：判断是否为一个月的最后一天 日期格式定义【datetime格式定义】 代码 说明 %Y 4位数的年 %y 2位数的年 %m 2位数的月 [01, 12] %d 2位数的日 [01, 31] %F %Y-%m-%d 简写形式；2012-04-18 %D %m/%d/%y 简写形式；04/18/12 %H 时间（24小时制） [00, 23] %I 时间（12小时制） [00, 12] %M 2位数的分钟 [00, 59] %S 秒 [00, 61] (秒60和61用于闰秒) %w 用整数表示的星期几 （星期天为第0天） [0, 6] %U 每年的第几周 [00, 53]。星期天被认为是每周的第一天，每年第一个星期天之前的那几天被认为是 “第0周” %W 每年的第几周 [00, 53]。星期一被认为是每周的第一天，每年第一个星期一之前的那几天被认为是 “第0周” %z 以+HHMM 或-HHMM 表示的UTC时区偏移量 【特定于当前环境的日期格式】 代码 说明 %a 星期几的简写 %A 星期几的全称 %b 月份的简写 %B 月份的全称 %c 完成的日期和时间；Tue 01 May 2012 04:20:57 pm %p 不同环境中的AM 或PM %x 适用于当前环境的日期格式 ；若在美国， “May 1 2012” 会产生 “05/01/2012” %X 适用于当前环境的时间格式； “04:24:12 PM” ##合并数据 横向合并 - 类同 join DataFrame.join(other, on=None, how=’left’, lsuffix=’’, rsuffix=’’, sort=False) other : DataFrame, Series with name field set, or list of DataFrame 方法对象必须是DataFrame，但join的对象可以是多个类型的；通用性比 pd.merge 更加好 on ：若不指定，按照索引来进行join； column name, tuple/list of column names, or array-like Column(s) in the caller to join on the index in other. lsuffix / rsuffix : string. Suffix to use from left /right frame’s overlapping columns； 均在已有列名之后跟字符串 sort : boolean, default False 1234567891011121314# 使用索引进行连接&gt;&gt;&gt; caller.join(other, lsuffix='_caller', rsuffix='_other')&gt;&gt;&gt; A key_caller B key_other 0 A0 K0 B0 K0 1 A1 K1 B1 K1 2 A2 K2 B2 K2 3 A3 K3 NaN NaN 4 A4 K4 NaN NaN 5 A5 K5 NaN NaN # 使用关键列进行连接；需要指定连接的列名&gt;&gt;&gt; caller.join(other.set_index('key'), on='key') pd.merge(df1,df2, on =’val’, how=’inner’)：将df1，df2根据val列进行内联接 pd.merge(df1, df2, on = ,[left_on=] how = , [left_index=False, srot=True, copy=True, suffixes=(‘_x’,’_y’)]) df1, df2 ：必须都是DataFrame on = ‘val’ 用于连接的列名；若不指定则以列名的交集作为连接列 当涉及左右两个表单列名不相同时，需使用left_on / right_on left_on = ‘val1’ 左侧表中用作连接的列 right_on = ‘val2’ 右侧表中用作连接的列 left_index / right_index =True ,将索引列作为 [连接列] how = ‘inner’ / ‘left’ / ‘right’ / ‘outer’ （outer为求并集） sort = True/False ，根据连接列对合并的数据进行排序，默认为True suffixs，字符串元组，在两个表中有重复的列名时，可用将字符串追加到重叠列名的末尾，默认为(‘_x’,’_y’) copy = True，默认为True，即将结果复制到数据结构中 对于层次化索引，以 [列表的形式] 指名作用合并键的多个列 12345678910111213141516171819202122232425&gt; pd.merge(lefth, righth, left_on = ['key1', 'key2'], right_index=True)&gt; data key1 key2 event1 event2&gt; 0 0 Ohio 2000 4 5&gt; 0 0 Ohio 2000 6 7&gt; 1 1 Ohio 2001 8 9&gt; 2 2 Ohio 2002 10 11&gt; 3 3 Nevda 2001 0 1&gt;&gt; lefth&gt; data key1 key2&gt; 0 0 Ohio 2000&gt; 1 1 Ohio 2001&gt; 2 2 Ohio 2002&gt; 3 3 Nevda 2001&gt; 4 4 Nevda 2002&gt;&gt; righth&gt; event1 event2&gt; Nevda 2001 0 1&gt; 2000 2 3&gt; Ohio 2000 4 5&gt; 2000 6 7&gt; 2001 8 9&gt; 2002 10 11&gt; 纵向合并 - 增加行 df1.append(df2)：将df2中的 [行] 添加到df1的尾部 df.concat([df1,df2], ignore_index = True) ：纵向合并，将df2中的 [所有行] 添加到df1的尾部 ignore_index = True，表示进行纵向合并，不保留轴上的索引，产生一组新的索引 数据选取与删除行列选取 涉及布尔判断时，默认的对象为所有观测行的所有列 选取的内容会包含索引与数值 通过索引方式返回的列只是相应数据的视图。对此所做的任何修改，会直接反映到源数据。 df[col]：根据列名，并以Series的形式返回 [列] df[ [col1, col2] ]：以DataFrame形式返回 [多列] df[ df[col] &gt; 0.5 ]：选择col列的值大于0.5的所有行 先对 df[col] &gt;0.5 进行布尔判断，返回True 和 False，再选取所有True的值 对具体的观测行进行条件选取 ；等价于 Select * From table where col &gt; 0.5 也可为布尔型数组(过滤行)、切片（行切片）、布尔型DataFrame 1234567891011121314# 指定列中的特定值，并返回所有的行data[data['three']&gt;5] one two three fourColorado 4 5 6 7Utah 8 9 10 11New York 12 13 14 15# 返回布尔值data &gt; 5 one two three fourOhio False False False FalseColorado False False True TrueUtah True True True TrueNew York True True True True df.loc[ n [, m] ] ：通过 [ 行标签 ] 索引行数据 。 主要基于标签的, 但也可以与布尔数组一起使用。 n 为行标签；若行标签为字符串，则也需要用字符串表示。loc[‘d’] 表示索引的是第’d’行（index 是字符） 若出现m，则表示可以索引行与列 起始索引值为0； df.iloc[ n [,m] ]：通过 [ 行号 ] 索引行数据 。 主要基于整数位置 (从0到 length-1 轴), 但也可以与布尔数组一起使用。 n 为行号； 若出现m，则表示可以索引行与列 loc 在index的标签上进行索引,范围包括start和end. iloc 在index的位置上进行索引,不包括end. 12345678910111213141516171819202122232425# ---- loc -------import pandas as pddata = [[1,2,3],[4,5,6],[7,8,9]] index = [0,1,2] columns=['a','b','c'] df = pd.DataFrame(data=data, index=index, columns=columns) &gt;&gt;&gt; df a b c0 1 2 31 4 5 62 7 8 9&gt;&gt;&gt; df[0:1]a b c0 1 2 31 4 5 6# 索引某行某列df.loc['d',['b','c']] # ---- iloc -------## 索引第一列的所有数据df.iloc[:,[1]] 多条件选取1234567891011121314151617181920212223242526272829303132data = [[1,2,3],[4,5,6],[7,8,9]] index = [0,1,2] columns=['a','b','c'] df = pd.DataFrame(data=data, index=index, columns=columns) # 所有列的多条件选取df[(df['b']&gt;2 ) &amp; (df['a']&gt;1)] a b c1 4 5 62 7 8 9# 指定列的多条件选取df['c'][(df['b']&gt;2 ) &amp; (df['a']&gt;1)]1 62 9# 指定列的多条件选取&gt;&gt;&gt; df.loc[(df['b']&gt;2 ) &amp; (df['a']&gt;1),'c']1 62 9Name: c, dtype: int64# 指定多列的 多条件选择df.loc[(df['b']&gt;2 ) &amp; (df['a']&gt;1),'b':'c'] # 获取值&gt;&gt;&gt; df.loc[(df['b']&gt;2 ) &amp; (df['a']&gt;1),'c'].valuesarray([6, 9], dtype=int64) df.ix[1, val ] 因为容易混淆，建议不使用。 df.ix[1, val ]：既能通过行号，也可以通过索引位置来进行选取，但ix中的索引右端为包含； 因为容易混淆，建议不要使用。 若行的索引名为数字时，在进行选中时，选择的为行索引的数值名称，而非位置 123456789101112# 因行索引不为数字，故代表位置，右端不包含data.ix[0:2] one two three fourOhio 0 1 2 3Colorado 4 5 6 7# 因行索引为数字，故代表的为行索引的名称data.ix[0:2] Id Survived0 1 01 2 12 3 1 ###条件选取 - filter df.filter(item=[val], like= , regex=’’, axis=1)：选择DataFrame中满足条件的子集 filter的条件判断是对 行索引/ 列名 进行的匹配，而非具体的观测值 item：指定的列名；若不指定，则表示全体 regex：满足正则表达式的列名 ，此时axis=1 like ：满足like的行索引的所有行，此时axis=0 （该功能是SQL中没有的） axis = 1 ：基于列； axis = 0 ：基于行 123456789101112131415161718192021222324&gt;&gt;&gt; dfone two threemouse 1 2 3rabbit 4 5 6&gt;&gt;&gt; # select columns by name&gt;&gt;&gt; df.filter(items=['one', 'three']) one threemouse 1 3rabbit 4 6&gt;&gt;&gt; # select columns by regular expression&gt;&gt;&gt; df.filter(regex='e$', axis=1) one threemouse 1 3rabbit 4 6&gt;&gt;&gt; # select rows containing 'bbi'&gt;&gt;&gt; df.filter(like='bbi', axis=0)one two threerabbit 4 5 6 ###随机与排序选取 df.sample(frac=0.5)：随机选取所有数据中的50%的观测行 df.sample(n=10)：随机选取10行 df.nlargest(n, ‘value’)：根据’value’进行排列，并选取最前面的n个值 df.nsmallest(n, ‘value’):根据n进行排序，并选取最后面的n个值 s.iloc[0]：按位置选取数据 s.loc[‘index_one’]：按索引选取数据 重复值 - duplicated df.duplicated()：判断是否有重复行 df.duplicates()：移除重复行，默认保留第一个出现的值组合 df.duplicates([val1, val2], take_last=True)：指定部分列进行重复项判断； take_last=True 指定保留最后一个 s.dropna()：将Series中删除所有包含空值的行 s.astype(float)：将Series中的数据类型更改为float类型 s.replace(1,’one’)：用‘one’代替所有等于1的值 s.replace([1,3],[‘one’,’three’])：用’one’代替1，用’three’代替3 唯一值 - unique df[‘val’].unique：返回某一列的唯一值 df.[‘val’].value_conuts：计算列中每个值出现的次数 数据删除 - drop df.drop(val, axis=0 )：删除索引行/变量列，并返回一个新的对象 axis默认为0，删除索引为val1,val2的观测 [行] 1df.drop([val1,val2], axis=1) # 删除列名为val1,val2的 [列]，并返回一个新的对象； s.drop() 【实战演练】返回某列中不为NUll的所有行1data1 = data0[data0['column'].notnull()] 创建新变量 往往需要用到apply函数，然后用 merge 或者 join 来进行合并 增加列 df[‘Volumn’] = df.Length * df.Height 1234567In [219]: df['b']=1 In [220]: df Out[220]: c a b 0 1 5 1 1 2 6 1 pd.Series(my_list)：从可迭代对象my_list创建一个Series对象 若不指定索引 index = [‘’, ‘’ ] ，则会自动创建从0开始的索引列 通过索引返回/赋值的数据，是对应数据的视图；所做的修改都会直接反映在源数据上； 算术运算中，会自动对齐不同索引的数据，若对应索引不存在，则填充为NaN 12345obj2 = Series([4, 7, -5, 3], index = ['b', 'd', 'a', 'c']) # 指定索引# 字典创建：字典中的 键 = 索引sdata = &#123;'Ohio': 35000, 'Texas': 71000, 'Orgen': 16000, 'Utah': 5000&#125;obj3 = Series(sdata) df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])：增加一个日期索引 apply DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds) 若提前定义了函数，默认将之前的才变量传入为第一个参数； 例如 apply(sum)，其实是将变量传递给sum()的第一个变量 func : Function to apply to each column/row np.mean / np.sum ：常规统计函数均可用np.xxx 表示对每一列使用该函数 123456789101112&gt;&gt;&gt; df.apply(numpy.sum, axis=0) # equiv to df.sum(0)# 定义链接的函数；为apply做准备；def link(a): a = str(a) # 必须是字符串格式 link = 'http://xinyitong.gensee.com/webcast/site/entry/join-5c9543e2905146aa9a6f2b16bd1f6de0' c = '?nickName=visitor' return (link + c + a) link_add = tb0['员工编号'].apply(link); 重编码 - 字符串 字符串操作：Python内置、Re模块、矢量化操作 Re模块的函数主要分三个大类：匹配模式、替换、拆分 矢量化”(简化)是重写循环的过程，使得不是将阵列的单个元素处理N次，而是将阵列的4个元素同时N / 4次处理。 使用 str.func 在str属性上使用索引 12345678&gt; # 使用str.func&gt; matches = df.str.match(pattern)&gt;&gt; # 在str属性上使用索引&gt; matches.str[0]&gt;&gt; matches.str.get(1)&gt; &gt; 常常需要结合 apply 函数进行批量操作 匹配 - find &amp; match &amp; search Python 内置 find()：返回第一个发现的子串的第一个字符所在的位置；否则返回 -1 rfind()：返回最后一个发现的子串的第一个字符所在的位置；否则返回 -1 index()：返回子串第一个字符所在的位置；若没有找到返回ValueError startswith() / endswith() ：判断字符是否以某个前缀/后缀 开始或结尾，返回True count：返回子串在字符串中出现的次数（非重复） Re模块 match(pattern, string, flags=0)：字符串string的开头 开始搜索正则表达式模式pattern；若匹配成功，则返回一个匹配对象（仅返回匹配的部分）；否则返回None search(pattern,string, flags=0)：从字符串string中（任意位置）搜索正则表达式模式pattern 第一次出现的地方； 如果匹配成功，则返回一个匹配对象；否则返回None findall(pattern, string [,flags]) ：在字符串string中搜索匹配pattern的所有内容，并返回一个匹配对象的 [列表 list] finditer(pattern, string [, flags])：在字符串string中搜索匹配pattern的所有内容，返回一个迭代器，该迭代器返回一个匹配对象 矢量化的字符串方法 df.str.func match() ：根据指定的正则表达式对各个元素执行re.match findall() startswith / endswith contains() ：返回各字符串是否含有指定模式的布尔型数组 count：模式出现的次数 ​ 替换 - replace &amp; sub python内置 strip / lstrip / rstrip：去除空格（包括换行符）。相当于对各个元素执行x.strip() ljust /rjust ：用空格（或其他字符）填充字符串的空白侧以返回符合最低宽度的字符串 df.replace(1,’one’)：用‘one’代替所有等于1的值 df.replcae([1,2], [‘one’, ‘two’]) ：多个值之间替换 df.replace({-999:na.nan, -1000:0})： 传入的参数也可以是字典 replace - 替换； 此处的替换为对整个值进行查找，而非值中的部分值 eg: 第3个观测行daf\n ，无法用 data.replace(’\n‘, ‘’) 进行替换 12df.replace(old, new [,max]) # 将old值替换为new# max，可选字符串, 替换不超过 max 次 lower / upper () ：转化为小写/大写 Re模块 re.sub(pattern, repl ,string, max = 0) : 把字符串string中所有匹配正则表达式pattern的地方 替换成 字符串 repl 如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。 若max 的值没有给出，则对所有匹配的地方进行替换 subn() ：该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数 矢量化的字符串 strip / lstrip / rstrip：去除空格（包括换行符）。相当于对各个元素执行x.strip() pad()：在字符串左边、右边或两侧添加空白符 center()：相当于pad(side=’both’) replace()：用指定字符串替换找到的模式 repeat()：重复值； s.str.repeat(3) 相当于对各个字符串执行 x *3 get()：获取各元素的第i个元素 len()：计算各字符串长度 lower / upper () ：转化为小写/大写 分隔与连接 Python内置 split：通过指定的分隔符将字符串拆分为一组子串 ‘sep’.join(seq) ：将字符串用作连接其他字符串序列的分隔符 sep：分隔符；可以为空 seq：要连接的元素序列、字符串、元组、字典 123&gt;&gt;&gt; seq1 = ['hello','good','boy','doiido'] &gt;&gt;&gt; print ':'.join(seq1) hello:good:boy:doiido Re模块 split：根据找到的模式将字符串拆分为数段 矢量化字符串函数 split() slice()：对Series中的各个字符串进行子串截取； cat()：实现元素级的字符串连接操作，可指定分隔符 对象类型 dir()：获得对象的所有属性与类型 type() - 判断对象类型 instance() - 判断一个对象是否为某种类型：返回布尔值Ture/Falses 12345678910111213141516171819# 指定判断类型&gt;&gt;&gt; isinstance('a', str)True&gt;&gt;&gt; isinstance(123, int)True# 先创建判断的对象&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True# 还可以判断一个变量是否是某些类型中的一种&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 能用type()判断的基本类型也可以用isinstance()判断 常规格式转化 int(x [,base ]) ：将x转换为一个整数 long(x [,base ]) ：将x转换为一个长整数 float(x)：将x转换到一个浮点数 str(x)：将对象 x 转换为字符串 repr(x)：将对象 x 转换为表达式字符串 eval(str) ：用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s)：将序列 s 转换为一个元组 list(s)：将序列 s 转换为一个列表 chr(x) ：将一个整数转换为一个字符 unichr(x) ：将一个整数转换为Unicode字符 ord(x)：将一个字符转换为它的整数值 hex(x)：将一个整数转换为一个十六进制字符串 oct(x)：将一个整数转换为一个八进制字符串 complex(real [,imag ])：创建一个复数 缺失值###判断 df.isnull()：检查DataFrame对象中的空值，并返回一个Boolean数组 df.notnull()：检查DataFrame对象中的非空值，并返回一个Boolean数组 Python中内置的None会被当做NA处理 pandas用浮点值NaN (Not a Number) 表示浮点和非浮点数据中的缺失数据；其类型为 float ###移除 df.dropna()：删除所有包含空值的行，返回为剔除后的对象（一行中只要有一个值为NaN，就删除整行） 12345df.dropna(how='all', axis=1, thresh=n)## how='all', 指定排除一行中 [所有值均NA] 行/列## axis=1, 删除所有包含空值的 [列]; 默认axis=0, 即删除所有包含空置的[行]## axis=1,thresh=n, 删除所有 [小于n个非空值] 的 [行] ###重编码 df.fillna(x, inplace=True)：用x替换DataFrame对象中所有的空值，inplace表示在源数据中修改 123456789fillna(value [, method = 'ffill',limit =n, axis=0, inplace=False])# value 填充值# method 差值方式，默认为ffill；也可为bfill# limit 可以连续填充的最大数量# axis 待填充的轴，默认为0# inplace 默认为False，表示返回新对象；若为True，则对原始数据进行修改df.fillna(0) # 将缺失值替换为0df.fillna(&#123;1: 0.5, 3: -1&#125;) # 对位置值为1的 [列]，缺失值替换为0.5；即对第二列，将NaN值替换为0.5 汇总与描述统计 常规情况下，axis=1 代表列； axis=0 代表行； 计算情况下，axis=1 代表沿着每一行遍历所有的列，并向下执行方法 常规统计值 count()：非NA的数量 describe()：计算统计汇总 sum() mean() / median() quantile() min() / max() var()：方差 / std()：标准差 mad() :根据平均值计算平均绝对离差 argmin() / argmax()：计算能够获取到最小值/最大值的索引位置（整数） （对应 iloc） idxmin() / idxmax()：计算能过获取到最小值/最大值的所索引值 （对应loc） 常规统计值 - 高阶 cumsum()：累计和 cummin() /cummax() ：累计最小值/累计最大值 cumprod()：累计积 skew()：偏度（三阶矩） kurt()：峰度（四阶矩） diff()：一阶差分（对时间序列很有用） pct_change()：百分数变化 corr()：相关系数 ocv()：协方差 数据聚合与分组分组聚合是由三个过程来组成的：拆分Split - 应用Apply - 合并Combine 数据根据所提供的一个或多个键被拆分 (Split) 为多组。并且拆分操作是在对象的特定轴 (axis=1 列； 或 axis=0 - 行)上执行的 将一个函数Apply应用到各个分组并产生一个新的值 将所有的结果合并Combine到最终结果的对象中 grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df[‘key1’]的中间数据而已。该对象已经有了所需的一切信息 123456789101112131415161718import pandas as pdimport numpy as npdf = pd.DataFrame(&#123;'key1':['a','a','b','b','a'], 'key2':['one','two','one','two','one'], 'data1':np.random.randn(5), 'data2':np.random.randn(5)&#125;)# grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已grouped = df['data1'].groupby(df['key1'])grouped&lt;pandas.core.groupby.SeriesGroupBy object at 0x000000000876EBA8&gt;# 调用GroupBy的方法进行聚合计算grouped.mean() key1a 0.486419b -0.771562Name: data1, dtype: float64 分组 groupby：在分组的基础上，计算非NA的值统计量； 并且对所有的数值数据进行统计计算，而对非数据数据列则会排除。 默认对axis=0上进行分组；该场景应认为是计算的场景，axis=0 表示以列为单位，遍历每一行；即对该列中的各个值进行分组；效果等同于SQL中的groupby df.groupby(‘ col’ )：返回一个按列col进行分组的Groupby对象 df.groupby( [‘col1’,’col2’] )：多条件分组； （ 等价于SQL中Group by key1, key2 ） df.groupby().size()：返回一个包含分组大小的Series as_index = False ：以 “无索引” 的形式返回聚合数据 group_keys = False ：禁止分组键。分组键会跟原始对象的索引共同构成结果对象中的层次化索引。该函数可禁止该效果。 123456789101112131415161718192021222324252627282930313233343536373839# grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已grouped = df['data1'].groupby(df['key1'])grouped&lt;pandas.core.groupby.SeriesGroupBy object at 0x000000000876EBA8&gt;# 调用GroupBy的方法进行聚合计算grouped.mean() key1a 0.486419b -0.771562Name: data1, dtype: float64 # 对所有的数值数据进行统计计算，而对非数据数据列则会排除。 'key2'列自动被排除在外df.groupby('key1').mean() data1 data2key1 a 0.486419 -0.379653b -0.771562 -0.562044 # -----------df.groupby(['col1', 'col2'])-----------------# 一次传入多个数组，表示多条件分组 df.loc[:,'data1'].groupby([df['key1'],df['key2']]).mean() # 等价于SQL中 Group by key1, key2 key1 key2a one 0.882282 two -0.305308b one -1.010323 two -0.532800Name: data1, dtype: float64 # ---------------Size--------------------df.groupby('key1').size() key1a 3b 2dtype: int64 层次化索引的重塑 - stack 可构建类似数据透视表的结构 stack()：列转行；将数据的列 “旋转” 为行 unstack()：列转行；将数据的行 “旋转” 为列 stack操作的是对最内层的索引进行操作。 若用字符串表示，则直接输入该索引的名称 .stack(‘number’) 若用数字表示，0 - 第一层索引； 1 - 第二层索引 123456df.loc[:,'data1'].groupby([df['key1'],df['key2']]).mean().unstack()key2 one twokey1 a 0.882282 -0.305308b -1.010323 -0.532800 选取部分列 分组 df[‘data1’].groupby(df[‘key1’])：返回的一个已分组的数据框对象（语法糖：df.groupby(‘key1’)[‘data1’] ） df[[‘data1’]].groupby(df[‘key1’]) ： 语法糖为df.groupby(‘key1’)[[‘data1’]] 通过函数 - 分组 任何被当做分组键的函数都会在各个索引值 （行的索引值，而非列名）上被调用一次，其返回值就会被用作分组名称。 若索引为人的名字；假设你希望根据人名的长度进行分组，虽然可以求取一个字符串长度数组，但其实仅需 传入len函数即可 1people.groupby(len).sum() ####通过索引级别 - 分组 针对层次化索引数据集，可以根据索引级别进行分组；通过level 关键字传入 级别编码 或者 名称 即可。 df.groupby(level=’cty’, axis=1).mean() 对层次化索引的数据，根据索引级别进行聚合.通过level关键字传入级别编号或名称 1hier_df.groupby(level='cty', axis=1).count() 对分组进行迭代通过字典或Series 分组 传入一个 字典或Series 根据其值的内容分别分组 数据聚合 聚合：从数组产生标量值的数据转换过程 GroupBy会高效地对Series进行切片，然后对各片调用Piece，最后将这些结果组装为最终结果 自定义聚合函数 将自定义的函数传入aggregate 或 agg方法即可 aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。 df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值df 1234def peak_to_peak(arr): return arr.max() - arr.min()df.groupby('key1').agg(peak_to_peak) 优化过的GroupBy 方法 .count() ： 非NA值的数量.sum() ： 非NA值的和.mean().mdian()： 非NA值的算术中位数.std / .var： 无偏（分母为n-1）标准差和方差.min / .max.prod()： 非NA值的积.first / .last ：第一个和最后一个非NA的值 面向列的多函数应用 一次应用多个函数 df.groupby( [‘sum’, ‘mean’]) ：一次应用多个函数：对于描述统计，可以将函数名以 字符串str 的形式传入，并作为一个 列表list 传入，得到一个以相应的函数命名的列 df.groupby( [ (‘foo’, ‘mean’), (‘bar’, ‘sum’) ]) ：传入多个函数，并重命名列名。 当传入的是一个由 (name, function)元组组成的列表list ，则各元组的第一个元素会被用作DataFrame的列名（可以将这种二元元组看做一个有序映射） 123456789101112131415161718192021df.groupby('key1').agg(['sum','mean']) data1 data2 sum mean sum meankey1 a 1.459256 0.486419 -1.138960 -0.379653b -1.543123 -0.771562 -1.124087 -0.562044# ---- 先定义要传入的多个函数为对象A；也可以运行fc = ['count', 'mean', 'max'] df.groupby('key1').agg(fc) data1 data2 count mean max count mean maxkey1 a 3 0.486419 1.041325 3 -0.379653 0.010709b 2 -0.771562 -0.532800 2 -0.562044 0.038084# 传入带有自定义名称的元组列表fc_name = [('计数','count'),('最大值','max')] 对不同的列使用不同的聚合函数 df.groupby(‘key1’).agg( { ‘tip’: np.max, ‘size’: ‘sum’} ) ：向 agg 传入一个列名映射到函数的 字典dict df.groupby(‘key1’).agg( { ‘tip_pct’ : [‘min’, ‘,max’], ‘size’: ‘sum’}) ：对不同列完成不同数量的聚合 分组运算transform &amp; apply transform &amp; apply 只能产生两种结果： 一个可以广播出去的标量值 一个相同大小的结果数组 aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。 df.groupby(‘val’).transform( func )：将一个函数应用到各个分组，返回该结果的值； 若产生的是一个标量值，则该值会被广播出去。 123456789101112131415161718df.groupby('key1').transform('mean') data1 data20 0.486419 -0.3796531 0.486419 -0.3796532 -0.771562 -0.5620443 -0.771562 -0.5620444 0.486419 -0.379653# 对比 df.groupby('key1').mean() data1 data2key1 a 0.486419 -0.379653b -0.771562 -0.562044# 分组运算并合并数据df.groupby('key1').transform('mean').add_prefix('mean_') # DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。 apply 是更一般性的 “拆分-应用-合并”； 传入的函数一般都是需要提前定义的；而无法直接调用已有的函数（sum/mean等） GroupBy.apply(func)： data.apply(np.mean)：对DataFrame中的每一 [列] 应用函数np.mean axis = 0 默认：以行为单位，遍历列的所以行；可以理解为 SQL中指定某列的Group by axis = 1 ：以列为单位，遍历行的所有列。 1234567891011# 定义函数：根据分组选出最高的5个tip_pct值def top(df, n=5, column = 'tip_pct'): return df.sort_index(by=column)[-n:] # 将该函数应用tips.groupby('smoker').apply(top)# -----------------------------------------------# 如果传入的函数能够接受其他参数或关键字，可以将这些内容直接放在函数名后面一并传入applytips.groupby(['smoker', 'day']).apply(top, n=1, column = 'totoal_bill') 样式输出 - style 【提醒】 采用格式化函数之后，整个对象类型则变更为 styler ，此时不应该赋值给原对象。因为赋值后，无法应用任何 DataFrame的函数； 格式输出并不改变原对象的值 在最后阶段应用格式化输出的函数 输出设置 Styler.format(formatter, subset=None)：格式化单元格的文本显示值 pandas.io.formats.style.Styler.format 对象必须是 DataFrame；对于Series无效；即若只取 DataFrame的一列，则会报错； formatter: str, callable, or dict &lt; formatter是 a 或 dict {column name： a} &gt;； a 是如下之一 str: this will be wrapped in: a.format(x) ； 这将包装在：a.format(x) callable: called with the value of an individual cell 使用单个单元格的值调用 subset: IndexSlice An argument to DataFrame.loc that restricts which elements formatter is applied to 123456789&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(4, 2), columns=['a', 'b'])# 对所有对象调用格式化函数&gt;&gt;&gt; df.style.format('&#123;:.2%&#125;') # 注意&#123;&#125;是用引号 括起来的&gt;&gt;&gt; df['c'] = ['a', 'b', 'c', 'd']# 通过字典的方式来指定特定列的输出格式 ## 对于数值类型，直接调用format函数； 对于文本，直接调用str.funcdf.style.format(&#123;'a':format('&#123;:.2%&#125;'),'b':format('&#123;:.2%&#125;'),'c':str.upper&#125;) 对于数值类型，直接调用format函数； 对于文本，直接调用str.func 格式化单元格的文本显示值。 参考说明axis的含义【结论】 常规情况下，axis=1 代表列； axis=0 代表行； 计算情况下，axis=1 代表沿着每一行遍历所有的列，并向下执行对一个的方法 如果我们调用df.mean(axis=1),我们将得到按行计算的均值 如果我们调用 df.drop((name, axis=1),我们实际上删掉了一列，而不是一行 df.mean其实是在每一行上取所有列的均值，而不是保留每一列的均值。也许简单的来记就是axis=0代表往跨行（down)，而axis=1代表跨列（across)，作为方法动作的副词（译者注） 换句话说： 使用0值 表示沿着每一列或行标签\索引值向下执行方法 使用1值 表示沿着每一行或者列标签模向执行对应的方法 下图代表在DataFrame当中axis为0和1时分别代表的含义: axis参数作用方向图示 另外，记住，Pandas保持了Numpy对关键字axis的用法，用法在Numpy库的词汇表当中有过解释： 轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。 所以问题当中第一个列子 df.mean(axis=1)代表沿着列水平方向计算均值，而第二个列子df.drop(name, axis=1) 代表将name对应的列标签（们）沿着水平的方向依次删掉。 12345678910111213141516171819&gt;&gt;&gt;df = pd.DataFrame([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], \columns=["col1", "col2", "col3", "col4"])&gt;&gt;&gt;df col1 col2 col3 col4 0 1 1 1 1 1 2 2 2 2 2 3 3 3 3 &gt;&gt;&gt; df.mean(axis=1)0 11 22 3&gt;&gt;&gt; df.drop("col4", axis=1) col1 col2 col30 1 1 11 2 2 22 3 3 3 常见问题两行相减 &amp; 环比12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python_基本概念与操作]]></title>
      <url>%2F2017%2F05%2F17%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FPython%2FPython_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FPython_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[数据类型 Number（数字） int（整型） float（浮点型） complex（复数） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） Number（数字） 字符串 字符串的输入 单引号/双引号； 单引号 三个引号1234567- **字符转义**： - `\ (反斜杠)` - `r`` ` 引号内部的字符串默认都不转义 ```python r`ABC\.CSV$` 合并 ：运用加号 ( + ) 来进行合并字符串 空白 添加空白：制表符 (\t) 、换行符(\n) 删除空白：两侧 - strip()；左侧 - lstrip()；右侧 - rstrip() 赋值与变更 ： 必须将变更后的对象赋值，因为字符串是不可更改的； f = f.strip() 字符串 *(星号) 数字；表示字符串重复输出n次 print(&quot;.&quot; * 10) 转换 : str() 长度：len(string) 格式化 用%来实现字符串的格式化 1234binary = "binary"do_not = "don't"y = "Those who know %s and those whe %s." % (binary, do_not)print(y) 字符串 含义 %d - digit 整数 %f - float 浮点数 %s - string 字符串 %x 十六进制整数 %% 一个% 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串 布尔值 and / or / not 空值 None，一个特殊的空值 可变与不可变对象 str是不变对象，而list是可变对象 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的 对于不可变对象，比如str，对str进行操作，str内部是不变的。 123456789101112# 可变对象&gt;&gt;&gt; a = ['c', 'b', 'a']&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a['a', 'b', 'c']# 不可变对象&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a.replace('a', 'A')'Abc'&gt;&gt;&gt; a'abc' # 虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc' 始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’ 。 当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了 对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 数据类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 数据结构元组 - tuple what ：元组是一种不可变序列 元组和列表一样可以使用索引、切片来取值。 创建元组后不能在原地进行修改替换等操作 元组支持嵌套，可以包含列表、字典和不同元组 why ：元组的不可变性，在保证一个程序安全方面起到很大作用。 创建tuple 元组是用小括号( )包括起来的，( )括号中的元素用逗号分割，这样就完成元组的创建了 用tuple函数进行创建 1234567891011121314151617&gt;&gt;&gt;(1,2,3)(1,2,3)# 如果新建时没有用( )括号包括，只用逗号进行分隔python也会把它认做为元组&gt;&gt;&gt;1,2,3(1,2,3)# 如果你新建的元组中只有一个值，那么请记得在这个值后边加上逗号&gt;&gt;&gt;1,(1,) # 如果没有逗号，python只当把它当做整型来处理。&gt;&gt;&gt;1----------------------------------------------------------------------------------------------------------------------------------------# 用到tuple函数的功能：它可以一个列表为参数，把它转换为元组。&gt;&gt;&gt;tuple([7,8,9])(7,8,9)&gt;&gt;&gt;tuple('hello') # 把字符串'hello'中的每一个字母，都做为一个新的元素添加到新元组中('h', 'e', 'l', 'l', 'o') 修改元组元组是不可变的，类似字符串，不能在原处修改内容，但我们可以把它的类型做下转换，例如把一个元组转换为一个列表进行修改，之后再转换成元组。 索引 - 切片 列表list - 基本功能 what ：可以包含不同类型的数据对像，同时它是一个有序的集合；同时，它支持添加 append、插入 insert、修改、删除del等操作 1. 创建 list列表理解为任意对像的序列，只要把需要的参数值放入到中括号[ ]里面就可以了 用函数list()创建 123456names = ['ada','amy','ella','sandy']list()# 列表可以包含不同类型对像，也支持嵌套：&gt;&gt;&gt;a = ['a',567,['adc',4,],(1,2)] 2. 查找(索引) - 切片 方括号中索引值，半闭半开区间；左侧包括，右侧不包括 使用方括号[ ] 与 冒号 : 索引从0开始； 最后一个列表的元素为-1 (倒数第二个为-2，从末尾开始数正常) 1names[1:2] 3. 修改 列表是有序的，可以通过list下标来修改特定位置的值 1234&gt;&gt;&gt;a = [1,9,9]&gt;&gt;&gt;a [0] = 9&gt;&gt;&gt;a[9,9,9] 4. .append() / .insert() - 添加 末尾添加 - append(obj) / append(“string”) 插入元素 - insert(n, obj) /insert(n, “string”) motorcycles.insert(0, &#39;ducati&#39;) 第一个实参n表示插入的索引位置；这种操作会使得表中所有位于该索引之后的元素往右移一个位置； 5. del &amp; pop &amp; remove - 删除 根据位置直接删除 - del del motocycles[0] 根据位置删除 - pop() 默认情况下，弹出列表末尾的一个元素 motorcycles.pop() 指定索引位置，则弹出该位置的元素 motorcycle.pop(1) 每次只能删除一个索引位置的元素 根据值删除 - remove() remove 只删除第一个指定的值；若要删除的值在列表中出现多次，需要用循环来操作 motorcycles.remove(&#39;string&#39;) / motorcycles.remove(obj) 如果被弹出的元素不再需要使用，就选择del 6. .sort() / sorted() - 排序 永久性排序 - 方法sort() cars.sort(reverse=True) 默认按字母顺序进行升序排列 临时性排序 - 函数sorted() sorted(cars, reverse = True) 7. .reverse - 反转 方法reverse() cars.reverse() 反转是在原有的基础上进行颠倒；不同于按倒序排列 8. 长度 - len() Python计算列表list元素时从1开始。但索引是从0开始的；所以，在确定列表长度时会遇到差一 列表 - 操作1. 遍历列表 - 循环 for循环对列表的每个元素进行访问。 12for magician in magicians: print(magician.title() + ", that was a great trick!") 使用单数、复数的名称，有利于判断是单个列表元素还是整个列表 冒号的使用 缩进的代码必须是循环的一部分；没有缩进的代码只执行一次 2. 创建数值列表- range 函数range() ，半闭半开区间； 1range(1,100,2) # c为步长 3. 列表推导式 将for循环和创建新元素的代码合并成一行；（语法糖） 12345678910111213resutl = [ expr_value for value in collection if condition]# expr_value 为value的表达式 squares = [value**2 for value in range(1,11)]# 若缺少变量result，则直接返回符合的值# ----等价于---------result = []for value in collction: if condition: result.append(value) # ---------示例-------------- strings = ['a', 'as', 'bat', 'car', 'dove', 'python'][x.upper() for x in strings if len(x) &gt; 2] 字典推导式 12&gt; dict_result = &#123; key-expr: value-expr for value in collection if condition&#125; # 区别在与用 花括号&gt; &gt; 集合推导式 12&gt; set_result = &#123;expr for value in collection if condition&#125;&gt; 4. 使用列表的一部分 - 切片/复制 切片 ：指定第一个元素、最后一个元素的索引； 12345players[0:3] # 列表中实际的 1~3个元素；players[:4] # 未指定第一个元素的索引，则从0开始players[2:] # 未指定最后一个元素的索引，则到末尾； 等价于players[2:-1]players[-3:] # 从倒数第3个元素的开始到末尾players[:] # 列表的所有元素 复制列表 ：复制，两者之间没有联系。通过复制来实现 1friend_food = my_food[:] 若直接赋值，则表示指向同一个对象；两者之间有关联； 12345678910111213friend_food = my_food# --------------示例----------------my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foodsmy_foods.append('cannoil')print(my_foods)print(friend_foods)&gt;&gt;&gt;['pizza', 'falafel', 'carrot cake', 'cannoil']['pizza', 'falafel', 'carrot cake', 'cannoil'] 字典 - dict what ：字典是一系列键-值对。每个键都与一个值相关联。 一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉 dict是用空间来换取时间的一种方法，并且需要牢记的第一条就是dict的key必须是不可变对象。 字符串、整数等都是不可变的，因此，可以放心地作为key dict全称dictionary，在其他语言中也称为map 1. 创建与访问 创建： 用花括号、冒号来实现 dict() 1234p = &#123;&#125;p = &#123;'color': 'green', 'points': 5, # 最后一个仍留有逗号，为以后添加键值做准备 &#125; 访问：指定方括号内的键 1p['color'] 2. 添加与删除 添加键-值对：直接赋值，若键不存在则创建 12p['x_position'] = 0p['y_position'] = 25 删除 123del p['color']p.pop('color') # 指定的是键，而非值； 在列表list中，pop指定的是索引 3. 遍历字典 遍历所有的键-值对 - .items() 遍历所有的键 - .keys() 遍历所有的值 - .values() 123456for key, value in user_0.items(): passfor key in user_0.keys(): passfor value in user_0.values(): pass 按顺序遍历所有的键 - for key in sorted(user_0.keys()): 集合 - set what ：没有重复的键。 why ：重复元素在set中自动被过滤 set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象 1. 创建创建一个set，需要提供一个list作为输入集合 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s{1, 2, 3} 2.添加与删除 添加 - .add() 删除 - .remove() 条件判断1.条件测试 相等 == 不相等 != 检查多个条件：and / or 为改善可读性，建议加上括号 (age &gt; 21) and (age_1 &gt; 21) 2. 检查特定值是否包含在[列表] in / not in 3. if语句 if语句 if - else 语句 if - elif - else 语句 它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的 elif 和 else 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False 1234567891011121314151617# if语句if x: print(x)# if-else 语句 if x: passelse: pass # if-elif-else语句if x: passelif y: passelse: pass 4. input - 有问题的条件判断 input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数 12345birth = input('birth: ')if birth &lt; 2000: print('00前')else: print('00后') 循环break &amp; continue break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。 break 立即退出循环； 即该for/while循环停止，不在运行任何代码 嵌套循环中，仅跳出当前所在for/while循环 continue 忽略余下代码，直接返回for/while循环的开头。即立刻开始第二次循环 12345678910## 返回100以内的质数# k = ''for i in range(50:101): # 第1层循环 for a in range(2:i): # 第2层循环 (从2开始作为除数，并且终止于i-1) if i % a == 0: break # 此处break跳出的是for a 这个第2层循环；即该for a循环不在执行，i 从 50增加到51 if a == i - 1: print(i) # k = k +str(i) + '\n'# print(k) 函数1. 定义函数 定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。 12345def my_abs(x): if x &gt; 0: return x else x &lt; 0: return -x 如果想定义一个什么事也不做的空函数，可以用pass语句：pass语句什么都不做. 实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 123&gt; def nop():&gt; pass&gt; 参数检查 调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError： 当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError(('bad operand type')) if x &gt;= 0: return x else: return -x 返回多个值 12345import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 2. 参数1. 形参与实参 形参：函数完成工作时所需的一项信息 实参：调用函数时传递给函数的信息 位置实参：顺序很重要 关键字实参：传递给函数的 名称 - 值对 2. 参数的默认值 在形参部分赋值 必选参数在前，默认参数在后 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 3. 可选参数(实参) 使用默认值让实参变为可选的：空字符串 + 置于末尾 12def get_formatted_name(first, last, middle=''): print(first + middle + last) 4.1 任意数量的(可变)实参 允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple 【关键区别】。 在形参之前加上一个星号(*) ： 创建一个名为numbers的空元组tuple，并将所有收到的值封装到这个元组中 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，要调用一个可变参数；允许你在list或tuple前面加一个星号(*)，把list或tuple的元素变成可变参数传进去： 123456&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14# ---------其他方式-------------calc(nums[0], nums[1], nums[2]) 位置实参 + 任意数量实参 ：将位置实参写在前 + 任意数量实参仍用 *形参名 12def make_pizza(size, *toppings): print(size + toppings) 4.2 任意数量的关键字实参 允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict 【关键区别】 形参之前加上两个星号(\) ：创建一个名为person的空字典，并将收到的所有名称-值对封装到这个字典中** 该方式不限制关键字参数的名字 12345def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) person('bob' , 35, city = 'Beijing', tall =32) &gt;&gt;&gt;name: bob age: 35 other: &#123;'city': 'Beijing', 'tall': 32&#125; 限制关键字参数的名字，就可以用命名关键字参数 命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数 【建议采用此种命名方法】 12345def person(name, age, *, city, job): print(name, age, city, job) person('Kate', 21, args=32, city='shanghai', job='doctor')[out]: Kate 21 32 shanghai doctor 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了 但该可变参数为元组，会用圆括号括起来 12345def person(name, age, *args, city, job): print(name, age, args, city, job) person('Kate', 21, 32, city='shanghai', job='doctor')[out]: Kate 21 (32,) shanghai doctor 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数 5. 参数组合 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用； 123456789101112131415def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)# *args 作为一个任意数量的实参，为一个元组f1(1, 2, 3, 'a', 'b', x=99) [out]: a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125; --------------------------------------------------------------------def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) # *,d 作为一个整体，为命名关键字参数# **kw 为关键字参数（实参名字可任意命名）f2(1, 2, d=99, ext=None)[out]: a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125; 通过一个tuple和dict，你也可以调用上述函数： 1234567args = (1, 2, 3, 4)kw = &#123;'d': 99, 'x': '#'&#125;f1(*args, **kw)[out]: a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 其他 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名” a =abs ; a(-1) 6. 参数小结 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})。 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数 3. 传递实参 - 列表12345678910111213def greet_users(names): '''doc strings''' for name in names: msg = "Hello, " + name.title() + "!" print(msg)usernames = ['hanah', 'ty', 'magto']greet_users(usernames)[out]:Hello, Hannah!Hello, Ty!Hello, Magot! 4. 返回值 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None。 函数可以同时返回多个值，但其实就是一个tuple。 使用return语句将值返回到函数的调用行 12345678def get_formatted_name(firsr, last): full_name = first + ' ' + last return full_name.title()#--------------------------------------------------------def get_formatted_name(firsr, last): full_name = &#123;'first': first, 'last': last&#125; # 返回字典 return full_name 5. 递归函数 每个函数应只负责一项具体的工作。若执行的任务太多，可在函数中调用另一个函数 在函数内部，可以调用其他函数。所谓递归函数，一个函数在内部调用自身本身 。 举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出： fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n 所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 使用递归函数的优点是逻辑简单清晰，理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。缺点是过深的调用会导致栈溢出。 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。 5. 保存与调用如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名） 1from abstest import my_abs # 导入my_abs() 函数 函数式编程 函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 what ：函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。 计算机（Computer）和计算（Compute） 计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。 计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。 对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量 任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。 允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 why ：函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 高阶函数 变量可以指向函数 函数本身赋值给变量 1234567891011&gt;&gt;&gt; abs(-10)10&gt;&gt;&gt; abs&lt;built-in function abs&gt;# abs(-10)是函数调用，而abs是函数本身。-----------------------------------------------------------------------------&gt;&gt;&gt; f = abs&gt;&gt;&gt; f&lt;built-in function abs&gt;# 说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。 函数名也是变量 函数名其实就是指向函数的变量 。对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！ 传入函数 12345678def add(x, y, f): # f = abs return f(x) + f(y) x = -5y = 6f = absf(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11return 11 ​ 切片&amp;迭代1. 切片 tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。 切片 ：指定第一个元素、最后一个元素的索引； 12345players[0:3] # 列表中实际的 1~3个元素；players[:4] # 未指定第一个元素的索引，则从0开始players[2:] # 未指定最后一个元素的索引，则到末尾； 等价于players[2:-1]players[-3:] # 从倒数第3个元素的开始到末尾players[:] # 列表的所有元素 切片的第三个值为步长step 12345678# 前10个数，每两个取一个：&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8]# 所有数，每5个取一个：&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25] 字符串的选取 123# 字符串'xxx'也可以看成是一种list，每个元素就是一个字符。&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC' 复制列表 ：复制，两者之间没有联系。通过复制来实现 1friend_food = my_food[:] 2. 迭代 what ：如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable 集合数据类型：列表list、元组tuple、字典dict、字符串string、集合set generator，包括生成器和带yield的generator function 可以使用isinstance()判断一个对象是否是Iterable对象 迭代操作 list或tuple迭代 12for i in list: print(i) 字典dict迭代 dict迭代的是key。 如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for key, value in d.items()。 123&gt;&gt;&gt; d = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; for key in d: # value in d.values() / key, value in d.items()print(key) 字符串迭代 12&gt;&gt;&gt; for ch in 'ABC':print(ch) 索引和元素同时迭代：Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： 123456&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):print(i, value)0 A1 B2 C 判断迭代 判断是否可迭代：通过collections模块的Iterable类型判断 1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 3. 列表生成式 将for循环和创建新元素的代码合并成一行；（语法糖） 12345678910111213141516resutl = [ expr_value for value in collection if condition]# expr_value 为value的表达式 squares = [value**2 for value in range(1,11)]# 若缺少变量result，则直接返回符合的值# ------------------------等价于---------------------------------result = []for value in collction: if condition: result.append(value) # ---------------------示例------------------------- strings = ['a', 'as', 'bat', 'car', 'dove', 'python'][x.upper() for x in strings if len(x) &gt; 2][x * x for x in range(1, 11) if x % 2 == 0] 字典推导式 12&gt; dict_result = &#123; key-expr: value-expr for value in collection if condition&#125; # 区别在与用 花括号&gt; &gt; 集合推导式 12&gt; set_result = &#123;expr for value in collection if condition&#125;&gt; 两层循环 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 4. 生成器 what ：一边循环一边计算的机制，称为生成器：generator。 如果列表元素可以按照某种算法推算出来，这样就不必创建完整的list，从而节省大量的空间。 创建生成器generator 只要把一个列表生成式的 [] 改成 ()，就创建了一个generator： 12345L = [x * x for x in range(10)][0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x * x for x in range(10))&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 返回值 next()函数获得generator的下一个返回值 通过迭代 123456789&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1# ---------------------通过迭代----------------------------&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n) 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True list、dict、str等数据类型不是Iterator 。 因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 类面向过程 vs. 对象的程序设计 what ：面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程 vs. 对象编程： 面向过程的程序设计：把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 面向对象的程序设计：把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向过程 12345678## 假设我们要处理学生的成绩表，为了表示一个学生的成绩# 面向过程的程序可以用一个dict表示std1 = &#123; 'name': 'Michael', 'score': 98 &#125;std2 = &#123; 'name': 'Bob', 'score': 81 &#125;# 处理学生成绩可以通过函数实现，比如打印学生的成绩def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象 采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property） 123456789# 如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 创建 - 类类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据； 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同： class后面紧接着是类名，即Dog，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 attribute为该类的属性；def 定义的该类的行为 123456789101112131415161718192021class Dog(): """一次模拟小狗的简单尝试"""# ----------直接定义属性----------------- # 调用类时无需再传入外部参数，此时已默认其属性值 name = 'Kite' age = 3 #------------初始化属性------------------ # 调用类时必须传入外部参数 def __init__(self, name, age): """初始化属性 name 和 age""" self.name = name self.age = age self.color = 'white' # 直接定义属性，且该属性无需出现在()中；调用类时也无需再传入外部参数，此时已默认其属性值 def sit(self): """模拟小狗被命令时下蹲""" print(self.name.title() + " is now sitting.") def roll_over(self,n): """模拟小狗被命令时打滚n次""" self.n = n print(self.name.title() + " rolled over " + self.n + "times!") __init__ ： 初始化属性，此类方式在调用类时需传入外部参数 有了init方法，在创建实例的时候，就不能传入空的参数了，必须传入与init方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： self ：在类中定义属性，第一个参数永远是self，表示创建的实例本身。因此，在方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 即，将外部参数的属性传入到内部 创建 - 实例因为类时一个抽象的概念，在创建具体的实例之前，必须先有一个容器； 123456# 已创建了默认属性my_dog = Dog()my_dog# 未创建默认属性，而是初始化属性my_dog = Dog('willie', 6) # 必须传入外部参数 访问 采用方法的方式来进行访问 1234my_dog.name[out]: 'willie'my_dog.roll_over(2) 限制访问 要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 12345678910class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) bart = Student('Bart Simpson', 98) 改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了： 1234&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 获取限制访问的变量 ：增加方法 - 给Student类增加get_name和get_score这样的方法 12345678910class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score bart.get_name 允许外部代码修改 ： 增加方法 - set_score方法 12345class Student(object): ... def set_score(self, score): self.__score = score 需要注意的是，在Python中，变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用name、score这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 修改属性 直接修改属性的值 1my_dog.color = "black" 通过方法修改属性 1234567class Dog(): --snip-- def update_color(self, color): self.color = color my_dog.color('black') 继承与重写一个类继承另一个类时，会自动获得另一个类的所有属性和方法。原有的类：父类；新的类：子类； 创建子类时，父类必须包含在当前文件夹，且位于子类的前面 必须在括号内指定内类的名称 使用super().__init__将父类和子类关联起来，使其包含父类的所有属性 1234567891011class Car(): --snip-- class ElectricCar(Car): # 括号中为父类的名称 def __init__(self, make, model, year): super().__init__(make, model, year) # 通过super().__init__将父类和子类关联，并获得父类的所有属性 self.batter_size = 70 # 可同时新建属性，同时指定默认值# --------------重写父类中的方法--------------------------- def fill_gas_tank(): # 当定义的方法中括号中的内容为空，表示忽略该方法 print("This car doesn't need a gas tank.") 导入类12345678910# 导入指定的类from filename import classname1, classname2from car import Car, ElectricCar# 导入整个模块import filename# 导入模块中的所有类from filename import * ##主要函数 对象类型 type() - 判断对象类型 instance() - 判断一个对象是否为某种类型：返回布尔值Ture/Falses 12345678910111213141516171819# 指定判断类型&gt;&gt;&gt; isinstance('a', str)True&gt;&gt;&gt; isinstance(123, int)True# 先创建判断的对象&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True# 还可以判断一个变量是否是某些类型中的一种&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 能用type()判断的基本类型也可以用isinstance()判断 获得对象的所有属性与类型 - dir() 字符串操作替换 - replace12345replace(old, new[, max]) # max，可选字符串, 替换不超过 max 次relpace("a","b") # 将a替换为bval.replace(",", "::") 分隔 - split - string转listspilt - 通过指定的分隔符将字符串拆分为一组子串 字符串会转为列表list 12345spilt(",") # 分隔后的字符串会转变为列表格式listval = 'a,b, guido'val.split(',')# ['a', 'b', ' guido'] 去空格 - stripstrip - 去除空格（含换行符），相当于对各个元素执行x.strip() 12345strip()val.strip()val.lstrip()val.rstrip() 联接 - join - list转stringjoin - 联接其他字符串序列的分隔符 [列表转字符串] 1234','.join(val) # 将val转为string"::".join(val) # 将::作为分隔符，联接对象val中的各个子串## 转化之后，可将list转变为str 其他1234count # 返回子串在字符串中出现的次数（非重叠）startswith / endswith # 判断是否以某子串开始或结束，返回True或Falsefind / frind # 返回第一个/最后一个发现的第一个只字符所在的位置；若没有找到，则返回 -1 val.find(",")index # 返回子串第一个字符所在的位置；若没有找到，引发 ValueError 函数 VS. 方法若为方法，也直接在符合的对象之后进行引用。 DataFrame.xxx ：数据框类型的对象 datetime.xxx：时间类型的对象 函数 函数function —— A series of statements which returns some value toa caller. It can also be passed zero or more arguments which may beused in the execution of the body. 从定义的角度上看，函数(function)就相当于一个数学公式，它理论上不与其它东西关系，它只需要相关的参数就可以。所以普通的在module中定义的称谓函数是很有道理的。 函数是一段代码，通过名字来进行调用。它能将一些数据（参数）传递进去进行处理，然后返回一些数据（返回值），也可以没有返回值。所有传递给函数的数据都是 显式传递 的。 方法 方法method —— A function which is defined inside a class body. Ifcalled as an attribute of an instance of that class, the methodwill get the instance object as its first argument (which isusually called self). 方法，它是与某个对象相互关联的，也就是说它的实现与某个对象有关联关系。这就是方法。虽然它的定义方式和函数是一样的。也就是说，在Class定义的函数就是方法。 方法的定义可以是这样的，与某个对象进行绑定使用的函数。注意哦。绑定不是指” .”这个符号，这个符号说实在的只有域名的作用。绑定在这里是指，会默认赋值该绑定的对象。 方法也是一段代码，也通过名字来进行调用，但它跟一个对象相关联。方法和函数大致上是相同的，但有两个主要的不同之处： 方法中的数据是隐式传递的； 方法可以操作类内部的数据（请记住，对象是类的实例化 。类定义了一个数据类型，而对象是该数据类型的一个实例化） 从上面可以看出, 别的编程语言一样, Function也是包含一个函数头和一个函数体, 也同样支持0到n个形参,而Method则是在function的基础上, 多了一层类的关系, 正因为这一层类, 所以区分了 function 和 method.而这个过程是通过 PyMethod_New实现的 1234567891011121314151617181920212223242526PyObject *PyMethod_New(PyObject *func, PyObject *self, PyObject *klass)&#123; register PyMethodObject *im; // 定义方法结构体 im = free_list; if (im != NULL) &#123; free_list = (PyMethodObject *)(im-&gt;im_self); PyObject_INIT(im, &amp;PyMethod_Type); // 初始化 numfree--; &#125; else &#123; im = PyObject_GC_New(PyMethodObject, &amp;PyMethod_Type); if (im == NULL) return NULL; &#125; im-&gt;im_weakreflist = NULL; Py_INCREF(func); /* 往下开始通过 func 配置 method*/ im-&gt;im_func = func; Py_XINCREF(self); im-&gt;im_self = self; Py_XINCREF(klass); im-&gt;im_class = klass; _PyObject_GC_TRACK(im); return (PyObject *)im; 以本质上, 函数和方法的区别是: 函数是属于 FunctionObject, 而 方法是属 PyMethodObject 123456789101112131415161718def aa(d, na=None, *kasd, **kassd): passclass A(object): def f(self): return 1a = A()print '#### 各自方法描述 ####'print '## 函数 %s' % aaprint '## 类方法 %s' % A.fprint '## 实例方法 %s' % a.f#输出结果: #### 各自方法描述 ###### 函数 &lt;function aa at 0x000000000262AB38&gt;## 类方法 &lt;unbound method A.f&gt;## 实例方法 &lt;bound method A.f of &lt;__main__.A object at 0x0000000002633198&gt;&gt; 【Bound Method 和 Unbound Method】 method 还能再分为 Bound Method 和 Unbound Method, 他们的差别是什么呢? 差别就是 Bound method 多了一个实例绑定的过程!A.f 是 unbound method, 而 a.f 是 bound method, 从而验证了上面的描述是正确的! 详细参见：https://segmentfault.com/a/1190000009157792 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; def fun(): pass&gt;&gt;&gt; type(fun)&lt;class'function'&gt; #没有问题&gt;&gt;&gt; class Cla(): def fun(): pass @classmethod def fun1(cls): pass @staticmethod def fun2(): pass&gt;&gt;&gt; i=Cla()&gt;&gt;&gt;Cla.fun.__class__&lt;class'function'&gt; #为什么还是函数&gt;&gt;&gt;i.fun.__class__ #这个还像话&lt;class 'method'&gt;&gt;&gt;&gt;type(Cla.fun1)&lt;class 'method'&gt; #这里又是方法&gt;&gt;&gt; type(i.fun1)&lt;class 'method'&gt; ＃这里仍然是方法&gt;&gt;&gt;type(Cla.fun2)&lt;class 'function'&gt; ＃这里却是函数&gt;&gt;&gt; type(i.fun2)&lt;class 'function'&gt; ＃这里却是函数 普通方法（老版中直接就是”instancemethod”）在module中与在Class中定义的普通函数，从其本身而言是没有什么区别的，他们都是对象函数属性。 之所以会被说在Class中的定义的函数被称为方法，是因为它本来就是面向将来的实例对象的，其实他们就是实例方法，这些方法是与实例相联系的（从实例出发访问该函数会自动赋值）。所以你从Class访问仍然是一个函数 类方法（”classmethod”），因为类同样是对象，所以如果函数与类进行联系了话（与实例方法一样的模式）那么就能够这么说了！ 静态方法，虽然定义在内部，并且也较方法，但是却不与任何对象联系，与从类访问方法是一样的，他们仍然是函数。 【实战演练】for循环1234567for i in range(1,4): a = str(i) + '.' + i*'caihf' print (a) 1.caihf2.caihfcaihf3.caihfcaihfcaihf 打开与写入1234567891011121314151617with open ('whodata.txt') as f: a = f.readlines()['This is a test.\n', '\n', 'Beautiful is better than ugly.\n', 'Explicit is better than implicit.\n', 'Simple is LbOMONEetter than complex.\n']# ---------------------------c=''for i in range(0,len(a)): b = str(i+1) + '.' + a[i] c= b+c print(c)1.This is a test.2.3.Beautiful is better than ugly.4.Explicit is better than implicit.5.Simple is LbOMONEetter than complex.6.Complex is better than complicated.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据分析 vs. 数据挖掘]]></title>
      <url>%2F2017%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F30_%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%20vs.%20%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%2F</url>
      <content type="text"><![CDATA[Surface data, not mining it（呈现数据，而非挖掘） 对于数据分析的思路、可视化呈现，这些如果你做的好，完全可以成为一个业务指导者； 主要区别基本概念与服务目的 “ 数据分析 ”的重点是观察数据，“ 数据挖掘 ”的重点是从数据中发现“知识规则”KDD（Knowledge Discover in Database），数据统计的重点是参数估计和假设检验。 “数据分析、数据统计”得出的结论是人的智力活动结果，“数据挖掘”得出的结论是机器从学习集（或训练集、样本集）发现的知识规则。 “数据分析”需要人工建模，“数据挖掘”自动完成数学建模，“数据统计”则是把模糊估计变得准确而定量。可以通过机器学习自动建立输入与输出的函数关系，根据KDD得出的“规则”，给定一组输入参数，就可以得出一组输出量。 重心偏度数据分析则是业务部门主导,在数据挖掘结果及手工整理材料的基础上,得出他们需要知道的事情。重心在于决策和结果 数据挖掘总体上是业务部门提需求建议,总体规划实施还是技术部门主导。偏向于自动化,大方向上; 运作思路 基本思路 经典思路：目前在做数据分析时，采用的是传统的逻辑推理的分析的思路。==先提出问题，再通过严谨的逻辑推理进行验证，解释商业问题。== 新思路：尝试使用相关性进行数据挖掘分析；就是数据挖掘的一些技术，比如聚类、决策树、随机森林等高级统计模型。这种思路做出的东西，一般而言是技术门槛较高、解决经典思路无法解答的问题，也符合当前流行的大数据思维、人工智能思维。新思路的处理问题逻辑，==先有相关性分析，找出导致问题的相关性因素，然后再解释背后的商业逻辑。== ​ 适用范围 经典思路：符合人脑的思维模式，由A—&gt;B —&gt; C的逻辑顺序。在解决小而美的独立case时，效率高。当然，实际商业环境中，80%的问题都是小而美的问题，但是出风头的往往是那20%。比如，“为什么今天某个页面的转化率突然升高啦”这类的问题，通过逻辑推理，一步一步下钻，可以很快定位原因。但是对于多因素的问题，交叉影响之下，各有权重，这种思路就有了瓶颈。 新思路：这是AlphaGo下围棋是采用的思路，决策next move是因为nextmove对最终赢得棋局概率最高。这是一种结果导向的思维，将智能问题变成了数据问题。AlphaGo不需要知道如何布局，只关注每一次的落子都在提高最终胜利的概率。这种思路可以解决目标明确且影响因素众多的决策问题。这个思路现在越来越火主要由于计算力和数据量的提升和增多，机器有了足够的样本进行testing，如同中国式填鸭式教学，看多了，下意识里就知道如何处理了。 案例 您的问题提到三个概念，数据分析、数据挖掘还有目前炒的火热的大数据，谈这些概念的区别和联系，以及未来的就业前景，就不得不从这些职业细分的来源以及公司的业务需求谈起，通过公司的业务流程把他们串起来，自然能豁然开朗。 -—————————————– A公司是一家音乐软件公司，一开始只是一个简单的音乐网站，提供其他网站的mp3下载链接和搜索服务，因为访问量小而且没有自己的曲库，所以基本不涉及数据分析，团队构成就是网站前端开发为主。 慢慢地，随着音乐行业竞争加剧以及对版权的重视，A公司开始通过购买版权建立自己的曲库，慢慢地曲库开始有几十万首歌，同时为了现金流开始推广付费会员服务，搭建了一套账号体系，这时因为有了很多自己的数据（歌曲信息数据，会员数据），购买了很多服务器同时团队引进了DBA（Database Administrator），这是技术端最初的数据相关岗位，同时因为数据量小，公司用的是MySQL数据库，因为免费且开源。此时业务端因为每个月都有会员付费情况，而会员的转化率跟付费率是很重要的指标，需要专门的人去跟进并写Excel进行分析，一开始是由产品部的同事在做，慢慢地开始招聘一些专门做报表的人，这是最初的数据分析师，或称数据运营，工作就是简单地处理一下Excel函数，做一下PPT。 后来A公司拿到了风险投资，开始发展多元化产品战略，不仅做音乐软件，还做MTV视频软件，产品线慢慢从1变成2,3，数据源本来只存在于一个产品，现在分散到多个产品，各个产品团队由于数据上报格式不一，口径不一，导致数据无法规整统一地进行分析，于是公司决定成立一个数据中心，统一地从各个产品部门的数据库、网络日志里拉取数据，用统一的格式处理并存储，此时光有DBA就不够了，于是公司决定招聘几个ETL工程师或称数据仓库工程师，负责从各个部门的服务器进行数据的抽取（Extract）、转换（Transform）、加载（Load），形成统一的数据仓库，或称数据集市，这时业务端也不甘寂寞了，你们招工程师，那我们也招分析师，而这时招聘要求也提高了，除了Excel，多了对SPSS及统计背景的要求。 来到了2012年，由于Google的Mapreduce框架大大提高了数据处理的速度，诞生了Hadoop，也就是大数据的技术代名词，大数据的概念吹遍大江南北，很多国内公司都不甘寂寞地整起Hadoop，这时A公司也挖了BAT的工程师过来担任数据架构师，搭建了整套Hadoop系统，虽然是跟风，其实也是因为数据量越来越大，传统的关系型数据库已经不能满足大数据量的存储以及因为快速迭代的互联网开发模式所带来的数据及时性的需求，而随着数据量的增多，数据的价值越来越显重要，这时一种职业开始崭露头角，他们是数据挖掘工程师，挖掘机可不是普通的精通Excel就能干的数据分析师能开的，数据分析师说白了是马后炮，为管理层写写报表，展现一下数据，让管理层知道一下过去一年公司有哪些成长，并不直接产生业务价值，而数据挖掘工程师干的活是预测，是分类，是依托数据为公司开拓更多的产品线，带来更多的用户，他们不仅需要有扎实的统计学背景，还要会编程，会用代码来实现算法，并最好能将算法在分布式平台上实现。A公司的死对头B公司就是靠数据挖掘工程师做的歌曲推荐系统拉来了上千万的日活。 慢慢地数据分析师发现完了，自己做的事情越来越低价值了，工资死活涨不上去，于是转型，变成了数据产品经理，负责分析业务部门的各种业务需求，并负责协调数据仓库团队或数据挖掘工程师，将需求变成数据后台或者如推荐系统、用户画像这样的挖掘类产品。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[atom_设置]]></title>
      <url>%2F2017%2F05%2F05%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FAtom%2Fatom_%E8%AE%BE%E7%BD%AE%26%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[插件备份与还原官方插件管理方式；( 登录 https://atom.io/) 首先你需要拥有一个 Github 账户，在 atom.io 看到什么好插件，只需点击 star 收藏。某天，你想一次把收藏插件全部安装，只需执行命令： 123win + R &gt; cmdapm install stars # 会提示你输入自己的 token 按照提示一步一步来就可以。更多操作执行 apm stars --help 查看。 常规设置 自动换行 123file - setting - editor Soft Wrap # 表示到窗口末尾自动换行Soft Wrap At Preferred Line Length # 表示代码到80个字符自动换行 主题选择 UI Theme = One Dark Syntax Theme = Base16 Tomorrow Dark ​ 快捷键Atom是GitHub推出的一款编辑器，该编辑器暂时还不是很成熟，比如目前还无法支持代码补全等功能。但是GitHub作为一个极具影响力的开源社区，Atom必然会得到快速发展。在此记录Atom的部分常用快捷键。 这些快捷键都可以在Atom的在线文档中查阅到。 123456789101112131415161718192021222324252627282930313233343536373839Ctrl + T : 在当前工程中查找文件 Ctrl + B : 在当前已经打开的文件中查找文件 Ctrl + Shift + B : 查找已经更改，但是并未被提交（commit）到仓库的文件 Ctrl + 0 : 在文件编辑区和工程浏览区之间切换 *Ctrl + * : 打开/关闭工程浏览区 Ctrl + / : 快速注释/去除注释 A : 在工程浏览区中选中某一级目录的状态下，快捷添加文件 M : 在工程浏览区中选中某一级目录的状态下，快捷移动文件，并且可以快捷重命名 Delete : 在工程浏览区中选中某一级目录或者文件的状态下，快捷删除文件 Ctrl + F : 查找当前文件中的指定字段 Ctrl + Shift + F : 查找当前工程中的指定字段 Ctrl + R : 查找当前文件中的符号，如宏定义和函数定义等等 Ctrl + K然后按↑/↓/←/→ : 创建新的编辑面板 Ctrl + K然后按Ctrl + ↑/↓/←/→ : 在各个编辑面板之间切换焦点 Ctrl + W : 关闭当前面板 Ctrl + Alt + &#123; : 折叠（fold）当前代码，多次按该快捷键组合则向上层折叠 Ctrl + Alt + &#125; : 打开（unfold）当前代码，多次按该快捷键组合则向下层打开 Ctrl + Alt + Shift + &#123; : 折叠（fold）所有代码 Ctrl + Alt + Shift + &#125; : 打开（unfold）所有代码 Ctrl + Shift + P : 打开Atom控制面板。 PS: 其实所有快捷键都可以通过触发Ctrl + Shift + P命令而弹出的下拉框来查看。理论上来说只需记住该快捷键即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R语言_自动化]]></title>
      <url>%2F2017%2F05%2F02%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2Fdocument%2FR_%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
      <content type="text"><![CDATA[R实现自动化 - knitr 、 rmarkdown 自动化12345install.packages("knitr")install.packages("rmarkdown")library(knitr)library(rmarkdown) 在Tools-Golbal options-Sweave-weave Rnw files using -选择knitr 新建一个Rmd的文件，或者在File-new file-R markdown，新建一个Rmd的文件 现在knitr可以支持多种语言引擎，目前知道的有r,bash,pl,python等。 用knitr动态生成内容使用一个含有特殊标记的代码块，knitr会运行其中的代码，并抓取该代码的输入，最后把代码的输出作为文档的一部分 123​```&#123;r echo=FALSE&#125;print("hello knitr")​ 12345它将会产生一段内容插入到当前的markdown文件中。如下所示：```R#&gt; [1] &quot;hello knitr&quot; r告诉knitr使用R语言引擎来执行程序，echo=FALSE是knitr能够识别的一个参数，这个意思是，这段代码本身不会出现在最后的文档中。 后面的参数可以控制代码的执行以及输出的格式等，常见的参数有：（多个参数用,分开） eval 是否求值当前代码块 echo 是否显示源代码 results ‘markup’ ,‘asis’ tidy 是否美化R代码 fig.width fig.height out.width out.height 设备和输出图片的大小 fig.path 输出图片的前缀，如’./rfigures/p123-‘,将生成’./rfigures/p123-…png’ include 是否在结果中包含当前块的结果 collapse 输出和代码之间是否分开，缺省为“FALSE“,即分开 comment 输出前的注释符，缺省为’##’ 除了在代码块上指定参数以外，也可以使用ops_chunk$set(tidy=FALSE) 来设置这些参数。如果设定这些参数以后，会在当前文件中一直有效。所以，如果为了使代码块更简单，可以使用这个函数来设置一些参数 另外，knitr中除了每个代码块的参数外，还有包级别的参数，可以使用opts_knit$set(progress=TRUE,verbose=TRUE)这样的方式来设置。常见的包级别参数有： verbose 是否输出更多信息 所有的knitr参数，可以参考这里: http://yihui.name/knitr/options/#package_options 用knitr插入动态表格在knitr中生成表格，可以使用knitr::kable。 123​```&#123;r&#125;knitr::kable(head(iris))​ 123456789101112&gt; 注意这里的kable是带有参数的，即**生成html和latex时要用不同的参数调用，因此这个函数不宜直接放在rmd文件中**。最好的方式是使用一个函数来封装这个函数，在封装函数中判定当前的目标格式，然后再利用不同的参数来调用这个函数。在实际的使用中，我用blogtable来封装这个函数，这个函数是这样定义的：```Rblogtable&lt;-function(x)&#123; if(is_latex()) &#123; knitr::kable(x,format=&quot;latex&quot;,align=&quot;c&quot;) &#125;else&#123; knitr::kable(x,format=&quot;html&quot;,table.attr = &quot;class=\&quot;table table-bordered\&quot;&quot;, align=&quot;c&quot;) &#125;&#125; 后面的table.attr用来指定表格的css，这样html中生成的每个表格会居中显示。这样，我就可以在我的rmd文件中这样使用它了: 123​```&#123;.r&#125;rwp::blogtable(head(iris))​ 123456### 为表格添加标题kable中有一个参数叫`caption` , 这个参数用来指定表格的标题，现在，我们把这个参数也加到`blogtable`中去。试验一个实例： aa=c(6223,6220,6210,6205,6213)bb=letters[1:5]link=paste0(“http://www.bagualu.net/wordpress/archives/&quot;,aa)rlink=rwp::link(link,bb)dd=data.frame(link=rlink,index=1:5)rwp::blogtable(dd,none_escape_column=1,caption=”几篇博文”)12345678910111213## 用knitr插入动态图片在有图片生成的r块中，用`fig.path`指定图片的前缀。(注意在实际的页面中没有eval=FALSE参数)```r​```&#123;r fig.path=&apos;rfigures/p5304-&apos;,eval=FALSE&#125; library(rcnmap)#分别使用红色红色黄色在中国地图上画出湖北，上海和甘肃省cnmap(c(&quot;hubei&quot;,&quot;shanghai&quot;,&quot;gansu&quot;),c(&quot;red&quot;,&quot;red&quot;,&quot;yellow&quot;))​ ``` 生成的图片在rfigures/p5304-unnamed-chunk-2-1.png（相对当前的工作目录） 然后的html中，图的链接为:&lt;img src=&quot;rfigures/p5304-unnamed-chunk-2-1.png&quot; title=&quot;&quot; alt=&quot;&quot; width=&quot;672&quot; /&gt; 为了让这个图能够在最终的页面中显示出来，你需要把这个图拷贝到适当的地方。 为图片添加标题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《企业生命周期》读书笔记_爱迪思]]></title>
      <url>%2F2017%2F05%2F01%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F50_%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86%2F10_%E6%88%98%E7%95%A5%E7%AE%A1%E7%90%86%2F%E3%80%8A%E4%BC%81%E4%B8%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%8B%2F%E3%80%8A%E4%BC%81%E4%B8%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%88%B1%E8%BF%AA%E6%80%9D%2F</url>
      <content type="text"><![CDATA[《企业生命周期》_[美] 伊查克 • 爱迪思 《Managing Corporate Lifecycles 》_Ichak Adizes； 写于1996 在生命周期某一阶段属正常的问题有可能在另外一个阶段就是不正常的。 （未完） 孕育期 what ：这一阶段先于企业出现，这时企业还没有诞生；整个企业作为一个概念存在。 企业发展的第一个阶段 why ：孕育期所要强调的是创业的意图 + 未来所能够提供的可能性。 how ：这个阶段，创业者正在确立自己所要承担的责任，同时还在通过其他人来验证自己的想法。 孕育期，创业者的激励目标：满足市场需求，创造价值，为生活增添意义； 创业者必须从情感上对自己热衷的想法的市场价值承担责任。这个想法应该让它们着迷，创业者应该对所感受到的市场需求做出反应，他们要情不自禁地去满足这样的需求。产品或服务将要产生的利润不过是验证了他们在自己想法上的信心罢了。 他们必须把目标放在满足客户的需求上。最关键的是要以销售额来衡量。 对于客户需求的责任与客户是否感受到这个需求时没有关系的。创业者谈论的是市场应该买的东西，而不一定是市场正在买的东西。创办公司时，将注意力放在还没有确定或没有表达出来的需求上的企业家是以产品而不是以市场为导向的。 他们不是在对已经建立的需求做出反应，而是在试图教育和改变市场。 孕育期 Vs. 创业空想公司诞生的定义：有了关于所承担责任的一些具体表单，而不是签署了公司章程。即创业者承担了风险之后，公司才算诞生。eg：辞去了工作，签订了办公租约等其他形式 正常现象 不正常现象 兴奋不已，但经过了现实检验 所承担的责任没有经过现实检验 从头到尾进行了细节考虑 没有进行从头到尾的细节考虑 创业者现实而有责任心 创业者狂热而不现实 致力于增加价值的产品导向 纯粹的利润导向 责任心与风险担当 责任心与风险不对应 创业者掌握控制权 创业者的控制地位不稳定 婴儿期 what ：关注的焦点从构想和可能性转到了成效的生产( 实际行动 )上。企业必须销售，销售，再销售。 how ：虽然创业者谈的是销售，而他应该全神贯注于如何增加销售量。但在现实中，婴儿期的企业还是以产品为导向。因为他还在修补产品在技术上的漏洞以及企业在生产和业绩上的问题。但这是正常的。 婴儿期的企业在销售方面所做的努力总是远远低于应有的水平。创业者是唯一的销售人员。因为他们比其他任何人都要更了解这个产品或服务； 若想形成一个销售型的企业，并且把这个任务交给其他人去做，需要 把产品稳定下来 制定出价格政策并贯彻执行 准备好能够准确描述企业及产品、支持销售工作的材料 这一阶段的企业能做到的事情也就是对最紧急的事情做出反应，这时候的管理是一种危机管理。在进入到下一阶段之前，真正以销售为导向的模式是不会形成的。 投资不足：婴儿期的企业最需要的是营运资金；没有它，企业就会死亡。有些创业者往往低估了自对现金和营运资金的需求量。这个失误源于创业者在孕育期普遍所具有的狂热； 在开始的时候，绝大多数婴儿期的企业在经营中都是负的现金流，它们对营运资金的需要超过了从销售中获得的现金。由此产生的压力必然让企业以行动为导向，靠机会驱动，并以敏捷和灵活性的手段不惜一切去搜寻现金，这几乎没有给规章制度留下任何空间。 在这个阶段，创业者几乎不可能收获什么具体的奖励。让创业者勇往直前的是他们在孕育期确立的责任心。而且没有家庭的支持，创业者一般不是丢了家庭就是丢了公司。 管理者独断的领导风格：企业要在婴儿期获得成功，其创业者必须充满激情，并且忌讳任何人的干预。他们集权。但一旦企业的成长脱离了婴儿期，这样的问题就应该消失。婴儿期的企业是为了生存而战，它们在决策上不应该有丝毫的迟疑。 婴儿夭折当热情和责任心日渐消耗的时候，企业也快玩了。时间是决定性的，拖得过长的婴儿期是一种病态症状。 正常现象 不正常现象 产品导向 过早的销售导向 投资者问题不断 投资者疑惑不断 责任心没有受到危机的威胁 责任心被危机破坏 现金支出 &gt; 收入 意识不到负的现金流 缺乏管理深度 过早地授权 缺乏制度 过早地规定制度和程序 没有授权 创业者失去控制 独角戏，但愿意听取不同意见 听不进不同意见，自大 失误不少 不容忍失误 根据危机进行管理 出现无法管理的危机 家庭成员比较支持 缺乏家庭的支持 董事会成员比较支持 缺乏董事会成员的支持 领导风格有所变化：以行动为导向 领导风格缺乏变化 婴儿期较短 婴儿期过长 短期融资用于短期投资项目 短期融资用于长期投资项目 善意的独断 独断 学步期：疯狂年代 what ：企业运转起来，现金流也不错，销售提高了，也生存下来了，而且还呈现出兴旺发达的迹象。 how ：学步期的企业就像刚学会走路的孩子，对什么都感兴趣，他们看到的只有机会，而从来看不到问题。 企业被动的销售导向：婴儿期还是以产品为导向，到了学步期就会转向市场，但这还只是一种销售导向，并不是营销导向的。 营销，是决定以什么样的价格销售什么样的产品，是通过哪些渠道来分销，还要详细说明如何促进分销；市场营销起的作用是计划和定位，它不但决定要做什么，还要决定不做什么。 创业者陷阱 青春期：再生与成熟盛年期老化的迹象贵族期：老化中的企业撒冷期、官僚期和死亡期]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Github搭建个人博客]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FHexo%2FHexo%2BGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[Hexo+Github搭建个人博客 前段时间本人利用业余时间，在网上查询各种资料，使用Hexo+Github的方式搭建起了我个人的博客——BrightLoong。相信网上已经有无数前辈写了类似的文章来记录如何搭建博客的过程和步骤，我也不哗众取宠或者班门弄斧了，把我在搭建博客中使用 资料做一个收集，同时也将我在搭建博客过程中遇到的坑列举出来，以及对应的解决方法，也是对搭建博客过程的一个记录，毕竟好记性不如烂笔头。那话不多说，接下来就是一个简单的介绍以及如何搭建的步骤(本文基本也是安照官方的步骤在介绍，我只是在有些地方记了下自己踩过的坑，强烈建议大家跟着Hexo官方文档操作)。 本文适用于Windows搭建 什么是Hexo 在Hexo官网上如此描述：Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.（Hexo是一个快速，简单和强大的博客框架。你可以使用Markdown（或其他语言）写博客，之后Hexo能在几秒钟生成具有美观主题的静态文件。）如果你想了解更多关于Hexo的东西，请移步Hexo官网。 Hexo是一款基于Node.js的静态博客框架，可以deploy到Github上，所以首先要在电脑上安装git和node.js,并在Github上注册自己的账号，由于这些东西不是本篇博客要涉及到的主要内容，你可以谷歌、百度，也可以参考我下面提供的链接。 Git安装 你可以去官网下载Git，因为国外资源可能很慢，你也可以下载我在网盘上提供的Git镜像。具体如何使用，请参照廖雪峰老师关于Git的教程，如果你仅仅是想安装git那看看Git安装的那个章节 Node.js安装配置 关于Node.js的安装以及配置，可以参照菜鸟教程上面关于Node.js安装配置的教程，上面也有下载的链接，本人就是参照上面安装的。具网上有些文章说，安装完成后最好重启电脑，以免之后无法使用hexo的相关命令，我倒是没有遇到，不过如果大家遇到这种问题就重启吧。 Hexo安装 必须要在你安装了上述的Git以及Node.js之后才能进行Hexo的安装。 1. 用以下命令安装Hexo 在任意地方点击右键，选择Git Bash Here 1$ npm install -g hexo-cli 如果安装过程中遇到一下错误： 1ERROR Deployer not found : github 运行 1$ npm install hexo-deployer-git --save 2. 创建博客存放目录，并进行初始化，安装依赖包（最好不要使用带中文的路径，以免后面出现不必要的麻烦） 打开一个目录，在这个地方点击右键选择Git Bash Here,执行以下命令 123$ hexo init &lt;folder&gt; #创建目录并执行初始化$ cd &lt;folder&gt;$ npm install #安装依赖包 &lt;folder&gt;改为你想要的目录。 当然你也可以自己新建一个目录，比如我在F盘中创建了myblog目录，进入目录中点击右键选择Git Bash Here，直接执行以下命令 12$ hexo init $ npm install 不管你用哪种方式，执行完毕后你会发现以下目录结构 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 3. 启动服务 执行以下命令来启动服务 12$hexo g #hexo generate，生成静态文件$ hexo s #hexo server，启动本地服务器 如果启动过程中没有报错，此时你用浏览器访问http://localhost:4000/，是不是看到了一个Hello World的博客页面，hexo3.0使用的默认主题是landscape（之后我会讲如何更换主题，以及集成第三方的工具），而且此时的服务是本地启动的，别人并不能看到（继续我接下来的操作就好了）。 这个时候如果在浏览器没看到漂亮的博客页面怎么办，别急，先确认你在启动过程中是不是报错了，如过有的话估计是上面的操作有误，如果没有并且发现页面一直在加载中，估计是端口被占用了，我就遇到了这个问题。怎么办?把4000端口给杀死，还有更简单的——在hexo s命令后面加上启动参数，修改默认端口：hexo s -p &lt;port&gt;，比如我用的 hexo s -p 8000，现在重新访问http://localhost:8000/记得把地址的8000改成你自己对应的端口号，是不是看到了美丽的界面。 4. 注册Github账号，并创建仓库。 想要别人也访问到你的页面，跟着继续吧。首先在Github官网上注册一个账号，有账号的跳过注册，直接登录。登录后找到new repository按钮创建一个新的仓库。 然后填写repository name就行了，要注意的是：这个名字的格式必须为youname.github.io，并且必须和你的账户名相同，比如我的账户名是BrightLoong，我的地址就是brightloong.github.io（最开始我就是将name随意填写，虽然是这个格式但是根本访问不了，会报404的错误）。 5. 将本地文件推送到github 最后，剩下的就是将本地文件推送到github上了，首先打开站点配置文件_config.yml，比如我的路径是：F:\myblog_bonfig.yml。找到最后的deploy属性，如果没有就自己添加，将配置修改为： 1234deploy: type: git #推送方式 repository: https://github.com/BrightLoong/BrightLoong.github.io.git #你的推送地址 branch: master #你要推送的分支 这个地方要注意的是属性后面的冒号必须要有一个空格，否则会报错 配置好之后使用以下命令将服务部署到github上。 123$ hexo clean$ hexo g$ hexo d 使用hexo d命令，第一次会要求你输入用户名和密码，用户名和密码就是你注册github时候使用的用户名和密码。如果遇到以下错误： 1ERROR Deployer not found : github 运行 1$ npm install hexo-deployer-git --save 再执行上面的命令。 1$ npm install hexo-deployer-git --save 如果你没有配置Github的SSH，那么可能需要配置一下，你可以用以下命令查看一下 1ssh -T git@github.com 如果成功会有以下提示（我的账户名叫BrightLoong） 1Hi BrightLoong! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 如果没有，可以参考博客git添加ssh-key查看config。 如果没有报错误，那么博客就已经搭建起来，并发布到Github上了，在浏览器输入youname.github.io就能看到自己的博客了，如果中途报错说未识别的用户名，那么如果你确定你填写是正确的，重复使用hexo d命令，我当时就遇到过这种情况，我估计是网络不好引起的。 配置&amp;主题发布新的博客 既然博客已经搭建好了，那么不发几篇博文有就没有意义了，使用下面的命令来新建一篇叫做”brightloong”的文章。 1hexo new &apos;brightloong&apos; 命令执行之后，你会在你文件博客根目录的source/_post目录下找到你刚刚新建的md后缀的文件，比如我的是F:\myblog\source_posts\brightloong.md，hexo博客是使用markdown语法来书写的，如果不熟悉markdown语法可以快速的看一下markdown语法说明，或者是认识与入门Markdown,后者也有推荐一些不同平台下使用的编辑Markdown的工具，本人使用的是Cmd Markdown，它既支持在线的编辑，也可以下载下来使用。生成的md文件打开如下： 注意：在冒号后面一定要加上一个空格，否则在生成静态文件的时候会报错，并且也不能将其成功推送到github。 123456---title: brightloong #文章标题date: 2017-02-24 12:03:12 #创建时间tags: #文章标签，如果有多个标签可以使用[1,2,3]的形式，还有其他形式自己摸索吧---#这之后是正文 文章编写好之后，只用以下命令生成静态文件并推送到github上，执行完成后打开自己的博客页面，是不是发现刚刚编写的文章出现了；如果你想删除某一篇文章，那么在source/_post目录下找到对应的文章将其删除后，同样执行一下命令就OK了。 1234567hexo ghexo s # 在本地预览hexo cleanhexo ghexo d 站点配置文件_config.yml 站点配置文件_config.yml是在你博客保存目录的根目录下，注意将它与主题配置文件进行区分，比如我保存的博客目录为F:\myblog那么我站点配置文件为F:\myblog_config.yml，我使用的主题是Next主题，所以我的主题配置文件为F:\myblog\themes\next_config.yml。下面我先介绍下站点配置文件，我将一些主要的配置做了注释，如果你想了解更多的配置的含义和作用，请访问Hexo官方教程查看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: BrightLoong&apos;s Blog #博客的标题subtitle: #子标题description: Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable. #博客描述，可以是一段你喜欢的话，也可以是你博客的描述，只要你开心就好。author: BrightLoong #作者language: zh-Hans #语言（我使用的是简体中文）timezone: #时区（默认使用电脑时间）##之下的保持默认就好，没有什么需要更改的# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; #and root as &apos;/child/&apos;url: https://brightloong.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: source #source目录public_dir: publictag_dir: tags #标签目录archive_dir: archives category_dir: categories #分类目录code_dir: downloads/codei18n_dir: :langskip_render: static/** #注意这个属性（跳过渲染），你暂时不用配置，我之后会讲到，这个也是我遇到的坑##之下的保持默认就好，没有什么需要更改的# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #你设置的主题，接下来我会说到这个# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/BrightLoong/BrightLoong.github.io.git branch: master 主题更换 搭建自己的博客，最吸引人的莫过于那千变万化的主题了，大家可以在Hexo官网上看到无数漂亮、大方、简洁的主题。本人使用的是简洁的Next主题，你可以选择你喜欢的下载下来，将其解压放入themes目录中，比如我的目录是F:\myblog\themes，然后修改我在上面提到的站点配置文件中的theme属性，为你刚刚放入themes目录中文件的名字（最好是对解压文件修改一个名字，否则名字可能会比较长，我把我下载下来的主题改文了next）,做完这些之后并不代表你完成了，你还需要参考你所下载的主题所说的配置步骤进行相关的配置，由于不同的主题配置过程也尽不相同，大家根据自己下载的主题去配置，我在这里只说我使用的Next主题如何配置。 1theme: next 注意：从下面开始所说的都是Next主题的相关配置。 配置Next主题 如果你使用的和我一样，也是Next的主题，那么你最好还是看官方提供Next使用文档，并且文档是中文版的,我也仅仅是讲一些容易被忽略的配置，以及我使用的配置，以及在使用过程中遇到的问题;至于如何更换头像，添加分类和标签页面、切换主题样式（Next主题包含3中样式）之类的，大家还是照着官方的做更好。 1. 配置网站图标 如何让网站前能显示自己想要的图标，我当时也是找了很久，最后发现是在主题配置文件（我的是F:\myblog\themes\next_config.yml）的最前面，有一个favicon属性，我把一个名字叫favicon.ico的图片（通过在线生成ico的网站）放到了F:\myblog\source下，然后配置如下： 1favicon: /favicon.ico 2. 首页显示阅读全文按钮 首页的文章是不是默认展开了，显示出了整篇文章，怎么才能显示出如下的阅读全文的按钮。在主题配置文件中找到auto_excerpt属性进行配置 123auto_excerpt: enable: true #改写为true length: 150 #默认展示的高度 你也可以在自己的博文中添加来决定在首页展示到什么位置（我就喜欢用这种方式），这个标签后的内容就不会展示到首页啦。 3. 集成多说评论 登录多说，登录后在首页选择“我要安装”。创建站点，填写表单。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图： 创建站点完成后在 站点配置文件(我的是F:\myblog_config.yml) 中新增 duoshuo_shortname 字段，值设置成上一步红框中的值。 注意：新增字段的时候一定不要让字段前面有空格，否则会被认为是子字段，无法正确解析 12#多说评论duoshuo_shortname: brightloong #设置为红框中的值 多说评论中可以开启热评文章，在站点配置文件中增加字段： 1duoshuo_hotartical: true 开启后你可能会发现点击热评文章并不能跳转到对应的网页，进入多说后台查看，发现原来网址不正确，那简单，点击编辑修改成正确的网址就OK了。 4. 阅读次数统计 次数统计又leancloud提供，请参考由由Doublemine 贡献提供的为Next主题添加阅读次数统计功能 5. 集成百度分享 分享功能的集成是最坑的没有之一，我大概花了半天多的时间查找各种方法才将其解决，这里我先说官网的配置：编辑 站点配置文件，添加字段 baidushare，值为 true。 1baidushare: true #百度分享功能 欢欢喜喜的打开自己的博客。咦！百度分享功能咋没有添加上啊。不急，听我慢道来。我在主题文件中发现一个文件F:\myblog\themes\next\layout_partials\share\baidushare.swing，内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123;% if theme.baidushare.type === &quot;button&quot; %&#125; &lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_sqq&quot; data-cmd=&quot;sqq&quot; title=&quot;分享到QQ好友&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot; title=&quot;分享到微信&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tieba&quot; data-cmd=&quot;tieba&quot; title=&quot;分享到百度贴吧&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a class=&quot;bds_count&quot; data-cmd=&quot;count&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;2&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot; &#125;, &quot;share&quot;: &#123; &quot;bdSize&quot;: &quot;16&quot;, &quot;bdStyle&quot;: &quot;0&quot; &#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;tsina&quot;, &quot;douban&quot;, &quot;sqq&quot;, &quot;qzone&quot;, &quot;weixin&quot;, &quot;twi&quot;, &quot;fbook&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125; &#125; &lt;/script&gt;&#123;% elseif theme.baidushare.type === &quot;slide&quot; %&#125; &lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;1&quot;, &quot;bdMiniList&quot;: false, &quot;bdPic&quot;: &quot;&quot; &#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;tsina&quot;, &quot;douban&quot;, &quot;sqq&quot;, &quot;qzone&quot;, &quot;weixin&quot;, &quot;twi&quot;, &quot;fbook&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125;, &quot;slide&quot;: &#123; &quot;bdImg&quot;: &quot;5&quot;, &quot;bdPos&quot;: &quot;left&quot;, &quot;bdTop&quot;: &quot;100&quot; &#125; &#125; &lt;/script&gt;&#123;% endif %&#125;&lt;script&gt; with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||body).appendChild(createElement(&apos;script&apos;)).src=&apos;/static/api/js/share.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 注意到最开始的语句了吗if theme.baidushare.type === “button”，以及之后的else if theme.baidushare.type === “slide”什么意思，在theme下也就是主题配置文件中，baidushare字段下的type字段，我们打开主题配置文件(我的是F:\myblog\themes\next_config.yml)，这个配置是不是被注释掉了： 12baidushare: type: button #百度分享展示的方式button|slide 修改之后，再启动，发现还是没有（如果你是用的本地启动用local的方式访问可能会看到百度分享功能已经出现了），这个是后打开浏览器F12的调试功能，是不是发现控制台报错了，提示你从https中去访问http的资源是不行的。不知道大家有没有看到刚刚我们修改的主题配置文件中，在上面有一段注释： 123# Warning: Baidu Share does not support https.百度分享不支持httpsbaidushare: type: button 是的不支持https的方式，自己的域名是用https开头的（除非你自己购买了域名，如何购买更换域名请大家参考【Hexo+Github】域名和github绑定的问题）。并且，JiaThis等都不支持https，怎么办？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git常见问题与解决]]></title>
      <url>%2F2017%2F04%2F22%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FGit%2FGit%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[Git常见问题与解决 windows使用git时出现：warning: LF will be replaced by CRLF的解决办法遇到这两个错误，是因为Git的换行符检查功能。 core.safecrlfGit提供了一个换行符检查功能（core.safecrlf），可以在提交时检查文件是否混用了不同风格的换行符。这个功能的选项如下： false - 不做任何检查 warn - 在提交时检查并警告 true - 在提交时检查，如果发现混用则拒绝提交 建议使用最严格的 true 选项。 假如你正在Windows上写程序，又或者你正在和其他人合作，他们在Windows上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。这是因为Windows使用回车和换行两个字符来结束一行，而Mac和Linux只使用换行一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。 Git可以在你提交时自动地把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用core.autocrlf来打开此项功能，如果是在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF： 在Windows环境下使用git进行add的时候，会提示如下warning: “warning:LF will be replacee by CRLF”。 这是因为在Windows中的换行符为CRLF，而在Linux中的换行符为LF。在git创建的项目中换行符为LF，而执行git add时，系统会提示LF将被转换为CRLF。解决的办法很简单，禁止git的自动转换即可。 $ git config --global core.autocrlf false //禁用自动转换 然后再进行git操作即可。 如果项目已经创建，则需要先删除之前创建的.git 文件后添加上面的设置。 12$ rm -rf .git$ git config --global core.autocrlf false 完成后再重新执行git操作 123$ git init$ git add .$ git remote add *** P.S. CRLF : Carriage-Return Line-Feed 回车换行。即回车(CR,ASCII 13, \r)换行(LF, ASCII 10, \n). 在windows中使用回车换行标识一行的结束，而Linux中则只有换行符。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据分析工作梯度与团队建设]]></title>
      <url>%2F2017%2F04%2F21%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_%E5%B7%A5%E4%BD%9C%E6%A2%AF%E5%BA%A6%E4%B8%8E%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE%2F</url>
      <content type="text"><![CDATA[数据分析工作梯度与团队建设； why ：建立整体、全局的概念，目的是了解当前的自己处在什么阶段，并由此得出应该努力的方向。 数据分析工作的各个梯度1​ From 知乎 《数据分析团队如何给自己找活干?》 何明科 改变一个人的习惯是很难的，而改变认知比改变习惯更要难上一个或几个数量级。因此可以把我想做的事情分为如下几类，从易到难。 初做咨询的时候，有一个项目是帮助某国际手机品牌在中国做新渠道模式的试点及铺开。因为我们团队没有任何实操经验，一开始的过程就是帮人跑跑数据和写写报告，颇不受待见。后来因为搞出了一套周报自动生成器，才赢得客户团队的超级认可，顺利过关。 1. 满足缺失需求而不改变习惯，提升效率数据团队为业务团队提供的服务或者产品，完全没有改变业务团队的工作流，无非是补足其缺失的需求，让其查看数据、清理数据和分析数据大为简单方便，所以接受起来毫无难度。最重要的是，【对业务团队没有替代关系，同时也不指责业务团队之前做的不好。】 比如大公司往往因为业务众多而BI系统分散，这时候为团队一个整合的BI平台，绝对是加分项。 2. 改变工作流程，提升效率业务人员、运维人员、运营人员及产品人员平时会花费大量时间阅读数据、理解数据、建立假设、证明证伪假设和形成结论。数据工程师或者分析师完全可以在这些方面为业务方提供增值和提升其效率。 1. 找规律找异常观察数据趋势以及寻找异常，是非常重要的部分。 传统的做法：人脑形成经验，肉眼观察和肉脑判断；或者设定阈值，超过一定范围自动报警（常见于运维）；或者简单的四则运算判断，根据各种环比、同比或者平滑移动平均等等。 数据分析团队其实是应该可以利用傅里叶分析将周期性的变动和异动大部分区隔出来的，让这种分析和查找异常的过程升级，更精准的同时也提升效率。 2. 做分类提方案业务团队时常需要针对业务情况做各种分类，然后对症下药提供解决方案。这在销售团队里尤其常见，尤其是互联网公司的销售业务，每个城市的产出是销售业绩，有各种中间的过程变量：销售数量、销售人效、销售出勤率及成单率、销售流失率、当地流量（UV）数量、流量（UV）质量、商户续费率、新增商户数等等。 传统操作中，都是依靠运营人员或者BI人员根据人肉经验或者常用而简单的分析框架，对各城市的销售情况进行分类，找问题出方案。 数据分析人员完全可以利用更高阶的机器学习，针对业务情况进行更多维度和更实时的分类，然后将业务情况与方案进行匹配。 以上方案存在如下优势：高维会创造更精细的分类，有可能捕捉到以前被忽略的业务问题；高频（机器的高效率按天分析数据）会创造更实时的反馈 3. AI写报告BI部门每月或者每周都要撰写报告发给管理层阅读，这个工作完全是可以开发一套AI系统来自动完成的。 以上想法都是在【略微改变业务人员工作流程的情况下，为其带来更高效和更精准的结果，可以说是给业务人员赋能，简化其重复性劳东】，帮助其成功。但一方面因为稍微替代了其人脑的价值，招当事人反感；另一方面在初期的磨合过程中，机器肯定有不少犯错的机会招人类嫌弃，所以初期的磨合阶段可能会略有阻力。 3. 提供新思路，看到新世界数据分析人员还可以利用新技术、新算法或者新数据，帮助业务方找到剖析问题的新角度并证明其行之有效，也会对业务部门大有帮助，只不过因为其需要改变传统的思维习惯，更需要普及教育甚至是耐心。 ​ ——2017.04.21 数据分析工作的各个梯度2​ From 知乎 《数据分析团队如何给自己找活干?》 孙文亮 临时需求临时需求是了解业务，收集反馈，优化数据产品的最佳途径。 初始阶段，处理各部门踢过来的临时需求，并以各种形式的报表反馈回去。 效率提升期，通过数据分析库的建设、自动化及半自动化开发，提升数据获取效率；通过站会+看板方式加强协作，提升全流程效率。关键指标是响应速度，如90%临时需求在24小时内完成。 稳定期，临时需求量短期随业务波动，长期稳定。开始出现主动型临时需求，即数据组主动提出的临时需求。 衰减期，随数据自动化程度变高，业务逐渐稳定，商业模式逐渐清晰，临时需求开始衰减，但永远不会消失。 报表自动化 架构阶段；搭建自动化报表的基本框架，包括数据字典、数据管道、Email、Dashboard、数据中间层等基础建设。 报表增长期，针对周期性查看的报表建立自动化展示。此阶段主要看报表覆盖率，一般来说不同的职能不同业务方向，都会有3-5支报表。报表数量也能反映此阶段的发展情况。 分析系统建设，针对分析型需求，往往是各个维度细分查看，每次查看的维度都有差异，不适合做自动报表，适合建模之后做成分析系统，业务组成员或分析师，可以通过不同维度不同变量的筛选来完成分析需求。 关键指标是分析系统访问量。 报表整合期。接入一切可能的数据源，例如：接入worktile数据可以看团队开发节奏、接入sonar数据可以监控代码质量、接入jira可以监控bug数据、接入内网知识库可以看知识沉淀速度和个人影响力、接入后台录入数据可以极大补充数据灵活性。 报表设计期。用产品思想重新设计报表，定义角色、场景、需求，精简报表内容；下线无用报表，迭代高频报表，将自动化报表平台当作创业项目来建设，持续提升人均访问量和访问频次。 数据建模 让事与事之间具有数据上的可比性。评估指标是模型覆盖度，我们的大致顺序为产品功能建模、产品迭代建模、运营日常工作建模、运营活动建模、内容发布建模、传播建模、技术迭代管理建模、技术代码质量建模、技术响应速度建模、技术稳定性建模。 投入、产出关联。建立成本意识，在评估效果之外还需要评估成本。 工作与核心指标关联。要从商业模式的核心指标，逐渐分解到各个工作中去。针对工作中为核心指标贡献的项目，建立从局部指标到核心指标的关联关系，确定相关度，可大致评估贡献度，并让工作价值可评估。 分析报告 初始阶段，定义分析报告类型、格式，定义什么才叫Insight，通过反复迭代打磨，做出第一份理想的分析报告。 稳定产出期，分析师可持续产出分析报告，并且分析报告被业务组频繁引用。 数据探索期，主动发掘数据价值，为业务中遇到的Why和How的问题提供数据支持、建议。 数字建模 预测问题建模；最早可以从自动化的数据监控切入，根据预测数据正常值设定异常区间。后续逐渐会用到各种回归模型，为管理计划的定义和分解、产品决策、渠道监控、技术预警等提供数学模型。 归因问题建模；针对影响核心数据的变量，找出相关度，计算权重系数。为各种开放式问题提供原因解答。 数据分析团队的搭建和思考​ From 知乎 《数据分析团队如何给自己找活干?》张溪梦 以前说到数据驱动业务增长，我们第一个想到的可能是数据分析的方法。但就目前来看，数据驱动业务的增长已经成为一个不仅仅是分析方法和模型，而是包括了数据人才培养、数据架构的设计，甚至整个公司组织架构设计的企业治理问题。 数据分析团队发展的5个阶段我们途家网成立五年以来，整个数据团队的成长也是经历了五个阶段。 缺少专业的数据分析师 拥有专职的数据分析人员 成立了专门的BI团队； 更多的精力放在原始数据的收集、数据工具的优化上面。 业务井喷的阶段； 让每一个业务的负责方及时地看到自己的数据，会做一些数据可视化的工作 开始做一些自助式的分析； BI 团队负责制定标准的数据，让业务的人去自己去做分析。 BI 团队组成 务必能够保证用数据讲清楚每一个业务的状况 辅助公司做决策，用数据去告诉大家未来怎么样做更有效率，如何去达到公司最大的目标。 为了承担这两个责任，我们成立了四个团队。商业分析团队，BI报表团队，数据仓库团队和市场竞争分析团队。 商业分析团队 分析一些非固定的专项问题 负责一些分析工具的培训 首席分析师的培养 让一个熟悉业务的老员工转岗去做数据分析；或者说让一个熟悉技术，又懂业务的人去转岗，避免沟通上的低效。同时使用成熟的数据分析工具，避免在数据质量、以及重复性工作上浪费大量的时间精力。通过这样的方式，这个人会很快地把整个数据分析的框架搭建起来。最后你会发现，在公司成立四年到五年之后，这个人就是整个公司通过数据去驱动业务增长的灵魂。 业务和财务的互动 每周都会固定地去看一下，业务上的动作在财务报表上的表现。 为什么要做这件事情？因为通常来讲，从业务前端到最后财务数字的整个链条里，业务分析人员很难掌握财务收入的确认规则，财务人员又需要更多时间去学习掌握不停变化的业务逻辑。通过财务分析人员和业务分析人员深度的互补和互动，能够做到驱动一个企业尽快地盈利。至少这个过程会让我们知道，盈利的来源是什么，哪怕目前是亏损，你也能知道为什么是亏的，以及怎么能做到止损。 大胆假设，小心求证的分析思维 当业务人员来找分析师要一个数据的时候，负责任的数据分析师需要帮业务人员梳理分析的逻辑。 比如业务人员问你要一个APP订单变化的数据，但其实他想看的东西，或者应该看的东西，远不止这些。这时候再回过头去问他，你到底要干什么？这个时候你会发现，有可能是老板发现昨天的订单比前天的订单突然增长了50%，超出了他的预期，但是他又不知道为什么发生了这些增长。业务人员在做分析的时候，经常提出来的是一个点。但是对于一个数据分析师来说，你需要帮业务人员具体理这些分析的框架，最终找到数据变化的原因。 数据分析的几个步骤 定义问题；首先你想清楚，你在数据分析的时候你到底要分析什么题目？ 大胆假设；思考出现这个数据变化所有可能的原因。 小心求证；在小心求证完之后，才能得到比较客观的结论。 BI报表团队 将业务方常规需要查看的数据沉淀为 BI 报表 帮助业务人员实现可视化的自助式数据分析； 让业务人员能够通过一些拖拉拽的钻取操作，快速的看到问题的所在，找到问题的原因。 分析师自己沉淀一些主动分析的数据结果给大家看；传统的报表制作流程是，需求方把需求提出来，然后工程师来负责把报表做出来。但是我们会更强调商业分析师的主动性。 第一个主动性的要求是因为商业分析师在看过海量的数据之后需要产生自己的一些想法。从不同的维度上去分析数据，可能会对业务有额外的帮助。 第二个是因为，对于一个业务人员来讲，每天只看自己业务范围内的数据即可，但是跨业务之间的数据产生的价值大部分时候是被忽略的。所以商业分析师需要主动的去思考跨业务之间的逻辑，然后固化在报表上面，给业务人员提供更多的价值。 数据仓库团队在更大的公司，或者说在 BAT ，数据仓库应该是被放在技术部，而不是 BI 部门。我们把数据分析团队放在BI团队，因为这样能让分析师知道每一个指标，在数据库里是怎么被算出来的。数据的标准性和严谨性会有很大程度上的提升。 数据仓库的主要 4 个职能 负责整个原始数据的收集和清洗 负责数据报表的抽取；让数据仓库团队做一些数据指标的抽取工作，就可以让分析师直接去分析已经抽取过的统计表，大量地节省分析师在原始代码上的精力。 负责各个系统之间的数据规整；各个系统都会展示一些数据，但是每个系统展示的数据可能都不太一样。为了解决这个问题，我们会让数据仓库的工程师去做统一数据的输出，务必保证每一个人在每一个平台上看到的数据都是一致的。 负责一部分分析的职能 市场竞争分析团队整个企业内部的数据和企业外部的信息，才能组成一个企业数据完整的图谱，这样才能在一个完整的生态中找到企业增长之道。 经验与思考 六个经验 分析师一定要足够地了解业务。对于一个分析师来讲，商业敏感度是第一位的。 分析师一定要主动地梳理业务问题框架，而不是被动地接受业务方提上来的每一个小问题。 BI 报表团队要保证每个人都有数据可看，而且务必要通过一些可视化的手段提升业务人员阅读数据的效率，让他们能迅速地提取关键的信息。 在企业从小到大的过程中，推动一些自助式的分析，因为自助式的分析能够解决分析师的瓶颈问题。 善用工具。 数据分析视野问题，内部的数据一定要分析的非常透彻。但是每一个分析师的眼界不仅仅如此，更要有整个行业的宏观数据，这样才能找到企业的增长之道。 六个思考 我们对数据的要求是讲清楚业务，还是通过数据变现？ 我们对数据的要求又是什么？ 在什么阶段应该成立 BI 团队？ 数据分析师是不是有足够的权威？ 在特定的阶段，是研发一个工具，还是采买一个工具？ 这是一个效率提升的问题，要综合考虑公司目前的数据、人员等等情况。 业务方是否会主动看数据？ BI 团队会把数据梳理清楚，但是我们有没有做好日常的驱动工作，让每一个业务人员去看这些数据？ 集中式分析还是自助式分析？ 数据分析团队的组建团队成员 基础平台团队：主要负责搭建稳定、可靠的大数据存储和计算平台。 数据开发工程师：负责Hadoop、Spark、Hbase和Storm等系统的搭建、调优、维护和升级等工作，保证平台的稳定。 数据平台架构师：负责大数据底层平台整体架构设计、技术路线规划等工作，确保系统能支持业务不断发展过程中对数据存储和计算的高要求。 运维工程师 数据平台团队：负责数据的清洗、加工、分类和管理等工作，构建企业的数据中心，为上层数据应用提供可靠的数据。 数据开发工程师：负责数据清洗、加工、分类等开发工作，并能响应数据分析师对数据提取的需求。 数据挖掘工程师：负责从数据中挖掘出有价值的数据，把这些数据录入到数据中心，为各类应用提供高质量、有深度的数据。 数据仓库架构师：负责数据仓库整体架构设计和数据业务规划工作。 数据分析团队：主要负责为改善产品体验设计和商业决策提供数据支持。 业务分析师：主要负责深入业务线，制定业务指标，反馈业务问题，为业务发展提供决策支持。 建模分析师：主要负责数据建模，基于业务规律和数据探索构建数据模型，提升数据利用效率和价值。 ​ 工作方式数据团队的工作可以分成两大部分: 建设数据存储和计算平台 基于数据平台提供数据产品和数据服务。 平台的建设者包括三种人群： 基础平台团队对hadoop、spark、storm等各类大数据技术都非常熟悉，负责搭建稳定、可靠的大数据存储和计算平台。 数据平台团队主要负责各类业务数据进行清洗、加工、分类以及挖掘分析，然后把数据有组织地存储到数据平台当中，形成公司的数据中心，需要团队具有强大的数据建模和数据管理能力。 数据产品经理团队主要是分析挖掘用户需求，构建数据产品为开发者、分析师和业务人员提供数据可视化展示。 平台的使用者也可以包括三种人群： 数据分析团队通过分析挖掘数据，为改善产品体验设计和商业决策提供数据支持。 运营、市场和管理层可以通过数据分析师获得有建设性的分析报告或结论，也可以直接访问数据产品获得他们感兴趣的数据，方便利用数据做决策。 数据应用团队利用数据平台团队提供的数据开展推荐、个性化广告等工作。 分析团队的组织架构在整个大数据平台体系中的团队：基础平台、数据平台、数据应用和数据产品经理团队都可以保持独立的运作，只有数据分析团队的组织架构争议比较大。数据分析团队一方面要对业务比较敏感，另一方面又需要与数据平台技术团队有深度融合，以便能获得他们感兴趣的数据以及在数据平台上尝试实验复杂建模的可能。 外包：公司自身不设立数据分析部门，将数据分析业务外包给第三方公司 分散式：每个产品部门独立成立数据分析团队，负责响应自己产品的数据需求，为业务发展提供决策支持。 优势：数据分析团队与开发团队、设计团队以及策划团队具有共同的目标，团队整体归属感强，绩效考核与产品发展直接挂钩，有利于业务的发展。 劣势：在业务规模比较小的情况下，数据分析师比较少，交流的空间也比较小。因为身边的同事都不是该领域的人才，无法进行学习交流，所以成长空间会比较小，分析师的流失也会比较严重，最终陷入招募新人——成长受限——离职——招募新人的恶性循环。另一方面，每个产品团队都零星地招募几个分析师，整体来看给员工的感觉是公司并不是特别重视数据化运营的文化，对数据的认同感会被削弱，不利于公司建立数据分析平台体系。 集中式：数据分析团队与产品团队、运营团队各自独立，团队的负责人具有直接向分管数据的副总裁或CEO直接汇报的权限，团队负责响应各业务部门的数据需求。 优势：分析团队具有充分的自主权，可以专心建设好公司级别的数据平台体系，研究数据最具有价值的那些问题，有权平衡业务短期需求和平台长期需求直接的关系。另一方面，这种自上而下建立起来组织架构，可以向全体员工传达数据在公司的重要位置，有利于建立数据化运营的文化。 劣势：产品业务团队会觉得他们对数据的掌控权比较弱，一些业务数据需求得不到快速响应，认为分析团队的反应太慢无法满足业务发展的需要。随着业务发展越来越大，产品团队会自己招募分析师来响应数据需求，逐渐替代分析团队的工作，这样势必会导致分析团队的工作被边缘化。 嵌入式：数据分析团队同样独立于产品团队存在，但只保留部分资深数据专家，负责招聘、培训数据分析师，然后把这些人派遣到各产品团队内部，来响应各类业务数据需求。 优势：团队的灵活性比较好，可以根据公司各业务线的发展情况合理调配人力资源，重点发展的项目投入优秀的人才，一些需要关闭的项目人才可以转移到其他项目中去。 劣势：分析师被嵌入到产品团队内部，受产品团队主管的领导，从而失去了自主权，导致沦落为二等公民。人事关系在公司数据分析团队中，却要被业务团队主管考核，但业务团队主管并不关心他们的职业发展，导致分析师的职业发展受到限制。 大数据的基本框架客户是大数据的来源也是大数据最终要服务的终点。在这套框架中，数据分析的基本框架向下延伸，最基础从Customers(用户)开始，也在用户结束。 大数据框架 统一的大数据平台 “现在最缺乏的，是统一的大数据采集平台”。大数据已布满在企业的各个地方各个角落，“我们现在最缺乏的，不是数据，是一个统一的数据采集平台(Data Collection)。在一个企业的大数据框架中，最重要的部分是大数据的原始数据采集层。这基本包括三个层次： 最外层是用户； 其次是公司运营中各种会产生数据的业务应用系统(如ERP、CRM、SCM、OA等各种企业应用软件)、网站、APP、社交网络、电商平台等 之上是各种数据的采集平台。 从ETL到ELT 在数据采集上来之后，接下来便要对海量的数据进行所谓的抽取、转换、加载，即ETL。 传统的数据分析认为，数据收集之后是ETL，但现在变成了ELT，未来有可能只有EL没有T，甚至到最后全部将EL结合到一起，不再有功能性的划分。 为什么会有这种变化呢？这主要是因为以前的存储、计算、传输成本都很高，数据处理要用时间来换取空间。因此，当时的重点技术是要将原来非结构化的数据进行结构化转化，把数据压缩变小、节约存储空间，从而形成所谓的ETL模式。但很显然，这种模式存在一个无法避免的问题，即ETL过程是需要花费很多时间的。互联网时代是快鱼吃慢鱼的时代，企业需要实时了解各种数据，需要实时进行响应。费时的ETL模式显然完全不能适应当前的时代潮流。 是先BI后分析，还是先分析后BI? 数据仓库之上，便到了我们经常所说的BI了。 BI其实包括两个层次，即Analysis(分析)和 BI，其中分析主要为对数据进行高维度分析，BI则主要提供数据透视和展现 在大数据时代，这两个层次也有一个巨大的变化。是先BI再分析，还是先分析再BI呢？ 以往的做法基本上是先BI，而后在其上进行Analysis(分析)。目前国内绝大部分企业就是这么做的。大部分企业把BI与数据仓库中存储的数据相结合，用于报表分析、报表制作等。更重要的是，这类工作一般交由IT部门负责，使得BI变成了技术性工作。因此，现在很多企业中有大量的IT研发人员在开发报表。这种做法带来了“先BI再分析”的最大问题，即用数据的人不是做数据的人，做数据的人不是用数据的人。现在的先进做法是，将BI与分析进行对调，即先分析再BI，并且分析工作要由熟悉业务的数据科学家来承担。 把数据仓库的数据和分析直接结合，通过相关的分析技术和工具，直接挑选出具有商业价值的数据，之后通过BI迅速将其商业价值扩大化。 “输出洞察、输出决策、输出价值” 在分析、BI之后，便到了如何将数据价值发挥出来的环节。张溪梦认为，这主要包括DM(数据挖掘)、AI(人工智能)、洞察、决策、行动、价值等几个阶段。 “底层频次高价值低，顶层频次低价值高” 从客户、业务系统、数据采集、数据仓库、分析、BI、DM、AI、洞察、决策、行为、价值，再最终回到客户 其他摘抄 数据看板并不是终点，而是新的一次的起点。 大多数情况下能把一个部门的各个细节弄清楚就已经很不容易了。对业务细节的了解是做出深层次分析的前提。 靠数据报表提高公司运营效率不太现实。实际上业务部门很清楚影响效率的问题，只是没有技术，手段，设备去解决。用图表展示他们早就知道的问题没有帮助。 大家讲大数据，数据是从数据标签的采集开始的，一般都由前端工程人员实施，然后数据传输的工作由IT来管理，ETL一般由企业内部的数据仓库或者数据平台的团队负责，BI（商业智能）部门在分析部或者存在于业务部门之中，然后我们还有各种商业分析师，统计学家参与其中，这个运行框架体系因为各个部门参与的人非常多，流程很长]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进制与转换]]></title>
      <url>%2F2017%2F04%2F18%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F16%E8%BF%9B%E5%88%B6%2F</url>
      <content type="text"><![CDATA[描述了各个进制之间的关系； 十六进制 what：计算机中数据的一种表示方法。它由0-9，A-F组成，字母不区分大小写。0-9对应0-9；A-F对应10-15 how ：逢16进1。 采用位置计数法，位权是16为底的幂。 十六进制数的第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方 转换 10进制数 $\to$ 16进制数 十进制数的整数部分“除以16取余” 十进制数的小数部分“乘16取整” 1234567816进制的20表示成10进制就是：2×16¹+0×16º=32采余数定理分解，例如将487710转成十六进制：4877÷16=304....13(D)304÷16=19....019÷16=1....31÷16=0....1这样就计到487710=130D16 颜色 $\to$ 16进制 12345rgb(255,210,200) 方式为 井号（#）加上具体的数值（从左到右开始转换）#FFD2C8 (255/16 = ...15.9 # 小数取整，余数为15)，记为F (15/16 = ...15 )记为F]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL server_高级查询]]></title>
      <url>%2F2017%2F04%2F17%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FSQL-Server%2FSQL-server_%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[SQLserver高级查询 批处理 what ：同时从应用程序发送到 SQL Server 并得以执行的一组单条或多条 Transact-SQL 语句；SQL Server 将批处理的语句编译为单个可执行单元，称为执行计划。执行计划中的语句每次执行一条。 how ： 在遇到运行时错误的语句之前执行的语句不受影响。 唯一例外的情况是批处理位于事务中并且错误导致事务回滚。在这种情况下，所有在运行时错误之前执行的未提交数据修改都将回滚。 批处理终止批处理分隔关键字是GO。批处理关键字必须是这一行的唯一关键字； 关键字GO之后可添加一个注释 切换数据库：把USE命令插入到批处理中 GO(Transact-SQL) what ：向 SQL Server 实用工具发出一批 Transact-SQL 语句结束的信号 how ：当前批语句由上一 GO 命令后输入的所有语句组成，如果是第一条 GO 命令，则由即席会话或脚本开始后输入的所有语句组成。 GO 命令和 Transact-SQL 语句不能在同一行中。但在 GO 命令行中可包含注释 12&gt; # GO [count] ; # count 一个正整数，GO 之前的批处理将执行指定的次数&gt; 语句终止：在每个命令的末尾放置一个分号（；） 在CTE前面必须要放一个分号（当CTE不是批处理的第一条语句时） 不要把分号放在If 或者 While 条件之后 不要把分号缝在 End Try 之后 语句终止符必须跟在Meger之后 ​ 声明：DECLARE DECLARE；制定某个变量为特定的数据类型，并可指定具体内容； Declare变量跟 变量名 和 数据类型，并用分号结尾； 单个Declare 声明中用逗号隔开多个变量 变量赋值用分号隔开； 变量是在批处理或过程的主体中用 DECLARE 语句声明的，并用 SET 或 SELECT 语句赋值。 游标变量可使用此语句声明，并可用于其他与游标相关的语句。 除非在声明中提供值，否则声明之后所有变量将初始化为 NULL 123Declare @test Int, @testtwo Varchar(20) ;Set @test = 1 ;Set @testtwo = &apos;a value&apos; ; 使用Set 和 Select 命令 Set 与 Select 对比 命令 描述 Set 限制在从表达式中检索数据； 一次只能设置一个变量 Select 可从数据源中检所数据，还可包括其他Select子句(From、Where等）；可使用函数 一次课设置多个变量 Set命令可以使用访问数据源的标量子查询（一个变量） 如果你希望在确保没有行的情况下将变量设置为NULL，以及在不止一行的情况下获得一个错误，这是最佳做法； 【Select 命令在检索多行时，只会将最后一行的值存储在变量中】 123456789101112Use adventureworks2012GODeclare @productID Int, @producename varchar(25);Set @productID = 782; --声明一个变量Select @productID = productID, -- 声明多个变量； @productname = @productID + name --声明变量可叠加使用 From production.product Order by productID; Select 声明，即将 @var = value 作为一个整体，当做Select查询中的列去看待即可 声明变量可叠加使用 如果Select语句没有返回行，Select语句不会影响变量 12345678910GODeclare @productID Int, @producename varchar(25);Set @productID = 999;Select @productID = productID, -- 声明多个变量； @productname = @productID + name --声明变量可叠加使用 From production.product Where productID = 1000; -- 由于ProductID 没有1000，故ProductID仍未NULL 声明示例 12345678910111213141516171819202122232425262728293031323334353637383940# DECLARE @local_var data_type [= value] # 直接声明declare @mycounter int;DECLARE @find varchar(30) = &apos;Man%&apos;; # 使用名为 @find 的局部变量检索所有姓氏以 Man 开头的联系人信息 --Select ... WHERE LastName LIKE @find; # 使用select声明DECLARE @var1 varchar(30) SELECT @var1 = (SELECT Name FROM Sales.Store WHERE CustomerID = 1000) # 用声明并赋值过的变量构建一个Select语句并查询Select lastname,firstname,title From employees where firstname= @firstnamevariable or region=@regionvariable# 声明日期，并应用DECLARE @起始日期 date set @起始日期 = dateadd(dd,-3,getdate())Select top 100 * From [exchange].[YTX].[v_allcj] where 结算日期 = @起始日期------------------------------------------------# 声明多个变量declare @last_name varchar(30),@fname varchar(20);DECLARE @起始日期 datatime, @截止日期 datatimeset @起始日期 = &apos;2017-03-07&apos;;set @截止日期 = &apos;2017-03-07&apos;;# 给多个变量赋值declare @firstnamevariable varchar(20), @regionvariable varchar(30)set @firstnamevariable=&apos;anne&apos;set @regionvariable =&apos;wa&apos;------------------------------------------------------------全局变量select @@version --返回数据库版本select @@error --返回最后的一次脚本错误select @@identity --返回最后的一个自动增长列的id 过程流 使用条件T-SQL的If命令 一个if，一个命令的执行；并且没有Then和End来终止if命令； 123456789101112131415161718If condition Statement;If 1=0Print &apos;Line one&apos;;Print &apos;Line two&apos;;--结果返回Line two；--if语句之后没有分号； if语句实际上是后面语句的提前；----------------------------------------------------------------------------------# 使用Begin / End 有条件地执行多条语句If condition Begin; Multipie Line; End; --每个都有分号 使用If Exists()作为基于存在性的条件 If Exists() 结构使用从SQL Select语句返回的每一行作为条件。 因为If Exists() 结构会查找每一行，所以Select语句应当选择所有的列。一旦一个单行满足了If Exists()，查询就会继续执行 12345If Exists (Select * From production.product Where quantity = 0) Begin; Print &apos;Relpenish Inventory&apos;; End; 使用If / Else 执行替换语句 可选的Else定义了if条件为False时的执行代码；Else可控制下一个单个命令，后者Begin/End块 1234If condition Single line or Begin/End block of code; Else Single line or Begin/End block of code; – 使用While循环 what ：当条件为ture时循环代码； 触发器 - trigger what：一种特殊类型的存储过程，对特定事件作出相应。一种隐式的存储过程 数据定义语言(DDL)触发器 DDL触发器在用户以某些方式(CREATE、ALTER、DROP或相似的语句)对数据库结构进行修改时激活作出响应。一般来说，只会在对数据库结构的改变或历史进行极为严格的审计时才会用到DDL触发器。 数据操纵语言(DML)触发器 附加在特定表或视图上的代码片段；与需要显式调用代码的存储过程不同，只要有附加触发器的时间在表中发生，触发器中的代码就会自动运行。实际上也不能显式地调用触发器 after触发器（之后触发） INSERT触发器、DELETE触发器、UPDATE触发器 instead of 触发器（之前触发） 有时即使执行的动作是前面这些类型中的一种，触发器也不会激活。问题在于进行的操作是否在记录的活动中。 例如，DELETE语句是一个正常的记录活动，它会激活任何删除触发器，而TRUNCATE TABLE也有删除行的作用，但只是把表使用的空间释放而已-没有记录单个行删除操作，所以没有激活任何触发器。批量操作默认情况下不激活触发器，需要显式告知批量操作激活触发器。 1234567--创建触发器CREATE TRIGGER &lt;trigger name&gt; ON [ &lt;schema name&gt;. ]&lt;table or view name&gt; [WITH ENCRYPTION | EXECUTE AS &lt;CALLER | SELF | &lt;user&gt; &gt; ] &#123;&#123;&#123; FOR | AFTER&#125; &lt; [DELETE][,][INSERT][,][UPDATE] &gt; &#125; | INSTEAD OF &#125;[WITH APPEND][NOT FOR REPLICATION] AS &lt; &lt;sql statements&gt; | EXTERNAL NAME &lt;assembly method specifier&gt; &gt; ON子句：对创建触发器所针对的对象进行命名。 如果触发器的类型是AFTER触发器(使用FOR或AFTER来声明触发器)，那么ON子句的目标就必须是一个表-AFTER触发器不支持视图。 WITH ENCRYPTION选项：加密触发器 如果添加了这个选项，则可以确保没有人能够查看你的代码(甚至是你自己) FOR|AFTER子句与INSTEAD OF子句 除了要确定激活触发器(INSERT、UPDATE、DELETE)的查询类型以外，还要对触发器的激活时间做出选择。虽然人们经常考虑使用FOR触发器，但是也可以使用INSTEAD OF触发器。对着两个触发器的选择将会影响到是在修改数据之前还是之后进入触发器。 ( FOR和AFTER的意义是一样的。) ​ FOR|AFTER：表明了期望触发器在何种动作类型下激活。当有INSERT、UPDATE或DELETE或三者混合操作时，都可以激活触发器。 1234&gt; &gt; FOR INSERT,DELETE --或者是: &gt; &gt; FOR UPDATE,INSERT --或者是: &gt; &gt; FOR DELETE&gt; &gt; &gt; INSERT触发器：当有人向表中插入新的一行时，被标记为FOR INSERT的触发器的代码就会执行。 对于插入的每一行来说，SQL Server会创建一个新行的副本并把该副本插入到一个特殊的表中，该表只在触发器的作用域内存在,该表被称为Inserted表。 DELETE触发器 ：它和INSERT触发器的工作方式相同，只是Inserted表示空的(毕竟是进行删除而非插入，所以对于Inserted表示没有记录)。 相反，每个被删除的记录的副本将会插入到另一个表中，该表称为Deleted表，和Inserted表类似，该表只存在于触发器激活的时间内。 UPDATE触发器 ：对表中现有的记录进行修改时，都会激活被声明FOR UPDATE的触发器的代码。 唯一的改变是没有UPDATE表。SQL Server认为每一行删除了现有记录，并插入了全新的记录。声明为FOR UPDATE的触发器并不是只包含一个表，而是两个特殊的表，称为Inserted表和Deleted表。 ​ WITH APPEND选项：到它的可能性很小；WITH APPEND选项只能应用于6.5兼容模式中。 一旦创建了更新(或插入、删除)触发器，那么就不能创建另一个同一动作类型的触发器。为解决这个问题，WITH APPEND子句显式地告诉SQL Server，即使在表上已经有了这种类型的触发器，还可以添加一个新的触发器。当有合适的触发动作(INSERT、UPDATE、DELETE)发生时，会同时激活两个触发器。 NOT FOR REPLICATION选项 如果添加了该选项，会稍微地改变关于何时激活触发器的规则。在适当的位置使用这个选项，无论与复制相关的任务何时修改表，都不会激活触发器。通常，当修改了原始表，并且不会再进行修改的时候会激活触发器(进行内务处理或级联等操作)。 AS子句：AS关键字告诉SQL Server，代码将要启动。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《未来简史》读书笔记_尤瓦尔.赫拉丽]]></title>
      <url>%2F2017%2F04%2F16%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F10_%E5%8F%91%E5%B1%95%E5%8F%B2%2F%E3%80%8A%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%E3%80%8B_%E5%B0%A4%E7%93%A6%E5%B0%94.%E8%B5%AB%E6%8B%89%E4%B8%BD%2F%E3%80%8A%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E5%B0%A4%E7%93%A6%E5%B0%94.%E8%B5%AB%E6%8B%89%E4%B8%BD%2F</url>
      <content type="text"><![CDATA[《未来简史》_ [以色列]尤瓦尔•赫拉丽 Yuval Noah Harari 序 人类的新议题回顾困扰人类的三大议题，在时间的长河中逐渐解决之后，引出新时代的三个议题； 原有的议题 原有的议题 当下的 “ 改变 “ 饥荒 夺走生命的数量：肥胖&gt; 饥饿和营养不良 瘟疫与传染病 ~流感、黑死病~ 非传染性疾病 ~癌症、心脏病~ 战争 新时代的议题 新的议题 描述 战胜死亡 变化：由过去的神学问题 $\to$ 技术问题 追求幸福 两大方面：生理层面、心理层面（主观条件） 人成为神 三条路径：生物工程、半机械人工程、非有机生物工程 备注： 这里的人，并不指个人的人，而是“人类整体” 这仅仅是一项预测 追求，但不一定能够实现 死亡：原先认为死亡是无法避免的；但现在已经认识它只是部分机能的失效；如果我们能够更换细胞（更换心脏）、或者通过科技方法（基本、纳米技术、再生组织与器官）来进行机能的重塑，就可能延长甚至重新定义生命； 生命的延长会产生巨大的变化：婚姻、职业生涯 快乐：快乐与否取决于你的预期，而非客观条件；但随着客观条件的改善，预期也会不断膨胀；现在能让你感到快乐的事情，下一次发生的时候可能就不会如此 ； 快乐是主观的，是短暂的；获得快乐时，我们的反应不是满足，而是想得到更多； 19世纪和20世纪，国家虽然打造了一系列利于个人的系统，但它们最开始的出发点是为了国家强大，而不是确保个人福利； 成立学校 $\to$ 培养温顺而有技能的国民，为国家服务* 卫生系统 $\to$ 国家需要强大的士兵和工人 福利制度 $\to$ 最初开办养老金制度，主要目标是确保国民忠诚；你18岁的时候为国家打仗，在40岁愿意纳税，那是因为希望到70岁的时候可以得到国家的照顾； 【很多人追寻事业单位&amp;国有企业，出发点也是这样】 人成为神： 生物工程：基因、神经元、大脑回路 半机械人工程：让人体与各种非有机的机械装置（仿生手、义肢，或是将纳米机器人注入我们的血管，让它们负责修补） 例证：瘫痪的病人能够仅靠意念就移动仿生肢体或操作计算机 非有机生物工程：智能软件替代神经网络，无机生命替代有机生命 一旦走上这条路，将没有刹车；因为人类只要一有重大突破，就不可能只局限于它最初的目的； 其他知识 对于草坪的认知：富人的场所往往会有一片草坪，越大说明越富有； 【每个现象的背后一定会有它的原因】 因为贫穷的农民绝对不可能把土地与时间浪费在草坪上；于是，城堡入口的那一片草坪成了无法造假的身份的象征；之后，看到草坪，就会联想到权利、金钱和欲望 研究过去不是为了重复过去，而是为了从中获得解放 人们之所以害怕改变，是因为害怕未知。但历史唯一不变的事实，就是一切都会改变。 一、智人征服世界了解智人是一种怎样的生物。 人类与其他动物有何不同？ 人类如何征服世界？ 智人真的是比较高级的生命形式？还是仅仅只是欺负其他物种的生物而已？ 人类对待其他动物（世界）智人对地球的影响 人类灭绝和主宰了其他动物，征服了世界。 智人突破了地球上各个生态区之间的阻碍。在人类世，地球上各个区域之间是联系在一起的，地球有史以来第一次成为一个单一的生态系统。因为在智人以前，各个生态系统之间是彼此独立的； 智人开始突破自然选择的边界；几亿年来，生物的进化无论怎么变化都是在有机领域；而智人正准备将生命形式从有机领域延伸到无机领域。 生物也是一种算法 引出一个非常重要的核心观点：生物也是一种算法。 人和其他动物一样，都是一套以繁衍为目的的生物算法。只不过人类的算法，则是通过感觉、情感和思想来运作。 理念的转变（对待其他动物） 狩猎采集：平等地对待其他生物；人能否存活，有赖于理解和尊重周围动物的欲望； 农业社会：把动物从有感情、值得尊重的生命体降格为人类的资产；人类以自身需求驯养动物，无视动物的情感需求；研究表明，动物（尤其是母子之间）是有感情需求的。 进而把不同等级的人也视为资产；比如，出现过把人当做奴隶，随意处决； 农业社会产生了有神论者；有神论承认了人类的主导地位，可以剥削其他生物。比如基督教； 人类赋予诸神以神格，但同时也将人神格化了。 表面上，神创造了人类；但是，神要负责在人类和生态之间进行调节；但只有人才能与神交谈；（隐藏着说明，人类世高于其他生物的物种。） 现代社会：把人视为高于其他物种的存在；人文主义奠基了智人拥有某种独特而神圣的任性，动物则没有，而自然也不再重要； 人类的特质人有灵魂人有心灵作者并没有直接给出人类是否有心灵的答案；因为我们无法解释心灵； 人类的一切行为或感受都发生在神经网络中（当人有不同的情绪时，大脑不同区域的神经元有不同的反映） 如果一切都发生在神经网络中，那何必把心灵独立出来？ 如果心灵高于神经网络，那它又在哪里？ “他心问题” - “图灵测试”：但即使通过了测试，也并不能说明什么。 【这只是一个知识补充，并不是主要的核心观点】 ​ what ：图灵测试认为，想判断一台计算机有没有心灵，做法是安排测试者同时与真人和一个计算机沟通，而测试者不知道哪个是计算机哪个是人；最后让测试者对它们的身份进行判断；如果无法判断或打错，就认定它具有心灵； 图灵从自己的个人经验得出：你是谁并不重要，重要的是别人对你的看法了； 人有意义之网 动物只能想象实际存在的东西，而人类可以想象虚拟的东西，想象主体间的东西，比如国家、组织、法律。 只有智人才能够大规模且灵活的合作；并且，人类可以通过虚构的故事组织大规模的协作，这是人类的力量被放大、主宰世界的根本原因； 所有的大规模合作，都是基于我们想象的秩序； 想要破解未来，必须破解出种种赋予世界的虚拟构想； 客观现实、主观现实之外的第三种现实：互为主体的显示；互为主体的现实，并不是因为个人的信念或感受而存在，而是依靠很多人的沟通互动而存在的。这是个体集聚引发的群体效应；金钱原本是没有客观价值的 当大家一起编织出共同故事网的那一刻，意义就产生了。 那些诸神，都是我们虚构的；在斋戒日禁食，清明节扫墓，这些日期原本就是一个再正常不过的日子，只不过当我们一起编程的时候，意义就产生了。 智人统治世界，只因为只有智人能编织出互为主体的意义之网：其中的法律、约束力、实体和地点都只存在于他们共同的想象之后。 二、智人为世界赋予意义人类创造了怎样的世界？ 人类为何如此深信自己不但控制了世界，还能赋予世界意义？ 而人文主义（即对人类的崇拜）又是如何成为所有人最重要的宗教的？ 虚构的力量智人活在一个三重世界中： 客观世界（客观实体：河流、山川） 主观世界（内在的主观体验：恐惧、喜悦） 想象世界（金钱、神、国际、企业、品牌）； 品牌的价值，甚至高于客观实体的价值； 想象的虚拟实体 5000年前，人类发明了文字和金钱；文字：催生了强大的虚拟实体； 企业、组织，它们的力量在于能够将虚构的信仰建立在一个让人顺从的现实之上； 货币概念；整租制作一些本身并无价值的纸币，宣布它们是有价值的；强迫人们用这些纸张，人们别无选择 教育系统；那些优秀职位都是由成绩好的人抢下，所以它们宣扬考试是评估的最好方法 故事本应该只是工具，但却成为了目标 公司、组织和货币，都只存在于我们的想象之中，是人类发明了这些概念，好让它们为人类服务；但是，为什么最后反倒是人类为这些概念服务，甚至牺牲生命？ 要努力区分虚构和真实；我们一旦忘记了哪些是虚构的，就会开始跟现实渐行渐远 判断真实实体的标准：它是否会感觉到痛苦 未来会有更加强大的虚构概念 科学与宗教之争 虚构故事是人类社会的基础和支柱，随着历史的不断演进，关于神、国家、组织的故事越发强大，以致于开始主宰客观世界。 宗教 宗教不是超自然 宗教不是是否信仰“神”的问题 宗教是要巩固世界秩序； 宗教认为，人类受制于某种到的法则系统，这个系统并非由人所创造，也非人能改变 宗教是一套无所不包的故事，能够为人类的法律、规范和价值观赋予高于人类的合法性 科学与宗教 宗教并非只管伦理判断，它总是包含事实声明； 典型的宗教故事的三部分： 伦理判断：例如，“人命神圣” 事实声明：例如，“人命始于受孕那一刻” 两者相结合，得到具体的指示：例如，“就算受孕第一天，也不能堕胎” 对于宗教的伦理判断，科学无法反驳；但事实声明的部分，科学可以反驳； 宗教在乎的是“秩序”；目的是创造和维持社会结构； 科学在乎的是“力量”；目的是通过研究得到力量，以治疗疾病、生产食物； 现代历史其实是科学与特定宗教（人文主义）达成协议的过程，现代社会相信人文主义，而科学不是为了质疑，而是为了实现它的教义； 与“现代”的契约前现代人放弃了力量，相信了意义；例如，对当时的人来说，是否在战场上英勇战斗、是否早餐吃了禁忌的食物，都被赋予了重要的意义；如果发生什么可怕的事情（例如洪水、旱灾），我们会说这都是上天的旨意； 现代契约的本质：人类愿意放弃意义，换取力量。 现代生活就是在一个没有意义的宇宙里不断追求更多的力量。 现代社会对力量的追求： 人类原本的思维是资源是有限的，所有我不愿意将当下的资源拿来做研究与开发； 现代社会的理念基础是：经济不仅有可能增长，而且还是必要的。 直到现代社会，人们才开始相信未来，所以有了信贷这项奇迹；使得人们愿意将当下的资源拿出来做开发与研究，为的是换取未来更多的资源； 相信未来：这是经过几千年直到现在社会才出现的；因为，这一想法从根本上违反直觉、进化经验和世界运作的方式。 自然系统多半呈现平衡状态，而且生存之争大部分都是零和博弈，一方发展，另一方必然受到限制 自然界的万物相互制约，维持某种平衡； 例如，一片地区，如果狐狸多了，那被吃掉的兔子自然就少了，使得狐狸数量增加；但因为兔子数量的减少，使得部分狐狸会找不到食物就会饿死，然后狐狸的数量就下降了，接着兔子的数量开始增加； 离开了意义，现在社会之所以还在发展，是因为兴起了一种革命性的宗教：人文主义 人文主义革命人文主义崇拜人性，期望由“人类”来扮演上帝在基督教、伊斯兰教中中扮演的角色，或自然法则在佛教和道教中扮演的角色。 人文主义认为：人类必须从自己的内在体验找出意义，而且不仅仅是自己的意义，更是整个宇宙的意义； 人文主义的主要训诫：为无意义的世界创造意义。 人文主义让我们认为，人类自己就是意义的本源，因此自由意志也是最高的权威； 人文主义的教条 人文主义政治：选民能做出最好的选择 人文主义经济：顾客永远是对的； 即使你做出了完美的汽车，但市场上如果没有任何人购买，那说明顾客不懂欣赏？NO. 如果顾客不想要，那就说明这款车不够好； 人文主义美学：看的人觉得美，那就是美（与该事物实际是什么没有联系；就像抽象派的画） 人文主义伦理：感觉对了，那就去做 人文主义教育：要自己思考； 中世纪，所有意义和权威来自外界；因此教育的重点在于顺从、背诵经文、研读古老传统 现在教育，意义和权威源于我们的内心，所以重要的是你自己对这些事物的看法； 对知识的看法： 中世纪的欧洲，知识 = 经文 $\times$ 逻辑 科学革命，知识 = 实证数据 $\times$ 数学 人文主义，知识 = 体验 $\times$ 敏感性 体验：体验是一种主观现象；知觉、情绪与想法； 任何时候，体验都包括了我的一切知觉（热、紧张），我感受到我的情绪（愤怒、恐惧），自己一切我脑海中的想法 敏感性：（1）注意到自己的知觉、情绪和想法；（2）允许这些体验影响自己 体验和敏感性会形成一个互相加强的无限循环；比如喝茶，刚开始我只喝最普通的茶。直到某一天，我开始闭上眼睛，专心喝茶。我开始感受到茶独特的香味；很快，我想开始尝试不同的茶。再到后来，我不能满足普通商铺里的茶，追求更高品质的茶； 到了人文主义，重点放在了感受与体验上，而不是各种行为；而对战争的描述，业从神、伟大的英雄，转移到小兵和他们的体验上。（从一些电影作品以及其他艺术作品中可以看得到。） 人文主义的分裂 自由主义；每个人都是独特的，拥有永不重复的体验 【关注点：自我】 社会人文主义；社会主义责怪自由主义太过注重自己的感受而忽略他人的体验 【关注点：他人，关注自己的行动如何影响他人】 进化人文主义；各种体验和感受的冲突不可避免，最适合胜出； 三、智人失去控制权人类还能继续掌握世界、赋予世界意义吗？ 生物科技和人工智能将如何威胁人文主义？ 谁可能继承人类的角色，什么新宗教可能取代人文主义？ 为什么实现人为主义的梦想反而可能导致人文主义的崩塌。 实验室里的定时炸弹自由意志 自由主义的基础是人有自由意志，这是事实声明； 事实声明科学是可以介入的： 【从科学的角度来解释人的行为这一事件：人的行为只是某种电化学反映到产物】 每一个电化学反应都是前一项事件决定的，那最后达成的决定肯定也不是自由意志； 科学给出人类行为的解释，那就是特定的基因构造让大脑出现某种电化学反应，并进而引发行为； 按照这种解释，人的欲望不是一种“选择”，我们只能“感觉”到欲望，再据此行事； 毕竟，欲望也只是神经元的某种放电模式而已； 如果原子随机运动产生的决定，当然就是随机的，不能是自由意志 ​ 个人主义自由主义认为每个人都有单一的、不可分割的自我。但裂脑人实验，表明自我是可以物理分割的；左脑控制逻辑推理与语言，右脑控制图像；当有人问一个青年，你长大后想做什么，他会回答，“绘图员”；但如果不是让他以语言的形式回答，让它用自己的左手去拼写出未来想要做的事情，得到的结果却是“汽车比赛”；同样的情况也出现在其他实验中；即，左右脑对输出的内容是不同的； 并且，左脑不仅控制表达能力，还是个内部翻译人员；当左右脑控制的部分得出的结果不同时，由左脑对整个现象进行解释，并在两者之间建立某种联系，来表明他们之前的合理性； 冰水试验，引出人的两种自我：体验自我、叙事自我 体验自我：我们每时每刻的意识；并且它没有记忆力；它不会讲故事，并且当我们做重大决定的时候，也不会去问它的想法 叙事自我：就像左脑的内部翻译人员，永远忙碌着将过去的各个细节联接起来，编织成一个故事，并为未来做计划。 两者的关系：叙事自我就像记者或政治人物，他们不会描述所有细节，通常只用事件的高潮和最后结果来编织故事。整个体验的价值，是通过把峰值与终点加以平均而确定的。 案例1：冰水试验：对同一个人进行两种方式的试验；试验结束7分钟之后，如果他们必须再做一次，他们选择做哪一个实验： （1）“短”实验：时长60s，受试者将一只手放进14℃的冷水（足以让人不舒服）中60s，之后把手拿出来； （2）“长”实验：时长60s，受试者将一只手放进14℃的冷水（足以让人不舒服）中60s；之后研究人员会偷偷将热水导入容器，使水温略升为15℃。使得在最后一刻的水温升高； 这两个实验的顺序并不会固定的，受试者可以先做短或者长的试验，然后在调换做第二个；试验结束7分钟之后，如果他们必须再做一次，他们会选择哪个实验；结果表明，有80%的人选择了“长”实验。 叙事自我对两个实验的解释：（1）“短”实验，将最差的部分（水非常冷）和最后一刻（水还是非常冷）做平均，结论就是水非常冷；（2）“长”实验，将最差的部分（水非常冷）和最后一刻（水没那么冷）做平均，结论就是”水稍微温和一点“。 重点在于，叙事自我对时间持续多久没有感觉。 案例2：大肠镜检查：对患者进行大肠镜检查，之后请他们用 0 ~ 10来评价整体疼痛程度 假设：疼痛程度评分与疼痛持续时间相关；即持续时间越久，承受的痛苦越多，评分也应该越高。 结论：检查时间更久但在最后一刻减轻疼痛的对象，对整体疼痛的评分反而较低 （1）实验1：检查时间为8分钟，患者给出最高疼痛指数为8，最后一分钟打分为7；到最后，给出总的疼痛程度为7.5 （2）试验2：检查时间为24分钟，患者给出最高疼痛指数为8，最后一分钟打分为1；到最后，给出总的疼痛程度为4.5 试验2承受疼痛的痛苦要多很多，但并没有影响他的记忆。 叙事自我对我们的体验下判断时，并不会在意时间持续的长短，只会采用“峰终定律”，即只记得高峰和终点的体验，再平均作为整个事件的体验。 【对我的影响：今后自己做判断的时候，要理性地看待全局，避免峰终定律的影响；】 大分离科学对所谓人不可替代的说法的回应： 人类将失去在经济和军事上的用途，因此经济和政治制度将不再继续认同人类有太多价值； 社会系统仍然认为人类整体有其价值，但个人则无价值 社会系统仍然认为某些独特的个人有其价值，但这些人会是一个超人类的精英阶层，而不是一般大众； 超人类掌控世界，人类失去平等；智能是必要的，但意识并非如此；科幻电影通常假设计算机如果想赶上人类甚至超越人类就必须发展出意识；但如果想达到超级智能，并不是一定需要通过意识；例如，无人汽车；它的作用只是将人安全快速地从A地运送到B地；就这一点，自动汽车如果能够比人类做得更好，就算它不能享受音乐，那又怎么样呢？ 如果当所有的汽车均由计算器控制，那整个交通控制权就交给计算机算法，那就能将所有车辆连接成单一网络；控制车辆的算法能够清楚掌握两辆车在路上的位置和行动方向，绝不可能允许自己操纵的两辆车就此相撞；这就大大降低车祸的发生率； 算法掌控世界，人类失去神性人类整体仍有价值，但个人将不再具有权威，大部分选择由外部算法来管理。 大部分人类都将失业，或者失去价值；因为它们能比你做的更好； 例如，当有一个智能机器人，它搜集了你的所有数据，学习了所有的医疗知识，能够以远胜于顶尖医生的程度帮你诊断病情，同时根据你的家族与基因，然后跟你说，“今天开始的一个月，你要开始吃xx药”；但你此刻不觉得自己又任何疾病或者不适，你问它为什么？它回答，根据你的家族与基因，以及近期的生态特征的表象，包括脉搏、血压等等，得出的结果你应该吃这个。然后你继续问，为什么得出这个？它回答，查阅了所有相关的资料，然后解释原因需要1天的时候，这个时候你是选择听它的还是不听它的。也就是那个时候，它比你自己更加了解你自己的时候。 自工业革命爆发以来，人类就担心机械化可能导致大规模失业，然而这种情况并没有在过去发生。这是因为随着旧职业的淘汰，会有新职业的出现；因为总有一些事情人类做得比机器更好。人类只有两种能力：身体能力、认知能力；在机器与人类的竞争在仅限于身体能力时，人类边专注于需要至少一些认知技能的工作。然后，一旦算法在记忆、分析和辨识各种模式的能力上超过人类，那就会更进一步替代人类； 深度学习 对于智能的机器人，我们不再像过去一样给它算法让它来实现，而是让它自己学习；我们提供给系统的唯一信息就是屏幕上的原始像素，以及指示系统要努力得到高分。剩下的一些都是它自己解出来的。我们也并不知道具体是怎么解答出来的。 Googel 的 AlphaGo软件自学围棋；2016年3月，与韩国棋王李世石在首尔举行了一场比赛，AlphaGo最终以4:1打败李世石；在赛后分析AlphaGo的棋路后，多数人的结论则是人类在围棋上已经不再有希望打败它了。据称，当AlphaGo刚开始输掉一场比赛之后的晚上，作为人类的我们在晚上必然要休息。而AlphaGo却在晚上自己跟自己下了一万盘棋。这样的学习速度与密度，令人可怕。 事实上，随着时间的推移，不仅是因为算法越来越聪明，也是因为人类逐渐走向专业化，所以用计算机来取代人类越来越容易；远古的狩猎者想要生存下去，就要掌握各种各样的技能，正因为如此，想设计狩猎机器人的难度非常大。而现在，人工智能不必要在所有的综合能力上胜过人类，只要在特定行业需要的特定能力上超越人类，那就足够了。 即使，对于艺术（例如作曲）这件事，已经有机器人做出的曲子，让人大为称赞； 【个人观点：即使，计算机能够在艺术上制作出让人惊艳的作品；但毕竟感情的促发，是需要活生生的人类来演绎；所以，认为在这个事情上，作品不能替代感情。】 生命科学对自由主义的挑战 自由主义对个人主义的信念的前提假设 我是一个不可分割的个体。即我具备单一的本质，无法在分为各个部分或者子系统。在最深处的内在，有一个清晰、单一的声音，也就是真正的自我。 真正的自我是完全自由的 根据前两个假设，我能够了解一些别人发现不了的自己。也只有我能够进入自己内心自由的空间，只有我能够听到自己真实自我的声音。因此，自由主义才赋予个人极大的权威； 生命科学对这三个假设剔除的挑战 生物就是算法，人类不是不可分割的个体，而是由可分割的部分组成；即人类世许多不同算法的组合，并没有单一的内在。 构成人类的算法并不“自由”，而是由基因和环境压力塑造，虽然可能根据决定论或随机做出决定，但绝不“自由” 因此，外部算法有可能比我更加了解自己。如果能用某个算法监测组成身体和大脑的每个子系统，就能清楚掌握我是谁、我有什么感觉、我想要什么 其他知识 自由主义面对社会不平等的解药，不是让每个人都拥有同样的体验，而是对于不同的人类体验赋予同等的价值； 20世纪是大众的时代。20世纪的军队需要几百万的健康士兵，经济发展也需要几百万的健康工人；因此，各国都建立起公共服务卫生体系，以确保国民的活力与健康。人类最大的医疗成就正是为大众提供卫生设施、疫苗接种，消灭流行病； 意识的海洋 - 新的宗教科技 科技人文主义 仍然认为人类世造物的巅峰之作，智人升级为神，对抗最复杂的无意识算法 人文主义认为，只有人的欲望才能使世界充满意义。但如果我们连欲望都能选择，又凭借什么来做选择呢？ 但它面临一个无解的两难，它认为人的意志是宇宙中最重要的东西，因此推动人类开发控制；但一旦控制意志，人边失去神圣性，无法在科技面前立足； 数据主义 人类已经完成了自己伟大的宇宙任务，应该把接力棒传递给完全不同的实体； 数据主义数据主义认为，宇宙是由数据组成的，任何现象或实体的价值，在于对数据处理的贡献；在达尔文发表《物种起源》的150年后，生命科学已经认为生物体都是生化算法； 数据处理的两种概念整个世界，就是一个数据处理器；针对不同的情况，只不过整个处理器是单一的处理器*（集权组织，所有的决定都由少部分的集权人士来决定），还是一个*分散的处理器 经济系统 资本主义赢得冷战，并不是因为它更合理或是上帝对苏联降下怒火，而是因为这个阶段分散式的数据处理比集中式更优秀 政治系统 民主与专制本质上也是两套关于收集和分析信息的对立机制 全人类是一个数据系统，个人是芯片 人类历史就是一个数据的处理过程 增加处理器数量；拥有10万人口的城市，运算能力就会高于拥有1000人口的村庄 增加处理器种类；如果单一系统拥有不同的处理器，就能增加其动力与创意；农民、祭祀和医生所产生的想法，可能是狩猎者怎么也不会想到的 增加处理器之间的连接；如果只是增加数量与种类无法连接，是没有意义的；10个有连接的城市产出的效益通常都会高于10个孤立的城市； 增加现有连接的流通自由度； 这四个方面是互相矛盾的；处理器的数量与种类越多，自由连接就越困难；因此，智人数据处理系统的构建方法分成四个阶段，各自强调不同的方法； 人类已经经历了这四个阶段 认知革命；开始能够将大量智人连接为一个单一的网络；村落、部落的形成；对其他物种来说，能够连接成单一网络的个人数量有限制，但智人打破了这个限制；智人走向了各地，分散到不同区域，感受不同气候，并开始逐渐失去联系，经历不同的文化变革； 农业革命开始，持续到大约5000年前；农业加速了人口增长，使人类处理器数量急剧上升，更多的人生活在一起形成密集的地方网络； 约5000年前发明了文字和货币，结束与科学革命；有了文字和货币，人类合作开始走向鼎盛，各个团体融合起来，形成城市和王国；人类开始有意识地将整个地球联接为一个单一的网络； 约1492年，早起的探险者、贸易商使得整个地球初步联接为一个单一的网络；到了21世纪，更是形成了快速联通的网络。更重要的是，随着信息科技与网络的发展，信息能够在整个全球网络里自由流动； 信息自由就是最高的善数据主义的诫命： 要连接越来越多的媒介，产生越来越多的信息 把一切连接到系统，连不想加入的异端也不例外 数据主义将人类体验视同数据模式人文主义认为所有的体验发生在我们心中，我们要从给自己的心里找出一切事物的意义，进而为宇宙赋予意义； 数据主义认为，不分享就没有价值，而且我们不需要（甚至不可能）从自己心里找到意义；我们该做的，就是要记录自己的体验，再连接到整个大数据流中，接着算法就会找出这些体验的意义，并告诉我接下来要怎么做。 前几代人中，写日记只给自己看是很常见的人文主义；但现在很多年轻人会认为，如果么有人读到那不就是白写了？所以，现在的座右铭是 “ 如果你体验到了什么，就记录下来。如果你记录了什么，就上传。如果你上传了什么，就分享； ” 在18世纪，人文主义从以神为中心的世界观走向以人为中心，把神推到了一边。在21世纪，数据主义可能从以人为中心走向以数据为中心，把人推到一边；并且，数据主义对人类的威胁，正如人类对其他动物的威胁；数据不在乎我们的主观需求； 最重要的三个事项和问题 正在发展的三个事项 科学正聚合于一个无所不包的教条，也就是认为所有生物都是算法，而生命则是进行数据的处理。 智能正与意识脱钩 无意识但具备高智能的算法，可能很快比我们更了解我们 对应的三个问题 问题1：生物真的只算是算法，而生命也真的只是数据处理吗？ 问题2：智能和意识，究竟哪一个才更有价值？ 问题3：等到无意识但具备高度智能的算法比我们更了解我们自己时，社会、政治和日常生活会发生什么变化？ 其他知识 对于汽车与交通工具的新的认识：即使对于私人汽车，我们真正想要的并不是车辆本身，而是移动的便利；如果有一个智能系统，我能让计算机知道我需要在08:04准时上车，计算机把无人汽车调过来，把我送到公司之后就离去，它能够去服务于其他人；（如果我有自己的车辆，这个时候它应该就停在某个地方，消耗时光）到了18:11分，我走出公司门口，就会有另外一辆全民共享的无人汽车停在我的旁边，带我回家；如有能这样，我为何又需要自己拥有一辆车呢？但如果想要达到这样的目的，你就必须放弃隐私，允许算法永远知道我身在何处，想去何方；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书籍_书声活动]]></title>
      <url>%2F2017%2F04%2F09%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D_%E4%B9%A6%E5%A3%B0%E6%B4%BB%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[我终于相信，每一条走上来的路，都有它不得不那样跋涉的理由。每一条走下去的路，都有它不得不那样选择的方向。——席慕蓉 《际遇》 ##打破界限与无限可能通过自己专业与工作的不同，然后创业来阐述这个观点。推荐书籍:《问题背后的问题》 不要因为对方年龄小，就觉得对方做的事也就那样。放下偏见，以事论事。对TA ##读书就是要有用读书三个阶段: 无心之用； 读书去解决问题； 疑惑—精读—反思—试用活用—反馈 刻意用之：有意识地去运用书中的知识。 《麦肯锡的笔记术》 推荐书籍《影响力》《金字塔原理》（这两本书自己都看过，但只是当时有所感触。《影响力》中的原则偶尔会用一点。《金字塔原理》更是很久之前看的书。觉得这两本书，五一回家的时候要重新翻一下自己的读书笔记。回想起一句话:如果你没有把这个知识与观点运用，说明你并没有真正去理解它的意义） ##精进——帮助你成就未来很厉害的自己推荐书籍《精进》、《请停止无效努力》 ##爱笑的女孩运气不会太差提到了三种人:taker, giver ,matcher.取决于资源的分类（有限资源，无限资源）分享你的无限资源 : 知识，人脉推荐书籍:刘轩-《!祝你好运》 ##学习可以再友好一点吗？科学方法:不要去思辨它，去验证它验证它。 “狗可以，我也可以。”设计思维？设计的价值，在于让一切人造系统对人友好。 学习怪兽。学习不应该是辛苦的。不要把学习妖魔化。贝蒂爱德华推荐书籍《别闹了。费曼先生》 ##独立、成长、爱通过社群文化来解释行为。中国，静态社会文化。 他制他律的人格；个人的行为很大程度上由他是否在一个群体中所影响。 自我压缩的人格； 3个人的不发展； 依赖倾向。 努力成为我们力所能及的最好模样。 ##这是一首简单的小情歌认识文学家，小说家，认识文学是什么样的一个事物。文学的内容，里面的故事，内在的连接。 ##其他思考以前的时候，一直向内寻找，向内思索。当下，去输出，去分享。 将PPT尺寸调整为以16:9 为主。因为到了现在2017年，幕布基本上都已经换成了宽屏幕。 我选择开始__，因为我想要更幸福。我们之所以痛苦，是因为我们不得不做，而不是我们选择去做。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[魔鬼经济学_罗辑思维]]></title>
      <url>%2F2017%2F04%2F03%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F70_%E7%A4%BE%E4%BC%9A%E8%BF%90%E4%BD%9C%2F10_%E7%BB%8F%E6%B5%8E%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F</url>
      <content type="text"><![CDATA[经济学是资源分配最优化的方式。但必须考虑一个非常重要的因素，那就是社会关系。 根据理性可选择的最佳的行为方式，在社会关系的影响下，可能不会选择最理性的行为。 ​ 例如，踢点球的运动员选择的方向，基本是选择左或者右，因为踢歪了也有原因可说。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F04%2F01%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F90_%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%2F%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[OLTP 与 数据仓库事务处理系统 一个独立的事务处理系统也被称为在线事务处理系统（Online Transaction Processing，简称OLTP） 事务处理系统需要能够快速地定位到一条记录。当一次需要获取多条记录时，多条记录通常使用唯一的键值加以识别；例如订单系统中的一个订单信息，人力资源系统中的个人信息。更重要的是这些信息需要经常被更新，通常一次只更新一条记录。 OLTP 与 BI数据库（Data Warehouse，简称DWH）最大的区别：一个单一的事务里要分析的数据的数量。 OLTP系统中，很多并发的用户请求通常只处理一条数据或有限的一组数据 数据仓库系统必须处理几百万条数据的能力，来响应用户的一个简单请求 表 OLPT 与 数据仓库对比 | 指标 | OLTP | 数据仓库 || ———- | —————– | ————— || 系统覆盖范围 | 单一业务处理系统 | 多个业务主题 || 数据源 | 单一 | 多个 || | 静态 | 动态 || | 插入/更新 | 只读 || 单事务数据量 | 小 | 大 || 数据量 | 小/中 | 大 || 数据时间精度 | 当前时间戳 | 秒到天不等 || 批量加载/插入/更新 | 否 | 是 || 全部历史数据访问性 | 否 | 是 || 响应时间 | &lt;1秒 | &lt;10秒 || 系统可达性 | 7 $\times $ 24 小时 | 5 $\times$8 小时 || 典型用户 | 前端业务用户 | 分析人员、决策人员 || 用户数量 | 大 | 小/中 |​ OLTP what：联机事务处理过程（On-Line Transaction Processing），也称为面向交易的处理过程 why ：最大优点是可以即时地处理输入的数据，及时地回答。 how ：基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果 商业智能 BI 商业智能系统通常被称为决策支持系统（Decision Support System，简称DSS） ETL &amp; ELT ETL 代指数据从不同源到数据平台的整个过程，ETL Mapping 可理解为 数据加工算法， ETL what ：将数据从OLTP系统中转移到数据仓库中的一系列操作的集合。 ETL 指从一个或多个数据源抽取数据，经过一个或多个转换步骤后，物理地存储到目标环境中（通常是数据仓库） 数据仓库技术；用来描述Extract(抽取) - Transform(转换)- Load(加载)至目的端的过程。 why ：数据仓库利用 提取-转换-加载(ETL)过程将各种格式的数据和框架转换为便于数据检索的通用格式，以从整个企业的多个数据存储中收集大量数据。 how ：用户从数据源抽取出所需的数据，经过数据清洗，最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去 ETL体系结构 Extract 抽取：一般抽取过程需要连接到不同的数据源，以便为随后的步骤提供数据。 通过接口提取源数据，例如JDBC、专用数据库接口和平面文件提取器，并参照元数据来决定数据的提取及其提取方 Transform 转换：在抽取和加载之间，任何对数据的处理都是转换。 移动数据、根据规则验证数据、数据内容和数据结构的修改、集成多个数据源的数据、根据处理后的数据计算派生值和聚集值 Load 加载：将数据加载到目标系统的所有操作。 加载经转换和汇总的数据到目标数据仓库中，可实现SQL或批量加载。 数据中转区（Staging Area）：仅用来快速地从源数据系统中获取数据，并暂时保留这些数据。 数据中转区不一定是一个数据库系统；很多情况下，将数据保存在ASCII 文件中比插入数据库中表现更快 图1-1 有多个业务源系统，一个数据中转区，一个保存了所有历史数据的数据仓库和多个可以由终端用户访问的数据集市。 这些组成部分之间都是由数据整合过程来完成的，图中的ETL部分 ETL的其他用途 数据迁移：连接A数据库并将数据迁移至B数据库 Kettle拥有两种向导（复制表、复制多表），因此可以根据目标数据库的SQL语法生成新的目标表 因为这些工具提供了各种类型的连接和转换选项 数据同步：利用ETL工具保持两个或以上数据库之间的同步；通常情况下同步有时间限制，因此并不完全适用于同步的场景 ELT ELT ：首先从数据源进行抽取、加载到目标数据库中，再转化为所需要的格式；所有大数据量的处理全部放在目标数据库中进行。 优点：数据库系统更适合处理百万级以上的数据集成；数据库系统也通常会对 I/O（吞吐量）进行优化 ELT 工具需要知道如何使用目标数据库平台和相应的SQL方言 数据仓库 what ：数据仓库（Data Warehouse）是一个面向主题的（Subject Oriented）、集成的（Integrate）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策。 面向主题：指数据仓库中的数据是按照一定的主题域进行组织。 集成：指对原有分散的数据库数据经过系统加工, 整理得到的消除源数据中的不一致性。 相对稳定：指一旦某个数据进入数据仓库以后只需要定期的加载、刷新。 反映历史变化：指通过这些信息，对企业的发展历程和未来趋势做出定量分析预测。 ​ Date Warehouse；一种资讯系统的资料储存理论，此理论强调利用某些特殊资料储存方式，让所包含的资料，特别有利于分析处理，以产生有价值的资讯并依此作决策。 是将组织透过资讯系统之联机交易处理经年累月所累积的大量资料，透过数据仓库理论所特有的资料储存架构，作一有系统的分析整理，以利各种分析方法，例如线上分析处理及数据挖掘之进行，并且进而支持例如决策支持系统及主管资讯系统之创建，帮助决策者能快速有效的自大量资料中，分析出有价值的资讯，以利决策拟定及快速回应外在环境变动，帮助建构商业智能。 why ：为前端查询和分析作为基础 how ： 数据仓库 Vs. 数据库概括而言： 数据库内的资料是是面向业务的，即所谓的OLTP（联机事务处理） 数据仓库里的内容是用来支持决策的，也就是OLAP（联机事物分析）。 具体而言： 数据库里存放的是细节化的信息，而且是二维信息（所谓二维的数据结构，最简单的一种理解就是数据以表的形式组织），有很多基本资料和交易数据。 数据仓库是里存储的是摘要化的信息，并且是多维的信息（至于多维的数据结构理解起来可能比较抽象，可以想象成很多张表以一定顺序摞成一堆，这一堆又以另一种顺序放成一堆，以此类推）。数据仓库里这些多维的信息是数据挖掘的原材料（注意是数据仓库里的数据而不是数据库）。 数据仓库是由许多的数据库组成，也就是数据仓库相当于一个宫殿，而数据库是宫殿里的房间 数据仓库的出现，并不是要取代数据库。目前，大部分数据仓库还是用关系数据库管理系统来管理的。数据仓库与数据库的主要区别在于： （1）数据库是面向事务的设计，数据仓库是面向主题设计的。 （2）数据库一般存储在线交易数据，数据仓库存储的一般是历史数据。 （3）数据库设计是尽量避免冗余，数据仓库在设计是有意引入冗余。 （4）数据库是为捕获数据而设计，数据仓库是为分析数据而设计。 以银行业务为例。数据库是事务系统的数据平台，客户在银行做的每笔交易都会写入数据库，被记录下来，这里，可以简单地理解为用数据库记帐。数据仓库是分析系统的数据平台，它从事务系统获取数据，并做汇总、加工，为决策者提供决策的依据。比如，某银行某分行一个月发生多少交易，该分行当前存款余额是多少。如果存款又多，消费交易又多，那么该地区就有必要设立ATM了。 显然，银行的交易量是巨大的，通常以百万甚至千万次来计算。事务系统是实时的，这就要求时效性，客户存一笔钱需要几十秒是无法忍受的，这就要求数据库只能存储很短一段时间的数据。 分析系统是事后的，它要提供关注时间段内所有的有效数据。这些数据是海量的，汇总计算起来也要慢一些，但是，只要能够提供有效的分析数据就达到目的了。 数据仓库，是在数据库已经大量存在的情况下，为了进一步挖掘数据资源、为了决策需要而产生的，它决不是所谓的“大型数据库”。 面向主题的：传统数据库主要是为应用程序进行数据处理，未必按照同一主题存储数据；数据仓库侧重于数据分析工作，是按照主题存储的。这一点，类似于传统农贸市场与超市的区别—市场里面，白菜、萝卜、香菜会在一个摊位上，如果它们是一个小贩卖的;而超市里，白菜、萝卜、香菜则各自一块。也就是说，市场里的菜(数据)是按照小贩(应用程序)归堆(存储)的，超市里面则是按照菜的类型(同主题)归堆的。 时间相关：数据库保存信息的时候，并不强调一定有时间信息。数据仓库则不同，出于决策的需要，数据仓库中的数据都要标明时间属性。决策中，时间属性很重要。同样都是累计购买过九车产品的顾客，一位是最近三个月购买九车，一位是最近一年从未买过，这对于决策者意义是不同的。 不可修改：数据仓库中的数据并不是最新的，而是来源于其它数据源。数据仓库反映的是历史信息，并不是很多数据库处理的那种日常事务数据(有的数据库例如电信计费数据库甚至处理实时信息)。因此，数据仓库中的数据是极少或根本不修改的;当然，向数据仓库添加数据是允许的。 数据仓库是一种结构体系，而数据库是一种具体技术。这就是最根本的区别。 拿MySQL这个数据库和Apache Hive这个数据仓库为例。这里Hive事实上就是一个很宏大的“体系结构”。它可以把元数据保存在MySQL、Oracle或者Derby这些具体的数据库“技术”里；它在进行查询时把SQL转化成MapReduce job，这里它又用到了MapReduce计算模型这种“技术”。 数据仓库是伴随着信息与决策支持系统的发展过程产生的，而数据库并不是。 数据库/数据仓库的用户群体和工作场景不同； 数据库属于操作型系统，数据仓库属于分析性系统。 操作性系统（数据库）的用户群体是大量客户，每次操作修改的数据量非常小，对时间敏感度非常高。 分析性系统（数据仓库）的用户是决策人员，他们不修改数据但是会分析大量数据，而且他们对得出结果的时间不敏感。 ​ 数据库：传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。 数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 举个最常见的例子，拿电商行业来说好了。基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。 电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。 第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成多台服务器和多个业务数据库（量大+分库分表），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。 第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到非常精细化和具体的用户的集群分析，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。 这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于： 业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。 业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。 而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于： 数据结构为了分析和查询的便利； 只读优化的数据库，即不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。 那么在这里前一种业务数据库（读写都优化）的是业务性数据库，后一种是分析性数据库，即数据仓库。 数据库 比较流行的有：MySQL, Oracle, SqlServer等数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等 这样把数据从业务性的数据库中提取、加工、导入分析性的数据库就是传统的 ETL 工作。 数据仓库 Vs. 数据集市 数据仓库是单一的、大量（历史性）数据的存储仓库，可用来支持企业决策 因此涉及的数据涵盖了各种主题和各种业务领域，例如金融、物流、市场营销和客户支持 通常一个数据仓库不能被终端用户工具直接访问；相反，一个数据集市可以由多个终端用户直接访问，并且是以特定的数据分析为目的的，例如零售或者客户来电； ODS、DW、DM 可参考 OnoNote - D数据分析 - 数据架构 - 《数据仓库ODS、DW和DM概念区分》 1、在业务系统和数据仓库之间形成一个隔离层 一般的数据仓库应用系统都具有非常复杂的数据来源，这些数据存放在不同的地理位置、不同的数据库、不同的应用之中，从这些业务系统对数据进行抽取并不是一件容易的事。因此，ODS用于存放从业务系统直接抽取出来的数据，这些数据从数据结构、数据之间的逻辑关系上都与业务系统基本保持一致，因此在抽取过程中极大降低了数据转化的复杂性，而主要关注数据抽取的接口、数据量大小、抽取方式等方面的问题。 2、转移一部分业务系统细节查询的功能 在数据仓库建立之前，大量的报表、分析是由业务系统直接支持的，在一些比较复杂的报表生成过程中，对业务系统的运行产生相当大的压力。ODS的数据从粒度、组织方式等各个方面都保持了与业务系统的一致，那么原来由业务系统产生的报表、细节数据的查询自然能够从ODS中进行，从而降低业务系统的查询压力。 3、完成数据仓库中不能完成的一些功能 一般来说，带有ODS的数据仓库体系结构中，DW层所存储的数据都是进行汇总过的数据，并不存储每笔交易产生的细节数据，但是在某些特殊的应用中，可能需要对交易细节数据进行查询，这时就需要把细节数据查询的功能转移到ODS来完成，而且ODS的数据模型按照面向主题的方式进行存储，可以方便地支持多维分析等查询功能。 在一个没有ODS层的数据仓库应用系统体系结构中，数据仓库中存储的数据粒度是根据需要而确定的，但一般来说，最为细节的业务数据也是需要保留的，实际上也就相当于ODS，但与ODS所不同的是，这时的细节数据不是“当前、不断变化的”数据，而是“历史的，不再变化的”数据。 大数据平台]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F03%2F28%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FRegular-expression%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[正则表达式。 正则表达式 what：记录文本规则的代码 元字符匹配对象 符号 含义 解释 . 点号 匹配单个(除换行符以外)任意字符 （含空格、下划线等） \s 空白/空格- space 匹配任意的空白符 \S 非空白字符 匹配任何非空白字符，相当于[^ fv] \d 数字 - digit 匹配数字 ，相当于[0-9] \D 非数字 匹配任何非数字字符，相当于[^0-9] \w 任何字符 - whatever 匹配任何字母数字字符，相当于[a-zA-Z0-9_] \W 非任何字符 匹配任何非字母数字字符，相当于[^a-zA-Z0-9_] [ ] 字符组 匹配单个列出的字符，表示或的关系 [^ ] 排除性字符组 匹配单个未列出的字符 \char 转义字符 对于 ? 和 * 的对象在”匹配成功”时也可能并没有匹配任何内容。因为它们允许匹配的数量为0 即便是排除性字符，也需要匹配一个字符 转义符 \\*第一个转义符是对\进行转义，表示：查找 \*此类字符的内容 空格 也是一个字符 字符组 [ ] 字符组内匹配的是列出的单个字符，或者的关系 字符组元字符 ：字符组内的元字符，其含义表示为本身的含义，即代表普通文本字符，相当于转义之后的字符（连字符 - 除外） 连字符 ( - )表示一个范围；【注意：只有在字符组内部，连字符( - )才是元字符】 1[0-9] # 表示匹配的字符为0~9之间的任意一个 连字符 ( - ) 出现在字符组的开头，则仅代表普通文本字符； 1[-09] # 表示匹配的字符为 - 或者 0 或者 9 ​ 量词 - 计数功能对前一个/一组字符匹配的的次数 符号 含义 解释 ？ = 0 或 1 问号 不匹配，或仅匹配一次 * $\ge$ 0 星号 可能不匹配，也可能匹配任意多次 + $\ge$ 1 加号 至少匹配一次，也可能匹配任意多次 {m} 对于前一个字符重复m次 {min, max} 区间量词 对前一个字符重复min到max次 匹配位置 符号 含义 解释 ^ 脱字符 一行的开头位置 $ 美元符 一行的结束位置 \b 单词分界符 匹配单词的开始或结束 (用于精确匹配) \D 非单词分界符 匹配不是单词开头或结束的位置 其他元字符 符号 含义 解释 ( ) 括号 限定多线结构的范围； 为反向引用“捕获”文本 \1 , \2 反向引用 匹配之前的第一个、第二个括号内的字表达式所匹配的文本(即捕获的文本) \ 或者 匹配任意分隔的表达式 括号与反向引用的示例 分组0对应整个正则表达式 1234&gt; \b(a-zA-Z)*+\1\b&gt; # 若 \b(a-zA-Z)*+ 任意字符找到的以单词开头的内容为the，则\1 表示其末尾也应为the的内容 &gt; # 若有两个括号，\2表示第二个括号中所匹配的文本内容&gt; 多选结构 使用圆括号( ) 来进行表示，而非方括号 123456# 查找 gray 或 grey的写法1. gr[ae]y2. gr(a|e)y# 错误的写法 gr[a|e]y -表示查找 a 或者 | 或者 e 多选结构可以匹配任意长度的字符，而字符组[ ]只能匹配单个字符 示例你在一篇英文小说里查找hi，你可以使用正则表达式hi 通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。 很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b \bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词 Python - re模块由于Python的字符串本身也用\转义，因此强烈建议使用Python的r前缀，就不用考虑转义的问题了： 123s = r'ABC\-001' # Python的字符串# 对应的正则表达式字符串不变：# 'ABC\-001' 分组用()表示的就是要提取的分组（Group），进行提取子串 ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 12345678910&gt;&gt;&gt; m = re.match(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$', '010-12345')&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;&gt;&gt;&gt; m.group(0) # group(0) 永远是原始字符串'010-12345'&gt;&gt;&gt; m.group(1)'010'&gt;&gt;&gt; m.group(2)'12345'&gt;&gt;&gt; m.group() # 返回所有的值 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。 注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串 贪婪匹配 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 12&gt;&gt;&gt; re.match(r'^(\d+)(0*)$', '102300').groups()('102300', '') 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配： 12&gt;&gt;&gt; re.match(r'^(\d+?)(0*)$', '102300').groups()('1023', '00') 编译当我们在Python中使用正则表达式时，re模块内部会干两件事情： 编译正则表达式，如果正则表达式的字符串本身不合法，会报错； 用编译后的正则表达式去匹配字符串。 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配： 12345678&gt;&gt;&gt; import re# 编译:&gt;&gt;&gt; re_telephone = re.compile(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$')# 使用：&gt;&gt;&gt; re_telephone.match('010-12345').groups() ('010', '12345')&gt;&gt;&gt; re_telephone.match('010-8086').groups()('010', '8086') 使用方式为 命名的变量.方法(查找对象的范围)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R语言_ggplot2]]></title>
      <url>%2F2017%2F03%2F27%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2Fggplot2%2FR%E8%AF%AD%E8%A8%80_ggplot2%2F</url>
      <content type="text"><![CDATA[关于ggplot2包的应用。 数据结构、绘图对象、图层、标度变换、分面、坐标系、主题； 数据结构一个图形对象，由5部分组成 数据(数据框格式) + 图形属性映射 封箱：将数据分为子集的形式；默认为bins=30 一个/多个图层；图层：一个图层必须由4部分组成 一种位置调整方式 数据和图形属性映射 一种统计变换 一种几何对象 标度；每个图形属性映射都对应一个标度 一个坐标系统 分面设定 1. 绘图对象(数据+图形属性[aes])12# 数据+图形属性ggplot(data, aes()) why ：将数据变量映射到图形中；即指定每个变量扮演的角色 可以使用变量的函数值作为参数；eg: aes(sqtr(age)) aes - aesthetics 数据 必须是数据框（data.frame) ggplot2从给定的数据框中提取所需的变量，并生成一个新的数据集，而不是直接在原数据集上进行数据表换； 数据是以副本而不是引用的形式存储到图形对象的 如果你的数据改变了，绘图不会改变 可以被存储save()到磁盘上，并可被直接加载运行load() 替换数据集（ %+% ）； 用相同的代码，对不同的数据集绘图 1234567p &lt;- ggplot(mtcars aes(mpg,wt)) + geom_point() # 绘制散点图mt &lt;- transform(mtcars, mmpg=mpg^2)# 设置新的数据集p %+% mtcars## 对新的数据集绘制相同的图形 图形属性-aes what ：大小、颜色、形状、透明度； 每个图形属性还可以映射为一个变量或设定为一个常数 每一个图形属性都对应一个称为标度的函数，作用是将数据的取值映射到该图形属性的有效取值 属性 描述 shape 点的形状 fill 填充区域 color 区域的边界；点、线的颜色 linetype 线条类型 size 点的大小；线的宽度 alpha 颜色透明度； label 标签；rowname(data) group alpha 若想采用同一色度，则加上alpha=var 分组 分组变量必须是因子变量； 离散型变量的交互作用被设为分组的默认值 group=factor(var) / fill=factor(col) 多个分组 + 单个图形属性 - ggplot()函数 [what] - 将数据分成若干组，并用相同的方式对每个组进行渲染 1p &lt;- ggplot(Oxboys, aes(age, height, group=Subject)) + geom_line() 不同图层 + 不同分组 - geom(aes())函数 [what] - 不同水平下的数据整合来对统计汇总信息进行绘图； 不同的图层可能有不同的分组图形属性 group=1 ,表示选择所有数据 1p + geom_smooth(aes(gruop=1), method="lm", size=2, se=F) 修改默认分组 - geom(aes())函数 [what] - 自定义离散型变量中的默认分组 [how] - 在几何对象中进行修改 1234567# Occasion为离散型变量，默认分组变量即Occasionboysbox &lt;- ggplot(Oxboys, aes(Occasion, height)) + geom_boxplot() # 在原基础上添加个体轨迹（此处分组变量因为每个个体Subject)boysbox + geom_line(aes(group=Subject), colour="darkblue") --若直接在ggplot()函数中添加分组变量，则表示对之后所有图层都适用 2. 图层(几何对象) what： 每一个几何对象都对应着一个默认的统计变换和位置参数 （geometric object） 具体形式为点、线、条； why ：决定了图形的类型 how ：个体/群组几何对象； / 分组group 设定与映射 设定：p + geom_point(colour=”darkblue”) (其中p &lt;- ggplot(mtcars, aes(x=mpg, y=wt))） 行为：图层里colour参数设定了点的颜色 映射：p + geom_point(aes(colour=”darkblue”)) 行为：先创建一个只含有”darkblue”的变量，然后将colour映射到这个新变量；因为这个变量是离散型的，默认的颜色标度用色轮上等间距的颜色，并且此处只有一个值，因此这个颜色就是桃红色 设定【设定】图形属性为一个单一值 - 几何对象中的参数 what：用于设定图层的图形； 设定：几何对象中的参数 how ：具体组成 属性 描述 shape 点的形状 fill 填充区域 color 区域的边界；点、线的颜色 linetype 线条类型 size 点的大小；线的宽度 alpha 颜色透明度；[0~1] position 位置 binwidth 直方图宽度geom_histogram [0,1] width 箱线图宽度geom_boxplot [0,1] side 地毯图geom_rug的位置； notch=T/F 方块图是否为缺口 position 对图层中元素的位置进行微调； 常用于离散型数据；[连续型数据很少出现完全重叠的现象] 映射【映射】到一个变量：修改绘图对象的图形属性 why ：因为图绘图对象可以单独保存，所以才有修改的这个作用 how ：在几何对象中进行修改 绘图对象 - ggplot(mtcars, aes(mpg, wt)) 12345geom_point(aes(colour=cly) -&gt; aes(mpg, wt, colour=cyl))) # 添加geom_point(aes(y=disp) -&gt; aes(mpg, disp) # 修改 geom_point(aes(y-NULL)) -&gt; aes(mpg) # 删除 3. 图层(统计变换+位置调整)统计变化 - stat_xx what：以某种方式对数据进行统计汇总；必须是一个位置尺度不变的量 任何一个ggplot2图层都包括stat和geom两部分，或者说两个步骤 “每一个几何对象都有一个默认的统计变换，并且每一个统计变换也都有一个默认的几何对象”。 1234x &lt;- c(rnorm(100,14,5),rep(20,20)) y &lt;- c(rnorm(100,14,5) + rnorm(100,0,1),rep(20,20))ggplot(data= NULL, aes(x = x, y = y)) + geom_point(color = "darkred",stat = "sum") 等同于ggplot(data= NULL, aes(x = x, y = y)) + stat_sum(color = "darkred",geom = "point") 可在几何对象中修改统计变换； 1+ geom_histogram(aes(y=..density..)) 可在统计变换中修改集合对象； 12d &lt;- ggplot(diamonds,aes(carat,price))d +stat_density2d(geom="point", aes(size=..density..), contour=F) why ：将返回的数据集作为输出，并可在图形中展现；故可向原数据集中插入新的变量 当我们需要展示出某个变量的某种统计特征的时候，需要用到统计变换 how ：生成变量的名字必须用点号围起来 （..xx..） ​ 4. 标度变换(scale) what：控制数据到图形属性的映射；将数据单位（升、英里加仑数）转换为电脑可以识别的物理单位（像素和颜色）的过程 定义域（数据空间） 值域（图形属性空间） 将定义域映射的值域； 变换-训练-映射 why ：将数据转化为视觉可以感知的东西：大小、颜色、位置；提供读图时使用的工具：坐标轴+图例 how ：用法 - scale_图形属性名称_标度名称 ( scale_x_discrete() ) 可修改的标度，以适应变量类型与标度类型；（当修改底层数据或图形属性映射后） 12p &lt;- ggplot(mpg, aes(cty,hwy)) p + geom_point(aes(x=drv)) + scale_x_discrete() 图形属性：scale_colour / fill / x / y / shape / linetype / size scale_xxx_yyy的具体形式 xxx Description colour Color of lines and points fill Color of area fills (e.g. bar graph) linetype Solid/dashed/dotted lines shape Shape of points size Size of points alpha Opacity/transparency yyy Description hue Equally-spaced colors from the color wheel manual Manually-specified values (e.g., colors, point shapes, line types) gradient Color gradient grey Shades of grey discrete Discrete values (e.g., colors, point shapes, line types, point sizes) continuous Continuous values (e.g., alpha, colors, point sizes) 位置标度 - 坐标轴坐标轴标签名称123+ xlab("xx") / ylab("xx")+ labs(x="",y="",title="",subtitle="") 坐标轴刻度范围 固定标度的定义域 expand_limits()：通过指定的值，使其包含在刻度值中 expand_limits(x=0, y=0) 12345678910+ xlim() /ylim()xlim(n,n) / ylim(n,n) / ylim(0, max(data$var)) # 连续型xlim("a","b","c") # 离散型xlim(as.Date(c("2008-05-01","2008-08-01")) # 日期型控制数据出现的个数和顺序+ scale_x_ (limits=()) # + scale_x_discrete(limits=c("trt2", "ctrl")) # 本应该有3个离散变量 对条形图、直方图不可用xlim()，因为会删除其不再范围内的变量；应改用coord_cartesion(xlim=c(,) ) 刻度值的分段显示 + 转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667+ scale_x_continuous() # 连续型+ scale_x_discrete() # 离散型limits=c( ) # 固定标度的定义域；连续型-数值型，离散型-字符； limits影响显示在图形上的元素## 要显示的范围； #控制标签的个数和顺序breaks=c( ) # 指定坐标轴上应显示哪些刻度线的值或一个连续型标度在一个图例中将被如何分段## breaks影响显示在坐标轴和图例上的元素## scale_x_continuous(breaks=c(0.1,0.2)) # 设置显示的x轴标签刻度值=c(seq(0,200,20))labels=c() # 指定了应在断点处显示的标签## 若设置了labels，则必须同时指定breaks----------------------------------------------------------------------------------改变变量的显示顺序scale_x_discrete/continuous自定义# +scale_x_discrete(limits=c("trt1","ctrl","trt2"))只显示x1和x2两项## p &lt;- ggplot(diamonds,aes(x=carat,y=price))## p + geom_point(colour = "green") + scale_x/y_discrete(limits=c('x1','x2'))转置 -离散变量# + scale_x_discrete(limits=rev(levels(PlantGrowth$group))) + scale_x_discete(breaks=rev(levels(PlantGrowth$group)))## 必须跟在ggplot()之后，不可用 last_plot() + scale_x_ 否则会报错;但可用 p + scale_x_discrete转置 - 连续变量# 左右反转 - x轴scale_x_reverse()# 上下反转 - y轴scale_y_reverse()# 逆时针旋转coord_flip()# 顺时针旋转scale_x_reverse() + coord_flip() ----------------------------------------------------------------------------------设置x/y轴显示的相对比例# 1:1+ scale_y_continuous(breaks=seq(0, 420, 30)) + scale_x_continuous(breaks=seq(0, 420, 30))# 1:2+ scale_y_continuous(breaks=seq(0, 420, 30)) + scale_x_continuous(breaks=seq(0, 420, 15))----------------------------------------------------------------------------------使图形从原点(0,0)出发 -expandscale_x_continuous(expand=c(0,0)) # 这个参数使得数据与坐标轴有一定的距离；默认情况下，连续型变量距离为c(0.05, 0)，离散型变量距离为c(0, 0.6) ----------------------------------------------------------------------------------示例：ggplot(data=Salaries, aes(x=rank, y=salary, fill=sex)) + geom_boxplot() + scale_x_discrete(breaks=c("AsstProf", "AssocProf", "Prof"), labels=c("Assistant\nProfessor", "Associate\nProfessor", "Full\nProfessor")) + scale_y_continuous(breaks=c(50000, 100000, 150000, 200000), labels=c("$50K", "$100K", "$150K", "$200K")) + labs(title="Faculty Salary by Rank and Sex",x="", y="") 刻度值的变换 在统计计量之前，不会改变几何形状 12345678910111213141516171819202122232425刻度值变化+ scale_x_continous(trans="")+ scale_x_continuous(trans="log(10)") "sqtr"# 变换在计算统计摘要之前，虽然数值变换了，但坐标轴的刻度不会改变# 若直接在aes(x=log10(x))，变换也在计算统计摘要之前，但坐标轴刻度会改变日期与时间as.Date()+ scale_x_date(labels=date_format("%m%d"), breaks=date_breaks("2 weeks"))+ scale_x_datetime()------------------------------------------------------------------可能已失效# major / minor 指定主要和次要断点的位置，并允许以这些单位的倍数出现日期与时间-主刻度线 majorbreaks=，可为数值型向量date_breaks=""，只能是字符串向量，"2 weeks" / "10 years"# majOir="2 weeks"日期与时间-次刻度线 minorminor_breaks=，date_minor_breaks=""，只能是字符串向量，"1 day"日期与时间- 格式输出 formatlables=format(" ") # 若失效，改为 data_format() 颜色标度 显示的颜色，前提是已经设置的颜色属性；scalecolor / scalefill 12345678910111213141516171819scale_color_ / scale_fill_离散型颜色梯度+ scale_color/fill_hue() # 默认+ scale_color/fill_brewer(palette="")## 对象为点 - "Set1" / "Dark2"## 对象为面积 - "Set2" / "Pastel1" / "Pastel2" / "Accent"## 得到所有颜色的展示 library(RColorBrewer) display.brewer.all()手动离散型颜色标度+ scale_color/fill_manual(values=c("xx","xx")) 手动设定颜色的值col=rgb(1,1,1) ; col=hsv(0,0,1); col="white"; col="#FFFFFF"----------------------------------------------------------------------------------连续型颜色梯度（渐变色）scale_color/fill_gradient(low="", high="") # 双色 low,high，分别控制梯度两端的颜色scale_color/fill_gradient2(low="",high="", midpoint=) # 三色 low,high,midpoint(默认为0)scale_color/fill_gradientn() , color=xx # 自定义n色 一个颜色向量 .png) 离散型的手动标度123+ scale_shape_manual(values=c())+ scale_size_manual(valuse=c())+ scale_linetype_mannule(values=c()) 图例标度 - guides guides为每一个scale_by_scale的函数来设置参数 12345678910111213141516171819图例-guide_legend()guides(fill= guide_legend(title=, title.position="top", title.hjust=, title.vjust=, label=T, label.position="top", label.hjust=, label.vjust=, direction="vertical"/"horizonttal", nrow=2, ncol=2, reverse=F, byrow=F)图例 - 删除# bp &lt;- ggplot(data=PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot()guides(fill=FALSE) 替换fill为所需的美学+ guides(fill=FALSE)+ scale_fill_discrete(guide=FALSE)+ theme(legend.position="none") # 删除所有图例----------------------------------------------------------------------------------图例 - 位置 - 整个区域内 # 下面的数字位置是相对于整个区域，包括标题和标签，而不仅仅是绘图区域bp + theme(legend.position="top") # 该表示方法在绘图区之外； bottom;left;right;bp + theme(legend=c(0,0)) # 见下图位置 - 绘图区域内 # 添加legend.justification=c(0,0) 表示在绘图区的c(0,0)的方位，而不是在整个区域bp + theme(legend.justification=c(0,0), legend.position=c(0,0)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061图例 - 项目顺序更改图例中项目的顺序 - breaks+ scale_fill_discrete(breaks=c("ctr1","ctrl","ctr2")) # fill是ggplot(aes(fill=group)) 详见bp的构造反转图例中项目的顺序+ guide(fill=guide_legend(reverse=T))+ scale_fill_discrete(guide=guide_legend(reverse=T)) # 注意这里的fill参照bp的构成+ scale_fill_discrete(breaks=rev(levles(PlantGrowth$group)))+ guides(color = guide_legend(reverse=TRUE)) # 内部顺序 # 条形图时，且用fill来分组时# 当分组用alpha时，guide(alpha=guide_legend(reverse=T))----------------------------------------------------------------------------------图例-标题# 用fill来填充颜色,那么我们去掉图例就需要用fill, 去掉标题third &lt;- ggplot(mpg, aes(cyl, hwy, fill = factor(cyl))) + geom_boxplot()third + guides(fill=guide_legend(title=NULL))third + guides(fill = guide_legend(title = "how"))third + guides(fill = guide_legend(title.position = "top"))# 通过theme来调整+ theme(legend.title=element_blank())----------------------------------------------------------------------------------图例 - 标题和标签的文本第一种方式：guide可以被fill,colour, linetype, shape所引导+ scale_fill_discrete(values=c("#999999","#E69F00","#56B4E9"), name="Experiment\nCondition", breaks=c("ctrl", "trt1", "trt2"), labels=c("Control", "Treatment 1", "Treatment 2")) # 更改图例标题必须使用 scale_xx_discrete的方式图例-标签third + guides(fill = guide_legend(label = TRUE)) # 标签与否third + guides(fill = guide_legend(label.position = "top")) # 标签位置third + guides(fill = guide_legend(label.theme = element_text(size = 15, face = "italic", colour = "red", angle = 30)))第二种方式：改变数据框pg &lt;- PlantGrowth levels(pg$group)[levels(pg$group)=="ctrl"] &lt;- "Control"levels(pg$group)[levels(pg$group)=="trt1"] &lt;- "Treatment 1"levels(pg$group)[levels(pg$group)=="trt2"] &lt;- "Treatment 2"names(pg)[names(pg)=="group"] &lt;- "Experimental Condition" # 更改单个列的列名----------------------------------------------------------------------------------图例 - 标题和标签的外观# 默认情况下，图例不会有一个框。要添加一个框并修改其属性：bp + theme(legend.background = element_rect())bp + theme(legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"))图例-图表third + guides(fill = guide_legend(keywidth = 5)) # 图表宽度third + guides(fill = guide_legend(direction = "horizontal")) / "vertical"third + guides(fill = guide_legend(nrow = 2)) # 图表的列数图例 - 斜杠如果使用轮廓制作条形图（通过设置color =“black”），它将通过图例中的颜色绘制斜杠。 5. 分面(facet) what： 将数据划分为多个子集，并依次绘图 适用于离散型变量（若对连续型变量则需要先将其转换） 1234连续型变量转换为离散型cut_interval(x, n=10) # 将数据划分为n个长度相同的部分cut_number(x, n=10) # 将数据划分为n个有相同数目点的部分 why ：用于比较不同分组之间的情况；（理解为aes中gruop的不同变体；） 分组：容易发现各组之间细微的差别 分面：对于各组之间重叠问题严重时，可很好地解决该问题 how ： + facet_grid / wrap 网格型 what ：二维面板，由行和列通过变量来定义； why ：用于两个或多个变量来生成一个2维网格 how ：需要设定哪些变量作为分面绘图的行与列； ​ 多种形式 - facet_grid() 12345678910. ~ a # 一行多列，根据变量a进行分面为n列a ~. # 一列多行，根据变量a进行分面n行a~b # 多行多列.~a+b / a+b~. # 多个变量的多个水平在行/列上(或同时)--------------------------边际图----------------------------------------margins=T # 展示所有分面的边际图margins=c("col","col") # 列出需展示边际图的变量名称grand_row / grand_col # 分别生成所有行/列的边际图 网格型 - 分面位置占比 - space=”fixed”/ “free”（随标度范围变化而变化） 封装型 what：一维面板条，再封装到二维中 why ：处理单个多水平变量 多种形式 - facet_wrap() 12~ a, ncol=n~a, nrow=n 封装型 - 标度控制12345678scales=""scales="fixed" # 所有面板中x/y标度相同（默认）## 在相同的基准上进行比较，观察各子集相似的模式; ## 对于 facet_grid 必须是x/y都相同scales="free" # x/y每个面板的标度都可以变化; 自由标度，用于发现更多的细节scales="free_x" / "free_y" # x的标度可变，y 的尺度固定 分面的标签控制12data %&gt;% mutate(left = factor(left, labels = c("Remain", "Left"))) %&gt;% # 需先将变量设置为需显示的标签 6. 坐标系(coord) what：将两种位置标度结合在一起组成的二维定位系统 how ：笛卡尔坐标系、非笛卡尔坐标系 笛卡尔坐标 - cartesian() 123456789101112131415161718192021222324252627282930313233343536范围设置 - 放大coord_cartesian(xlim=c(n,n), ylim=c())## 与 +xlim() &amp; scale_x_continuous(limits=c()) 区别：## coord - 使用的仍是所有数据，只是展示的仅该部分数据；如同用放大镜看数据## xlim() &amp; scale_x_ - 是将超出此范围的数据都删除，仅对在该范围内的数据做图x/y轴翻转 + coord_flip(xlim=c(), ylim=c())# 或者 直接在图形属性aes()中将变量先后顺序调换转置 -离散变量# + scale_x_discrete(limits=rev(levels(PlantGrowth$group))) + scale_x_discete(breaks=rev(levels(PlantGrowth$group)))## 必须跟在ggplot()之后，不可用 last_plot() + scale_x_ 否则会报错;但可用 p + scale_x_discrete转置 - 连续变量# 左右反转 - x轴scale_x_reverse()# 上下反转 - y轴scale_y_reverse()# 逆时针旋转coord_flip()# 顺时针旋转scale_x_reverse() + coord_flip() -----------------------------------------------------------------------------坐标轴变换 - 在统计量计算之后，会改变几何形状+ coord_trans(x="sqrt", y=, xlim, ylim) + coord_trans(xtrans="sqrt", ytrans="", xlim, ylim)x/y轴标度比例+ coord_equal() # 默认为1:1+ coord_equla(ratio=1.5, xlim, ylim) # ratio=y/x的值 非笛卡尔坐标1234567极坐标+ coord_polar(theta="x", direction=1, start=0 ) # 绘制饼图/雷达图# direction= 1，顺时针，-1，逆时针 start=0 12点钟弧度的起点偏移量地图投影library(mapproj)coord_map 7. 主题(theme) what：对数据之外的图形外观进行控制； how ：设置与使用 使用方式：+theme(主题元素 = 主题性质) + theme(plot.title=element_text(size=20)) 主题与设置123456整体风格变动 - 四种种内置主题+ theme_gray() # 灰色背景，白色网格线+ theme_bw() # 白色背景，灰色网格线+ theme_classic() # 白色背景，无网格线+ theme_minimal() # 无坐标线 – 1234567891011121314设置 -theme_set() # 返回先前的主题theme_get() # 获得当前主题设置全局设置theme_set(theme_gray())局部设置 直接在ggplot()之后 + theme_gray() / bw()----------------------------------------------------------------------------------为之后的图形设置主题 theme_update()theme_update(plot.title=element_text(hjust=0.5, face="bold")) # 标题水平居中或者赋值为theme1 &lt;- theme_update() ,之后是 theme_set(theme1) – 12345678永久性存储主题theme1 &lt;- theme_minimal() + theme(plot.title=element_text(hjust=0.5, face="bold"), axis.line =element_line(linetype=1)) # 无坐标线theme2 &lt;- theme_classic() +theme(plot.title=element_text(hjust=0.5, face="bold")) # 白色背景，无坐标线theme3 &lt;- theme_gray() + theme(plot.title=element_text(hjust=0.5, face="bold")) # gray为默认theme4 &lt;- theme_bw() + theme(plot.title=element_text(hjust=0.5, face="bold"))ggplot() + theme_bw 边界 12# 图形边界plot.margin = unit(c(1,1,1,1),"lines") 主题元素+元素函数主题元素123456坐标系 - axis. axis.line # 直线和坐标轴axis.text.x # x/y轴标签axis.ticks # 轴须标签axis.title.x # x/y轴标题xis.ticks.margin # 坐标系边界 axis.ticks.margin = unit(0.8,"lines") – 12345678图例 - legend.legend.bakgroud # 图例背景legend.key # 图例符号legend.text # 图例标签legend.title # 图例标题legend.margin # 每个图例之间的边界# 独立运作+ theme(legend.position="none" / "left" /"right"/"bottom"/"top"/=c(n,n) ) # n为[0,1] – 123456面板 - panel.panel.backgound # 面板背景panel.border # 面板边界panel.grid.major # 主网格线panel.grid.minor # 次网格线panel.margin # 分面绘图区之间的边距 – 1234567整个图形 - plot.plot.background # 整个图形背景plot.title # 图形标题plot.margin # 图形边距 top, right, bottom, leftplot.margin = unit(c(1,1,1,1),"lines") # 等价于 = unit(rep(1,4),"lines") – 123其他 - strip.strip.backgroud # 分面标签背景strip.text.x # 水平/竖直条状文本 元素函数1234567891011121314151617181920文本 - element_text()# 处理标签axis.text.x/axis.ticks、标题plot.titleface="" # 字体格式## "bold.italic" # 粗斜体## "bold" # 加粗## "italic" # 斜体## "plain" # 无格式的color=""size=num # 文本大小hjust / vjust =[0,1] # 水平/竖直对齐## hjust=0 # 左对齐## hjust=1 # 右对齐## hjust=0.5 # 居中对齐lineheight=num # 行高angle=[0,360] # 旋转角度family="" # 字族 – 123456线条 - element_line() #处理线条axis.line 或线段panel.grid.major/minorsize=numcolor=""linetype=[0,6] – 1234567背景 - element_rect() # 处理背景 .background 使用的矩阵linetype=nsize=numcolor=""fill="" – 1234element_blank() # 空主题，表示删除的绘图元素主题元素=element_blank() 一页多图组图12library(gridExtra)grid.arrange(p1,p2,...pn, nrow=n, ncol=n) 子图 - viewport()+print1234567891011121314151617181920212223library(grid)viewport(x=n,y=n,width=n,height=n) # 设置图形的位置## x,y - 控制图形的中心位置，范围[0,1] ，左下角为(0,0)## width/height - 控制图形的大小，默认为比例大小[0,1]；### width=0.5, height=0.5 - 占1/4大小### width=1,height=1 - 占整个图形## 也可用绝对单位；eg: width = unit(1, "cm") / unit(1, "inch")print(p, vp=)# print(要增加子图的图形对象, vp=设置的图形位置对象) b &lt;- ggplot(economics, aes(uempmed,unemploy)) + geom_point() + geom_smooth(se=F)c &lt;- ggplot(economics, aes(uempmed,unemploy)) + geom_path()library(grid)subvp &lt;- viewport(x=0.75,y=0.35, width=0.4, height=0.4)b # 显示当前要增加子图的图print(c, vp=subvp)## 若要调整子图的属性，要先在外面调整好，再放入主图中； eg: c1 &lt;- c + theme() 属性参考几何对象 - 点 - geom_xx12345678plot# 点 # + stat_smooth() # 添加平滑曲线 dotplot# 点直方图(用点来表示观测值的个数)jitter# 给点添加扰动(减轻重叠问题) point - 散点图几何对象 - 线12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ablineabline(..., slope, intercept, show.legend=NA)# 线(由斜率和截距决定) 指定的斜率和截距geom_abline(slope=1, intercept=0, linetyep=2)hline# 水平线 ; yintercept=n / n1:n2vline# 竖直线 ; xintercept=----------------------------------------------------------------lineline(x,y, alpha, color, fill, linetype, size, arrow)# 按照x坐标的大小顺序依次连接各个观测值path# 路径图(按数据的原始顺序连接各个观测值)step# 以阶梯形式联接各个观测值----------------------------------------------------------------quantile# 添加分位数回归线segment# 添加线段/箭头 ## geom_segment(aes(x=, xend=, y=, yend= ))smooth# 添加光滑的条件均值线## method=smooth(默认) lm-线性; loess-非参数光滑曲线; gam-广义相加模型; glm-广义线性; rlm-健壮线性; ## formula= y~x （默认） y~log(x); y~poly(x,n) -n次多项式拟合; y~ns(x,n) -具有n个自由度的样条拟合## se=T/F 绘制置信区间；默认为T## level=num 默认为95%## fullrange=F/T ,拟合覆盖全图(T)，仅覆盖数据(F) 默认为Fdensity# 光滑密度曲线图density2d# 二维密度等高线图----------------------------------------------------------------lineranglinerang(x,ymin,ymaxn,alpha,color, lineype,size, show.legend=T/F)# 一条代表一个区间的竖直线pointrang# 用一条中间带点的竖直线代表一个区间 几何对象 - 面bar - 条形图 先做出x/y轴，再作图，运用stat ggplot(temp3, aes(content_rating, M)) last_plot() + geom_bar(stat=”identity”) 1234567891011121314151617181920212223242526272829303132333435363738# 条形图(以x轴为底的矩形)图形/位置调整# geom_bar(position="dodge") -分组条形图; (position="fill") -百分比条形图;水平条形图# + coord_flip()堆砌分组条形图（两个类别型变量）# ggplot(hr_good,aes(left,number_project,fill=factor(number_project))) + geom_bar(stat="sum") 调整距离宽度与间距; # width=0.5 -也可以看做x坐标轴之间的分割大小; position=position_dodge(0.7)----------------------------------------------------------------------项目排序 -reorder# 按z值的大小，重新排列条形图的顺序，只需将aes()中x的属性用reorder()函数更改即可; ## ggplot(df, aes(x = reorder(x, z), y = z, fill = y)) +geom_bar(stat = 'identity') + xlab('x')项目排序 -降序排序# 1. arrange(data, M) 升序排列# 2. data$M &lt;- factor(data$M, order=T, levels=data$M)) # 因子化 / data$M &lt;- with(data, factor(var, order=T, levels=var))项目排序 -如果x是因子，我们可以对其用带参数limits=rev(levels(…))的函数scale_x_discrete()进行修正。## + coord_flip() + scale_x_discrete(limits=rev(levels(PlantGrowth$group)))项目排序 -直接修正# 直接用scale_x_discrete(limits=c()) 来修正顺序-----------------------------------------------------------------------添加标签# geom_text(aes(label=var))## hjust/vjust=-0.2 -表示显示在外面; hjust/vjust=1.5 -表示显示在里面添加标签 -对于分组条形图# geom_text(position = position_dodge(0.9))添加标签 -对于堆积条形图# geom_text(position = position_stack()) histogram - 直方图123456789101112调整组距：# 1)binwidth=n # 组距宽度；也可以看做x坐标轴之间的分割大小# 2)bins=n # 组的数量# 3)breaks=c(n, n, n) # 具体的x轴坐标尺度来划分调整分组直方图两者之间重叠程度# position=position_dodge(0.5)密度直方图# histogram(aes(y=..density))在密度直方图基础上，添加核密度曲线## stat_density(geom="line") 其他面图12345678boxplot# 箱线图area# 面积图freqplot# 频率多边形图 几何对象 - 非常规图形漏斗图12345## 漏斗图 # 涉及概念 # 1.占位数 = （上阶段人数 - 当前人数）/2# 2.环节转化率 =当前人数/上阶段人数；# 3.整体转化率 = 当前人数 / 总人数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152## 思路1，利用占位符；条形图---------------------------test----------------------------------------------------library(reshape2)scope&lt;-c(0.9,0.8,0.6,0.4,0.2)Part&lt;-paste("part",1:5,sep="")Order&lt;-1:5 help&lt;-(1-scope)/2 # 表示该值为 两边留空的二分之一mydata&lt;-data.frame(Order,Part,help,scope) Order Part help scope1 1 part1 0.05 0.92 2 part2 0.10 0.83 3 part3 0.20 0.64 4 part4 0.30 0.45 5 part5 0.40 0.2# 重构为长格式mydata1&lt;-melt(mydata,id.vars=c("Order","Part"),variable.name="perform",value.name="scope") Order Part perform scope1 1 part1 help 0.052 2 part2 help 0.103 3 part3 help 0.204 4 part4 help 0.305 5 part5 help 0.406 1 part1 scope 0.907 2 part2 scope 0.808 3 part3 scope 0.609 4 part4 scope 0.4010 5 part5 scope 0.20# 构造有序因子变量，两个因子水平，分别是实际指标值和辅助值# 【关键1】在构造有序因子变量时，注意辅助值因子水平要高于实际值数据。柱形图堆叠时，【关键2】按照因子水平由高到低堆叠（底层因子水平高，顶层因子水平低，这样才能将指标值的数据条撑起，其实水平均居中）。mydata1$perform&lt;-factor(mydata1$perform,level=c("scope","help"),order=T) -----------------------------绘制图形--------------------------ggplot(mydata1,aes(Order,scope,order=desc(scope),fill=perform))+geom_bar(stat="identity",position="stack") # 即先堆叠高水平help，然后再堆叠低水平scope；# 制作色盘：（其实使用了一个白色色值隐藏掉了辅助列，理念跟在excel里面制作漏斗图一致，但是色盘颜色顺序白色要在第一个，这样将来颜色映射的时候颜色顺序与因子水平由大到小进行匹配的。）这一点非常重要，也是ggplot临摹漏斗图的核心技巧。Color&lt;-c("#FFFFFF","#088158")ggplot()+geom_bar(data=mydata1,aes(x=Order,y=scope,fill=perform),stat="identity",position="stack")+scale_fill_manual(values=sort(Color))+ # sort表示重新排序；因为颜色的填充是低水平(scope)，在高水平(help)进行填充geom_text(data=mydata,aes(x=Order,y=help+scope/2-.025,label=Part),col="white",size=4)+geom_text(data=mydata,aes(x=Order,y=help+scope/2+.035,label=paste(100*mydata$scope,"%",sep="")),col="white",size=5.5)+theme_nothing()ggplot()+geom_bar(data=mydata1,aes(x=Order,y=scope,fill=perform),stat="identity",position="stack")+scale_fill_manual(values=sort(Color))+ coord_flip()+ scale_x_reverse() + # 顺时针旋转geom_text(data=mydata,aes(x=Order,y=help+scope/2-.05,label=Part),col="white",size=4)+ # 标签位置设定geom_text(data=mydata,aes(x=Order,y=help+scope/2+.05,label=paste(100*mydata$scope,"%",sep="")),col="white",size=5.5)+theme_nothing() –1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859## 思路2，利用箱线图set.seed(123) #设定随机种子，保证做的图和这里的一样df &lt;- data.frame( var=LETTERS[1:10], #字母A-J id=1:10, #数字1-10 a=runif(10), #10个随机数 b=runif(10), #10个随机数 c=runif(10), #10个随机数 stringsAsFactors = F #不转换为因子) var id a b c1 A 1 0.2875775 0.95683335 0.88953932 B 2 0.7883051 0.45333416 0.69280343 C 3 0.4089769 0.67757064 0.64050684 D 4 0.8830174 0.57263340 0.99426985 E 5 0.9404673 0.10292468 0.65570586 F 6 0.0455565 0.89982497 0.70853057 G 7 0.5281055 0.24608773 0.54406608 H 8 0.8924190 0.04205953 0.59414209 I 9 0.5514350 0.32792072 0.289159710 J 10 0.4566147 0.95450365 0.1471136df_tmp4&lt;-df %&gt;% select(1:3) %&gt;% arrange(a) %&gt;% mutate(new_id=1:10, # 创建新变量，以此为排序 ymin = (1-a)/2, # 最小值，左边留空的值 ymax = a+(1-a)/2, # 最大值，右边留空的值 mid = 0.5) var id a new_id ymin ymax mid1 F 6 0.0455565 1 0.47722175 0.5227782 0.52 A 1 0.2875775 2 0.35621124 0.6437888 0.53 C 3 0.4089769 3 0.29551154 0.7044885 0.54 J 10 0.4566147 4 0.27169263 0.7283074 0.55 G 7 0.5281055 5 0.23594726 0.7640527 0.56 I 9 0.5514350 6 0.22428249 0.7757175 0.57 B 2 0.7883051 7 0.10584743 0.8941526 0.58 D 4 0.8830174 8 0.05849130 0.9415087 0.59 H 8 0.8924190 9 0.05379048 0.9462095 0.510 E 5 0.9404673 10 0.02976636 0.9702336 0.5---------------------------------------------ggplot(df_tmp4,aes(new_id,mid)) + # x轴为对应的各个指标 geom_linerange(aes(ymin=ymin,ymax=ymax, colour=factor(new_id)), size=15, alpha=0.5,show.legend = F)+ scale_x_continuous(breaks = 1:10, labels = df_tmp4$var)+ coord_flip() ------------------------------------------- ggplot(df_tmp4,aes(new_id,mid))+ # geom_step(colour="grey50")+ geom_crossbar(aes(ymin=ymin,ymax=ymax), size=0, fill="skyblue", colour="grey50", width=1)+ scale_x_continuous(breaks = 1:10, labels = df_tmp4$var)+ coord_flip() 其他图形1234567errorbar# 误差棒errorbarh# 水平误差棒rug# 边际地毯图(轴须图) – 1234567891011121314151617181920212223242526272829303132blank# 空白contor# 等高线图crossbar# 带水平中心线的盒子图hex# 六边形二维热点图map# 基准地图里多边形ploygon# 多边型(相当于一个有填充的路径)raster# 高效的矩形瓦片图rect# 二维矩阵图ribbon# 色带图(连续的x值所对应y的范围)violin# 小提琴图tile# 瓦片图 text - 文本注释123456789101112131415161718192021222324252627282930313233343536373839404142geom_text()geom_text(aes(label=var)) / geom_text(aes(label=rownames(var))) (x,y, alpha=, color=, size=, hjust=, vjust=,,nudge_x=0,nugde_y=0, angle=, fontface=, family=, lineheight=, show.legend=NA/F/T, check_overlap=F, na.rm=F )# hjust=0(右侧)，=1(左侧)，=0.5(居中，默认)；若小于0，则继续向右# vjust=0(向上)，=1(向下), =0.5(居中，默认); 若小于0，则继续向上；## vjust/yjust ，可以是 0(right/bottom) 和 1(left/top)，或者是字符串("left","right","middle","bottom","center","top"); 或者是 字符串 ("inward","outward")## nudge_x=2.5 ，x轴方向，向右微调2.5# 常用字体大小 size=4 ; 5.5; ## 标签显示为百分比label=paste(100*mydata$scope,"%",sep="")# ggplot() + geom_text(data=mydata,aes(x=Order,y=help+scope/2+.035,label=paste(100*mydata$scope,"%",sep="")),col="white",size=5.5)p &lt;- ggplot(mtcars, aes(x=wt, y=mpg, label=rownames(mtcars)))p + geom_text()p + geom_text(size=10) # Change size of the label[变更标签的大小]p &lt;- p + geom_point()# Set aesthetics to fixed value[设置为固定值的美学]p + geom_text()p + geom_point() + geom_text(hjust=0, vjust=0)p + geom_point() + geom_text(angle = 45)# Add aesthetic mappings[审美映射]p + geom_text(aes(colour=factor(cyl)))p + geom_text(aes(colour=factor(cyl))) + scale_colour_discrete(l=40)p + geom_text(aes(size=wt))p + geom_text(aes(size=wt)) + scale_size(range=c(3,6))# Add an annotation not from a variable source[添加注释，而不是从一个变量源]c &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()c + geom_text(data = NULL, x = 5, y = 30, label = "plot mpg vs. wt")# Or, you can use annotate[或者，您可以使用注释]c + annotate("text", label = "plot mpg vs. wt", x = 2, y = 15, size = 8, colour = "red")---------------------------------------------------------------------------------------geom_label() # draws a rectangle behind the text, making it easier to read. aes(label=rownames(var)) 可在任何几何对象中出现 geom_point(aes(laber=rownames(var))) 图形属性linetype 符号 描述 1 solid - 实线 2 dashed - 虚线 3 dotted - 点 4 dotdash - 破折号 5 longdash - 长破折号 6 twodash - 双破折号 position 符号 描述 示例 stack 堆叠 堆砌条形图 fill 堆叠并高度标准化为1 百分比堆砌条形图 dodge 避免重叠，并排放置 分组条形图 jitter 给点添加扰动，避免重叠 identity 不做任何调整 identity ，不适合条形图，因为后面画的条形会挡住先画的 side地毯图geom_rug的位置； 符号 描述 b 底部 l 左侧 r 右侧 t 顶部 bl 左下 “tl” 、 “tr”、”br” 左上、右上、右下 shape fontface1fontface= "plain", "italic", "bold", "bold.italic" 统计变换常用统计变换 统计变换 描述 stat_identity 不做任何统计变换 stat_boxplot 计算组成箱线图的各种元素值 stat_density 一维密度估计 stat_density2d 二维密度估计 stat_smooth 添加拟合曲线 stat_summary 对每个x所对应的y值做统计描述 stat_unique 删除重复值 stat_bin count - 直方图 density - 频率多边形图 1234567密度直方图# ggplot(diamonds, aes(carat)) + geom_histogram(aes(y=..density..), binwidth=0.1) 添加拟合曲线# p &lt;- ggplot(diamonds, aes(x=carat,y=price,color=cut))# p + geom_point(color='green',alpha=0.2)+ stat_smooth() 统计变换 stat_xx 统计变换 描述 stat_bin 计算封箱(bin)数据 bin2d 计算封箱内的观测值个数 bindot 计算“点直方图”封箱数据 binhex 计算“六边形热图”封箱数据 boxplot 计算组成箱线图的各种元素值 contour 三维数据的等高线 density 一维密度估计 density2d 二维密度估计 function 添加新的函数 identity 不对数据进行统计变换 qq 计算qq图的相关值 quantile 计算连续的分位数 smooth 添加光滑曲线 spoke 将角度和半径转换成xend和yend sum 计算每个单一值的频数[有助于解决散点图的图形重叠问题] summary 对每个x对应的y值做统计描述 summary2d 对二维矩形封箱设定函数 summaryhex 对二维六边形封箱设定函数 unique 删除重复值 ydensity 小提琴图，计算一维y轴方向的核密度函数的估计值 作图规范标准作图规范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ggplot(mtcars, aes(disp,hp)) # 绘制对象(数据，图形属性aes) + geom_point(aes(color=factor(cyl))) # 图层(几何对象)-设定;若要分组，必须为因子factor变量 # geom_point(color="blue") # 图层(几何对象)-映射 # stat_(） # 统计变化 + goem_text(aes(label=cyl, color=cyl), size=, vjust=0.5,hjust=0.5,nudge_x=0.5, nudge_y=0.5, show.length=F) # 标签; hjust=0(向右),vjust=0(向上); nudge_x=0.5 向x轴方向微调0.5+ annotate("text", x = 4, y = 25, label = "Some text")+ xlim(0,10) # x轴的定义域，表示只选取该范围内的数值进行作图；超出部分则删除; # xlim(0,max(mtcars$disp)) # 必须有data$var # xlim("a","b","c") # 离散型 # xlim(as.Date(c("2008-05-01","2008-08-01")) # 日期型 + sacle_y_continuous( limits=c(min(mtcars$hp),300), breaks=c(100,150,400), # =c(seq(0,200,20)) 指定坐标轴上应显示哪些刻度线的值 或一个连续型标度在一个图例中将被如何分段（即显示哪些刻度的值） labels=c("100k","150k","400k") # 指定了应在断点处显示的标签 + labs(x="", y="", title="", subtitle="") # 坐标轴的标签名称 + scale_x_discrete(breaks=rev(levels(mtcars$hp))) # 转置 # scale_x_reverse() # 转置-连续型变量 + scale_y_continuous(breaks=seq(0, 420, 30)) + scale_x_continuous(breaks=seq(0, 420, 15))# 设置x/y轴显示的相对比例; 同 coord_equal(ratio=) + sacle_color_brewer(palette="") + scale_fill_hue() # 离散型标度的颜色设置 # scale_color_manual(values=c()) 手动自定义设置颜色 # scale_color_gradient（low="", high="") 连续型标度的颜色设置； 双色； + guides(fill=guide_legend((title=, title.position="top",label.position="top", nrow=2,reverse=F) # 设置图例 # guides(fill=FALSE) 删除图例 + facet_grid(.~ y, margins=T, space="fixed") # 网格型分面 margins=c("col","col") 所需展示的边界图的变量 # facet_wrap(~y, ncol=2, scales="free_x") # 封装型分面+ coord_flip() # 坐标轴翻转+ coord_equal(ratio=2, xlim, ylim) y/x轴的比例 + theme1 # theme1 &lt;- theme_minimal() + theme(plot.title=element_text(hjust=0.5, face="bold"), axis.line =element_line(linetype=1))+ theme(axis.line=element_line(linetype=1,size=1), axis.title.x=element_text(), panel.grid.minor=element_blank(), plot.title=element_text(face="bold",size=, hjust=0.5), plot.background=element_rect(fill=,color=)) # theme(主题元素= 主题性质) axis/legend/panel/plot/strip+ plot.margin = unit(c(1,1,1,1),"lines") # 图形边界 top/right/bottom/left grid.arrange(p1,p2,...pn, nrow=2) # library(gridExtra) 组图--------------------------------------------------------------------ggplot(data=, aes(x=, y= )) + geom_xx(...) + stat_xx(...) + annotate(...) + scale_xx(...) + coord_xx(...) + guides(...) + theme(...)# mtcars，R中自带的数据集 可对图形分别进行设定与修改 - 基础图形可被保存 123456创建绘图对象# p &lt;- ggplot(mtcars, aes(x=mpg, y=wt))设定与修改p + geom_point(aes(colour=factor(cyl))p + geom_point(aes(y=disp)) – 1234做不同运算的图形# ggplot(huron, aes(year))+ geom_line(aes(y=level-5), color="blue")+ geom_line(aes(y=level-5), color="red") 作图问题图形基本处理 矢量图形(PDF, PostScript, SVG，AI,) 位图(PNG, JPEG, TIFF，bmp，jpg) 123456789101112summary() # 查看结构print() # 呈现-----------------------------------------------------------------------------------保存ggsave() # 保存到磁盘--ggsave("name.png", [plot=plot_name] width=, height=) # plot_name为创建图像的名称；若忽略，则对最佳的图像保存save() # 缓存保存到磁盘; 可保存一个图形对象的完整副本，并可用load()来重现该函数 图片保存21.5寸显示频：1920px $\times$ 1080px （比值 = 1.7777） 电脑显示频 -16:9 （比值 = 1.777） 电脑显示频 - 4:3 （比值 = 1.333） savePlot 的妙用（在R中的使用，非Rstudio） 1234567savePlot(filename = "Rplot", type = c("wmf", "emf", "png", "jpg", "jpeg", "bmp", "tif", "tiff", "ps", "eps", "pdf"), device = dev.cur(), restoreConsole = TRUE)# JPEG quality is 75% ; TIFF 无压缩。# 所以这个命令在Rstudio上没法运行，在在R编辑器下运行成功 粘贴复制（rstudio） 1234export - copy to clipboard生成图片以后，点击copy to clipboard,调整合适的大小，然后选择copy as的类型（bitmap,metafile）, 确认后，然后就可以将图片粘贴到你想要他到的地方了，得到的是矢量图(metafile)# 点击 export默认的单位是像素 导出高清的图 1234567891011121314151617181920212223242526272829303132333435tiff(filename = "test.tif",width = 15,height = 18,units ="cm",compression="none",bg="white",res=600)# res设置图片分辨率; units指定长宽的单位，px(oixeis,默认的)，in(inches),cm或者mm。compression为压缩方式，lzw压缩之后图片较小。可选的方式为none,rle,zlw,jpeg,zip。dev.new()pdf(file="example.pdf", width=12, height=8) #矢量图，pdf格式svg(file="example.svg", width=12, height=8) #矢量图，svg格式tiff(file="example.tiff", width=12, height=8， units="in", compression="lzw", res=150) #位图，tiff格式，常用于文章投稿。dev.off()# 默认的单位unit是英寸ggsave("myplot.png", width=8, height=8, unit="cm", dpi=300)------------------------------------------------------------------------------改变字体 install.packages("extrafont")library(extrafont) # Find and save information about fonts installed on your systemfont_import() # List the fontsfonts()After the one-time setup is done, there are tasks you need to do in each R session:library(extrafont) # Register the fonts with Rloadfonts() # On Windows, you may need to tell it where Ghostscript is installed# (adjust the path to match your installation of Ghostscript)Sys.setenv(R_GSCMD = "C:/Program Files/gs/gs9.05/bin/gswin32c.exe") # Finally, you can create a PDF file and embed fonts into it, as in Figure 14-4:library(ggplot2)ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point() + ggtitle("Title text goes here") + theme(text = element_text(size = 16, family="Impact"))ggsave("myplot.pdf", width=4, height=4)embed_fonts("myplot.pdf") 图片不清晰R中生成的图片，保存为.tiff格式，有3M，在word里还是模糊 一般情况下，如果需要在word中插入图片，分为两种方法：复制黏贴与插入图片菜单。同时，由于word文档往往为表述性质使用，因此并不需要分辨率很高的图片，像我个人使用都是800*600的jpg格式,单张图片尺寸保持在100k~200k之间刚好。然后如果插入图片较多，往往会造成word文档尺寸较大，不便于使用MMS工具传输，所以会使用wrod中的图片处理工具压缩文档中的所有图片。 关于图片模糊，事实上在给定显示设备参数不变的状态下会有两种情况，一种是图片分辨率太低，还有一种是图片分辨率太高。解决方法是根据你最终输出的需求（出版物，电子文档等）来调整相应输出设备分辨率参数，并把其作为模版保存下来即可 为图形添加注释 - annotate1234567891011# 一次只添加一个位置上的图形当x/y轴均为连续型的数值变量时，当annotate中的x/y引用对象时，必须是数值，可用as.numeric()来转换# peak &lt;- filter(data, var==max(var))# peak_x &lt;- as.numeric(peak[1,1])# peak_y &lt;- as.numeric(peak[1,2])p + annotate("text", x = 4, y = 25, label = "Some text")p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21, alpha = .2)p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25, colour = "blue")p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,colour = "red", size = 1.5) 项目排序顺序12345678910111213先设置好顺序 - factor按当前排序来指定顺序# data$col &lt;- factor(data$col, levles=data$col, order=TRUE)## arrange(data, col) 升序排列自定义顺序# data$col &lt;- factor(data$col, levels=c("col1","col2"),order=TRUE)----------------------------------------------------------------------------------标度变换# scale_x_discrete(limits=c("col","col")# scale_x_discrete(limits=data$col) 遮盖问题 图形相互覆盖无法看清 12345678910111213141516171819点的大小与形状 # geom_xxx(shape=)## shape=1(中空的点)## shape="." (像素大小的点)透明度；最小透明度为1/256# geom_xxx( alpha = [1/256 ,1] )添加随机扰动 - jitter ；[当数据存在一定离散性]# td &lt;- ggplot(diamonds, aes(table,depth)) + xlim(50,70) + ylim(50,70)## 直接添加 - td +geom_point ; td + geom_jitter() # 默认扰动量为40%## 调整后变更扰动率 - jit &lt;- positon_jitter(width=0.5); td +geom_jitter(position=jit)将点分箱，并统计每个箱中点的数量，在可视化这个数量# d &lt;- ggplot(diamonds, aes(carat,price)) + xlim(1,3) # 此时并无图形显示# d + stat_binhex() # 默认分箱数 # 即使没有几何对象也能做出图形# d + stat_binhex(bins=10) # 共10个封箱 # 默认为30个用stat_density2d做二维密度估计，并将等高线添加到散点图中 含权重数据 点/线 - size = 权重变量 复杂情况 - weight = 权重变量 ​ 交互式作图 - ggplotly12library(plotly)ggplotly(object) 统计摘要：为统计量绘图12345单独的摘要计算函数# fun.y / fun.ymin / fun.ymax统一的摘要统计函数# fun.data]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R语言_ggplot2]]></title>
      <url>%2F2017%2F03%2F27%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_ggplot2_%E5%9B%BE%E5%BD%A2%E8%89%BA%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[关于ggplot2包的应用。 数据结构、绘图对象、图层、标度变换、分面、坐标系、主题； 数据结构一个图形对象，由5部分组成 数据(数据框格式) + 图形属性映射 封箱：将数据分为子集的形式；默认为bins=30 一个/多个图层；图层：一个图层必须由4部分组成 一种位置调整方式 数据和图形属性映射 一种统计变换 一种几何对象 标度；每个图形属性映射都对应一个标度 一个坐标系统 分面设定 1. 绘图对象(数据+图形属性[aes])12# 数据+图形属性ggplot(data, aes()) why ：将数据变量映射到图形中；即指定每个变量扮演的角色 可以使用变量的函数值作为参数；eg: aes(sqtr(age)) aes - aesthetics 数据 必须是数据框（data.frame) ggplot2从给定的数据框中提取所需的变量，并生成一个新的数据集，而不是直接在原数据集上进行数据表换； 数据是以副本而不是引用的形式存储到图形对象的 如果你的数据改变了，绘图不会改变 可以被存储save()到磁盘上，并可被直接加载运行load() 替换数据集（ %+% ）； 用相同的代码，对不同的数据集绘图 1234567p &lt;- ggplot(mtcars aes(mpg,wt)) + geom_point() # 绘制散点图mt &lt;- transform(mtcars, mmpg=mpg^2)# 设置新的数据集p %+% mtcars## 对新的数据集绘制相同的图形 图形属性-aes what ：大小、颜色、形状、透明度； 每个图形属性还可以映射为一个变量或设定为一个常数 每一个图形属性都对应一个称为标度的函数，作用是将数据的取值映射到该图形属性的有效取值 属性 描述 shape 点的形状 fill 填充区域 color 区域的边界；点、线的颜色 linetype 线条类型 size 点的大小；线的宽度 alpha 颜色透明度； label 标签；rowname(data) group alpha 若想采用同一色度，则加上alpha=var 分组 分组变量必须是因子变量； 离散型变量的交互作用被设为分组的默认值 group=factor(var) / fill=factor(col) 多个分组 + 单个图形属性 - ggplot()函数 [what] - 将数据分成若干组，并用相同的方式对每个组进行渲染 1p &lt;- ggplot(Oxboys, aes(age, height, group=Subject)) + geom_line() 不同图层 + 不同分组 - geom(aes())函数 [what] - 不同水平下的数据整合来对统计汇总信息进行绘图； 不同的图层可能有不同的分组图形属性 group=1 ,表示选择所有数据 1p + geom_smooth(aes(gruop=1), method="lm", size=2, se=F) 修改默认分组 - geom(aes())函数 [what] - 自定义离散型变量中的默认分组 [how] - 在几何对象中进行修改 1234567# Occasion为离散型变量，默认分组变量即Occasionboysbox &lt;- ggplot(Oxboys, aes(Occasion, height)) + geom_boxplot() # 在原基础上添加个体轨迹（此处分组变量因为每个个体Subject)boysbox + geom_line(aes(group=Subject), colour="darkblue") --若直接在ggplot()函数中添加分组变量，则表示对之后所有图层都适用 2. 图层(几何对象) what： 每一个几何对象都对应着一个默认的统计变换和位置参数 （geometric object） 具体形式为点、线、条； why ：决定了图形的类型 how ：个体/群组几何对象； / 分组group 设定与映射 设定：p + geom_point(colour=”darkblue”) (其中p &lt;- ggplot(mtcars, aes(x=mpg, y=wt))） 行为：图层里colour参数设定了点的颜色 映射：p + geom_point(aes(colour=”darkblue”)) 行为：先创建一个只含有”darkblue”的变量，然后将colour映射到这个新变量；因为这个变量是离散型的，默认的颜色标度用色轮上等间距的颜色，并且此处只有一个值，因此这个颜色就是桃红色 设定【设定】图形属性为一个单一值 - 几何对象中的参数 what：用于设定图层的图形； 设定：几何对象中的参数 how ：具体组成 属性 描述 shape 点的形状 fill 填充区域 color 区域的边界；点、线的颜色 linetype 线条类型 size 点的大小；线的宽度 alpha 颜色透明度；[0~1] position 位置 binwidth 直方图宽度geom_histogram [0,1] width 箱线图宽度geom_boxplot [0,1] side 地毯图geom_rug的位置； notch=T/F 方块图是否为缺口 position 对图层中元素的位置进行微调； 常用于离散型数据；[连续型数据很少出现完全重叠的现象] 映射【映射】到一个变量：修改绘图对象的图形属性 why ：因为图绘图对象可以单独保存，所以才有修改的这个作用 how ：在几何对象中进行修改 绘图对象 - ggplot(mtcars, aes(mpg, wt)) 12345geom_point(aes(colour=cly) -&gt; aes(mpg, wt, colour=cyl))) # 添加geom_point(aes(y=disp) -&gt; aes(mpg, disp) # 修改 geom_point(aes(y-NULL)) -&gt; aes(mpg) # 删除 3. 图层(统计变换+位置调整)统计变化 - stat_xx what：以某种方式对数据进行统计汇总；必须是一个位置尺度不变的量 任何一个ggplot2图层都包括stat和geom两部分，或者说两个步骤 “每一个几何对象都有一个默认的统计变换，并且每一个统计变换也都有一个默认的几何对象”。 1234x &lt;- c(rnorm(100,14,5),rep(20,20)) y &lt;- c(rnorm(100,14,5) + rnorm(100,0,1),rep(20,20))ggplot(data= NULL, aes(x = x, y = y)) + geom_point(color = "darkred",stat = "sum") 等同于ggplot(data= NULL, aes(x = x, y = y)) + stat_sum(color = "darkred",geom = "point") 可在几何对象中修改统计变换； 1+ geom_histogram(aes(y=..density..)) 可在统计变换中修改集合对象； 12d &lt;- ggplot(diamonds,aes(carat,price))d +stat_density2d(geom="point", aes(size=..density..), contour=F) why ：将返回的数据集作为输出，并可在图形中展现；故可向原数据集中插入新的变量 当我们需要展示出某个变量的某种统计特征的时候，需要用到统计变换 how ：生成变量的名字必须用点号围起来 （..xx..） ​ 4. 标度变换(scale) what：控制数据到图形属性的映射；将数据单位（升、英里加仑数）转换为电脑可以识别的物理单位（像素和颜色）的过程 定义域（数据空间） 值域（图形属性空间） 将定义域映射的值域； 变换-训练-映射 why ：将数据转化为视觉可以感知的东西：大小、颜色、位置；提供读图时使用的工具：坐标轴+图例 how ：用法 - scale_图形属性名称_标度名称 ( scale_x_discrete() ) 可修改的标度，以适应变量类型与标度类型；（当修改底层数据或图形属性映射后） 12p &lt;- ggplot(mpg, aes(cty,hwy)) p + geom_point(aes(x=drv)) + scale_x_discrete() 图形属性：scale_colour / fill / x / y / shape / linetype / size scale_xxx_yyy的具体形式 xxx Description colour Color of lines and points fill Color of area fills (e.g. bar graph) linetype Solid/dashed/dotted lines shape Shape of points size Size of points alpha Opacity/transparency yyy Description hue Equally-spaced colors from the color wheel manual Manually-specified values (e.g., colors, point shapes, line types) gradient Color gradient grey Shades of grey discrete Discrete values (e.g., colors, point shapes, line types, point sizes) continuous Continuous values (e.g., alpha, colors, point sizes) 位置标度 - 坐标轴坐标轴标签名称123+ xlab("xx") / ylab("xx")+ labs(x="",y="",title="",subtitle="") 坐标轴刻度范围 固定标度的定义域 expand_limits()：通过指定的值，使其包含在刻度值中 expand_limits(x=0, y=0) 12345678910+ xlim() /ylim()xlim(n,n) / ylim(n,n) / ylim(0, max(data$var)) # 连续型xlim("a","b","c") # 离散型xlim(as.Date(c("2008-05-01","2008-08-01")) # 日期型控制数据出现的个数和顺序+ scale_x_ (limits=()) # + scale_x_discrete(limits=c("trt2", "ctrl")) # 本应该有3个离散变量 对条形图、直方图不可用xlim()，因为会删除其不再范围内的变量；应改用coord_cartesion(xlim=c(,) ) 刻度值的分段显示 + 转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667+ scale_x_continuous() # 连续型+ scale_x_discrete() # 离散型limits=c( ) # 固定标度的定义域；连续型-数值型，离散型-字符； limits影响显示在图形上的元素## 要显示的范围； #控制标签的个数和顺序breaks=c( ) # 指定坐标轴上应显示哪些刻度线的值或一个连续型标度在一个图例中将被如何分段## breaks影响显示在坐标轴和图例上的元素## scale_x_continuous(breaks=c(0.1,0.2)) # 设置显示的x轴标签刻度值=c(seq(0,200,20))labels=c() # 指定了应在断点处显示的标签## 若设置了labels，则必须同时指定breaks----------------------------------------------------------------------------------改变变量的显示顺序scale_x_discrete/continuous自定义# +scale_x_discrete(limits=c("trt1","ctrl","trt2"))只显示x1和x2两项## p &lt;- ggplot(diamonds,aes(x=carat,y=price))## p + geom_point(colour = "green") + scale_x/y_discrete(limits=c('x1','x2'))转置 -离散变量# + scale_x_discrete(limits=rev(levels(PlantGrowth$group))) + scale_x_discete(breaks=rev(levels(PlantGrowth$group)))## 必须跟在ggplot()之后，不可用 last_plot() + scale_x_ 否则会报错;但可用 p + scale_x_discrete转置 - 连续变量# 左右反转 - x轴scale_x_reverse()# 上下反转 - y轴scale_y_reverse()# 逆时针旋转coord_flip()# 顺时针旋转scale_x_reverse() + coord_flip() ----------------------------------------------------------------------------------设置x/y轴显示的相对比例# 1:1+ scale_y_continuous(breaks=seq(0, 420, 30)) + scale_x_continuous(breaks=seq(0, 420, 30))# 1:2+ scale_y_continuous(breaks=seq(0, 420, 30)) + scale_x_continuous(breaks=seq(0, 420, 15))----------------------------------------------------------------------------------使图形从原点(0,0)出发 -expandscale_x_continuous(expand=c(0,0)) # 这个参数使得数据与坐标轴有一定的距离；默认情况下，连续型变量距离为c(0.05, 0)，离散型变量距离为c(0, 0.6) ----------------------------------------------------------------------------------示例：ggplot(data=Salaries, aes(x=rank, y=salary, fill=sex)) + geom_boxplot() + scale_x_discrete(breaks=c("AsstProf", "AssocProf", "Prof"), labels=c("Assistant\nProfessor", "Associate\nProfessor", "Full\nProfessor")) + scale_y_continuous(breaks=c(50000, 100000, 150000, 200000), labels=c("$50K", "$100K", "$150K", "$200K")) + labs(title="Faculty Salary by Rank and Sex",x="", y="") 刻度值的变换 在统计计量之前，不会改变几何形状 12345678910111213141516171819202122232425刻度值变化+ scale_x_continous(trans="")+ scale_x_continuous(trans="log(10)") "sqtr"# 变换在计算统计摘要之前，虽然数值变换了，但坐标轴的刻度不会改变# 若直接在aes(x=log10(x))，变换也在计算统计摘要之前，但坐标轴刻度会改变日期与时间as.Date()+ scale_x_date(labels=date_format("%m%d"), breaks=date_breaks("2 weeks"))+ scale_x_datetime()------------------------------------------------------------------可能已失效# major / minor 指定主要和次要断点的位置，并允许以这些单位的倍数出现日期与时间-主刻度线 majorbreaks=，可为数值型向量date_breaks=""，只能是字符串向量，"2 weeks" / "10 years"# majOir="2 weeks"日期与时间-次刻度线 minorminor_breaks=，date_minor_breaks=""，只能是字符串向量，"1 day"日期与时间- 格式输出 formatlables=format(" ") # 若失效，改为 data_format() 颜色标度 显示的颜色，前提是已经设置的颜色属性；scalecolor / scalefill 12345678910111213141516171819scale_color_ / scale_fill_离散型颜色梯度+ scale_color/fill_hue() # 默认+ scale_color/fill_brewer(palette="")## 对象为点 - "Set1" / "Dark2"## 对象为面积 - "Set2" / "Pastel1" / "Pastel2" / "Accent"## 得到所有颜色的展示 library(RColorBrewer) display.brewer.all()手动离散型颜色标度+ scale_color/fill_manual(values=c("xx","xx")) 手动设定颜色的值col=rgb(1,1,1) ; col=hsv(0,0,1); col="white"; col="#FFFFFF"----------------------------------------------------------------------------------连续型颜色梯度（渐变色）scale_color/fill_gradient(low="", high="") # 双色 low,high，分别控制梯度两端的颜色scale_color/fill_gradient2(low="",high="", midpoint=) # 三色 low,high,midpoint(默认为0)scale_color/fill_gradientn() , color=xx # 自定义n色 一个颜色向量 .png) 离散型的手动标度123+ scale_shape_manual(values=c())+ scale_size_manual(valuse=c())+ scale_linetype_mannule(values=c()) 图例标度 - guides guides为每一个scale_by_scale的函数来设置参数 12345678910111213141516171819图例-guide_legend()guides(fill= guide_legend(title=, title.position="top", title.hjust=, title.vjust=, label=T, label.position="top", label.hjust=, label.vjust=, direction="vertical"/"horizonttal", nrow=2, ncol=2, reverse=F, byrow=F)图例 - 删除# bp &lt;- ggplot(data=PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot()guides(fill=FALSE) 替换fill为所需的美学+ guides(fill=FALSE)+ scale_fill_discrete(guide=FALSE)+ theme(legend.position="none") # 删除所有图例----------------------------------------------------------------------------------图例 - 位置 - 整个区域内 # 下面的数字位置是相对于整个区域，包括标题和标签，而不仅仅是绘图区域bp + theme(legend.position="top") # 该表示方法在绘图区之外； bottom;left;right;bp + theme(legend=c(0,0)) # 见下图位置 - 绘图区域内 # 添加legend.justification=c(0,0) 表示在绘图区的c(0,0)的方位，而不是在整个区域bp + theme(legend.justification=c(0,0), legend.position=c(0,0)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061图例 - 项目顺序更改图例中项目的顺序 - breaks+ scale_fill_discrete(breaks=c("ctr1","ctrl","ctr2")) # fill是ggplot(aes(fill=group)) 详见bp的构造反转图例中项目的顺序+ guide(fill=guide_legend(reverse=T))+ scale_fill_discrete(guide=guide_legend(reverse=T)) # 注意这里的fill参照bp的构成+ scale_fill_discrete(breaks=rev(levles(PlantGrowth$group)))+ guides(color = guide_legend(reverse=TRUE)) # 内部顺序 # 条形图时，且用fill来分组时# 当分组用alpha时，guide(alpha=guide_legend(reverse=T))----------------------------------------------------------------------------------图例-标题# 用fill来填充颜色,那么我们去掉图例就需要用fill, 去掉标题third &lt;- ggplot(mpg, aes(cyl, hwy, fill = factor(cyl))) + geom_boxplot()third + guides(fill=guide_legend(title=NULL))third + guides(fill = guide_legend(title = "how"))third + guides(fill = guide_legend(title.position = "top"))# 通过theme来调整+ theme(legend.title=element_blank())----------------------------------------------------------------------------------图例 - 标题和标签的文本第一种方式：guide可以被fill,colour, linetype, shape所引导+ scale_fill_discrete(values=c("#999999","#E69F00","#56B4E9"), name="Experiment\nCondition", breaks=c("ctrl", "trt1", "trt2"), labels=c("Control", "Treatment 1", "Treatment 2")) # 更改图例标题必须使用 scale_xx_discrete的方式图例-标签third + guides(fill = guide_legend(label = TRUE)) # 标签与否third + guides(fill = guide_legend(label.position = "top")) # 标签位置third + guides(fill = guide_legend(label.theme = element_text(size = 15, face = "italic", colour = "red", angle = 30)))第二种方式：改变数据框pg &lt;- PlantGrowth levels(pg$group)[levels(pg$group)=="ctrl"] &lt;- "Control"levels(pg$group)[levels(pg$group)=="trt1"] &lt;- "Treatment 1"levels(pg$group)[levels(pg$group)=="trt2"] &lt;- "Treatment 2"names(pg)[names(pg)=="group"] &lt;- "Experimental Condition" # 更改单个列的列名----------------------------------------------------------------------------------图例 - 标题和标签的外观# 默认情况下，图例不会有一个框。要添加一个框并修改其属性：bp + theme(legend.background = element_rect())bp + theme(legend.background = element_rect(fill="gray90", size=.5, linetype="dotted"))图例-图表third + guides(fill = guide_legend(keywidth = 5)) # 图表宽度third + guides(fill = guide_legend(direction = "horizontal")) / "vertical"third + guides(fill = guide_legend(nrow = 2)) # 图表的列数图例 - 斜杠如果使用轮廓制作条形图（通过设置color =“black”），它将通过图例中的颜色绘制斜杠。 5. 分面(facet) what： 将数据划分为多个子集，并依次绘图 适用于离散型变量（若对连续型变量则需要先将其转换） 1234连续型变量转换为离散型cut_interval(x, n=10) # 将数据划分为n个长度相同的部分cut_number(x, n=10) # 将数据划分为n个有相同数目点的部分 why ：用于比较不同分组之间的情况；（理解为aes中gruop的不同变体；） 分组：容易发现各组之间细微的差别 分面：对于各组之间重叠问题严重时，可很好地解决该问题 how ： + facet_grid / wrap 网格型 what ：二维面板，由行和列通过变量来定义； why ：用于两个或多个变量来生成一个2维网格 how ：需要设定哪些变量作为分面绘图的行与列； ​ 多种形式 - facet_grid() 12345678910. ~ a # 一行多列，根据变量a进行分面为n列a ~. # 一列多行，根据变量a进行分面n行a~b # 多行多列.~a+b / a+b~. # 多个变量的多个水平在行/列上(或同时)--------------------------边际图----------------------------------------margins=T # 展示所有分面的边际图margins=c("col","col") # 列出需展示边际图的变量名称grand_row / grand_col # 分别生成所有行/列的边际图 网格型 - 分面位置占比 - space=”fixed”/ “free”（随标度范围变化而变化） 封装型 what：一维面板条，再封装到二维中 why ：处理单个多水平变量 多种形式 - facet_wrap() 12~ a, ncol=n~a, nrow=n 封装型 - 标度控制12345678scales=""scales="fixed" # 所有面板中x/y标度相同（默认）## 在相同的基准上进行比较，观察各子集相似的模式; ## 对于 facet_grid 必须是x/y都相同scales="free" # x/y每个面板的标度都可以变化; 自由标度，用于发现更多的细节scales="free_x" / "free_y" # x的标度可变，y 的尺度固定 分面的标签控制12data %&gt;% mutate(left = factor(left, labels = c("Remain", "Left"))) %&gt;% # 需先将变量设置为需显示的标签 6. 坐标系(coord) what：将两种位置标度结合在一起组成的二维定位系统 how ：笛卡尔坐标系、非笛卡尔坐标系 笛卡尔坐标 - cartesian() 123456789101112131415161718192021222324252627282930313233343536范围设置 - 放大coord_cartesian(xlim=c(n,n), ylim=c())## 与 +xlim() &amp; scale_x_continuous(limits=c()) 区别：## coord - 使用的仍是所有数据，只是展示的仅该部分数据；如同用放大镜看数据## xlim() &amp; scale_x_ - 是将超出此范围的数据都删除，仅对在该范围内的数据做图x/y轴翻转 + coord_flip(xlim=c(), ylim=c())# 或者 直接在图形属性aes()中将变量先后顺序调换转置 -离散变量# + scale_x_discrete(limits=rev(levels(PlantGrowth$group))) + scale_x_discete(breaks=rev(levels(PlantGrowth$group)))## 必须跟在ggplot()之后，不可用 last_plot() + scale_x_ 否则会报错;但可用 p + scale_x_discrete转置 - 连续变量# 左右反转 - x轴scale_x_reverse()# 上下反转 - y轴scale_y_reverse()# 逆时针旋转coord_flip()# 顺时针旋转scale_x_reverse() + coord_flip() -----------------------------------------------------------------------------坐标轴变换 - 在统计量计算之后，会改变几何形状+ coord_trans(x="sqrt", y=, xlim, ylim) + coord_trans(xtrans="sqrt", ytrans="", xlim, ylim)x/y轴标度比例+ coord_equal() # 默认为1:1+ coord_equla(ratio=1.5, xlim, ylim) # ratio=y/x的值 非笛卡尔坐标1234567极坐标+ coord_polar(theta="x", direction=1, start=0 ) # 绘制饼图/雷达图# direction= 1，顺时针，-1，逆时针 start=0 12点钟弧度的起点偏移量地图投影library(mapproj)coord_map 7. 主题(theme) what：对数据之外的图形外观进行控制； how ：设置与使用 使用方式：+theme(主题元素 = 主题性质) + theme(plot.title=element_text(size=20)) 主题与设置123456整体风格变动 - 四种种内置主题+ theme_gray() # 灰色背景，白色网格线+ theme_bw() # 白色背景，灰色网格线+ theme_classic() # 白色背景，无网格线+ theme_minimal() # 无坐标线 – 1234567891011121314设置 -theme_set() # 返回先前的主题theme_get() # 获得当前主题设置全局设置theme_set(theme_gray())局部设置 直接在ggplot()之后 + theme_gray() / bw()----------------------------------------------------------------------------------为之后的图形设置主题 theme_update()theme_update(plot.title=element_text(hjust=0.5, face="bold")) # 标题水平居中或者赋值为theme1 &lt;- theme_update() ,之后是 theme_set(theme1) – 12345678永久性存储主题theme1 &lt;- theme_minimal() + theme(plot.title=element_text(hjust=0.5, face="bold"), axis.line =element_line(linetype=1)) # 无坐标线theme2 &lt;- theme_classic() +theme(plot.title=element_text(hjust=0.5, face="bold")) # 白色背景，无坐标线theme3 &lt;- theme_gray() + theme(plot.title=element_text(hjust=0.5, face="bold")) # gray为默认theme4 &lt;- theme_bw() + theme(plot.title=element_text(hjust=0.5, face="bold"))ggplot() + theme_bw 边界 12# 图形边界plot.margin = unit(c(1,1,1,1),"lines") 主题元素+元素函数主题元素123456坐标系 - axis. axis.line # 直线和坐标轴axis.text.x # x/y轴标签axis.ticks # 轴须标签axis.title.x # x/y轴标题axis.ticks.margin # 坐标系边界 axis.ticks.margin = unit(0.8,"lines") – 12345678图例 - legend.legend.bakgroud # 图例背景legend.key # 图例符号legend.text # 图例标签legend.title # 图例标题legend.margin # 每个图例之间的边界# 独立运作+ theme(legend.position="none" / "left" /"right"/"bottom"/"top"/=c(n,n) ) # n为[0,1] – 123456面板 - panel.panel.backgound # 面板背景panel.border # 面板边界panel.grid.major # 主网格线panel.grid.minor # 次网格线panel.margin # 分面绘图区之间的边距 – 1234567整个图形 - plot.plot.background # 整个图形背景plot.title # 图形标题plot.margin # 图形边距 top, right, bottom, leftplot.margin = unit(c(1,1,1,1),"lines") # 等价于 = unit(rep(1,4),"lines") – 123其他 - strip.strip.backgroud # 分面标签背景strip.text.x # 水平/竖直条状文本 元素函数1234567891011121314151617181920文本 - element_text()# 处理标签axis.text.x/axis.ticks、标题plot.titleface="" # 字体格式## "bold.italic" # 粗斜体## "bold" # 加粗## "italic" # 斜体## "plain" # 无格式的color=""size=num # 文本大小hjust / vjust =[0,1] # 水平/竖直对齐## hjust=0 # 左对齐## hjust=1 # 右对齐## hjust=0.5 # 居中对齐lineheight=num # 行高angle=[0,360] # 旋转角度family="" # 字族 – 123456线条 - element_line() #处理线条axis.line 或线段panel.grid.major/minorsize=numcolor=""linetype=[0,6] – 1234567背景 - element_rect() # 处理背景 .background 使用的矩阵linetype=nsize=numcolor=""fill="" – 1234element_blank() # 空主题，表示删除的绘图元素主题元素=element_blank() 一页多图组图12library(gridExtra)grid.arrange(p1,p2,...pn, nrow=n, ncol=n) 子图 - viewport()+print1234567891011121314151617181920212223library(grid)viewport(x=n,y=n,width=n,height=n) # 设置图形的位置## x,y - 控制图形的中心位置，范围[0,1] ，左下角为(0,0)## width/height - 控制图形的大小，默认为比例大小[0,1]；### width=0.5, height=0.5 - 占1/4大小### width=1,height=1 - 占整个图形## 也可用绝对单位；eg: width = unit(1, "cm") / unit(1, "inch")print(p, vp=)# print(要增加子图的图形对象, vp=设置的图形位置对象) b &lt;- ggplot(economics, aes(uempmed,unemploy)) + geom_point() + geom_smooth(se=F)c &lt;- ggplot(economics, aes(uempmed,unemploy)) + geom_path()library(grid)subvp &lt;- viewport(x=0.75,y=0.35, width=0.4, height=0.4)b # 显示当前要增加子图的图print(c, vp=subvp)## 若要调整子图的属性，要先在外面调整好，再放入主图中； eg: c1 &lt;- c + theme() 属性参考几何对象 - 点 - geom_xx12345678plot# 点 # + stat_smooth() # 添加平滑曲线 dotplot# 点直方图(用点来表示观测值的个数)jitter# 给点添加扰动(减轻重叠问题) point - 散点图几何对象 - 线12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ablineabline(..., slope, intercept, show.legend=NA)# 线(由斜率和截距决定) 指定的斜率和截距geom_abline(slope=1, intercept=0, linetyep=2)hline# 水平线 ; yintercept=n / n1:n2vline# 竖直线 ; xintercept=----------------------------------------------------------------lineline(x,y, alpha, color, fill, linetype, size, arrow)# 按照x坐标的大小顺序依次连接各个观测值path# 路径图(按数据的原始顺序连接各个观测值)step# 以阶梯形式联接各个观测值----------------------------------------------------------------quantile# 添加分位数回归线segment# 添加线段/箭头 ## geom_segment(aes(x=, xend=, y=, yend= ))smooth# 添加光滑的条件均值线## method=smooth(默认) lm-线性; loess-非参数光滑曲线; gam-广义相加模型; glm-广义线性; rlm-健壮线性; ## formula= y~x （默认） y~log(x); y~poly(x,n) -n次多项式拟合; y~ns(x,n) -具有n个自由度的样条拟合## se=T/F 绘制置信区间；默认为T## level=num 默认为95%## fullrange=F/T ,拟合覆盖全图(T)，仅覆盖数据(F) 默认为Fdensity# 光滑密度曲线图density2d# 二维密度等高线图----------------------------------------------------------------lineranglinerang(x,ymin,ymaxn,alpha,color, lineype,size, show.legend=T/F)# 一条代表一个区间的竖直线pointrang# 用一条中间带点的竖直线代表一个区间 几何对象 - 面bar - 条形图 先做出x/y轴，再作图，运用stat ggplot(temp3, aes(content_rating, M)) last_plot() + geom_bar(stat=”identity”) 1234567891011121314151617181920212223242526272829303132333435363738# 条形图(以x轴为底的矩形)图形/位置调整# geom_bar(position="dodge") -分组条形图; (position="fill") -百分比条形图;水平条形图# + coord_flip()堆砌分组条形图（两个类别型变量）# ggplot(hr_good,aes(left,number_project,fill=factor(number_project))) + geom_bar(stat="sum") 调整距离宽度与间距; # width=0.5 -也可以看做x坐标轴之间的分割大小; position=position_dodge(0.7)----------------------------------------------------------------------项目排序 -reorder# 按z值的大小，重新排列条形图的顺序，只需将aes()中x的属性用reorder()函数更改即可; ## ggplot(df, aes(x = reorder(x, z), y = z, fill = y)) +geom_bar(stat = 'identity') + xlab('x')项目排序 -降序排序# 1. arrange(data, M) 升序排列# 2. data$M &lt;- factor(data$M, order=T, levels=data$M)) # 因子化 / data$M &lt;- with(data, factor(var, order=T, levels=var))项目排序 -如果x是因子，我们可以对其用带参数limits=rev(levels(…))的函数scale_x_discrete()进行修正。## + coord_flip() + scale_x_discrete(limits=rev(levels(PlantGrowth$group)))项目排序 -直接修正# 直接用scale_x_discrete(limits=c()) 来修正顺序-----------------------------------------------------------------------添加标签# geom_text(aes(label=var))## hjust/vjust=-0.2 -表示显示在外面; hjust/vjust=1.5 -表示显示在里面添加标签 -对于分组条形图# geom_text(position = position_dodge(0.9))添加标签 -对于堆积条形图# geom_text(position = position_stack()) histogram - 直方图123456789101112调整组距：# 1)binwidth=n # 组距宽度；也可以看做x坐标轴之间的分割大小# 2)bins=n # 组的数量# 3)breaks=c(n, n, n) # 具体的x轴坐标尺度来划分调整分组直方图两者之间重叠程度# position=position_dodge(0.5)密度直方图# histogram(aes(y=..density))在密度直方图基础上，添加核密度曲线## stat_density(geom="line") 其他面图12345678boxplot# 箱线图area# 面积图freqplot# 频率多边形图 几何对象 - 非常规图形漏斗图12345## 漏斗图 # 涉及概念 # 1.占位数 = （上阶段人数 - 当前人数）/2# 2.环节转化率 =当前人数/上阶段人数；# 3.整体转化率 = 当前人数 / 总人数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152## 思路1，利用占位符；条形图---------------------------test----------------------------------------------------library(reshape2)scope&lt;-c(0.9,0.8,0.6,0.4,0.2)Part&lt;-paste("part",1:5,sep="")Order&lt;-1:5 help&lt;-(1-scope)/2 # 表示该值为 两边留空的二分之一mydata&lt;-data.frame(Order,Part,help,scope) Order Part help scope1 1 part1 0.05 0.92 2 part2 0.10 0.83 3 part3 0.20 0.64 4 part4 0.30 0.45 5 part5 0.40 0.2# 重构为长格式mydata1&lt;-melt(mydata,id.vars=c("Order","Part"),variable.name="perform",value.name="scope") Order Part perform scope1 1 part1 help 0.052 2 part2 help 0.103 3 part3 help 0.204 4 part4 help 0.305 5 part5 help 0.406 1 part1 scope 0.907 2 part2 scope 0.808 3 part3 scope 0.609 4 part4 scope 0.4010 5 part5 scope 0.20# 构造有序因子变量，两个因子水平，分别是实际指标值和辅助值# 【关键1】在构造有序因子变量时，注意辅助值因子水平要高于实际值数据。柱形图堆叠时，【关键2】按照因子水平由高到低堆叠（底层因子水平高，顶层因子水平低，这样才能将指标值的数据条撑起，其实水平均居中）。mydata1$perform&lt;-factor(mydata1$perform,level=c("scope","help"),order=T) -----------------------------绘制图形--------------------------ggplot(mydata1,aes(Order,scope,order=desc(scope),fill=perform))+geom_bar(stat="identity",position="stack") # 即先堆叠高水平help，然后再堆叠低水平scope；# 制作色盘：（其实使用了一个白色色值隐藏掉了辅助列，理念跟在excel里面制作漏斗图一致，但是色盘颜色顺序白色要在第一个，这样将来颜色映射的时候颜色顺序与因子水平由大到小进行匹配的。）这一点非常重要，也是ggplot临摹漏斗图的核心技巧。Color&lt;-c("#FFFFFF","#088158")ggplot()+geom_bar(data=mydata1,aes(x=Order,y=scope,fill=perform),stat="identity",position="stack")+scale_fill_manual(values=sort(Color))+ # sort表示重新排序；因为颜色的填充是低水平(scope)，在高水平(help)进行填充geom_text(data=mydata,aes(x=Order,y=help+scope/2-.025,label=Part),col="white",size=4)+geom_text(data=mydata,aes(x=Order,y=help+scope/2+.035,label=paste(100*mydata$scope,"%",sep="")),col="white",size=5.5)+theme_nothing()ggplot()+geom_bar(data=mydata1,aes(x=Order,y=scope,fill=perform),stat="identity",position="stack")+scale_fill_manual(values=sort(Color))+ coord_flip()+ scale_x_reverse() + # 顺时针旋转geom_text(data=mydata,aes(x=Order,y=help+scope/2-.05,label=Part),col="white",size=4)+ # 标签位置设定geom_text(data=mydata,aes(x=Order,y=help+scope/2+.05,label=paste(100*mydata$scope,"%",sep="")),col="white",size=5.5)+theme_nothing() –1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859## 思路2，利用箱线图set.seed(123) #设定随机种子，保证做的图和这里的一样df &lt;- data.frame( var=LETTERS[1:10], #字母A-J id=1:10, #数字1-10 a=runif(10), #10个随机数 b=runif(10), #10个随机数 c=runif(10), #10个随机数 stringsAsFactors = F #不转换为因子) var id a b c1 A 1 0.2875775 0.95683335 0.88953932 B 2 0.7883051 0.45333416 0.69280343 C 3 0.4089769 0.67757064 0.64050684 D 4 0.8830174 0.57263340 0.99426985 E 5 0.9404673 0.10292468 0.65570586 F 6 0.0455565 0.89982497 0.70853057 G 7 0.5281055 0.24608773 0.54406608 H 8 0.8924190 0.04205953 0.59414209 I 9 0.5514350 0.32792072 0.289159710 J 10 0.4566147 0.95450365 0.1471136df_tmp4&lt;-df %&gt;% select(1:3) %&gt;% arrange(a) %&gt;% mutate(new_id=1:10, # 创建新变量，以此为排序 ymin = (1-a)/2, # 最小值，左边留空的值 ymax = a+(1-a)/2, # 最大值，右边留空的值 mid = 0.5) var id a new_id ymin ymax mid1 F 6 0.0455565 1 0.47722175 0.5227782 0.52 A 1 0.2875775 2 0.35621124 0.6437888 0.53 C 3 0.4089769 3 0.29551154 0.7044885 0.54 J 10 0.4566147 4 0.27169263 0.7283074 0.55 G 7 0.5281055 5 0.23594726 0.7640527 0.56 I 9 0.5514350 6 0.22428249 0.7757175 0.57 B 2 0.7883051 7 0.10584743 0.8941526 0.58 D 4 0.8830174 8 0.05849130 0.9415087 0.59 H 8 0.8924190 9 0.05379048 0.9462095 0.510 E 5 0.9404673 10 0.02976636 0.9702336 0.5---------------------------------------------ggplot(df_tmp4,aes(new_id,mid)) + # x轴为对应的各个指标 geom_linerange(aes(ymin=ymin,ymax=ymax, colour=factor(new_id)), size=15, alpha=0.5,show.legend = F)+ scale_x_continuous(breaks = 1:10, labels = df_tmp4$var)+ coord_flip() ------------------------------------------- ggplot(df_tmp4,aes(new_id,mid))+ # geom_step(colour="grey50")+ geom_crossbar(aes(ymin=ymin,ymax=ymax), size=0, fill="skyblue", colour="grey50", width=1)+ scale_x_continuous(breaks = 1:10, labels = df_tmp4$var)+ coord_flip() 其他图形1234567errorbar# 误差棒errorbarh# 水平误差棒rug# 边际地毯图(轴须图) – 1234567891011121314151617181920212223242526272829303132blank# 空白contor# 等高线图crossbar# 带水平中心线的盒子图hex# 六边形二维热点图map# 基准地图里多边形ploygon# 多边型(相当于一个有填充的路径)raster# 高效的矩形瓦片图rect# 二维矩阵图ribbon# 色带图(连续的x值所对应y的范围)violin# 小提琴图tile# 瓦片图 text - 文本注释123456789101112131415161718192021222324252627282930313233343536373839404142geom_text()geom_text(aes(label=var)) / geom_text(aes(label=rownames(var))) (x,y, alpha=, color=, size=, hjust=, vjust=,,nudge_x=0,nugde_y=0, angle=, fontface=, family=, lineheight=, show.legend=NA/F/T, check_overlap=F, na.rm=F )# hjust=0(右侧)，=1(左侧)，=0.5(居中，默认)；若小于0，则继续向右# vjust=0(向上)，=1(向下), =0.5(居中，默认); 若小于0，则继续向上；## vjust/yjust ，可以是 0(right/bottom) 和 1(left/top)，或者是字符串("left","right","middle","bottom","center","top"); 或者是 字符串 ("inward","outward")## nudge_x=2.5 ，x轴方向，向右微调2.5# 常用字体大小 size=4 ; 5.5; ## 标签显示为百分比label=paste(100*mydata$scope,"%",sep="")# ggplot() + geom_text(data=mydata,aes(x=Order,y=help+scope/2+.035,label=paste(100*mydata$scope,"%",sep="")),col="white",size=5.5)p &lt;- ggplot(mtcars, aes(x=wt, y=mpg, label=rownames(mtcars)))p + geom_text()p + geom_text(size=10) # Change size of the label[变更标签的大小]p &lt;- p + geom_point()# Set aesthetics to fixed value[设置为固定值的美学]p + geom_text()p + geom_point() + geom_text(hjust=0, vjust=0)p + geom_point() + geom_text(angle = 45)# Add aesthetic mappings[审美映射]p + geom_text(aes(colour=factor(cyl)))p + geom_text(aes(colour=factor(cyl))) + scale_colour_discrete(l=40)p + geom_text(aes(size=wt))p + geom_text(aes(size=wt)) + scale_size(range=c(3,6))# Add an annotation not from a variable source[添加注释，而不是从一个变量源]c &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()c + geom_text(data = NULL, x = 5, y = 30, label = "plot mpg vs. wt")# Or, you can use annotate[或者，您可以使用注释]c + annotate("text", label = "plot mpg vs. wt", x = 2, y = 15, size = 8, colour = "red")---------------------------------------------------------------------------------------geom_label() # draws a rectangle behind the text, making it easier to read. aes(label=rownames(var)) 可在任何几何对象中出现 geom_point(aes(laber=rownames(var))) 图形属性linetype 符号 描述 1 solid - 实线 2 dashed - 虚线 3 dotted - 点 4 dotdash - 破折号 5 longdash - 长破折号 6 twodash - 双破折号 position 符号 描述 示例 stack 堆叠 堆砌条形图 fill 堆叠并高度标准化为1 百分比堆砌条形图 dodge 避免重叠，并排放置 分组条形图 jitter 给点添加扰动，避免重叠 identity 不做任何调整 identity ，不适合条形图，因为后面画的条形会挡住先画的 side地毯图geom_rug的位置； 符号 描述 b 底部 l 左侧 r 右侧 t 顶部 bl 左下 “tl” 、 “tr”、”br” 左上、右上、右下 shape fontface1fontface= "plain", "italic", "bold", "bold.italic" 统计变换常用统计变换 统计变换 描述 stat_identity 不做任何统计变换 stat_boxplot 计算组成箱线图的各种元素值 stat_density 一维密度估计 stat_density2d 二维密度估计 stat_smooth 添加拟合曲线 stat_summary 对每个x所对应的y值做统计描述 stat_unique 删除重复值 stat_bin count - 直方图 density - 频率多边形图 1234567密度直方图# ggplot(diamonds, aes(carat)) + geom_histogram(aes(y=..density..), binwidth=0.1) 添加拟合曲线# p &lt;- ggplot(diamonds, aes(x=carat,y=price,color=cut))# p + geom_point(color='green',alpha=0.2)+ stat_smooth() 统计变换 stat_xx 统计变换 描述 stat_bin 计算封箱(bin)数据 bin2d 计算封箱内的观测值个数 bindot 计算“点直方图”封箱数据 binhex 计算“六边形热图”封箱数据 boxplot 计算组成箱线图的各种元素值 contour 三维数据的等高线 density 一维密度估计 density2d 二维密度估计 function 添加新的函数 identity 不对数据进行统计变换 qq 计算qq图的相关值 quantile 计算连续的分位数 smooth 添加光滑曲线 spoke 将角度和半径转换成xend和yend sum 计算每个单一值的频数[有助于解决散点图的图形重叠问题] summary 对每个x对应的y值做统计描述 summary2d 对二维矩形封箱设定函数 summaryhex 对二维六边形封箱设定函数 unique 删除重复值 ydensity 小提琴图，计算一维y轴方向的核密度函数的估计值 作图规范标准作图规范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ggplot(mtcars, aes(disp,hp)) # 绘制对象(数据，图形属性aes) + geom_point(aes(color=factor(cyl))) # 图层(几何对象)-设定;若要分组，必须为因子factor变量 # geom_point(color="blue") # 图层(几何对象)-映射 # stat_(） # 统计变化 + goem_text(aes(label=cyl, color=cyl), size=, vjust=0.5,hjust=0.5,nudge_x=0.5, nudge_y=0.5, show.length=F) # 标签; hjust=0(向右),vjust=0(向上); nudge_x=0.5 向x轴方向微调0.5+ annotate("text", x = 4, y = 25, label = "Some text")+ xlim(0,10) # x轴的定义域，表示只选取该范围内的数值进行作图；超出部分则删除; # xlim(0,max(mtcars$disp)) # 必须有data$var # xlim("a","b","c") # 离散型 # xlim(as.Date(c("2008-05-01","2008-08-01")) # 日期型 + sacle_y_continuous( limits=c(min(mtcars$hp),300), breaks=c(100,150,400), # =c(seq(0,200,20)) 指定坐标轴上应显示哪些刻度线的值 或一个连续型标度在一个图例中将被如何分段（即显示哪些刻度的值） labels=c("100k","150k","400k") # 指定了应在断点处显示的标签 + labs(x="", y="", title="", subtitle="") # 坐标轴的标签名称 + scale_x_discrete(breaks=rev(levels(mtcars$hp))) # 转置 # scale_x_reverse() # 转置-连续型变量 + scale_y_continuous(breaks=seq(0, 420, 30)) + scale_x_continuous(breaks=seq(0, 420, 15))# 设置x/y轴显示的相对比例; 同 coord_equal(ratio=) + sacle_color_brewer(palette="") + scale_fill_hue() # 离散型标度的颜色设置 # scale_color_manual(values=c()) 手动自定义设置颜色 # scale_color_gradient（low="", high="") 连续型标度的颜色设置； 双色； + guides(fill=guide_legend((title=, title.position="top",label.position="top", nrow=2,reverse=F) # 设置图例 # guides(fill=FALSE) 删除图例 + facet_grid(.~ y, margins=T, space="fixed") # 网格型分面 margins=c("col","col") 所需展示的边界图的变量 # facet_wrap(~y, ncol=2, scales="free_x") # 封装型分面+ coord_flip() # 坐标轴翻转+ coord_equal(ratio=2, xlim, ylim) y/x轴的比例 + theme1 # theme1 &lt;- theme_minimal() + theme(plot.title=element_text(hjust=0.5, face="bold"), axis.line =element_line(linetype=1))+ theme(axis.line=element_line(linetype=1,size=1), axis.title.x=element_text(), panel.grid.minor=element_blank(), plot.title=element_text(face="bold",size=, hjust=0.5), plot.background=element_rect(fill=,color=)) # theme(主题元素= 主题性质) axis/legend/panel/plot/strip+ plot.margin = unit(c(1,1,1,1),"lines") # 图形边界 top/right/bottom/left grid.arrange(p1,p2,...pn, nrow=2) # library(gridExtra) 组图--------------------------------------------------------------------ggplot(data=, aes(x=, y= )) + geom_xx(...) + stat_xx(...) + annotate(...) + scale_xx(...) + coord_xx(...) + guides(...) + theme(...)# mtcars，R中自带的数据集 可对图形分别进行设定与修改 - 基础图形可被保存 123456创建绘图对象# p &lt;- ggplot(mtcars, aes(x=mpg, y=wt))设定与修改p + geom_point(aes(colour=factor(cyl))p + geom_point(aes(y=disp)) – 1234做不同运算的图形# ggplot(huron, aes(year))+ geom_line(aes(y=level-5), color="blue")+ geom_line(aes(y=level-5), color="red") 作图问题图形基本处理 矢量图形(PDF, PostScript, SVG，AI,) 位图(PNG, JPEG, TIFF，bmp，jpg) 123456789101112summary() # 查看结构print() # 呈现-----------------------------------------------------------------------------------保存ggsave() # 保存到磁盘--ggsave("name.png", [plot=plot_name] width=, height=) # plot_name为创建图像的名称；若忽略，则对最佳的图像保存save() # 缓存保存到磁盘; 可保存一个图形对象的完整副本，并可用load()来重现该函数 图片保存21.5寸显示频：1920px $\times$ 1080px （比值 = 1.7777） 电脑显示频 -16:9 （比值 = 1.777） 电脑显示频 - 4:3 （比值 = 1.333） savePlot 的妙用（在R中的使用，非Rstudio） 1234567savePlot(filename = "Rplot", type = c("wmf", "emf", "png", "jpg", "jpeg", "bmp", "tif", "tiff", "ps", "eps", "pdf"), device = dev.cur(), restoreConsole = TRUE)# JPEG quality is 75% ; TIFF 无压缩。# 所以这个命令在Rstudio上没法运行，在在R编辑器下运行成功 粘贴复制（rstudio） 1234export - copy to clipboard生成图片以后，点击copy to clipboard,调整合适的大小，然后选择copy as的类型（bitmap,metafile）, 确认后，然后就可以将图片粘贴到你想要他到的地方了，得到的是矢量图(metafile)# 点击 export默认的单位是像素 导出高清的图 1234567891011121314151617181920212223242526272829303132333435tiff(filename = "test.tif",width = 15,height = 18,units ="cm",compression="none",bg="white",res=600)# res设置图片分辨率; units指定长宽的单位，px(oixeis,默认的)，in(inches),cm或者mm。compression为压缩方式，lzw压缩之后图片较小。可选的方式为none,rle,zlw,jpeg,zip。dev.new()pdf(file="example.pdf", width=12, height=8) #矢量图，pdf格式svg(file="example.svg", width=12, height=8) #矢量图，svg格式tiff(file="example.tiff", width=12, height=8， units="in", compression="lzw", res=150) #位图，tiff格式，常用于文章投稿。dev.off()# 默认的单位unit是英寸ggsave("myplot.png", width=8, height=8, unit="cm", dpi=300)------------------------------------------------------------------------------改变字体 install.packages("extrafont")library(extrafont) # Find and save information about fonts installed on your systemfont_import() # List the fontsfonts()After the one-time setup is done, there are tasks you need to do in each R session:library(extrafont) # Register the fonts with Rloadfonts() # On Windows, you may need to tell it where Ghostscript is installed# (adjust the path to match your installation of Ghostscript)Sys.setenv(R_GSCMD = "C:/Program Files/gs/gs9.05/bin/gswin32c.exe") # Finally, you can create a PDF file and embed fonts into it, as in Figure 14-4:library(ggplot2)ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point() + ggtitle("Title text goes here") + theme(text = element_text(size = 16, family="Impact"))ggsave("myplot.pdf", width=4, height=4)embed_fonts("myplot.pdf") 图片不清晰R中生成的图片，保存为.tiff格式，有3M，在word里还是模糊 一般情况下，如果需要在word中插入图片，分为两种方法：复制黏贴与插入图片菜单。同时，由于word文档往往为表述性质使用，因此并不需要分辨率很高的图片，像我个人使用都是800*600的jpg格式,单张图片尺寸保持在100k~200k之间刚好。然后如果插入图片较多，往往会造成word文档尺寸较大，不便于使用MMS工具传输，所以会使用wrod中的图片处理工具压缩文档中的所有图片。 关于图片模糊，事实上在给定显示设备参数不变的状态下会有两种情况，一种是图片分辨率太低，还有一种是图片分辨率太高。解决方法是根据你最终输出的需求（出版物，电子文档等）来调整相应输出设备分辨率参数，并把其作为模版保存下来即可 为图形添加注释 - annotate1234567891011# 一次只添加一个位置上的图形当x/y轴均为连续型的数值变量时，当annotate中的x/y引用对象时，必须是数值，可用as.numeric()来转换# peak &lt;- filter(data, var==max(var))# peak_x &lt;- as.numeric(peak[1,1])# peak_y &lt;- as.numeric(peak[1,2])p + annotate("text", x = 4, y = 25, label = "Some text")p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21, alpha = .2)p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25, colour = "blue")p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,colour = "red", size = 1.5) 项目排序顺序12345678910111213先设置好顺序 - factor按当前排序来指定顺序# data$col &lt;- factor(data$col, levles=data$col, order=TRUE)## arrange(data, col) 升序排列自定义顺序# data$col &lt;- factor(data$col, levels=c("col1","col2"),order=TRUE)----------------------------------------------------------------------------------标度变换# scale_x_discrete(limits=c("col","col")# scale_x_discrete(limits=data$col) 遮盖问题 图形相互覆盖无法看清 12345678910111213141516171819点的大小与形状 # geom_xxx(shape=)## shape=1(中空的点)## shape="." (像素大小的点)透明度；最小透明度为1/256# geom_xxx( alpha = [1/256 ,1] )添加随机扰动 - jitter ；[当数据存在一定离散性]# td &lt;- ggplot(diamonds, aes(table,depth)) + xlim(50,70) + ylim(50,70)## 直接添加 - td +geom_point ; td + geom_jitter() # 默认扰动量为40%## 调整后变更扰动率 - jit &lt;- positon_jitter(width=0.5); td +geom_jitter(position=jit)将点分箱，并统计每个箱中点的数量，在可视化这个数量# d &lt;- ggplot(diamonds, aes(carat,price)) + xlim(1,3) # 此时并无图形显示# d + stat_binhex() # 默认分箱数 # 即使没有几何对象也能做出图形# d + stat_binhex(bins=10) # 共10个封箱 # 默认为30个用stat_density2d做二维密度估计，并将等高线添加到散点图中 含权重数据 点/线 - size = 权重变量 复杂情况 - weight = 权重变量 ​ 交互式作图 - ggplotly12library(plotly)ggplotly(object) 统计摘要：为统计量绘图12345单独的摘要计算函数# fun.y / fun.ymin / fun.ymax统一的摘要统计函数# fun.data]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[德国为什么会崛起_罗辑思维]]></title>
      <url>%2F2017%2F03%2F26%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E5%BE%B7%E5%9B%BD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%B4%9B%E8%B5%B7_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_201708%2F</url>
      <content type="text"><![CDATA[城市。是先有人的聚集。人为什么要聚集，因为分工越来越细，人们需要相互协作。人口密度越来越大，所以才有了大楼。为了加上协作，所以才有了公路，车辆，火车。德国能够快速崛起，很重要的一点是人，但不仅仅是人，他们的能力，而是他们的思维，或者说他们整体的思维意识。 ​ 好的精细的社会结构。判断标准是不是促进人的主观能动性。 ​ 社会经济的发展，最底层的保障是组装力量。它保障了最后的社会底线。使得商人对未来报有希望，对契约与信任有认同，所以才会有投资的出站。 ​ 一个国家的开放主要是两点。 第一，对外开放。把自己的东西出口，把好的东西引进来。这个基本大家都知道。 第二，对内开放。就是国内人们可以在不同的社会阶层之间流动。比如说，我们看到现在的高层富人，几十年前都是屌丝，他们通过自己努力进去到了新的阶层。如果你不好好努力，你就会变成屌丝。这就极大促发了人的主观能动性。如果存在严重的阶级分层，且无法流动。那想一想会是如何。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创新是怎么发生的？_罗辑思维]]></title>
      <url>%2F2017%2F03%2F25%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E5%88%9B%E6%96%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_201708%2F</url>
      <content type="text"><![CDATA[《创新是树也是网》创新。人的特性。不是单一性的，而是多纬度的。如果想要知道一个点的意义，你必须要把它放到整个网状中去评判。 《创新是怎么发生的？》阅读是自己与自己交流的过程。我们读书，肯定是先有一个问题，然后通过读书去解答这个问题。 创新，它不是一个目的性的活动。不是通过理性设立一个目标，你通过资源去匹配它，就冷达到的。 世界也不是一个纯理性的世界，不是都由因果关系组成的。因果关系，是人类理性发展出来的。比如大雁南飞，这不是一个因果性的行为，对它来说而是一个程序性的本能活动。对于孩子，很爱问为什么。为什么太阳从东边升起来，地球为什么会转，为什么是这样转的？等等。 西方有一个研究，说孩子的理性促发，可能就是对按开关灯会亮这个现象所最早促发的。 过去永远都不会死，甚至从未过去。 一夫一妻:人类文明伟大的结果。其他物种会出现2种情况:第一，群居。母的是抵御天敌。但对孩子的父亲归属是模糊的。第二，独居。虽然明确了孩子的归属，但缺失了群居的优势。以上这两点都会使得繁衍后代的速度变慢。因为母亲长年承担了抚育孩子的任务。唯独人类，既是独居一夫一妻，又获得了群居的协作。当两个结合在一起得时候，就能使得繁衍的速度大大加快。因为孩子的父亲能从外面找食物，大大缩短了母亲的哺乳期。理论上可以二年，甚至一年一胎。15万年-2万人6万年前-100万人1万年前，600万人。公元1世纪，2.5亿人核心有两个: 农业+一夫一妻制 在长达过去的所有历史中，是没有恋爱，是没有爱情的。婚姻，是为了繁衍后代，是为了绑定财产。目的论包装过后就被称为了进化论。认为，我们的一夫一妻制是进化而来的，认为我们发展了，道德高尚了。但现在生物学研究发现，在4000多种哺乳动物，，天然有120多种，就是一夫一妻制。在灵长类动物中，比较上升到18%。二态性，雄性比雌性大。二态性高，倾向于群居。二态性高，倾向于独居。人类，这两个方面都有一定的倾向。最后定格在一夫一妻。由一种假说: 因为狩猎。1.狩猎一定需要合作。而合作需要公平，对性资源的分配上是公平的。2.只要开始狩猎，人类就开始发明武器，那就拉平了体格方面的差距。比如发明一个棍子。人类创新创造是一个偶然获得了一个动因，然后发展了一个制度（副产品）。对于乱伦与近亲结婚，现在医学解释是体质的关系。但在历史上，两个假说:1.两个孩子从小在一起长大的人，对彼此没有兴趣。2.保护现有的社会关系的确定性。比如一个父亲跟他的女儿生下的孩子，那个男人是这个孩子的父亲？外公？一旦开始外婚制，产生了第二个社会关系，从而产生相互协作（副产品） 农业把人类从其他物种隔离开来。 1.要定居。2.要存储，要提高产量，发明工具。要交换。一个复杂社会的产生。私有财产制度的产生。 但农业是怎么来的？原始社会的生活水平不低。劳动时间也就6个小时。摄入的能量也是2000大卡路里。 这是现在医学研究出来，多了就变成胖子。而且他们几乎没有饿死。 大面积的饥荒，饿死是农业发明以后才发生的。 农业，是上天的恩赐。就是突然有一片地方，长出了食物，没有人劳动。这部分人，想要一直享受这样的食物，就要定居。然后因为有了食物的保障，就更方便繁衍，然后人口激增，食物短缺。这就需要有人出来进行劳动。农业。一种互驯。人以为改变了环境，而环境由于约束了人类。 郑也夫 《文明是副产品》 《信任论》 《代价论》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server_性能优化]]></title>
      <url>%2F2017%2F03%2F23%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FSQL-Server%2FSQL-Server_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[SQL Server 查询逻辑与性能优化 6.1 查询流6.1.1 Select 语法 Select语句的From部分将所有数据源组装进一个结果集，然后由Select语句的剩余部分对结果集执行操作。 Where子句作用于From组装的记录集，根据条件筛选某些行。 聚合函数对数据集执行求和操作。 Group by 子句根据在该子句中指定的列将大量数据集分组成较小的数据集。 Having 对较小的数据组执行聚合函数。 Order by 子句确定结果子的排列顺序。默认为升序； 12345678Select [Distinct] [Top(n)] *, columns, or expressions [From data source(s)] [Join data source ON condition] (may include multiple joins) [Where conditions] [Group by columns] [Having conditions] [Order by columns]; 6.1.3 查询语句的逻辑流数据源(From) —— 条件(Where) —— 列/表达式 (col/exp) —— Order by — 谓词 From，查询首先组装初始数据集。 Where，筛选；筛选过程实际上是选择符合标准的行的where子句。 Group by，组合数据的子集 [若要分组，先对数据排序，然后根据排序后的数据进行聚合] 聚合，Aggregations，选择性地对数据进行聚合；如求平均值，按列中的值对数据分组以及筛选组； Having，筛选数据的子集 列表达式：处理Select列，并计算任何表达式 [ 这个时候才涉及到列 ] Order by，排序 Over，窗口函数和排名函数通过与其他聚合函数一起提供结果的单独排序的视图 Distinct，从结果集中删除任何重复的行 Top，选定行后，执行计算，并按所需的顺序排序 Insert,Update,Delete，最后一个逻辑步骤是将数据修改操作应用到查询结果。 Output，选择插入和删除的虚拟表，并返回给客户端 Union，堆叠或合并多个查询的结果 6.2 From子句6.2.3 表名称 方括号：表名或字段名如果引用了sql server中的关键字，数据库会不识别这到底是关键字还是表名（还是字段名）时就必须要加； 查询语句的表中加上方括号[ ] ， 目的是以声明其不是保留字 ； 如果表名不是关键字，不用加方括号 6.2.4 完全限定的名称 Server.Database.Scheme.Table；服务器.数据库.架构.表名称 常使用后两部分来限定即可； 6.3 Where条件 最佳实践：找到事物的最好办法就是查找，而不是先排除不是该事物的所有东西。即where条件，声明肯定的限制条件优于否定的限制条件； 1where col &gt;= 10 ; 优于 where col !&lt; 9 惊叹号! ，不是ANSI标准的SQL； 6.3.1 Between And1234567891011# 使用带有日期时间值的 BETWEEN WHERE RateChangeDate BETWEEN &apos;2001-12-12&apos; AND &apos;2002-01-05&apos;; ----下面的示例检索所在的行【datetime值】可以介于&apos;20011212&apos;和&apos;20020105&apos;(含） 之间;因为在查询中的日期值和datetime值存储在RateChangeDate而无需在日期的时间部分中指定了列。-- 下面是结果集：BusinessEntityID RateChangeDate----------- -----------------------3 2001-12-12 00:00:00.0004 2002-01-05 00:00:00.000----未指定时间部分时，将默认使用 12:00 A.M。 --请注意，若某行的时间部分晚于 2002-01-05 12:00 A.M.， 则由于它处于范围之外，因此此查询不返回该行。 6.3.2 与列比较 如果函数用于where子句中的测试列，那SQL Server 在筛选where子句前被迫对每一行计算该函数； 123--正确的写法； where col = 130 -30--避免的情况； where col + 30 =130 对于NOT IN条件来说，如果列表中有NULL值，每行都别判定为FALSE； 证明否定命题是很难的，尤其是当NULL值也包括在内时； 123Select &apos;IN&apos; where &apos;A&apos; Not In (&apos;B&apos;, &apos;C&apos;); 返回 INSelect &apos;IN&apos; where &apos;A&apos; Not In (&apos;B&apos;, &apos;NULL&apos;); 返回空 6.3.3 使用Like搜索条件 运算符 含义 示例 % 任意长度的字符串 Email Like ‘%@%.com’ ‘_’ 任意一个字符 AuthorName Like ‘张_’ [ ] 在指定范围内的任意一个字符 A Like ‘A6C8[1-5]’ [^] 不在指定范围内的任意一个字符 A Like ‘A6C8[^1-6]’ 查找含通配符的表达式： 把通配符放入方括号[ ] 内 在其之前放一个转义符 6.3.4 多个where条件 布尔逻辑运算的优先次序： NOT &gt; AND &gt; OR 12345678910Where name Like &apos;Chain%&apos; or ProductID Between 320 And 324 And name Like &apos;%s%&apos; --1. 先执行And，即找出name中 带有 s 的名字；--2. 再在其中寻找 name中有Chain 或者 ProduceID在[320,324]------------------Where (name Like &apos;Chain%&apos; or ProductID Between 320 And 324 ) And name Like &apos;%s%&apos;--1. 先执行括号，即先找出name中有Chain 或者 ProduceID在[320,324]--2. 再在其中找出name中 带有 s 的名字； what： why ： how ： what： why ： how ：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server 2012宝典_读书笔记]]></title>
      <url>%2F2017%2F03%2F22%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FSQL-Server%2FSQL-Server2012%E5%AE%9D%E5%85%B8_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[《SQL Server 2012 宝典》读书笔记 第一部分 入门第2章 数据架构2.2 数据库目标OLTP what：联机事务处理过程（On-Line Transaction Processing），也称为面向交易的处理过程 why ：最大优点是可以即时地处理输入的数据，及时地回答。 how ：基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果 ETL what：数据仓库技术；用来描述Extract(抽取) - Transform(转换)- Load(加载)至目的端的过程。 why ：数据仓库利用提取-转换-加载(ETL)过程将各种格式的数据和框架转换为便于数据检索的通用格式，以从整个企业的多个数据存储中收集大量数据。 how ：用户从数据源抽取出所需的数据，经过数据清洗，最终按照预先定义好的数据仓库模型，将数据加载到数据仓库中去 2.3 智能数据库设计物理架构 what：包括数据库的表、列、主键、外键与约束。 瀑布式开发 vs. 敏捷式开发 瀑布式开发：经历4个项目阶段：需求收集、设计、开发和实现。虽然这种方法可能对一些工作有效，但当创建软件时，用户往往直到看到了才知道他们想要的是什么。这是往往已经进入了开发阶段。 敏捷式开发：用大量短周期或迭代替代单个较长的开发过程，从而解决这个问题。每次迭代都构建了可测试的工作模型，并且用户能够使用软件，从而进一步发现他们的需求。当用户看到进展迅速并相信可以添加新特性时，他们会更愿意在软件的生命周期内引入更多特性，而不是检查在下一个版本中实现。 第二部分 建立数据库和处理数据第6章 基本的查询流6.1 查询流6.1.1 Select 语法 Select语句的From部分将所有数据源组装进一个结果集，然后由Select语句的剩余部分对结果集执行操作。 Where子句作用于From组装的记录集，根据条件筛选某些行。 聚合函数对数据集执行求和操作。 Group by 子句根据在该子句中指定的列将大量数据集分组成较小的数据集。 Having 对较小的数据组执行聚合函数。 Order by 子句确定结果子的排列顺序。默认为升序； 12345678Select [Distinct] [Top(n)] *, columns, or expressions [From data source(s)] [Join data source ON condition] (may include multiple joins) [Where conditions] [Group by columns] [Having conditions] [Order by columns]; 6.1.3 查询语句的逻辑流数据源(From) —— 条件(Where) —— 列/表达式 (col/exp) —— Order by — 谓词 From，查询首先组装初始数据集。 Where，筛选；筛选过程实际上是选择符合标准的行的where子句。 Group by，组合数据的子集 聚合，Aggregations，选择性地对数据进行聚合；如求平均值，按列中的值对数据分组以及筛选组； Having，筛选数据的子集 列表达式：处理Select列，并计算任何表达式 [ 这个时候才涉及到列 ] Order by，排序 Over，窗口函数和排名函数通过与其他聚合函数一起提供结果的单独排序的视图 Distinct，从结果集中删除任何重复的行 Top，选定行后，执行计算，并按所需的顺序排序 Insert,Update,Delete，最后一个逻辑步骤是将数据修改操作应用到查询结果。 Output，选择插入和删除的虚拟表，并返回给客户端 Union，堆叠或合并多个查询的结果 6.2 From子句6.2.3 表名称 方括号：表名或字段名如果引用了sql server中的关键字，数据库会不识别这到底是关键字还是表名（还是字段名）时就必须要加； 查询语句的表中加上方括号[ ] ， 目的是以声明其不是保留字 ； 如果表名不是关键字，不用加方括号 6.2.4 完全限定的名称 Server.Database.Scheme.Table；服务器.数据库.架构.表名称 常使用后两部分来限定即可； 6.3 Where条件 最佳实践：找到事物的最好办法就是查找，而不是先排除不是该事物的所有东西。即where条件，声明肯定的限制条件优于否定的限制条件； 1where col &gt;= 10 ; 优于 where col !&lt; 9 惊叹号! ，不是ANSI标准的SQL； 6.3.1 Between And1234567891011# 使用带有日期时间值的 BETWEEN WHERE RateChangeDate BETWEEN &apos;2001-12-12&apos; AND &apos;2002-01-05&apos;; ----下面的示例检索所在的行【datetime值】可以介于&apos;20011212&apos;和&apos;20020105&apos;(含） 之间;因为在查询中的日期值和datetime值存储在RateChangeDate而无需在日期的时间部分中指定了列。-- 下面是结果集：BusinessEntityID RateChangeDate----------- -----------------------3 2001-12-12 00:00:00.0004 2002-01-05 00:00:00.000----未指定时间部分时，将默认使用 12:00 A.M。 --请注意，若某行的时间部分晚于 2002-01-05 12:00 A.M.， 则由于它处于范围之外，因此此查询不返回该行。 6.3.2 与列比较 如果函数用于where子句中的测试列，那SQL Server 在筛选where子句前被迫对每一行计算该函数； 123--正确的写法； where col = 130 -30--避免的情况； where col + 30 =130 对于NOT IN条件来说，如果列表中有NULL值，每行都别判定为FALSE； 证明否定命题是很难的，尤其是当NULL值也包括在内时； 123Select &apos;IN&apos; where &apos;A&apos; Not In (&apos;B&apos;, &apos;C&apos;); 返回 INSelect &apos;IN&apos; where &apos;A&apos; Not In (&apos;B&apos;, &apos;NULL&apos;); 返回空 6.3.3 使用Like搜索条件 运算符 含义 示例 % 任意长度的字符串 Email Like ‘%@%.com’ ‘_’ 任意一个字符 AuthorName Like ‘张_’ [ ] 在指定范围内的任意一个字符 A Like ‘A6C8[1-5]’ [^] 不在指定范围内的任意一个字符 A Like ‘A6C8[^1-6]’ 查找含通配符的表达式： 把通配符放入方括号[ ] 内 在其之前放一个转义符 6.3.4 多个where条件 布尔逻辑运算的优先次序： NOT &gt; AND &gt; OR 12345678910Where name Like &apos;Chain%&apos; or ProductID Between 320 And 324 And name Like &apos;%s%&apos; --1. 先执行And，即找出name中 带有 s 的名字；--2. 再在其中寻找 name中有Chain 或者 ProduceID在[320,324]------------------Where (name Like &apos;Chain%&apos; or ProductID Between 320 And 324 ) And name Like &apos;%s%&apos;--1. 先执行括号，即先找出name中有Chain 或者 ProduceID在[320,324]--2. 再在其中找出name中 带有 s 的名字； 6.4 列、星号、别名和表达式6.4.2 别名 要使用与SQL Server关键字相同的别名或包含空格的别名，可将别名让入方括号[]、单引号’’或双引号””。 插入某个列均为x的值，只要在Select中添加’x’即可 1Select Name, &apos;x&apos;, Name+sex From table 6.5 结果集排序6.5.1 通过列名称来指定顺序 Order by 排序列可以不必是Select返回的列 order by子句和选择列表中的列的顺序完全无关 6.5.2 使用表达式来指定顺序 在Order by子句中，可以使用表达式 123456789Order by LastName + FirstName;----------------------------------Order by Case When Left(description, 5) = &apos;This &apos; Then Stuff(description, 1, 5, &apos;&apos;) Else description End;--根据Case的不同情况来进行排序 6.5.3 使用列别名指定顺序 Order by 子句允许别名存在，是因为逻辑上Order by 子句在组合列和别名后执行； Where子句不可使用别名，因为在逻辑上在处理列及表达式前先执行Where子句 6.5.4 使用列的顺序位置来进行排序 （若改变了选择的列，则列的位置顺序会发生更改）6.6 Select Distinc 从查询的结果集中删除重复的行 6.7 Top( ) 谓词6.7.1 With Ties 允许最后的位置包含多行，但这多行是完全相同的 1Select top (10) With Ties listprice From ... 6.7.2 随机行选择 使用Top(1) 返回单行，且用Newid()随机排序结果；每次将返回一个随机值 涉及到较大的表时，可用Tablesample( n Percent/Rows)选项 由于是随机选择，可通过Repeatable()来指定 [效果同R语言中的set.seed()] 123Select top(1) Lastname From person.person Tablesample(10 Percent) -- 随机选择10%的 Repeatable(1234) Order by Newid(); --随机排序结果集 第7章 关系数据库设计和创建物理数据库架构7.1 数据库基础知识7.1.2 表、行和列 一个行 = 一个项 一个列 = 该项相关的具体数据片段 一个单元格 = 单个项的单个数据部分 7.1.3 数据库设计阶段 DDL what：数据库模式定义语言DDL(Data Definition Language)。用于描述数据库中要存储的现实世界实体的语言。 how ：DDL数据库模式定义语言是SQL语言（结构化查询语言）的组成部分。 SQL语言包括四种主要程序设计语言类别的语句：数据定义语言(DDL)，数据操作语言(DML)，数据控制语言(DCL)和事务控制语言（TCL）。 DML what：数据操作语言(Data Manipulation Language) 查询(Select)、插入(Insert)、修改(Update)、删除(Delete) 7.1.5 三个“一规则” 一个实体(表)代表一组相似的事情 一个元组(行)代表一件事情 一个特性(列)代表关于该事情的一个描述性事实 7.1.8 主键 主键：一个或一组可用于唯一标识元组(行)的属性； 每个实体必须有一个主键，没有主键就不是有效的实体 候选键：所有潜在的主键；（身份证号码、雇员编号、驾驶证号码都可以做为主键） 备选键：没有选中做为主键的候选键； 7.1.9 外键 外键：主表中复制主键而来的元组(行)，用于连接两个实体(主要实体、次要实体) 次要主体的外键指向主要实体的主键 7.2 数据库设计模式7.2.3 多对多模式 在SQL DDL中实现多对多关系，必须要用到第三个表（关联表/联接表)，从而认为地在两个实体之间创建两个一对多的关系 7.3 范式第一范式（1NF） what：原子性 + 主键；求数据库的每个列的值域都是由原子值组成 + 每个字段的值都只能是单一值 主键：每个数据行必须在独一无二的识别项 原子性： 表中不会有多个存储同类数据的列 （fruit1, fruit2） 列中不会有多个类型相同的值 （apple, orange, banana） 1971年埃德加·科德提出了第一范式 第二范式（2NF） what：第一范式（主键为组合键） + 没有部分依赖（所有非键的字段都一定是候选键全体字段的函数） 组合键 由两列以上组成的主键； 组成后具有唯一性 how ：数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系：每个非键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些数据只和一个键的一部分有关的话，就得把它们独立出来变成另一个数据表。如果一个数据表的键只有单个字段的话，它就一定匹配第二范式。 有一个数据表记录了设备组件的信息，如下所示： 组件 ID (主键) 价格 供应商ID (主键) 供应商名称 供应商住址 65 59.99 1 Stylized Parts VA 73 20.00 1 Stylized Parts VA 65 69.99 2 ACME Industries CA 这个数据表的每个值都是单一值，所以它匹配第一范式。因为同一个组件有可能由不同的供应商提供，所以得把组件 ID 和供应商 ID 合在一起组成一个主键。组件(关键词)和价格之间的关系很正确：同一个组件在不同供应商有可能会有不同的报价，所以价格确实和主键完全相关(完全依赖)。另一方面，供应商的名称和住址就只和供应商 ID 有关(部分依赖)，这不匹配第二范式的原则。仔细看就会发现 “Stylized Parts” 这个名称和 “VA” 这个住址重复出现了两次；要是它改名了或是被其他公司并购了怎么办？这时候最好把这些数据存到第二个数据表中： 供应商 ID (主键) 名称 住址 1 Stylized Parts VA 2 ACME Industries CA 这么一来，原本的 “组件来源” 数据表就得要做相对应的改动： 组件 ID (主键主键) 价格 供应商 ID（主键、非关键词） 65 59.99 1 73 20.00 1 65 69.99 2 检查数据表里的每个字段，确认它们是不是都和关键词完全相关， 这样才能知道这个数据表是不是匹配第二范式； 如果不是的话，就把那些不完全相关的字段移到独立的数据表里。 接下来的步骤是要确保所有不是键的字段都和彼此没有相依关系，这就叫做第三范式。 第三范式（3NF） what：要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。 ​ 第8章 数据类型、表达式和标量函数8.1 数据类型8.1.1 字符数据类型 长度固定：当输入的数据长度没有达到指定的长度时将自动以英文空格在其后面填充，使长度达到相应的长度 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点 一般来说，如果含有中文字符，用nchar/nvarchar，如果纯英文和数字，用char/varchar。 类型 特点 容量 char 长度固定，8000个英文，4000个汉字 1字节 varchar 长度可变，8000个英文，4000个汉字 1字节 nchar 长度固定 Unicode编码，存储4000个字符 2个字节 [不论是英文还是汉字] nvarchar 长度可变 Unicode编码，存储4000个字符 2个字节 [不论是英文还是汉字] text 长度可变 1字节 ntext 长度可变 Unicode编码 2字节 Unicode或非Unicode​ 数据库中，英文字符只需要一个字节存储就足够了，但汉字和其他众多非英文字符，则需要两个字节存储。如果英文与汉字同时存在，由于占用空间数不同，容易造成混乱，导致读取出来的字符串是乱码。 ​ Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。而前缀n就表示Unicode字符，比如nchar,nvarchar，这两种类型使用了Unicode字符集。 8.1.2 数值数据类型 数据类型 说明 大小 Bit 1或0 1位 Tinyint 0~255整数 1字节 Smallint -32,768~32,767 整数 2字节 Int -2,147,483,648~2,147,483,647 整数 4字节 Bigint -2$^{63}$ ~ 2$^{63}$-1 的整数 8字节 Decimal / Numeric -10$^{38}$ +1 的固定精度数值 根据长度而变化 Money -2$^{63}$ ~ 2$^{63}$-1 的数值，精确到万分之一 8字节 SmallMoney -2,147,483,648~2,147,483,647 的数值，精确到万分之一 4字节 Float -1.79E+308 ~1.79E+308 的浮点数值 4或8字节 Real 24位精度的浮点值 4字节 浮点数：伴随着因为无法精确表示而进行的近似或舍入。 在计算机科学中，浮点（英语：floating point，缩写为FP）是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数（计算机中通常是2）的整数次指数得到。以这种表示法表示的数值，称为浮点数。这种表示方法类似于基数为10的科学计数法。 浮点指的是带有小数的数值。 大部分计算机采用二进制（b=2）的表示方法。位（bit）是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。 8.1.3 日期/时间数据类型 数据类型 说明 字符大小 Datetime 1553年1月1日开始至9999年；Jan 1, 1753，精度3毫秒 8字节 Smalldatetime 1900年至2079年6月6日；精度1分钟 Jun 6, 2079 Date 0001年至9999年； 3字符 Time(2) 时间值，精度可变 3-5字节 Datetime(2) 0001年至9999年，精度可变，从0.01秒到100纳秒 6-8字节 Datetimeoffset 8.2 构建表达式8.2.1 运算符 加号(+)运算符的两种作用 算术表达式 字符串串联 123Select &apos;abc&apos;+&apos;da&apos;; / Select col1+col2 From Select &apos;abc&apos;+Convert(varchar(10),&apos;21&apos;); 如果串联字符串和整数，必须将整数转为字符串 8.2.2 按位运算符 布尔 exclusive or 运算符 xor ( ^ ) 只有一个为真，返回True；两个都为真，返回False 1Select 1^1 按位 Not ( ~ ) 对表达式中每个逻辑求反。 1Select (~)@A 按位Not 不能和布尔表达式一起使用 8.2.3 Case 表达式 最大的优点是可以与Select语句“内联” 若else缺失，表示其他值返回NULL Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略； 相等判断的话，顺序也要注意 布尔判断的话，例如根据金额大小来判定等级，必须要最高的金额写在最前面； 1234567891011121314151617## 两者区别1. 输入表达式，只能用于等同性(=)检查2. 布尔表达式，不局限于等同行(=)检查--用输入表达式，将与每个where子句中的值比较Case &lt;input expression&gt; --只能用于等同性检查，而不进行其他比较 when &lt;when exp&gt; then &lt;result exp&gt; [n...] [else &lt;result exp&gt;]End--给每个when子句提供一个布尔表达式，求值为TRUE或FALSE [布尔值是“真” True 或“假” False 中的一个]Case when &lt;Boolean exp&gt; then &lt;result exp&gt; [n...] [else &lt;result exp&gt;]End 简单Case：case 简单表达式只能用于等同性检查，而不进行其他比较 1234567891011121314151617181920212223# 在SELECT语句中，CASE 简单表达式只能用于等同性检查，而不进行其他比较SELECT ProductNumber, Category = CASE ProductLine --表示如果 ProductLine = R 则返回 Road； Case之后的变量，为比较的变量 WHEN &apos;R&apos; THEN &apos;Road&apos; WHEN &apos;M&apos; THEN &apos;Mountain&apos; WHEN &apos;T&apos; THEN &apos;Touring&apos; WHEN &apos;S&apos; THEN &apos;Other sale items&apos; ELSE &apos;Not for sale&apos; END, Name FROM Production.Product ； --Select top 10 SalesOrderID % 10 As &apos;OrderLastDigit&apos;,ProductID % 10 As &apos;ProductLastDigit&apos;,&quot;How Colse ?&quot; = CASE SalesOrderID % 10 WHEN ProductID % 1 THEN &apos;Exact Match&apos; -- 可在When子句中引用第二个列来做判断 WHEN ProductID % 1-1 THEN &apos;Within 1&apos; WHEN ProductID % 1+1 THEN &apos;Within 1&apos; ELSE &apos;More Than One Apart&apos; END FROM Sales.SalesOrderDetail ；-- % 表示返回余数； 5%2 返回1-- 变量名在Case之前使用双引号（“”）说明，该变量是新创建的变量;但不建议如此； ​ 布尔型Case：**不局限于**等同行(=)检查 1234567891011121314-- 没有输入表达式（即Case关键字与第一个When之间的部分）-- When表达式必须求值为一个 布尔值；（Case简单语句中，When的表达式可以为1、3、Price+1[含运算]）Select top 10 SalesOrderID % 10 As &apos;OrderLastDigit&apos;,ProductID % 10 As &apos;ProductLastDigit&apos;,&quot;How Colse ?&quot; = CASE -- 没有输入表达式 WHEN (SalesOrderID % 10) &lt; 3 THEN &apos;Ends With Less Than Threes&apos; WHEN ProductID =6 THEN &apos;ProductID is 6&apos; -- 可在When子句中引用第二个列来做判断 WHEN ABS(SalesOrderID % 10 - ProductID) &lt;= 1 THEN &apos;Within 1&apos; ELSE &apos;More Than One Apart&apos; END FROM Sales.SalesOrderDetail ；# 可在条件表达式中混合搭配的字段# 可执行为任何表达式，只要最后的结果为布尔值 8.2.4 Iif与Choose函数 iif函数是case语句的简写版本：iif(boolean_exoression, true_value, fasle_value) Choose函数是一个逻辑运算符；返回数组中的第x列 Choose(index, var1, var2, var3) --index为索引；若超出数组的边界，会返回空值 Select Choose(3, &#39;Linda&#39;, &#39;Tiger&#39;, &#39;Bears&#39;) # 返回Bears 8.2.5 使用空值 what：空值NULL表示不存在的值，是一个未知值；并不表示0； how ：包含空值的任何表达式结果均是一个未知值 Null + 1 = Null 聚合函数中SUM( ) 与AVG( ) 会自动排除NULL进行计算； Count( * ) 会计算空值；但Count( col )会排除空值 1# 测试空值 - Is Null 12345678910111213141516## 处理空值 # Isnull() --将NULL替换为某个值Select Isnull(col, 0) -- 对col列进行搜索，并将空值NULL转换为0；也可以是其他任意值/字符串--isnull(soucre_expression, prlacement_value) # isnull是T-SQL特有的函数-----------------------------------------------------------------------------# Coalesce()Select Coalesce(Null, Null+1, 1+2, &quot;abc&quot;) 返回3--Coalesce(expression, expression,... ) # 接受一系列表达式或列，返回第一个非空值-----------------------------------------------------------------------------# Nullif()--Nullif()接受两个参数；如果他们相等，则返回空值；否则，返回第一个参数； 8.3 标量函数 what：标量函数返回单个值 包括日期时间函数、数值函数、系统函数 8.3.2 日期和时间函数 函数名 描述 Getdate 返回当前服务器的日期和时间 Current_timestamp 除了ANSI标准，等同于Getdate Getutcdate 返回当前服务器的日期和时间，并转化为格林威治标准时间 Sysdatetime 返回当前服务器的日期和时间 Sysutcdatetime 返回当前服务器日期，并转化为格林威治标准时间 Sysdatetimeoffset 返回Datetimeoffset值 日期处理函数 函数名 描述 Dateadd 在指定的日期上累加数值得到新的日期；dateadd(datepart,number,date) SELECT DATEADD(yyyy, 4, ‘01/09/2003’) 返回：2007-01-09 datepar是参数的格式：datepart=yy(年)，mm(月)，qq(季度)；date 参数是合法的日期表达式。number 是您希望添加的间隔数；对于未来的时间，此数是正数，对于过去的时间，此数是负数。 DATEDIFF 返回两个日期的差值 ； datediff(datepart,startdate,endate) SELECT DATEDIFF(dd, ‘02/05/2003’, ‘02/09/2005’) 返回：735 DATEPART 返回指定日期部分的整数（整数形式） SELECT DATEPART(dd, ‘01/09/2003’) 返回：9 DATENAME 返回指定日期部分的字符串（字符串形式）；工作日(dw)、周(wk)、日(dd)、月(mm) SELECT DATENAME(dw, ‘02/02/2009’) 返回: 星期一 Eomonth 返回针对指定开始日期的月份的最后一天 YEAR 返回指定日期“年”部分整数 SELECT YEAR(GETDATE()) 返回：当前年份整数 MONTH 返回指定日期“月”部分整数 SELECT MONTH(GETDATE()) 返回：当前月份整数 DAY 返回指定日期“日”部分整数 SELECT DAY(GETDATE()) 返回：当前日期整数 查询：日期的应用12345678910111213141516171819202122232425262728# 获取当前时间 - getdateselect getdate();# 返回指定的时间 - dateaddselect dateadd(dd, 3, &apos;2017-01-31&apos;); # datepart：yy/qq/mm/ww/dd/hh/mi/ss/ms ; # num为正或为负；--dateadd()仅接受提取日期部分# 计算两个时间差 - datediffselect datediff(dd,&apos;2016-06-01&apos;, &apos;2017-01-31&apos;); # yy/qq/mm/ww/dd/hh/mi/ss/ms--datediff(date_type,startdate , enddate)# 取出时间的某一部分 - datename/datepartselect datename(dd, &apos;2017-01-31&apos;); # datename 字符串形式select datepart(dd, &apos;2017-01-31&apos;); # datepart 整数形式# 获取日期的年份/季度/月度/日期等 select year(getdate()); quarter/month/day# 返回针对指定开始日期的月份的最后一天 - EomonthSelect Eomonth(&apos;2016-02-32&apos;,1) # 返回 2016-03-31--Eomonth(start_date, month_to_add) 参考：日期缩写参考 datediff / datename / datepart /dateadd 日期部分 缩写 year yy, yyyy quarter qq, q month mm, m dayofyear dy, y # 查询date在当年是第多少天. 一年中的第几天； day dd, d week wk, ww # 查询date在当年中是第几周 / 以周为单位的间隔数 weekday dw # 一周中的第几天(星期几) Hour hh minute mi, n second ss, s millisecond ms 8.4 字符串函数 函数名 功能描述 举例 Len 返回指定字符串的字符个数(而不是字节)，其中不包含尾随空格 SELECT LEN(‘李丽然作者’) 返回:5 Datelength 返回指定字符串的字节数 SELECT DATALENGTH(‘中国人’) 返回：6 UPPER 将小写字符转换成大写字符 SELECT UPPER(‘book图书表’) 返回:BOOK图书表 Ltrim 返回去掉左侧空格的字符串 SELECT LTRIM(‘ Authors’) 返回: Authors CHARINDEX 查找一个指定的字符串在另一个字符串中的起始位置 SELECT CHARINDEX(‘L’, ‘HELLO’, 1) 返回:3 LEFT 返回字符串中从左边开指定个数的字符 SELECT LEFT(‘zhangsan’, 2) 返回:zh Substring 返回字符串的一部分：从字符串串的起始位置连续取指定个数的子串 SELECT SUBSTRING(‘我爱我的家乡’,3, 2) 返回：我的 Replace 替换一个字符串中的字符 SELECT REPLACE(‘我爱我的家乡家乡’, ‘家乡’, ‘学校’) 返回: 我爱我的学校学校 Stuff 将一个字符中删除指定数量的字符，并插入另一个字符 Concat 将多个字符串组合为单个字符串 使用字符串字面量时，通过输入两个单引号转化为一个单引号 Replace(name, ‘’’’, ‘’) ; Life’’s Great! 被解释为 Life’s Great! 行数&amp;字符数12345678910# 返回观测值的行数 - count SELECT COUNT(name) FROM my_contacts;--Count(*) 计算含空值的行数--Count(col) 计算不含空值的行数# 返回字符串的字符个数 - lenSELECT LEN(&apos;中国人&apos;) ; # 返回:3# 返回字符串的字节数 - datalengthSELECT DATALENGTH(&apos;中国人&apos;); # 返回：6 去空格12# 去空格 - ltrim / rtrimselect ltrim(rtrim(&apos; &quot;左右都没有空格&quot; &apos;)); # 左右去空格 12345# 生成空格 - spaceselect space(2); # 生成2个空格SELECT RTRIM(LastName) + &apos;,&apos; + SPACE(2) + LTRIM(FirstName) FROM Person.Person# 剪裁姓氏，并将逗号、两个空格和 Person 中的 AdventureWorks2012 表列出的人员名字串联起来 取子串12345# 取子串：特定位置 - substringselect substring(name,1,2); # 返回na;# 取子串：左/右 - left /rightselect left(ltrim( name), 3); # 返回nam; 返回特定位置1234567# 返回位置：起始位置 - charindexselect charindex(&apos;L&apos;, &apos;HELLO&apos;, 1); # 返回:3; 1表示第一次出现--charindex(serach string, string ,starting position) ；第三个参数默认为1，可不写# 返回位置：表达式中某模式第一次出现的起始位置 - patindexpatindex(&apos;%123%&apos;,&apos;abc123def&apos;); # 返回4--允许通配符的使用 替换123456# 替换 - replaceselect replace(&apos;abcdef&apos;,&apos;cde&apos;,&apos;xxx&apos;); 返回 abxxxf# 删除&amp;替换 - stuff()Select stuff(&apos;abcdef&apos;, 3, 2, &apos;123&apos;) -- 返回ab123ef；从第三个位置开始删除2个字符，并插入123--stuff(string, insertion position, delete count, string inserted); 合并123# 合并为一个字符串 - concat()Select Concat(Null, &apos;Patrick &apos;, 1, &apos; LeBlacn&apos;)--隐式地将所有值转换为字符串，将空值转为空字符串 格式转换123456789101112131415# 转换：大小写 - upper/lowerselect upper(&apos;abc&apos;); # 返回 ABC# 转换：反转 - reverseselect reverse(&apos;abc&apos;); # 返回&apos;cba&apos;# 转换：字符形式 - charselect char(213);# 转换：字符串形式 - strselect str(123.45, 6,1); # 把数值转换成字符串格式--返回123.5； 将123.45转为6个位置的字符串，数字的小数部分舍入为1为小数；# 转换：ascii码 - asciiselect ascii(123) as &apos;123&apos; 1234567891011121314151617# 格式的转换、显示 - convert : 将第2个参数转换为第1个参数所指定的类型 / 用不同的格式显示日期/时间数据。-- CONVERT (data_type[(length)], expression [, style]) ;-- [,style] 日期格式样式SELECT CONVERT(DateTime, &apos;2020-09-09&apos;); # 返回: 2020-09-09 00:00:00.000SELECT CONVERT(varchar(5), 92.89); # 返回：92.89SELECT CONVERT(varchar(11), GETDATE(), 121); # 返回：2010-03-24常用日期格式： - 23 ：日期格式 yy-mm-dd - 111：日期格式 yy/mm/dd - 120：日期格式 yyyy-mm-dd hh:mi:ss(24h) - 121：日期格式 yyyy-mm-dd hh:mi:ss.mmm(24h) - 105：日期格式 dd-mm-yy - 110：日期格式 mm-dd-yy Data_type : INT / DECIMAL(10,2) / CHAR() / VARCHAR() / 8.6 数据类型转换函数Cast( )Convert( )1234567891011121314151617# 格式的转换、显示 - convert : 将第2个参数转换为第1个参数所指定的类型 / 用不同的格式显示日期/时间数据。-- CONVERT (data_type[(length)], expression [, style]) ;-- [,style] 日期格式样式SELECT CONVERT(DateTime, &apos;2020-09-09&apos;); # 返回: 2020-09-09 00:00:00.000SELECT CONVERT(varchar(5), 92.89); # 返回：92.89SELECT CONVERT(varchar(11), GETDATE(), 121); # 返回：2010-03-24常用日期格式： - 23 ：日期格式 yy-mm-dd - 111：日期格式 yy/mm/dd - 120：日期格式 yyyy-mm-dd hh:mi:ss(24h) - 121：日期格式 yyyy-mm-dd hh:mi:ss.mmm(24h) - 105：日期格式 dd-mm-yy - 110：日期格式 mm-dd-yy Data_type : INT / DECIMAL(10,2) / CHAR() / VARCHAR() / convert - style的参考值 一位或两位数字样式提供两位数的年份；3位数字样式提供4位数字的年份； 代码 Style 格式 100 或者 0 mon dd yyyy hh:miAM （或者 PM） 101 mm/dd/yy 102 yy.mm.dd 103 dd/mm/yy 104 dd.mm.yy 105 dd-mm-yy 106 dd mon yy 107 Mon dd, yy 108 hh:mm:ss 109 或者 9 mon dd yyyy hh:mi:ss:mmmAM（或者 PM） 110 mm-dd-yy 111 yy/mm/dd 112 yymmdd 113 或者 13 dd mon yyyy hh:mm:ss:mmm(24h) 114 hh:mi:ss:mmm(24h) 120 或者 20 yyyy-mm-dd hh:mi:ss(24h) 121 或者 21 yyyy-mm-dd hh:mi:ss.mmm(24h) 126 yyyy-mm-ddThh:mm:ss.mmm（没有空格） 130 dd mon yyyy hh:mi:ss:mmmAM 第9章 联接、子查询和CTE合并数据9.1 使用联接 what：将两个数据集相乘，并对结果进行限制。这样只返回两个数据集的交集。 why ：横向合并两个数据集，并通过匹配一个数据源的行与另一个数据源的行，从组合中产生新的数据集。 当涉及多个联接时 一定要用较小规模的数据对查询进行单元测试； 并坚持使用左外联接 9.1.1 内联接Inner Join 在连接条件中使用等于号（=）运算符，其查询结果中列出被连接表中的所有列，包括其中的重复列。 在连接条件中使用除等于号之外运算符（&gt;、&lt;、&lt;&gt;、&gt;=、&lt;=、!&gt;和!&lt;） 多个数据源的联接（顺序并不重要） 所要获得字段的表要写在最前面；即From之后； 可实现A联接B，B联接C，C联接D； 12345Select cst.companyname, prod.name From Customre As cst Inner join salesorderhead As soh On cst.customerid = soh.customerid Inner join salesorderdetail As sod On soh.salesorderid = sod.salesorderid Inner join product As prod On sod.productid = prod.productid 9.1.2 外联接 what：以一个表为基准表，进行联接； 若使用外联接，顺序非常重要 how ：无论是否匹配，外联接都包含所有数据 外联接中的条件设置（执行逻辑） 当条件位于Join子句中，先包括外表的所有行，然后用条件包括第二个表中的行 当条件位于Where子句中，先执行联接，然后将条件应用于联接行 1234567# 条件位于Join子句Select a.col, b.col From table As a Left join table2 As b On a.id = b.id And a.Lastname = &apos;Adams&apos; --该条件限制的是第二个表中的行 [And a.Lastname = b.name] --也可以再进行限制 – 123456# 条件位于Where子句Select a.col, b.col From table As a Left join table2 As b On a.id = b.id Where a.Lastname = &apos;Adams&apos; --该where条件是对联接后的表进行限制 ​ 9.1.4 交叉联接Cross Join 不带WHERE条件子句，它将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积 （例如：T_student和T_class，返回4*4=16条记录） 如果带where，返回或显示的是匹配的行数。 9.2 差集查询 what：分析两个数据集之间相关性的查询； why ：用于查找不存在或不匹配的数据 how ：一般需分两步来执行 联接 设置第二个数据集的主键为NULL 左差集查询 不在右表中的左表数据集；【可用Inner Join 中不等号为条件进行联接 &lt;&gt;】 1234Select c.customerid, so.ordernumber From customer As c Left join salesorder As so On c.customerid = so.customerid Where so.ordernumer Is Null; --设置第二个表的主键为NULL 全差集查询123456Select c.customerid, so.ordernumber From customer As c Left join salesorder As so On c.customerid = so.customerid Where so.customerid Is Null or c.customerid Is Null --设置两个表的的主键为NULL 9.3 使用联合9.3.1 Union All 返回每个结果集中的所有行，且不考虑是否存在重复行 每个Select必须具有相同的数量、类型； 列名或别名由第一个Select确定 Order by子句放在最后，并且对所有结果进行排序，且列名必须是第一个Select语句中存在的 可用Select Into，但Into必须放在第一个Select语句中 9.4 子查询9.4.1 简单子查询 what：子查询是独立运作的； how ：运行逻辑 非相关子查询被执行一次 结果传输到外查询 外查询被执行一次 ​ 公用表表达式 what：CTE (Comman Table Expression )；在单个 SELECT、INSERT、UPDATE、DELETE 或 CREATE VIEW 语句的执行范围内定义的临时结果集。 why ：确定查询结果可当做临时视图来使用；即后续的查询可以引用公共表表达式中的表及字段； CTE 与派生表类似，具体表现在不存储为对象，并且只在查询期间有效。 与派生表的不同之处在于，CTE 可自引用，还可在同一查询中引用多次。 how ：CTE使用With子句，而With子句定义了CTE；在With子句内分别是名称、别名、AS、括号、Select查询语句 CTE自身只是一个不完整的SQL语句 一旦With子句中定义了CTE，查询的主要部分就可以使用其名称引用CTE；就像CTE是其他任何表源一样； 若将多个CTE包含在相同的查询中，在主查询之前确定CTE的顺序，并用逗号分隔；并且后面的CTE可以引用在它之前定义的任何CTE CTE不能嵌套 With子句的表达式格式 1234567891011With CTEname [Col Aliases] As (Select ...From ... )------------------------------------------------------With CTEname1 (col names) As (Select) , Ctename2 (col names) As (Select)Select ... From CTEname1 Inner join CTEname2 On 嵌套子查询：子查询可以多个嵌套 9.4.5 相关子查询 what：先执行外查询，相关子查询的运行要引用外查询中的列 why ：对于复杂的Where条件来说很有用 how ：执行逻辑 先执行一次外查询 在外查询中对每一行执行一次子查询，把外查询中的值取代为子查询的每一次执行 子查询的结果要整合到结果集中 子查询可出现在Select子句中，也可以出现在Where 子句中； 判断是否为相关子查询的标准为是否引用了外查询中的列； 没有引用外查询中的列，为非相关子查询；先于外查询运行 引用了外查询中的列，为相关子查询，后于外查询运行 第10章 聚合、窗口化和排名数据10.1 聚合函数聚合是在对From和Where子句筛选后的数据集进行聚合计算；即运营逻辑是在其之后执行 10.1.1 基本集合 一旦查询包含了聚合函数，那么每一列必须参与到聚合函数中。 函数名 功能描述 AVG 平均值 SUM 求和 MAX/MIN 求最大值/最小值 COUNT 计算非空单元格（ 返回 int 数据类型值） count_big 计算非空单元格（返回 bigint 数据类型值） VAR 方差 # 平方 varp 总体方差 STDEV 标准差 stdevp 总体标准差 Count(*)，计数时也将NULL计入；其他所有聚合函数，包括Count(col_name)的形式，计算时均已排除了NULL 表a，观测值10行，其中2个NULL；Count(*) # 返回10； Count(列名) # 返回8 除非，可用 isnull() 函数进行转换，来计算； 例如，对表a求平均值，若直接用avg() ，其分母为8； 若想使得其分母变成10，应添加 case when isnull(col_name,0) then col_name else end 10.1.2 聚合、平均和空值 除Count(*)外，所有聚合函数忽略空值； avg( ) $\ge$ $sum( ) \over count(*)$ Count(*)，计数时也将NULL计入； 其他所有聚合函数，包括Count(col_name)的形式，计算时均已排除了NULL 表a，观测值10行，其中2个NULL； Count(*) # 返回10； Count(列名) # 返回8 除非，可用 isnull() 函数进行转换，来计算； 例如，对表a求平均值，若直接用avg() ，其分母为8； 若想使得其分母变成10，应添加 case when isnull(col_name,0) then col_name else end 10.2 集合中的分组 Group by 会根据某一列的值将数据集自动分成子集。 数据集被分成子组之后，聚合函数在每一个子组上执行。 对于Group by子句，空值NULL被认为是相等的，并被分组到单个结果行 Group by不局限于对列分组，也可以对表达式执行分组（但该表达式必须与Select中的相同） 10.2.2 分组集 对分组集来说，汇总行是每个子集中的每个唯一值组成的行 10.2.3 筛选已经分组的结果 使用Having子句对已分组的结果进行筛选 10.3 窗口化和排名10.3.2 Over子句 在窗口内分区：Partition by 执行逻辑：先对查询结果进行排序，之后通过Partition by的列进行分区； 1234567891011Sum(cola) Over(partition by col1 order by col2)--其他聚合函数：avg/max/min /count # 根据分组求和Over(Partition by col) --根据col1的分组对cola进行求和； [若同一组别有多个维度，则求和的值是相同的]# 根据排名求累计和Over(Order by col2)--根据col2的顺序对cola列累计求和； [若同一组有多个维度，求和的值是累加的]# 根据分组后的排名，求累积和Over(Partition by col1 order by col2) --根据Col1的分组进行排名得出Col2的次序，并按col2的次序对cola进行分组求和 12# 移动平均CONVERT(varchar(20),AVG(SalesYTD) OVER (ORDER BY DATEPART(yy,ModifiedDate)),1) AS MovingAvg 10.4 排名函数 Rank、Row_number、Dense_rank、Ntile 12345678910111213141516171819202122232425262728# 排名：无重复排名 - Row_number（组内连续的唯一的)row_number() over (order by col2); # 对所有进行排名row_number() over (partition by col1 order by col2); # 根据COL1分组，在分组内部根据 COL2排序-------------------------------------------------# 排名：有重复排名 - Rank （若出现字段值相同，序号一样，下一个跳过1位[排名是非连续的]）rank() over([partion by col1] order by col2); 对所有进行排名ProductID Name LocationID Quantity Rank 494 Paint - Silver 3 49 1 495 Paint - Blue 3 49 1 493 Paint - Red 3 41 3 -------------------------------------------------# 排名：有重复排名 - Dense_rank （若出现字段值相同，序号一样，后一个不跳过[排名是连续的]）dense_rank() over([partion by col1] order by col2)ProductID Name LocationID Quantity Rank 494 Paint - Silver 3 49 1 495 Paint - Blue 3 49 1 493 Paint - Red 3 41 2 -------------------------------------------------# 排名：对序号进行分组处理 - Ntilentile (4) over ([partion by col1] order by col2); # (4)表示分为4组 ntile函数的分组依据（约定）： 首先系统会去检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配就完成分组了；若不能，则会先分出一个组，这个组分多少条记录呢？就是 （总记录数/总组数）+1 条，之所以分配 （总记录数/总组数）+1 条是因为当不能进行平均分组时，总记录数%总组数肯定是有余的，又因为分组约定1，所以先分出去的组需要+1条。 分完之后系统会继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若不能，则再分出去一组，这个组的记录数也是（总记录数/总组数）+1条。 举个例子，将53条记录分配成5组，53%5 = 3不能平均分配，则将余数3平均分配到前3组 （余数 = 分配的组数），然后比较余下的 53-(11*3)=20 条记录能否平均分配给未分配的2组，能平均分配，则剩下的2组，每组各20/2=10 条记录，分配完成，分配结果为：11，11，11，10，10。 Offset &amp; Fetch ：完成分页 12345# Offset &amp; Fetch 必须结合使用Select ... From Order by Offset n rows # 表示跳过n行 Fetch Next 20 rows only # 表示返回之后的20行 第11张 通过视图投影数据11.2 基本视图123Create View schema.tableAs Select 第12章 在SQL Server中修改数据12.1 插入数据12.1.1 插入简单的值行 把值插入到一个新行时，每个值对应一个插入列（一一对应），但表中列的顺序是无关紧要的； 123Insert [Into] schema.table [ (colums, ...) ] Values (value,...), (value,...); 虽然并不需要列出表中的每一行，但如果一列出现了，那么Insert命令必须有一个值；如果插入时省略了该列的值，则会在该列插入NULL 若该列有一个默认约束，则插入默认值； 若该列没有默认约束，且可以为NULL，则插入NULL 若该列没有默认约束，且不可为NULL，则会报错 若要在标识列中插入数据，要使用Set Identity_insert on / off关键字 1234Set Identity_insert dbo.address On Insert Into dbo.address (AddreddID, Addressl, city, state, county) Valuse(999, )Set Identity_insert dbo.address Off 12.1.2 从Select语句中插入结果集12Insert [Into] schema.table [ (colums,...)] Select columns From data [Where conditions]; schema.table 必须存在 into schema.table中的列必须与之后Select中的列相同 若schema.table中有5列，只选取其中3列插入，则其他2列的观测值对NULL 12.1.3 从存储过程插入结果集12Insert [Into] schema.table [ (colums,...)] Execute storedprocedure; 12.1.5 在插入数据时创建表12Select colums Into newtable From data [where conditions]; 若Select…Into 命令只从一个表中抽取数据，而Select语句不包含数据类型转换函数，那么表列和null设置保持原状的可能性很大；但键、约束和索引会丢失。 12.2 更新数据12.2.1 更新单个表12345Update schema.table Set column = expression, column = value /*[From data] SQL Server 特有的T-SQL扩展，用来进行联接；正常情况下应在where子句中创建子查询*/ [Where conditions]; Update 只能更新单个表 12.2.2 执行全局搜索与替代12345# replace(data, &apos;aaa&apos;, &apos;bbb&apos;)Update address Set county = Replace(county, &apos;sun&apos;, &apos;dark&apos;) -- 将county列中所有的sun替换为dark Where county Like &apos;%shine&apos; ; 12.2.3 更新数据时引用多个表12.3 删除数据12345678910111213# deleteDelete [From] schema.table /*[From data] SQL Server 特有的T-SQL扩展，用来进行联接；正常情况下应在where子句中创建子查询*/ [Where conditions];# 删除所有行Delete From schema.table--不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：---------------------------------------------------------------------------------# 删除所有行 - truncateTruncate Table dbo.address truncate 、delete与drop区别 相同点 truncate和不带where子句的delete、以及drop都会删除表内的数据drop、truncate都是DDL语句(数据定义语言)，执行后会自动提交。Delete是DML语句(数据库操作语言) 不同点 truncate 和 delete 只删除数据不删除表的结构(定义)；drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。 delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动。drop 语句将表所占用的空间全部释放。truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。 速度：drop&gt; truncate &gt; delete TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同：二者均删除表中的全部行。但TRUNCATE TABLE 比DELETE速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 安全性： 想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。 小心使用 drop 和 truncate，尤其没有备份的时候 使用上，想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大 想删除表,当然用 drop 对于由FOREIGN KEY 约束引用的表，不能使用TRUNCATE TABLE，而应使用不带WHER 子句的DELETE语句。由于 TRUNCATE TABLE不记录在日志中，所以它不能激活触发器。 TRUNCATE TABLE不能用于参与了索引视图的表。 12.3.2 级联删除 引用完整性（RI）指的是任何辅助行外键都都不能指向主行主键，除非主行缺失存在。 如果一个外键值在某个地方指向了主键，删除主键就会失败（除非先删除指向主键的外键） 12.4 合并数据 Meger语句。使用 MERGE 语句在一条语句中执行插入、更新或删除操作。 有条件地在目标表中插入或更新行。 如果目标表中存在相应行，则更新一个或多个列；否则，会将数据插入新行。 同步两个表。根据与源数据的差别在目标表中插入、更新或删除行。 12345678910111213141516171819Meger flightpassengers As f -- MERGE 子句用于指定作为插入、更新或删除操作目标的表或视图 Using checkin as c --USING 子句用于指定要与目标联接的数据源 On c.lastname = f.lastname --ON 子句用于指定决定目标与源的匹配位置的联接条件 And c.firstname = f.firstname And c.flightcode = f.flightcode And c.flightdate = f.flightdate When Matched Then Update Set f.seat = c.seat When Not Matched By Target --当Soucre表与Target表（基准表）不匹配时，对Target表进行操作 Then Insert (Firsrname, Lastname, Flightcode, flightdate, seat) When Not Matched By Source --当Target表与Soucre表（基准表）不匹配时，对Target表进行操作【相同】 Then Delete;--WHEN 子句（WHEN MATCHED、WHEN NOT MATCHED BY TARGET 和 WHEN NOT MATCHED BY SOURCE）基于 ON 子句的结果和在 WHEN 子句中指定的任何其他搜索条件指定所要采取的操作。--OUTPUT 子句针对插入、更新或删除的目标中的每一行返回一行。--必须由分号进行终止--必须是一对一匹配；一对多匹配是不允许的--联接条件必须是确定性的，也就是可重复的 12.5 返回修改后的数据 Output子句可以访问插入的和删除的虚拟表，以及任何在From自引用的数据源来选择要返回的数据。 Output子句有一个较为高级的应用，可以把输出数据传输到外查询。 12.5.1 从插入返回数据123Insert Into personlist Output Inserted.* -- Inserted. Valuse(7777, &apos;Jane&apos;, &apos;Doe&apos;); 12.5.2 从更新返回数据 可同时返回更新前、更新后的数据 12345Update personlist Set firstname = &apos;Jane&apos;, Lastname = &quot;Doe&quot; Output Deleted.firstname oldfirstname, Deleted.lastname oldflastname, --Deleted.column oldcolumn Inserted.firstname newfirstname, Inserted.lastname newlastname Where businessentityID = 7777 12.5.3 从删除返回数据123Delete From personlist Output Deleted.* Where ... 12.5.4 从合并返回数据1234... Output deleted.column, deleted.column, $action, -- 显示数据库操作的行为（为Insert、Delete、Update) inserted.column, inserted.column ; 12.5.5 把数据库返回到表中12345678910Declare @Deletedperson Table( businessentityID Int Not Null Primary Key, lastname Varchar(50) Not Null, firstname Varchar(50) Not Null)Delete dbo.personlist Output Deleted.colunm, Deleted.column Into @Deletedperson Where bussinessentityID = 2; 第三部分 高级T-SQL数据类型和查询技术第四部分 使用T-SQL编程第16章 使用T-SQL编程16.1 T-SQL批处理16.1.1 T-SQL批处理 终止批处理：批处理分隔关键字是GO。批处理关键字必须是这一行的唯一关键字； 关键字GO之后可添加一个注释 切换数据库：把USE命令插入到批处理中 ​ 16.1.2 T-SQL格式化 语句终止：在每个命令的末尾放置一个分号（；） 在CTE前面必须要放一个分号（当CTE不是批处理的第一条语句时） 不要把分号放在If 或者 While 条件之后 不要把分号缝在 End Try 之后 语句终止符必须跟在Meger之后 16.2 操作变量16.2.1 变量默认值和作用域 T-SQL变量使用 Declare创建； Declare变量跟 变量名 和 数据类型，并用分号结尾； 多个逗号隔开的变量可以用单个Declare 声明 变量赋值用分号隔开； 123Declare @test Int, @testtwo Varchar(20) ;Set @test = 1 ;Set @testtwo = &apos;a value&apos; ; 16.2.2 使用Set 和 Select 命令 Set 与 Select 对比 命令 描述 Set 限制在从表达式中检索数据； 一次只能设置一个变量 Select 可从数据源中检所数据，还可包括其他Select子句(From、Where等）；可使用函数 一次课设置多个变量 Set命令可以使用访问数据源的标量子查询（一个变量） 如果你希望在确保没有行的情况下将变量设置为NULL，以及在不止一行的情况下获得一个错误，这是最佳做法； Select 命令在检索多行时，只会将最后一行的值存储在变量中 123456789101112Use adventureworks2012GODeclare @productID Int, @producename varchar(25);Set @productID = 782; --声明一个变量Select @productID = productID, -- 声明多个变量； @productname = @productID + name --声明变量可叠加使用 From production.product Order by productID; Select 声明，即将 @var = value 作为一个整体，当做Select查询中的列去看待即可 声明变量可叠加使用 如果Select语句没有返回行，Select语句不会影响变量 12345678910GODeclare @productID Int, @producename varchar(25);Set @productID = 999;Select @productID = productID, -- 声明多个变量； @productname = @productID + name --声明变量可叠加使用 From production.product Where productID = 1000; -- 由于ProductID 没有1000，故ProductID仍未NULL 16.2.3 增量变量 声明变量的赋值可以直接用等号（=）联接 可以叠加使用，并且可使用算术运算符 123Declare @x int = 1; -- 直接用等号赋值Set @x = @x +5 --可进行算术运算 16.2.4 条件选择 在Select语句中运用 Where子句，进行条件选择 1Select @var = expression Where BooleanExpression; 16.2.5 在SQL查询中使用变量1234Declare @productID int = 999;Select name From production.product Where productID = @porductID; 16.3 过程流16.3.1 使用条件T-SQL的If命令 一个if，一个命令的执行；并且没有Then和End来终止if命令； 123456789If condition Statement;----------------------------------If 1=0Print &apos;Line one&apos;;Print &apos;Line two&apos;;--结果返回Line two； if语句之后没有分号； if语句实际上是后面语句的提前； 使用Begin / End 有条件地执行多条语句 1234If condition Begin; Multipie Line; End; --每个都有分号 使用If Exists()作为基于存在性的条件 If Exists() 结构使用从SQL Select语句返回的每一行作为条件。 因为If Exists() 结构会查找每一行，所以Select语句应当选择所有的列。一旦一个单行满足了If Exists()，查询就会继续执行 12345If Exists (Select * From production.product Where quantity = 0) Begin; Print &apos;Relpenish Inventory&apos;; End; 使用If / Else 执行替换语句 可选的Else定义了if条件为False时的执行代码；Else可控制下一个单个命令，后者Begin/End块 1234If condition Single line or Begin/End block of code; Else Single line or Begin/End block of code; 16.3.2 使用While循环 what ：当条件为ture时循环代码； 16.5 临时表和表变量临时表 对象 描述 本地临时表 使用# 进行创建 关闭当前会话窗口时就会消失 全局临时表 使用## 进行创建 关闭SQL Management的最后一个会话窗口(即关闭软件)时就会消失 表变量 使用@进行创建； 当批处理、过程或函数结束后，表变量就不存在了。 临时表与表变量的区别 两者都存储在tempdb中；只不过表变量存储在内存中的tenpdb页面中 表变量没有统计函数的功能 若临时空间 $\ge$ 250行，那就使用临时表 第17章 存储过程的开发存储过程的优势 一致性。存储过程封装一条/多条T-SQL语句，可在系统的不同区域内一致地执行 可维护性。它们是模块化的，并且独立于调用它们的应用程序。 安全性。在两个前端提供优势：数据库、应用程序。 从数据的角度：存储过程是对象。意味着向特定用户或组授予执行该存储过程的能力。 从应用程序的角度：存储过程让用户有机会再执行T-SQL过程之前验证输入 性能。存错过程执行是服务器端的进程。意味着无论多复杂，在网络上也只会发送一条语句。 17.1 管理存储过程17.1.1 创建、更改和删除存储过程 Create Create命令必须是批处理语句中的第一条。批处理的终止就结束了存储过程的定义。 在Create Procedure 和下一个批处理终止符(GO)之间的所有内容都被视为存储过程定义的一部分 创建存储过程时始终使用两部分的命名约定：schema.objectname。确保将存储过程添加到适当的框架中 12345GOCreate Procedure sales.information As Select currencycode, name From sales.currency;GO 其他命令：Alter / Drop 17.1.4 执行存储过程12Execute sales.information;Exec sales.information; 17.2 把数据传递到存储过程 存储过程的参数化特征使其成为代码重用的重要特征； 调用存储过程时，必须为每个已定义的参数提供数值。 17.2.1 输入参数 指定参数值: 通过命名参数值 12345678Create Proc sales.information @currencycode char(3) AS Select currencycode, name From sales.currency Where currencycode = @currencycode;GOExecute sales.information @currencycode = &apos;USD&apos;GO 参数默认值：只需在输入参数信息后面添加 =”default value” 123456789GOAlter Procedure sales.information @currencycode char(3) = &apos;USD&apos; AS Select currencycode, name From sales.currency Where currencycode = @currencycode;GOExecute sales.information @currencycode = Default;Execute sales.information Default --效果同上 通过列表与表作为存储过程的参数输入 12345GoCreate Proc sales.rate @rateIDlist varchar(50)ASDeclare @ 17.3 从储存过程中返回数据 输出参数：使用输出变量可以从存储过程返回标量函数； Return：使用Return语句可以从存储过程返回单个整数值； 结果集：存储过程可以通过一个或多个Select语句返回数据 17.3.1 输出参数 输出参数：能使存储过程把数据返回到主调应用程序。在创建和调用过程都需要关键字Output。 在存储过程内，输出参数是一个局部变量，就像输入参数一样。 但实际上输出参数是双向参数。当存储过程终止时，其当前值要传输到主调应用程序。 ​ 在主调用程序的过程中，必须创建局部变量来接收输出参数的值。 创建带有输出参数@currencyname的存储过程sales.currencyname 声明局部变量@currencynameoutput （输入函数）以接收输出参数 执行存储过程，为输出参数@currencyname赋予@currencynameoutput （输入函数）的值，该值在局部变量初始化之前为NULL 在执行存储过程期间，基于出入参数后@currencycode的值，通过Select语句为输出参数赋值。 存储过程完毕，而且执行要传递回SSMS。局部变量@currencycodeoutput接收输出参数的值 Print命令把该局部变量的值发送到SSMS的message选项卡 123GOCreate Proc sales.currencyname @currencycode Char(3),#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R语言_统计分析]]></title>
      <url>%2F2017%2F03%2F20%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2Fdocument%2FR_%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[运用R语言完成数据的统计分析。 包括统计函数、交叉表、相关性等。 统计函数基本统计量 名称 含义 示例 mean(x) 均值 median(x) 中位数 sd(x) 标准差 var(x) 方差 mad(x) 绝对中位差 quantile(x,) 分位数，probs是0-1之间的数值向量 quantile(x,probs) quantile(x,c(.3,.7)) range(x) 求值域 rang(c(1,2,3,4))，返回(1,4) sum(x) diff(x,) 滞后分差； diff(x,lag=n) 1)diff(c(1,5,23,29),lag=2) min(x) max(x) scale(x,) 为数据对象x按列进行中心化或标准化 scale(x,center=TRUE,scale=TRUE) scale 默认情况下，scale对矩阵或数据框的指定列进行均值=0，标准差=1的标准化； 中心化 center=T 标准化 center=T,scale=T 若对任意均值，SD为标准差，M为均值 newdata &lt;- scale(mydata)*SD+M mad( ) - 绝对中位差 1.求原样本S1中位数，记为m12.原样本S1各元素减去m1，得到的值去绝对值，得到新的样本S23.求新样本S2的中位数m24.返回的值=1.4826*m2 概率函数 名称 作用 全称 示例 说明 d 概率函数 density p 分布函数 distribution function pnorm(x,mean=a,sd=b) 生成mean=a,sd=b的x【左侧的面积值】；pnorm(1.96)=0.975 q 分位数函数 quantile function qnorm(0.x,mean=a,sd=b) 生成0.x分位数，mean=a，sd=b的情况下；默认为标准正态 r 生成随机数 random rnorm(x,mean=a,sd=b) 生成x个mean=a,sd=b的随机数；默认情况下a=0,b=1，且mean/sd可省略 概率函数 含义 beta Beta分布 binom 二项分布 nbinom 负二项分布 multinom 多项分布 norm 正态分布 lnorm 对数正态分布 unif 均匀分布 t t分布 f F分布 logis Logistic分布 exp 指数分布 chisq （非中心）卡方分布 pois 泊松分布 geom 几何分布 hyper 超几何分布 cauchy 柯西分布 signrank Wilcoxon符号秩分布 wilcox Wilcoxon秩和分布 weibull Weibull分布 通用函数123## 截尾trim=0.n # 在统计函数中加入trim表示截去最高和最低各n%，计算中间(1-n)%的值c&lt;-matrix(rnorm(12),1,mean,trim=0.2) 交叉表 what ：一种分类汇总的表格 Cross Tabulations why ：用于查看变量的频数、占比 多结果列联表1234567891011121314library(gmodels)CrossTable(x,y, digtis=3, max.width=5, expected=F, prop.r=T, prop.c=T, prop.t=T, prop.chisq=TRUE, chisq=F, fisher=F, mcnemar=F, missing.include=F, format=c("SAS","SPSS"), dnn=NULL,...) # x，一个矩阵或向量。如果出现y，则x必须是一个向量# max.width= ，如果想要一个单柱立式表，可设为1# expected=F/T, 如果为T，chisq将被设置为TRUE和Chi-Square单元计数将被纳入# prop.r - 行比例 ; prop.c - 列比例; prop.t - 表比例; # prop.chisq - 卡方贡献的每个单元格# format="SAS" / "SPSS" ,默认输出格式为"SAS"# 独立性检验 chisq=F / fisher=F / mcnemar= FCrossTable(data$col, data$col); / with(data, CrossTable(col1, col2))CrossTable(HR_data$sales, HR_data$salary, prop.r=T,prop.c=F, prop.t=F, prop.chisq=F) # 只有prop.r=T ,表示对每一行求比例 单结果列联表 表格紧凑化 - ftable(table) 1234567891011121314151617181920212223242526272829303132计算频数table(object1, object2, object3, [useNA=ifany])# 若出现useNA=ifany，则将NA视为一个有效类别# x &lt;- with(data, table(col))xtabs(formula, data=matrix/df ) # 从矩阵/数据框中提取xtabs(~col1+col2, data=frame_name)-----------------------------------------------------------------------------------计算占比prop.table(table, margins) # 一般都需指定所求变量的比例（默认为表比例）## prop.table(table) --对所有变量求比例## prop.table(table, 1) --对第一个变量求比例## porp.table(table, 2） --对第二个变量求比例## prop.table(table, c(1,2)) -对第一、第二个变量求比例；当维度大于2时## prop.table(table)*100 -- 得到百分比形式-----------------------------------------------------------------------------------计算边际和margin.table(table, margins)添加新的结果addmargins(table, margins)# addmargins(table) -对所有变量创建边际和# addmargins(prop.table(table, 1), 2) -对table表中第一个变量求比例，并对第二个变量创建边际和 相关性 what ： 描述定量变量之间的关系；衡量两个样本之间的相关性；若为0，则表示两者不相关，即独立 相关系数 线性相关程度-Pearson积差相关系数 分级定序变量的相关程度-Spearman等级相关系数 非参数等级相关程度-Kendall’s Tau相关系数 协方差：一个变量的偏离程度，会对另一个变量的偏离程度产生多大的影响； 如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果X 与Y 是统计独立的，那么二者之间的协方差就是0 但是反过来并不成立，即如果X 与Y 的协方差为0，二者并不一定是统计独立的。取决于协方差的相关性η 方差：当两个变量是相关的特殊情况 偏相关：控制一个变量或多个定量变量时，另外两个变量之间的关系 why ：确定变量之间的影响程度的强弱，以得出变量的重要性[为后续分析提供变量选择] 相关系数123456789101112131415161718192021222324252627cor(matrix/df, use="everything", method="pearson")# 先选择定量变量的数据集 data&lt;- select(data, )# use= ，表示对缺失值NULL的处理方式## use="everything"(默认) , 结果为missing;## use="all.obs",结果报错; ## use="complete.obs"--行删除; ## use="pairwise.complete.obs"--成对删除# method=， 表示选择的相关系数种类## method="pearson"（默认）## method-"spearman"## method="kendall"cor(matr/df) - 得到一个两两计算相关性的方阵cor(HR_comma[ , 1:8]) # 只可对定量变量做相关性# 求一组变量与另一组（非两两）的相关矩阵x &lt;- states[ , c("col", "col")]y &lt;- states[ , c("col", "col", "col"]cor(x, y) ----------------------------------------------------------------------------------- cov(matrix/df, use="everything", method="pearson") – 12345678偏相关library(ggm)pcor(vector, S)# vector，一个数值型向量, 数值代表变量的序数；前两个数值表示要计算的变量下标，其余为要排除的变量# S，变量的协方差阵colnames(data)pcor(c(1,2,4,5), cov(data)) 相关图 - 可视化1234567891011121314151617181920212223242526272829303132333435363738394041424344library(corrgram)corrgram(dataX, order=TRUE, lower.panel=, upper.panel=, text.panel=, diag.panel=, main="")# dataX，是一行一个观测值的数据框，即长格式 或者是一个 相关性矩阵## [reshape2包] - melt(data, [id="" / c("", "")] # order=TRUE, 相关矩阵使用【主成分分析法】对变量进行重排序# lower/upper.panel=,控制非对角线的设置## NULL - 不显示## panel.shade - 用阴影深度表示相关性大小## panel.pie - 用饼图填充比例表示相关性大小（顺时针，正相关）## panel.pts - 画一个散点图## panel.ellipse - 画一个置信椭圆+平滑曲线## panel.conf - 画出相关性+置信区间（用数值表示，而非图片）# text.panel=panel.txt - 输出变量名# cex.labels=num，变量名的大小# diag.panel=，控制主对角线的设置## panel.minmax - 输出变量的最大最小值和变量名## panel.ednsty - 输出核密度曲面和变量名corrgram(mtcars /cor(data), order=TRUE, lower.panel=panel.pei, upper.panel=panel.conf, text.panel=panel.txt, main="")----------------------------------------------------------------------------------- library(corrplot)corrplot(corr, method="number", order="FPC" tl.col="black", title="",tl.srt=45，mar=c(1,1,3,1)...)# corr，是一个相关性矩阵，且必须是方形；# method="", 可视化的图形，circle（默认），square, ellipse, number, shade, color, pie# type=""，图形矩阵的位置，full（默认，全部完整矩阵），lower/upper,显示下三角/上三角# order=""，相关矩阵的排序方法，original(默认,原来的顺序), FPC(第一主成分), hclust(层次聚类次序), AOE(特征向量角的顺序)# add=FALSE(默认)，不添加到现有的图形中（即创建一个新的图形），若为TRUE，则添加到现有的图形# mar=c(1,1,3,1) # 用来调节边界大小，以放下标题# tl. 文本标签## tl.cex= # 文本标签的大小## tl.col= 文本标签的颜色corrplot(corr,method="circle") 类别变量 总体均值对比 回归 what ：建立因变数Y与自变数 X之间关系的模型 why ： 了解变量之间是否相关？相关的方向与强度？ 并建立数学模型以观察特定变量来预测因变量；（可以给出自变量来估计因变量的条件期望） how ：分析步骤 确定因变量与自变量，选择回归方程 1234因变量 - 二值型数值/类别型变量# Logistic回归因变量 整理数据格式 12345678Logistic回归赋值 - 二分法 # data$col[data$col cond] &lt;- 1# data$col[data$col cond] &lt;- 0因子化# data$col &lt;- as.factor(data$col) 拟合模型 12Logistic回归 # fit &lt;- glm(formula, data=, family=binomail) 查看统计量，并重新选择自变量 1summary(fit) 重新拟合模型，并查看统计量 123Logistic回归 - # fit2 &lt;- glm(formula, data=, family=binomal)# summary(fit2) 模型选择 - 嵌套对比 12Logistic回归 - 卡方检验(若p值&lt;0.05，说明多余的变量对方程有显著影响，不能舍去)# anova(fit, fit2, test="Chisq") 解释模型 12Logisctic回归# 指数化 - exp(coef(fit)) 深层次分析 交叉验证：- 评价回归方程的泛化能力；即，回归方程对新观测样本的预测能力 模型评价：评价预测变量对结果概率的影响【在选择最佳模型之后】 过度离势 [ Logistic回归 ] [what] - 过度离势：观测到的响应变量的方差 &gt; 期望的二项分布的方差(σ²=npq)； [why] - 过度离势会导致标准误检验和不精确的显著性检验；若出现过度离势，可用类二项分布来代替，即glm(,,family=quasibinomial) [how] - 比较模型的残差偏差与残差自由度的比值；若比值非常接近1，则没有过度离势；若比1大很多，则存在过度离势；deviance(fit) / df.residual(fit) 预测模型 12Logistic回归# predict(fit, newdata=, type="response") 确定统计量 参考 表达式 常见表达式 表达式 作用 示例 解释 ～ 分隔符号 y～x+z+w 左边-因变量/响应变量 右边-自变量/解释变量 + 分隔预测变量 ： 预测变量的交互项 y～x+z+x:z * 所有可能交互项的表达方式 y～xzw—y～x+z+w+x:z+x:w+z:w ^ 交互项的某个次数 y～(x+z+w)^2—y～x+z+w+x:z+x:w+z:w 交互项最高次为2次 . 包含除因变量之外的所有变量 y～.—y～x+z+w 当一个数据框包含y,x,z,w这四个变量时 - 减号，从等式中移除某个变量 y～(x+z+w)^2-x:w— y～x+z+w+x:z+z:w -1 删除截距项 y～x-1 拟合y在x上的回归，并强制直线通过原点 I() [大写i ] 从算术（而非表示式）的角度来解释括号中的元素 y～x+I((z+w)^2) 表示的是x+(z+w)²，而非x+z+w+z:w function 可以在表达式中运用的数学函数 log(y)～x+z+w mpg ~ wt \ cyl 表示按条件（cyl）绘图； 即按cyl的水平为【分组条件】分别绘制mpg和wt的关系图 研究设计表达式 表达式 作用 示例 y～A 单因素ANOVA y～x+A 含单个协变量的单因素ANCOVA y～A * B 双因素ANOVA 展开为 ~A+B+A:B y～x1+x2+A*B 含两个协变量的双因素ANCOVA y～B+A（B是区组因子） 随机化区组 y～A + Error(Subject/A) 单因素组内ANOVA y～B*W+Error(Subject/W) 含单个组内因子(W)和单个组间因子(B)的重复测量ANOVA 展开为 ~B+W+B:W 1.小写字母，定量变量 2.大写字母，组别因子（若不转换为factor，则默认为定量协变量） 3.Subject，被试者独有的标志变量 4.Error(Subject/A)，表示组内因子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R语言_数据处理]]></title>
      <url>%2F2017%2F03%2F19%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2Fdocument%2FR_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[运用R语言进行数据处理。 数据导入、数据结构、数据格式、数值处理、表格处理、日期处理、数字处理、缺失值与唯一值； 数据导入与导出导入 要导入的数据必须存放在getwd()目录下 Windows下路径要用斜杠/或者双反斜杠\\ 123456789101112131415161718192021222324library(readr)read_csv("filename.csv", col_names=c(), col_types=col( colname=col_ ))## read_csv导入 读取分隔符为逗号 ## read_tsv导入 读取分隔符为制表符 ## read_csv2导入 读取分隔符为分号library(readr)data &lt;- read_csv("filename.csv", col_names =c("",""), col_types=col( cost=col_numeric(), ))library(dplyr)data &lt;- tbl_df(data) # 将表格转化为tbl_df的格式View(data) # 视图形式查看# 设置列名 col_names = TRUE/FASLE/c("name1","name2") # 第一行作为列名/不作为列名/重命名[数量必须相同]# 排除某个列、变更列的格式 col_types = cols( X6=col_skip(),X1=col_character() ) # 不选中X6列 （X6为列名）# 设置编码 locale = locale(encoding = "UTF-8")## read.table导入data &lt;- read.table("filename.csv", header=TRUE,sep="",na.strings=c("x")) # header=T,即将第一行作为列名；默认为FASLE;# sep=""，分隔符；默认为（空格、换行、回车、制表符），可设置为逗号(,)、制表符(\t)# na.strings=c("x","y") 将等号之后的内容会被转换成NA；即该表中x/y的值会被转化为NA## 直接用RStudio导入分别设置第一行为列名、更改列名、列格式、跳过列 – 12345## 加载包中的数据data(filename, package="") # 装在包中的特定数据## 列出当前已加载包中所含的所有可用示例数据集data() / data(package="") 导出1234setwd("D:\\")write.table(y,"sample.csv",sep=",")# y是R中的数据，sample.csv是存到本地的文件名write.csv(data, file="D:/bearf2.csv") # 若保存至其他位置，需要完整路径 数据结构数据整体结构1234567891011121314## 返回数据结构str(object)## 返回数据结构/统计摘要summary() # 区别对待不同类型的数据变量- (1)数值型：相关极值等信息；(2)名义型/有序型：显示的是各水平的频数值## 返回对象格式/类型class() # 返回 numeric / character / factor / ts …## 返回对象维度dim()## 返回对象模式mode() 行列名称&amp;重命名1234567## 返回所有列的名称names(object) colnames(object)## 返回所有行的名称row.names(object) rownames(object) --二维以上的任何对象 – 12345678910## 直接修改fix(object) # 可以改变格式 numeric / character## 重命名列名library(dplyr)rename(data, newname=oldname) # 新的列名在前## 选择变量时进行重命名select(data, oldname = newname) # 新的列名在后 列重新排序1mtcars &lt;- mtacrs[, c(12,1:11)] # 将第12列置于第一行 长宽格式转换123456789101112131415161718192021222324252627## 转为长格式形式library(reshape2)melt(data, id.vars, measure.vars, variable.name = "variable", ..., na.rm = FALSE, value.name = "value", factorsAsStrings = TRUE)# varaiable.name ，表示将 各个变量的列名 放在这个列下面；# value.name，表示对应观测值的具体数值new &lt;- melt(data, id="var", measure="var")# id="var"/ c("var1","var2") 以该变量为基准进行重构# measure="var"/ c("var1","var2") 需要将哪些变量组合进id列的变量；若measure缺失，表示所有字段`new &lt;- melt(economics, id="data", measure=c("unemploy","uempmed")``new &lt;- melt(economics, id="data", variable.name="unemploy",value.name="uempmed")` --------------------------------------------------------------------------------- ## 重铸为宽格式[excel统计表单的形式]dcast(data, formula, fun.aggregate = NULL, ..., margins = NULL, subset = NULL, fill = NULL, drop = TRUE, value.var = guess_value(data)# formula中出现的变量，原本为变量的列名，融合后是不参与计算的；参与的是对应的value列 new &lt;- dcast(data, formula, FUN)# formula，rowvar1+rowvar2 ~ colvar1+colvar2的格式； rowvar-以此为基准的id列；colvar-需要重构的变量列# FUN，按照任意函数来重构dcast(data, ID~variable, mean) 数据行数、唯一值数1234567891011## 返回总行数/列数ncol() / nrow()length - 计算元素的长度## 返回对象的个数 或者 某个列的的观测值行数length(object/data$col)# 返回对象的唯一值的行数length(unique(data$col/object))# 返回非空置的行数length(na.omit(object/data$col)) tidyr包 gather — 宽数据转为长数据。类似于reshape2包中的melt函数 spread — 长数据转为宽数据。类似于reshape2包中的cast函数 unit — 多列合并为一列 separate — 将一列分离为多列 123456789宽数据转为长数据gather(data, key, value, ..., na.rm = FALSE, convert = FALSE) # key, value 输出列的名字# 这里，...表示需要聚合的指定列 mtcarsNew &lt;- mtcars %&gt;% gather(attribute, value, -car)nrow(mtcarsNew) # 返回333# 它把出了car以外的所有列都聚集起来，然后各自地把它们名字都放在各自的属性和相应的值的列中。 – 12345678多列合并为一列unite()unite(data, col, ..., sep = "_", remove = TRUE)-----------------------------------------------------------------------------------一列拆解为多列separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE, convert = FALSE, extra = "warn", fill = "warn",...) 数据格式因子化12345678910111213## 简单因子化data$col &lt;- factor(data$col)## 有序因子化：按当前顺序来指定顺序data$col &lt;- factor(data$col, order=TRUE, levels=data$col)## 有序因子化：自定义顺序data$col &lt;- factor(data$col, order=TRUE, levels=c("col1","col2")) # 因子顺序，从低到高；左侧为最低## 简单无序data$col &lt;- factor(data$col, order=FALSE)## 无序因子化/名义变量data$col &lt;- factor(data$col, levels=c("col1","col2"), labels=levels / c("new_col1","new_col2")) factor与as.factor的区别 as.factor(x) – 只能对整个数据/列进行转换，其中无法插入其他语法 1234## 根据第二列的值，重新对第一列的值进行排序data$col &lt;- reorder(data$col,data$col2,[FUN],[order=T/F])# FUN，表示对第二列进行的变换，以此为排序依据# order= T/F ,逻辑值，返回一个有序因子 or 一个因素 数据格式索引 格式判断 格式转换 含义 is.numeric( ) as.numeric( ) 数值格式 is.integer( ) as.integer( ) 整数 is.character( ) as.character( ) 字符串格式 is.factor( ) as.factor( ) 因子化 is.logical( ) as.logical( ) 逻辑值 as.Date(object, “format”) 日期格式 is.list( ) as.list( ) 列表 is.data.frame( ) as.data.frame 数据框格式 is.matrix( ) as.matrix( ) 矩阵格式 is.array( ) as.array( ) 数据组 is.vector( ) as.vector( ) 向量格式 double：数值型格式（双精度向量：保存更多的有效位数） 1234567data$col &lt;- as.numeric(data$col)------------------------------------------------------------------------------------多列变更gb[,c("net_activation","total_income")] &lt;- lapply(gb[,c("net_activation","total_income")], as.numeric)data[,col:col] &lt;- lappy(gb[,col:col], as.numeric) 有效位数&amp;小数位数1234## options(digigs=7) # 默认值 有效位数options(digits=n) # 限定最小值的有效位数，并使其他数字舍入后与其小数点后的位数相同；--xx&lt;-c(98,263.5, 2.43, 1.5531)--options(digits=2) [1]98 263.6 2.4 1.6 数据处理绑定数据框123456789101112## with绑定数据框&lt;- with(data, &#123; stats &lt;- summary(mpg) &#125;)# 花括号&#123;&#125;之间的语句都对数据框table执行，赋值仅在此函数的括号内生效；若使用&lt;&lt;则为全局变量# 若在with符号左侧（new&lt;-with()）出现赋值的对象，则在with符号内产生的赋值依然在其外有效# attach() / detach() # 必须成对出现attach(data)...detach(...) 基础函数funs12345678910111213141516171819202122funs(...)funs_(dots, args = list(), env = baseenv())# dots, ... ## A list of functions specified by:## Their name, "mean"## The function itself, mean## 调用的函数 点号(.) 作为一个虚拟参数 mean(., na.rm = TRUE)# args 指定要添加到所有函数调用的附加参数的列表。(A named list of additional arguments to be added to all function calls.)# env The environment in which functions should be evaluated.-----------------------------------------------------------------------------------Examples# funs(mean, "mean", mean(., na.rm = TRUE))# Overide default namesfuns(m1 = mean, m2 = "mean", m3 = mean(., na.rm = TRUE))# If you have function names in a vector, use funs_fs &lt;- c("min", "max")funs_(fs) plyr包 what ：用来切割、计算、合并数据的包 why ：在一个函数内同时解决spilt-apply-combine的三个步骤 Spilt：把要处理的数据分割成小的片段 Apply：对每个小片段进行操作 Combine:把片段重新组合 how ： 1234567891011121. a*ply(.data, .margins, .fun, ..., .progress = "none") 2. d*ply(.data, .variables, .fun, ..., .progress = "none") 3. l*ply(.data, .fun, ..., .progress = "none")# ddply(.data, .variables, .fun = NULL, ..., .progress = "none", .inform = FALSE, .drop = TRUE, .parallel = FALSE, .paropts = NULL)# 第一个参数是要操作的原始数据集，比如baby_name# 第二个参数是按照某个（也可以几个）变量，对数据集分割，比如按照year对数据集分割，可以写成.(year)的形式# 第三个参数是具体执行操作的函数，对分割后的每一个子数据集，调用该函数# 第四个参数可选，表示第三个参数对应函数所需的额外参数## 其他参数，可以暂时不用考虑。ddply()函数会自动的将分割后的每一小部分的计算结果汇总，以data.frame的格式保存。&lt;span style="color:red"&gt;分割后的数据，是fun的第一个参数。&lt;/span&gt; – 12345678910111213141516# 对原始数据集做一些操作，并把结果存储在原始数据中transform()ddply(baby_names, .(year, sex), transform, rank = rank(-percent, ties.method = "first"))# 第二个参数有点变化，除了year，还有sex，这表示对baby_name数据集，对year和sex分类（类似于SQL中的group by year, sex）。第四个参数是transform的额外参数，如果查看transform的帮助文档，其函数调用方式如下：# 不追加结果到原始数据，而是产生新的数据集summarize()summarize(baby_names_2008_boy, trend = max(percent) - min(percent))# 0.010266 数值相关创建123456## 创建序列 - seq()seq(from_num, to_num, by_num) ## 创建重复值 - rep()rep(x, n) 替换与返回123456789101112131415根据值来替换## object[object condition] &lt;- XX &lt;- "" # 前后变量名必须一致leadership$age[leadership$age&gt;75]&lt;-"Elder"## ifelse(test, yes, no)temp6$budget &lt;- with(temp6,&#123; ifelse(budget&lt;(qnt[1]-h),NA,budget) ifelse(budget&gt;(qnt[2]+h),NA,budget)&#125;)temp6 &lt;- na.omit(temp6)## sub()sub(patter, replacement, object, ignore.case=FALSE, fixed=FALSE) --# patter表达式/文本字符串， replacement要替换的值，在object中搜索pattern；fixed=F(默认),pattern为正则表达式；fixed=T,pattern为字符串文本 (相似于vlookup函数) – 12345根据位置来替换## substr() - 返回中间的部分；即替换substr(object,star_num,stop_num) substr(object,star_num,stop_num) &lt;- "xx" #用xx替换其之间的值；若数量少于则循环，若大于则不会覆盖超出部分 复杂替换：正则表达式 拆分1234## strspiltx &lt;- strspilt(object, "sep", fixed=FALSE) -- # 对object按照”sep"进行分割，若fixed=F(默认),sep为正则表达式；否则为文本字符串； strspilt("abc", "") --返回含1个成分，3个元素的列表"a" "b" "c" 合并123456## cat合并；将所有的对象合并为一个单元格的值object &lt;- "name"x &lt;- cat("x1","x2",object, num, [sep=""] )## paste合并；若对象为不同“列”，则一一对应合并；若对象有3列，合并后仍为3列paste("x1","x2",4\n, …, [sep=""]) cat( ) 与 paste( ) 相同与区别 区别： paste( ) 对应的列单独合并 cat( ) 合并为一个单元格 123456&gt; paste(c("X","Y"),1:10,sep="")&gt; # [1] "X1" "Y2" "X3" "Y4" "X5" "Y6" "X7" "Y8" "X9" "Y10"&gt;&gt; cat(c("X","Y"),1:10,sep="")&gt; # XY12345678910&gt; &gt; 长度123456## 计算字符数量 - nchar## 计算元素数量 - lengthx1&lt;-c("ab","cde","fghij")nchar(x1)----2,3,5length(x1)----3 字符规则 引用符 字符 含义 Quotes \n newline；换行 Quotes \r carriage return Quotes \t tab；制表符 Quotes \b backspace；空格 Quotes \a alert (bell) Quotes \f form feed Quotes \v vertical tab Quotes \ backslash \ Quotes \’ ASCII apostrophe ‘（单引号） Quotes \” ASCII quotation mark “（双引号） Quotes ` ASCII grave accent (backtick) ` Quotes \nnn character with given octal code (1, 2 or 3 digits) Quotes \xnn character with given hex code (1 or 2 hex digits) Quotes \unnnn Unicode character with given code (1–4 hex digits) Quotes \Unnnnnnnn Unicode character with given code (1–8 hex digits) 表格相关返回指定子集 - 行12345678910111213141516171819202122232425262728293031323334353637383940library(dplyr)filter()## 根据条件选取 filter(tbl_df, cond)filter(hflights_df, Month == 1, DayofMonth == 1)&lt;- filter(tbl_df, x %in% c("a","b")) # 集合运算：并且(&amp;)，或者(|)# 条件判断1： %in% - 表示x中含"a"或者"b"的值，返回为逻辑为真# 条件判断2：否定(!=)、大于(&gt;)、大于等于(&gt;=)、恒等于(==)## 排除多条件的观测值 / 或者用 &amp; 联接&lt;- filter(iris,!Species %in% c("setosa"))&lt;- filter(iris,Species !="setosa" &amp; Species != "kaggle")## 选中子集中的特定列filter() %&gt;% select(., var)## 通过行数的位置进行选取filter(tbl_df, n:n) # 等价于data[n:n, ]--------------------------------------------------------------------------------------## 前/后/任意选取head(data, n) 等价于 first(data, n)tail(data, n) 等价于 last(data, n) nth(x) # 返回第x个观测 (dplyr包)## 随机选取sample_frac(iris, 0.5, replace=TRUE) # 按比例sample_n(iris, 10, replace=TRUE) # 按数量## 选取并排列前n个数top_n(tbl_df, n)top_n(tbl_df,-n) # 从底部开始选择n个数据## 删除重复值distinct(hflights_df, Month, .keep_all = TRUE)#.keep_all = TRUE指保留除Month以外的其它列的内容。默认的情况是不保存其他列的。 vector-向量 123&gt; x &lt;- x[num:num] &gt; x &lt;- x[c(num1,num2,num3)]&gt; &gt; 矩阵/数组/数据框 123456789&gt; ## 一般选取&gt; z &lt;- z[i,j] / z[i, ] / z[, j]&gt;&gt; ## 连续选取&gt; z[i:j, ] / z[ ,i:j] / z[i:j] # []方括号中无逗号出现，表示选取列&gt; z[c("row","row") , ] &gt; z[, c("col","col")] &gt; z[c("col", "col")]&gt; &gt; 列表 12&gt; x &lt;- mylist[[ ]] # 其中规则与数据框中相同&gt; – 12## subset选取subset(data, condition, select=c(col1,col2) / col1:col2 ) 返回指定子集 - 列1234567891011121314151617181920212223242526272829303132333435363738library(dplyr)select()## 通过列名(无需引号)来选取 select(tbl_df, var1,var2)#连续多变量 select(tbl_df, var1:var4)#排除某变量 select(tbl_df, -var) / select(tbl_df, -(var1:var4))select(hflights_df, -(Year:DayOfWeek))## 不同条件列选择 - select_if()hflights %&gt;% select_if(is.factor)hflights %&gt;% select_if(function(col) is.numeric(col) &amp;&amp; mean(col) &gt; 3.5)-------------------------------------------------------------------------------------------## 通过选项函数进行选择#列名中以元素x为首的列 - starts_with("x")select(iris_df, starts_with("Petal")) #列名中以元素x结尾的列 - ends_with("x")select(iris, ends_with("Width")) #列名中包含元素x的列 - contains("x")select(iris_df, contains("etal"))#排除对应的列，函数前加负号 -select(iris_df, - starts_with("Petal")) #所有变量 - everything() 一般调整数据集中变量顺序时使用select(df2tbl,y,everything()) #将变量y放到最前 #选择包含在声明变量中的 - one_of("")select(iris_df, one_of("Species","Petal.Width")) # 等价于 select(tbl_df, var,var) #选择名称符合指定匹配正则表达式的列 - matches("")select(iris, matches(".t.")) #选择x01到x05的变量 num_range('x', 1:5, width = 2) – 1234567891. vector-向量x &lt;- x[num:num] / &lt;- x[c(num1,num2,num3)]2.矩阵/数组/数据框--[]方括号中无逗号出现，表示选取列(1)z &lt;- z[i,j] / z[i, ] / z[, j] / z[i:j, ] / z[ ,i:j] / z[i:j] (2)z &lt;- z[c("row","row") , ] 有逗号/ z[, c("col","col")] / [c("col", "col")] 3.列表x &lt;- mylist[[ ]] --其中规则与2中相同 更改数据/创建新变量123456789101112131415161718192021222324252627## 在原始数据上做修改library(dplyr)transfrom()transform(df, var3=var1+var2) # 此时将创建新列； 若为 var2 = var2 * 1.5 则将替换为2倍的var2的值transform(gb, round(select(gb, 消费金额,激活净值,总收入_含点差),2)) # 因为在源数据上做修改，所以无需赋值 ## 创建新列data$new_col &lt;- c( , )----------------------------------------------------mutate(tbl_df, var3=var1+var2, var4=var3+..)# 优势在于可对刚添加的列进行变换`mutate(hflights_df, gain = ArrDelay - DepDelay, gain_per_hour = gain / (AirTime / 60)）` ## 对每一列运行窗口函数 - mutate_each()mutate_each(iris, funs(min_rank), [var1,var2])# 窗口函数--between() # 数据在a、b之间--lag # 把除最后一位以外的所有数据延后，第一个元素为NA--ntile # 把数据分为n分--lead # 把除第一个值以外的所有元素提前，最后一位为NA--percent_rank # 把数据在[0,1]中重组，并排序--row_number # 排序。并列时将并列数在前的序号在前--dense_rank #无缝排序--min_rank # 排序，并列时，其他序号延号 概述函数123456789101112131415161718192021222324252627282930313233# 创建新的对象library(dplry)summarize()## 对数据进行概述，并创建新的子集summarize(tbl_df,FUN,na.rm=T) # 常伴有na.rm=T`summarize(hflights_df, delay = mean(DepDelay, na.rm = TRUE))`# 概述函数--first() / last() / nth()--n() / n_distinct()--min() / max() / mean() / sd() / median() / IQR() / sum() ## 分组后求数据聚合summarize(group_by(df2tbl,x), sum(y))group_by(tbl_df,var) %&gt;% summarize(., sum(Y))## 对每一列运行概述函数summarise_each_(tbl, funs(mean(., na.rm=T)), vars)# vars, 与Select用法相同。如果确实，则选择所有未分组的变量.# funs(sum(., na.rm=T))--------------------------------------------------------------------------------------count()## 计算变量中每一个特定值的行数count(tbl_df, var, [wt=])# wt="" 若缺失，则统计数量；分类统计观测值行数count(iris, Species) # 分组计算Species列中各类别的频量；类似于基本函数包中的table函数# wt="",若指定某一列，则会通过计算非缺失值的总和来比对权重(weighted)；# wt = var2 ， 表示按var中的类别来分组计算var2中未缺失值的对应的求和count(iris, Species, wt=Sepal.Length) # 即按Species分组后，求对应Sepal.Length中的值的总和--等价于 iris %&gt;% group_by(., Species) %&gt;% summarize(., sum(Sepal.Length)) 分组与排序123456789101112131415library(dplyr)gropu_by## 分组groub_by(tbl_df, var) # var为分组变量iris %&gt;% group_by(., Species) %&gt;% summarize(., sum(Sepal.Length))# 为每一个分组分别进行概述iris %&gt;% group_by(., Species) %&gt;% mutate(., ...))# 按组计算新变量ungroup(iris) ## 移出数据框的分组信息 – 123456789101112131415161718library(dplyr)排序 - arrange()arrange(tbl_df,var,desc(var))# 默认为升序排序；降序为descarrange(flights, desc(dep_delay - arr_delay))# 可以在排序里面使用计算 --------------------------------------------------------------------------------------## 排序 reorder# 以对col2列进行函数FUN处理后为排序标准，对col1进行排序；默认为升序，且默认转为有序因子order=T reorder(data$col1, data$col2,FUN,[order=T]) with(InsectSprays, reorder(spray, count, median) # 以count列的中位数为排序标准对spray进行升序排列 --------------------------------------------------------------------------------------## 排序 - orderdata[order(data$col1, -data$col2)， ] # 负号，表示降序； 管道函数12%&gt;% # 将对象传递给下一个函数的第一个参数 数据合并12345678910111213141516171819202122232425bind_rows(y,z) # 将数据集z作为新的行插入到y中bind_cols(y,z) # 将数据集z作为新的列插入到y中## 但必须调整好顺序left_join(a,b,by="x1") # 向数据集a中加入匹配的数据集b记录inner_join(a,b,by="x1")outer_join(a,b, by="x1") # 保留所记录，所有行---------------------------------------------------------------------------------## 合并列cbind(object1, object2) # object1在前；但每个对象必须有相同的行数，且有相同的顺序；cbind(object1,object[,-1]) / cbind(object1, data$col)#1.当合并的对象中有要丢弃的向量时，可一步完成；#2.若不是对于丢弃的向量，data[,j]表示的是跟data的第j列合并---------------------------------------------------------------------------------## 合并行rbind(object1, object2)## merge合并merge(object1, object2, by="col_name"/=c("x1","x2")) # 按照by的内容来合并列 数据拆分123456对整个表格数据作用## 将连续型变量x分给为n个区间；用于创建美观的分割点pretty(x, n) ## 将连续型变量x分割成有n个水平的因子cut(x, n,[order_result=TRUE]) 数据划分1234567891011121314## 划分训练集、测试集library(caret)set.seed(1234) # 必须要有，因为划分是随机划分的；createDataPartition(y, p=0.x , time=1, list=TRUE)# time=num, (默认为1），要创建的分区的数目# p=0.x , 划分为p%的训练数据的百分比，故(1-p)为检验样本量的百分比# list=FALSE/TRUE，逻辑值； 一般为FALSE# y, target variable，目标变量inTraining &lt;- createDataPartition(hr_model$left, p = .75, list = FALSE) # 将数据进行划分成75%的训练样本和25%检验样本training &lt;- hr_model[ inTraining,] -将75%的训练样本数据添加到hr_modeltesting &lt;- hr_model[-inTraining,] -将余下25%的检验样本数据添加到hr_modelprint(table(hr_model$left)) - 输出分割后的数据行数 日期处理12345678910111213141516171819## 当前日期Sys.Date() / date()## 日期间隔 - difftmedifftime(object1, object2, units="") --"auto”,"secs”,"mins”,"hours”,"days”,"weeks”其中的一个，默认为天## 日期格式as.Data(object, "input_format")as.Date(x, "01/02/1956")## 输出指定格式的日期值，并可以提取日期中的某些部分format(x, format="output_foramt")format(today, format="%B %d %Y")# [1] "November 27 2014"format(today, format="%A")# [1] "Thursday" 数字处理1234567891011121314151617181920212223options(digigs=7) # 默认值## 指定小数位数（舍入） - roundround(x, [digits=num]) # 将x舍入为指定位数n的小数（默认值为0）## 指定有效位数（舍入） - sigif()sigif(x, [digits=num]) # 指定最小值的有效位数--sigif(3.531,digits=2) # 返回 3.5## 取整 - trunc()trunc(3.531) # 返回3## 取整 - 向上/向下floor() # 向下取整；等同于Intceiling() # 向上取整(大于等于x最小整数)-------------------------------------abs(x) # 绝对值x %% y # 余数 exp(x) # 指数ln(x) / log(x,[y]) # 对数sqrt(x) # 平方根x^n # 幂次方 – 12345678910111213## 列/行求和colSums(x)rowSums(x)## 行/列均值colMeans(x) rowMeans(x)range(object) # 值域quantile(x,c(0.n,0.n)) # 分位数sd(x) # 标准差var(x) # 方差 缺失值与唯一值1234567891011121314151617缺失值与不可能值## 检查缺失值is.na(x) # 缺失值colSums(is.na(x)) # 求该列缺失值的数量mean(is.na(x)) # 若比例小，可直接移除 na.omit(x)is.nan(x) # 不可能值is.infinite(x) # 无穷值---------------------------------------------## 移除缺失值na.rm = T # 在计算之前将缺失值移除，可用在函数内部## 整行删除na.omit(x) # 移除所有含缺失值所在的行【删除整行】newdata &lt;- na.omit(mydata) # 用来存储没有缺失值的数据 – 12345678910111213141516171819唯一值## 只对向量可用；或对 各行中各变量完全相同的行取一行unique(x) ## 可对数据框使用!duplicated(x) # 返回逻辑值；若完全相同则为TRUE逻辑：返回data中所有不相同的值，然后在进行行选取data[x, ]# 删除各行中变量完全相同的值 = unique(x)data &lt;- data[!duplicated(data), ] --# 返回各列所有相同的值 data[duplicated(test),]# 删除某变量中相同的值data &lt;- data[!duplicated(test[, "var"]), ] -- # 返回单列所有相同的值 data[duplicate(test[,var]),]# 删除某两个变量完全相同的行 data &lt;- data[!duplicated(test[, c("var1","var2")], ] -- # 返回多列相同的值 data[dulpicated(test[,c("var1","var2")],] 逻辑判断1which() # 返回为真的逻辑对象，允许对数组array使用 R符号常见符号 名称 作用 示例 &lt;- 赋值符号 / 转义符 [ ] 给定元素所处位置的数值 a[c(2,4)] ： 用于表示一个数值序列 a[2:6] [i,j] 选择指定的行与列 [i,] [,j] [i,j] [,] “” 用于目录名、文件名、包 ‘ ‘ 引用双引号的文字为文本时出现 labs(title=’ positon=”fill” ‘) # 用于注释。#之后出现的任何文本都会被R解释器忽视； 并且R只能对单行进行注释，故当出现多条命令符，需在每行前面加上# $ 选取一个给定数据框中的某个特定变量 patientIDdata$age &lt;&lt;- 特殊赋值符 [[ ]] 用于列表中选取对象 mylist[[“ages”]] mylist[[2]] ^或** 求幂 x% %y 求余数（x mod y) 5%%2=1 x% / %y 整数除法。5%/2%=2 == 严格等于（在浮点型数值时慎用==） 2+2==4 != 不等于 !x 非x x∣y x或y x&amp;y x和y isTRUE(x) 测试x是否为TRUE [,-1] [-1,] [,c(-2,-3)]/[,-c(2,3)] 删除第一列 删除第一行 删除多列，两种表达方式均可 mydata&lt;-mydata[,-1] mydata&lt;-mydata[,-c(2,3)] “[“ 提取谋而对象一部分的函数，后跟序列数n；1表示该对象的第一部分； 2表示该对象的第二部分； R中常见表达式 符号 作用 示例 解释 ～ 分隔符号 y～x+z+w 左边-因变量/响应变量 右边-自变量/解释变量 + 分隔预测变量 ： 预测变量的交互项 y～x+z+x:z * 所有可能交互项的表达方式 y～xzw—y～x+z+w+x:z+x:w+z:w ^ 交互项的某个次数 y～(x+z+w)^2—y～x+z+w+x:z+x:w+z:w 交互项最高次为2次 . 包含除因变量之外的所有变量 y～.—y～x+z+w 当一个数据框包含y,x,z,w这四个变量时 - 减号，从等式中移除某个变量 y～(x+z+w)^2-x:w— y～x+z+w+x:z+z:w -1 删除截距项 y～x-1 拟合y在x上的回归，并强制直线通过原点 I() 【大写的i】 从算术（而非表示式）的角度来解释括号中的元素 y～x+I((z+w)^2) 表示的是x+(z+w)²，而非x+z+w+z:w function 可以在表达式中运用的数学函数 log(y)～x+z+w mpg ~ wt \ cyl 表示按条件（cyl）绘图； 即按cyl的水平为【分组条件】分别绘制mpg和wt的关系图 研究设计表达式 表达式 作用 解释 y～A 单因素ANOVA 1.小写字母，定量变量 2.大写字母，组别因子（若不转换为factor，则默认为定量协变量） 3.Subject，被试者独有的标志变量 4.Error(Subject/A)，表示组内因子 y～x+A 含单个协变量的单因素ANCOVA y～A * B 双因素ANOVA 展开为 ~A+B+A:B y～x1+x2+A*B 含两个协变量的双因素ANCOVA y～B+A（B是区组因子） 随机化区组 y～A + Error(Subject/A) 单因素组内ANOVA y～B*W+Error(Subject/W) 含单个组内因子(W)和单个组间因子(B)的重复测量ANOVA 展开为 ~B+W+B:W]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Next主题_定制]]></title>
      <url>%2F2017%2F03%2F18%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FHexo%2FNext%E4%B8%BB%E9%A2%98_%E5%AE%9A%E5%88%B6%2F</url>
      <content type="text"><![CDATA[对Next主题配置的补充。 所有的标签之后要有一个空格；date:(空一格) 2017/03/20 对于网站加载的具体问题，按F12(chrome浏览器)进行查看； 图片背景图片 首先找到一个背景图片放到 hexo -&gt; themes -&gt; next -&gt; source -&gt; images 的路径下； hexo -&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _custom ，找到路径下的custom.styl文件，在文件的最上方加上一代码 12345// Custom styles.body &#123; background:url(/images/background.jpeg); background-attachment: fixed;&#125; ​ 文章开头加入图片 且支持点击放大功能 how ：开头匹配内容中假如photos字段，可以加图片链接列表： 12345678---title: Next主题的fancybox展示图片date: 2016-09-03 17:15:22tags:photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg--- 或者使用 截断；将图片放到more之前即可； 更改显示标签 在所选的语言中themes\hexo-theme-next\languages\zh-Hans.yml中修改 1234567891011121314post: sticky: 置顶 posted: 发表于 modified: 更新于 in: 分类于 visitors: 阅读次数 read_more: 阅读全文 untitled: 未命名 toc_empty: 此文章未包含目录 -------# 示例，若将modified: 更新于更改为 modified: 在文章显示的标签就不再有&quot;更新于&quot;三个字，而是直接显示时间 显示更新日期 主题配置文件 在hexo/themes/hexo-theme-next/_config.yml中将updated_at改为true 123# Post meta display settingspost_meta: updated_at: true 文章的前置设置 1updated: 2015-12-13 updated的时间要晚于date的时间。 然后重新hexo g一下就可以看到效果了。 置顶设置 修改站点文件夹下 node_modules/hexo-generator-index/lib/generator.js 添加以下代码 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 以下为更改后的整体代码 修改后只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序。 （数字大的在前面； 3 &gt;2&gt;1 ; 若top值一样则按照文章日期降序排） 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 评论系统NexT 支持多款评论系统。 如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 分享系统 在站点配置文件中，添加字段baidushare，值为 true 关于什么是站点配置文件，我相信大家应该清楚了，如果不知道的话请看我的上一篇博文中有所提及。 1baidushare: true #百度分享功能 在主题配置文件中，找到baidushare字段，设置其展现方式 12baidushare: type: button #百度分享展示的方式button|slide 做好上面两步后，在你的百度分享还没有出现的情况下，打开浏览器的F12,发现提示https访问http资源的问题。之后介绍怎么解决百度分享在https下的使用。 百度分享在https中的使用 百度分享不能使用的主要原因是它会去请求http中的资源，一个share.js，既然这样，我们能想到的就是把这个资源放到非http上，或者干脆直接放到我们自己的目录下面。 大家可以按照方案提供者hrwhisper依照他的博文百度分享不支持https的解决方案去做，在遇到问题的时候回到我的博文，或者可以直接按照我说的做。 下载资源文件，并放到自己blog的目录下。 Github地址：https://github.com/hrwhisper/baiduShare 这里我要强调一下，在站点配置文件中，有一个source_dir字段，这个是你访问资源的根目录，比如我在sourc中放置了一个test.jpg的文件，那么访问它的路径就是/test.jpg 1source_dir: source static 解压后丢到站点根目录，也就是source目录下面。然后将百度分享中的代码修改，我使用的是Next主题，这段代码在文件F:\myblog\themes\next\layout_partials\share\baidushare.swing中，(显示顺序的调整，可在该文件中)如果你找不到可以在你的主题文件夹中搜索baidushare。 123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 这样之后重启服务，看看百度分享是不是出现了，如果出现了，恭喜你，成功了。如果没有，请你继续往下看。 在站点配置文件中设置skip_render字段 在你发现百度分享还是没有出现的时候，打开F12，是不是发现share.js文件已经成功加载了，但是这个文件报错，你进入F:\myblog.deploy_git\static\api\js(我的就是这个目录，因为我把博客放在了F:\myblog下)，打开share.js文件，发现这个文件末尾并没有加载完，我我们下载下来的static\api\js\share.js是不一样的，为什么？ 原来，hexo会把/source下的文件全部渲染 怎么解决这个问题，有两种办法：你可以设置站点配置文件下的skip_rende字段，让hexo在渲染的时候跳过static之下的所有文件。 123456789skip_rende: static/**#单个文件夹下的全部文件：skip_render: test/*#单个文件夹下的指定类型文件：skip_render: test/*.md#单个文件夹下的全部文件以及子目录:skip_render: test/**#多个文件夹：#skip_render:# test1/*.html #注意前面的空格，代表是skip_render之下的# test2/** 你也可以选择不设置这个属性，而是把static文件放在主题文件的source目录下，我的是（F:\myblog\themes\next\source）。做完这些操作后，你的百度分享应该已经出现在你的博客中了，just enjoy it。（ps：除了以上解决百度在https下使用的方法以外，还有一个方法就是使用CDN，具体方式请参考巧用七牛CDN的镜像功能使百度分享支持HTTPS。再多说一句关于JiaThis不能支持https的问题个人觉得也可以用以上的方式来解决，这个大家可以自行研究。）（ps plus：关于博客的搭建就暂时告一段落了。）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R_安装与配置]]></title>
      <url>%2F2017%2F03%2F16%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FR%2FR_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2FR_%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[R语言安装、卸载与基本配置； 工作空间 工作空间（workspace）就是当前R的工作环境，它储存着所有用户定义的对象（向量、矩阵、函数、数据框、列表） 。 在一个R会话结束时，你可以将当前工作空间保存到一个镜像中，并在下次启动R时自动载入它。 获得与修改当前存储路径 123456789101112131415161718# 返回当前目录getwd()# 指定存储路径setwd("D:/Downloads/R")--同时在RStudio — Tools — Global Options — General 中设置默认路径# 列出当前工作空间中的对象ls()# 移除一个对象rm(object) options() # 显示或设置当前选项load("myfile") # 读取一个工作空间到当前回话中 默认值为.RDataloadhistory("myfile") # 载入一个命令历史文件（默认值为.Rhistory） 保存 save(objectlist, file=”myfile”) ： 保存指定对象到一个文件中 save.image(“myfile”) ： 保存工作空间到文件myfile中（默认值为.RData） savehistory(“myfile”) ： 保存命令历史到文件myfile中（默认值为.Rhistory） 数据库相关1234567891011121314151617# 列出当前工作空间中的对象ls()# 读取一个工作空间到当前会话中（默认值为.Rdata）load("myfile")# 保存指定对象到一个文件中save(objectlist,file="myfile")# 移除一个/多个对象rm(objectlist)# 在当面会话从执行一个脚本source("filename")# 退出Rq() 帮助文档1234567891011121314# 打开帮助文档首页help.start()# 查看函数foo的帮助?foo / help(foo) # 函数foo的使用示例example("foo")# 以foo为关键词搜索本地帮助文档??foo / help.serach(foo) # 列出名称中含有foo的所有可用函数apropos("foo",mode="function") 包的使用 install.packages(&quot;name&quot;, destdir=&quot;D:\\3_资源收集\\90_软件安装\\4 程序编程\\R\\library&quot;) 12lib_down &lt;- c("D:\\3_资源收集\\90_软件安装\\4 程序编程\\R\\library")install.packages("", destdir=lib_down) 若在Rstudio中安装失败，可选择在R中进行安装 常用安装包 12345678library(readr)library(readxl)library(dplyr)library(reshape2)library(stringr)library(lubridate)library(scales)library(ggplot2) 1234567891011121314151617181920212223242526# 安装包install.packages("ggplot2")--# 安装多个包install.packages(c("name1","name2"))# 加载包library(ggplots)# 移除已加载的包detach("package:name")# 卸载包remove.packages("name")# 更新包update.packages("ggplot2")# 包-帮助help(package="ggplot2")# 包-调用函数 两个冒号package::fun(x) - Hmisc::describe(myvars) # 调用Hmisc中的describe函数来对myvars得出统计量# 查看已安装的包installed.packages() 手动安装包 下载package.zip文件 打开R的菜单栏-&gt;Packages-&gt;“Install package from local zip file… 选择package.zip文件 研究过R包的结构的朋友就会发现，zip文件解压之后就是R中library里的结构。那么，我们可以直接解压zip包，然后将解压后的文件放入R安装根目录的library文件夹里 我在CRAN上没找到目标包，是什么情况（如功能强大的Rweibo包）？ 答：这时候不要急，可能该包在R-forge project 上，上该站查查看吧。 报错与解决 missing value where TRUE/FALSE needed 12# With a little digging into Github, the answer seems to be specifying the following in the .Rprofile:options(repos=c(CRAN="https://cran.rstudio.com/")) 常用的包 lib_down &lt;- &quot;D:\\1_工作学习\\90_软件应用\\3_程序编程\\R\\library&quot; destination : 目的地 1234567&gt; # 常用&gt; c("readr","readxl","xlsx","dplyr","plyr", "reshape2","stringr","ggplot2","plotly","lubridate"，"rmarkdown","knitr")&gt;&gt; # 统计分析&gt; c("Hmisc","pastecs","psych","doBy","car","effects","leaps","corrgram","corrplot","vcd","ggm","gmodels")&gt;&gt; &gt; 数据导入与导出 1install.packages(c("readr","readxl","xlsx"),destdir=lib_down) 数据处理 1install.packages(c("dplyr","plyr", "reshape2"),destdir=lib_down) 字符串 1install.packages(c("stringr"), destdir=lib_down) 作图 1234install.packages(c("ggplot2","plotly"),destdir=lib_down)# plotly :交互式作图# grid : 一页多图 日期 1install.packages(c("lubridate"),destdir=lib_down) 自动化 12345678910install.packages(c("knitr","rmarkdown"), destdir=lib_down)-----------------------------------------------------------------------------------在Tools-Golbal options-Sweave-weave Rnw files using -选择knitr 新建一个Rmd的文件，或者在File-new file-R markdown，新建一个Rmd的文件。 操作 Markdown中的R语言的代码是三个后引号,然后后面加上&#123;r&#125;开始,&#123;r,&#125; 大括号中，r字母后面可以加入不同的参数 ```&#123;r,eval=FALSE&#125;​ 123456789&lt;br&gt;### 统计分析- **描述统计量**```rinstall.packages(c(&quot;Hmisc&quot;,&quot;pastecs&quot;,&quot;psych&quot;,&quot;doBy&quot;),destdir=lib_down) 列联表 1install.packages(c("gmodels"),destdir=lib_down) 相关性 1install.packages(c("corrgram","corrplot","vcd","ggm"),destdir=lib_down) 回归 1install.packages(c("car","effects","leaps"),destdir=lib_down) 方差分析 1install.packages(c("gplots","multcomp"),destdir=lib_down) 时间序列 1install.packages(c("forecast","satas"),destdir=lib_down) 机器学习 聚类 12 代码格式 内容 注意 示例 缩进 1.两个空格，不要使用制表符，永远不要混用 2.例外: 当括号内发生折行时, 所折行与括号内的第一个字符对齐 二元操作符（+,&lt;-,-等） 1.两侧加上空格 2.在函数调用中传递参数时 = 两边的空格可加可不加. 逗号（，） 逗号后须加空格，逗号前不加空格 括号( ) 在前括号前加一个空格, 函数调用时除外. 正例: if (debug) 反例: if(debug) 连接数据库 参照 新增数据库设置 控制面板项 - 管理工具 - 数据源（ODBC） 添加 - 选择对应的SQL Name ： 可以任意取 Server ： locale 或者指定的数据库 anly2.dm.ytx.com 使用登录的Windows账户 或者 自定义账户密码 进入R安装RODBC包并载入 123456install.packages("RODBC")library(RODBC) connect=odbcConnect('name',uid='xxx',pwd='xxx') #连接前面创建的数据库，本机的话uid和pwd可以忽略; # name 为之前设置的Name；# 若之前设置时 选择使用Windows登录的账户，则账户密码不用填写connect &lt;- odbcConnect("SQLServer") 查询 123456789101112131415# 使用sql进行查询sqlQuery(connect,"select * from USArrests") # 从数据库读取数据表，并返回一个数据框对象sqlFetch(channel, "USArrests",rownames = "state") # 查看数据库中的表sqlTables(connect) # 返回数据库中表的信息sqlTables(channel) # 返回数据库表sqtable列的信息sqlColumns(channel, sqtable) 存入表格 1234data(USArrests) #把R自带的数据USArrests 写入数据库中sqlSave(connect,USArrests,rownames = "state",addPK = TRUE) #把行名称改为state,并保存，此时进入数据库可看到表格sqlSave(connect, mydf, tablename = sqtable, append = FALSE) # 将一个数据框写入或更新(append=True)到数据库 删除 12345# 删除表中的内容sqlClear(channel, sqtable) # 删除表格sqlDrop(channel,"USArrests") 关闭连接 1odbcClose(connect) #关闭连接 Jupyter中添加R 方法1 1234nstall.packages('devtools')devtools::install_github('IRkernel/IRkernel')# or devtools::install_local('IRkernel-master.tar.gz')IRkernel::installspec() # to register the kernel in the current R installation Per default IRkernel::installspec() will install a kernel with the name “ir” and a display name of “R”. Multiple calls will overwrite the kernel with a kernel spec pointing to the last R interpreter you called that commands from. You can install kernels for multiple versions of R by supplying a name and displayname argument to the installspec() call (You still need to install these packages in all interpreters you want to run as a jupyter kernel!): 1234# in R 3.3IRkernel::installspec(name = 'ir33', displayname = 'R 3.3')# in R 3.2IRkernel::installspec(name = 'ir32', displayname = 'R 3.2') Now both R versions are available as an R kernel in the notebook. If you encounter problems during installation Have a look at the full installation instructions! Search the existing open and closed issues. If you are sure that this is a new problem, file an issue. 方法2 Installing via supplied binary packages Making the kernel available to Jupyter 1234567install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))devtools::install_github('IRkernel/IRkernel')# Don’t forget step 2/2!# Third 该步骤无需网络IRkernel::installspec()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库_关系型数据库结构]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F90_%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%2F10_%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[关系数据库的层次结构可以分为四级：数据库(Database)、表(Table)与视图、记录(Record)和字段(Field)，相应的关系理论中的术语是数据库、关系、元组和属性 数据库类型划分 本地数据库：数据库驻留在本机驱动器或局域网中，如果多个用户并发访问数据库，则采取基于文件的锁定(防止冲突)策略 典型的本地数据库有Paradox、dBASE、FoxPro以及Access等 基于本地数据库的应用程序称为单层应用程序，因为数据库和应用程序同处于一个文件系统中。 远程数据库 ：数据库通常驻留于其他机器中，用户通过结构化查询语言SQL来访问远程数据库中的数据；远程数据库又称为SQL服务器 来自于远程数据库的数据并不驻留于一个机器而是分布在不同的服务器上。典型的SQL服务器有InterBase、Oracle、Sybase、Informix、MicrosoftSQLServer，以及IBMDB2等。 基于SQL服务器的应用程序称为两层或多层应用程序，因为数据库和应用程序驻留在彼此不依赖的系统(层)中。 表 关系数据库的基本成分是一些存放数据的表(关系理论中称为“关系”) 数据库中的表从逻辑结构上看相当简单，它是由若干行和列简单交叉形成的，不能表中套表。 要求表中每个单元都只包含一个数据 ​ 视图 what：一个查询所定义的虚拟表；视图其实没有改变任何事情，只是对访问的数据进行了某种形式的筛选。 why ：利用视图访问经过筛选和处理的数据，而不是直接访问基础表，在一定程度上也保护了基础表 只显示他们关心的数据；或者不给予用户访问基础表的权利； how ：如果你要创建一个视图，为其指定一个名称和查询即可。Sql Server只保存视图的元数据，用户描述这个对象，以及它所包含的列，安全，依赖等。当你查询视图时，无论是获取数据还是更新数据，Sql server都用视图的定义来访问基础表；【如下为要求】 不能在视图定义中指定ORDER BY ，除非定义中包含Top或For Xml 说明； 所有的列必须有列名； 这些所有的列名必须唯一； 123CREATE VIEW dbo.V1 AS SELECT CustomerID,CompanyName FROM Customers WHERE EXISTS(SELECT * FROM Orders WHERE Customers.CustomerID = Orders.CustomerID); 1234# 只有指定了Top或for xml语句后，ORDER BY 才能使用ALTER VIEW dbo.V1 AS SELECT TOP(10) CustomerID,CompanyName FROM Customers WHERE EXISTS(SELECT * FROM Orders WHERE Customers.CustomerID = Orders.CustomerID) ORDER BY CompanyName 这表明视图绝不可能像只是直接运行底层SELECT语句那样快。不过，视图存在有一个原因–这就是它的安全性或为用户所做的简化，在你的需要和开销之间权衡，找到最适合特定情况的解决方案。 记录 what：表中的一行称为一个记录。 how ：一个记录的内容是描述一类事物中的一个具体事物的一组数据 记录的集合(元组集合)称为表的内容，表的行数称为表的基数。 表名以及表的标题是相对固定的，而表中记录的数量和多少则是经常变化的 字段 what：表中的一列称为一个字段。 how ：每个字段表示表中所描述的对象的一个属性；每个字段都包含了数据类型相同的一批数据，因此，字段名相当于一种多值变量。字段是数据库操纵的最小单位。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库_关系模型]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F90_%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%2F10_%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[介绍数据库模型中的关系模型。 关系模型 what：采用二维表格结构表达实体类型及实体间联系的数据模型。 how ：关系模型中无论是实体还是实体间的联系均由单一的结构类型——关系来表示。在实际的关系数据库中的关系也称表。一个关系数据库就是由若干个表组成。 基本概念与术语1. 关系 - 表关系(Relation)：一个关系对应着一个二维表，二维表就是关系名。 2. 元组 - 行元组(Tuple)：在二维表中的一行，称为一个元组。 3. 属性 - 列属性(Attribute)：在二维表中的列，称为属性。属性的个数称为关系的元或度。列的值称为属性值； 4. 域 - 值域（值）域(Domain)：属性值的取值范围为值域。 5. 分量 - 具体的值分量：每一行对应的列的属性值，即元组中的一个属性值。 6. 关系模型关系模式：在二维表中的行定义，即对关系的描述称为关系模式。一般表示为（属性1，属性2，……,属性n）；如老师的关系模型可以表示为教师（教师号，姓名，性别，年龄，职称，所在系）。 7. 键 - 唯一标识键(码)：如果在一个关系中存在唯一标识一个实体的一个属性或属性集称为实体的键，即使得在该关系的任何一个关系状态中的两个元组，在该属性上的值的组合都不同。 8. 候选键候选键(候选码)：若关系中的某一属性的值能唯一标识一个元组；如果在关系的一个键中不能移去任何一个属性，否则它就不是这个关系的键，则称这个被指定的候选键为该关系的候选键或者候选码。 例如下列学生表中“学号” 【或】 “图书证号”都能唯一标识一个元组，则“学号”和“图书证号”都能唯一地标识一个元组“学号”和“图书证号”都可作为学生关系的候选键。 学号 姓名 性别 年龄 图书证号 所在系S3001 张明 男 22 B20050101 外语S3002 李静 女 21 B20050102 外语S4001 赵丽 女 21 B20050301 管理 选课表中，只有属性组“学号”【和】 “课程号”才能唯一地标识一个元组，则候选键为（学号，课程号） 学号 课程号S3001 C1S3001 C2S3002 C1S4001 C3 9. 主键 - 选定一个唯一标识主键（主码）：在一个关系的若干候选键中指定一个用来唯一标识该关系的元组，则称这个被指定的候选键称为主关键字，或简称为主键、关键字、主码。每一个关系都有并且只有一主键 通常用较小的属性组合作为主键。 学生表，选定“学号”作为数据操作的依据，则“学号”为主键 选课表中，主键为（学号，课程号） 10. 主属性和非主属性主属性和非主属性：关系中包含在任何一个候选键中的属性称为主属性，不包含在任何一个候选键中的属性为非主属性。 11. 全键（全码）全键或者全码：一个关系模式中的所有属性的集合。 12. 外键（外码）外键或者外码：关系中的某个属性虽然不是这个关系的主键，但它却是另外一个关系的主键时，则称之为外键或者外码。 13. 超键（超码）超键或者超码：如果在关系的一个键中移去某个属性，它仍然是这个关系的键，则称这样的键为关系的超键或者超码。 14. 参照关系与被参照关系参照关系与被参照关系：是指以外键相互联系的两个关系，可以相互转化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Excel_常用功能]]></title>
      <url>%2F2017%2F03%2F11%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FOffice_Excel%2FExcel_%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[Excel常用功能指引。 判断两列相同值在第三列中输入如下函数 = 1234567Vlookup(&apos;判断列&apos;, &apos;查找区域&apos;,&apos;从左到右第n列&apos;, &apos;精确查找0&apos;)-----------------------------------------------------if(A1=B1,&apos;相同&apos;,&apos;不相同&apos;)----------------------------------------------------Excat(text1, text2) ; 比较两个字符串是否相同（区分大小写）。返回TRUE 或 FASLE 数值双击后才显示完全1选中 — 数据 — 分列 — 输出为“文本” 合并CONCATENATE() 1234=concatenate(text1,text2)--or--= A1&amp;A2&amp;&apos;.&apos;&amp; 创建自定义序列 有关Excel 2010和更高版本中，单击文件&gt;选项&gt;高级&gt;常规&gt;编辑自定义列表。 先将排序号的字段编写出来，直接选择导入即可 数据透视数据透视表合并标签数据透视表 — 选项 — 布局和格式 — 合并且居中排列带标签的单元格 透视表数据排序选中透视表某个字段 — 数据 — 排序 统计重复项目将同一个变量同时置入 “列” 与 “值” 两个框中 作图散点图 - 分组 多数据系列图表的绘制一般需要使用数据添加功能 修改形状 在已经生成的散点图的散点上，单击鼠标右键，“设置数据系列格式”，选择“填充”中的“标记”，在“数据标记选项”中，勾选“内置”，然后选择“类型”中的形状，并调节形状的大小，即可以其他形状（也可以是图片），代替熟悉的圆点标记。 常用函数清洗处理类主要是文本、格式以及脏数据的清洗和转换。很多数据并不是直接拿来就能用的，需要经过数据分析人员的清理。数据越多，这个步骤花费的时间越长。 Trim清除掉字符串两边的空格。 MySQL有同名函数，Python有近似函数strip。 Concatenate=Concatenate(单元格1，单元格2……) 合并单元格中的内容，还有另一种合并方式是&amp;。”我”&amp;”很”&amp;”帅” ＝我很帅。当需要合并的内容过多时，concatenate的效率快也优雅。 MySQL有近似函数concat。 Replace=Replace（指定字符串，哪个位置开始替换，替换几个字符，替换成什么） 替换掉单元格的字符串，清洗使用较多。 MySQL中有同名函数，Python中有同名函数。 Substitute和replace接近，区别是替换为全局替换，没有起始位置的概念 Left／Right／Mid=Mid(指定字符串，开始位置，截取长度) 截取字符串中的字符。Left/Right（指定字符串，截取长度）。left为从左，right为从右，mid如上文示意。 MySQL中有同名函数。 Len／Lenb返回字符串的长度，在len中，中文计算为一个，在lenb中，中文计算为两个。MySQL中有同名函数，Python中有同名函数。 Find=Find（要查找字符，指定字符串，第几个字符） 查找某字符串出现的位置，可以指定为第几次出现，与Left／Right／Mid结合能完成简单的文本提取MySQL中有近似函数 find_in_set，Python中有同名函数。 Search和Find类似，区别是Search大小写不敏感，但支持＊通配符 Text将数值转化为指定的文本格式，可以和时间序列函数一起看 关联匹配类在进行多表关联或者行列比对时用到的函数，越复杂的表用得越多。多说一句，良好的表习惯可以减少这类函数的使用。 Lookup=Lookup（查找的值，值所在的位置，返回相应位置的值） 最被忽略的函数，功能性和Vlookup一样，但是引申有数组匹配和二分法。 Vlookup=Vlookup(查找的值，哪里找，找哪个位置的值，是否精准匹配) Excel第一大难关，因为涉及的逻辑对新手较复杂，通俗的理解是查找到某个值然后黏贴过来。 Index＝Index（查找的区域，区域内第几行，区域内第几列） 和Match组合，媲美Vlookup，但是功能更强大。 Match＝Match（查找指定的值，查找所在区域，查找方式的参数） 和Lookup类似，但是可以按照指定方式查找，比如大于、小于或等于。返回值所在的位置。 Row返回单元格所在的行 Column返回单元格所在的列 Offset＝Offset（指定点，偏移多少行，偏移多少列，返回多少行，返回多少列） 建立坐标系，以坐标系为原点，返回距离原点的值或者区域。正数代表向下或向左，负数则相反。 逻辑运算类数据分析中不得不用到逻辑运算，逻辑运算返回的均是布尔类型，True和False。很多复杂的数据分析会牵扯到较多的逻辑运算 IF经典的如果但是，在后期的Python中，也会经常用到，当然会有许多更优雅的写法。也有ifs用法，取代if(and())的写法。 MySQL中有同名函数，Python中有同名函数。 And全部参数为True，则返回True，经常用于多条件判断。 MySQL中有同名函数，Python中有同名函数。 Or只要参数有一个True，则返回Ture，经常用于多条件判断。 MySQL中有同名函数，Python中有同名函数。 IS系列常用判断检验，返回的都是布尔数值True和False。常用ISERR，ISERROR，ISNA，ISTEXT，可以和IF嵌套使用。 计算统计类常用的基础计算、分析、统计函数，以描述性统计为准。具体含义在后续的统计章节再展开。 Sum／Sumif／Sumifs统计满足条件的单元格总和，SQL有中同名函数。 MySQL中有同名函数，Python中有同名函数。 Sumproduct统计总和相关，如果有两列数据销量和单价，现在要求卖出增加，用sumproduct是最方便的。 MySQL中有同名函数。 Count／Countif／Countifs统计满足条件的字符串个数 MySQL中有同名函数，Python中有同名函数。 Max返回数组或引用区域的最大值 MySQL中有同名函数，Python中有同名函数。 Min返回数组或引用区域的最小值 MySQL中有同名函数，Python中有同名函数。 Rank排序，返回指定值在引用区域的排名，重复值同一排名。 SQL中有近似函数row_number() 。 Rand／Randbetween常用随机抽样，前者返回0~1之间的随机值，后者可以指定范围。 MySQL中有同名函数。 Averagea求平均值，也有Averageaif，Averageaifs MySQL中有同名函数，python有近似函数mean。 Quartile=Quartile（指定区域，分位参数） 计算四分位数，比如1~100的数字中，25分位就是按从小到大排列，在25%位置的数字，即25。参数0代表最小值，参数4代表最大值，1~3对应25、50（中位数）、75分位 Stdev求标准差，统计型函数，后续数据分析再讲到 Substotal=Substotal（引用区域，参数） 汇总型函数，将平均值、计数、最大最小、相乘、标准差、求和、方差等参数化，换言之，只要会了这个函数，上面的都可以抛弃掉了。 Int／Round取整函数，int向下取整，round按小数位取数。 round(3.1415,2)=3.14 ; round(3.1415,1)=3.1 时间序列类专门用于处理时间格式以及转换，时间序列在金融、财务等数据分析中占有较大比重。时机序列的处理函数比我列举了还要复杂，比如时区、分片、复杂计算等。这里只做一个简单概述。 Year返回日期中的年 MySQL中有同名函数。 Month返回日期中的月 MySQL中有同名函数。 Weekday=Weekday(指定时间，参数) 返回指定时间为一周中的第几天，参数为1代表从星期日开始算作第一天，参数为2代表从星期一开始算作第一天（中西方差异）。我们中国用2为参数即可。 MySQL中有同名函数。 Weeknum=Weeknum(指定时间，参数) 返回一年中的第几个星期，后面的参数类同weekday，意思是从周日算还是周一。 MySQL中有近似函数 week。 Day返回日期中的日（第几号） MySQL中有同名函数。 Date=Date（年，月，日） 时间转换函数，等于将year()，month()，day()合并 MySQL中有近似函数 date_format。 Now返回当前时间戳，动态函数 MySQL中有同名函数。 Today返回今天的日期，动态函数 MySQL中有同名函数。 Datedif=Datedif（开始日期，结束日期，参数） 日期计算函数，计算两日期的差。参数决定返回的是年还是月等。 MySQL中有近似函数 DateDiff。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mathjax与LaTex公式简介]]></title>
      <url>%2F2017%2F03%2F11%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FMarkdown%2FMathjax%E4%B8%8ELaTex%E5%85%AC%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[MathJax简介MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。 MathJax项目于2009年开始，发起人有American Mathematical Society, Design Science等，还有众多的支持者，个人感觉MathJax会成为今后数学符号渲染引擎中的主流，也许现在已经是了。 本文接下来会讲述MathJax的基础用法，但不涉及MathJax的安装及配置。此外，推荐使用StackEdit学习MathJax的语法，它支持Markdown和MathJax，本文使用此编辑器撰写。 https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/5044 基础公式标记与查看公式使用MathJax时，需要用一些适当的标记告诉MathJax某段文本是公式代码。此外，MathJax中的公式排版有两种方式，inline和displayed。inline表示公式嵌入到文本段中，displayed表示公式独自成为一个段落。例如，f(x)=3×xf(x)=3×x这是一个inline公式，而下面 f(x)=3×xf(x)=3×x 在MathJax中，默认的displayed公式分隔符有$$...$$ 和\[…\],而默认的inline公式分隔符为(…),当然这些都是可以自定义的，具体配置请参考文档。下文中，使用$$…$$作为displayed分隔符，$…$作为inline分隔符。 此外，可以在渲染完成的公式上方右键点击，唤出右键菜单。在菜单中提供了查看公式代码、设置显示效果和渲染模式的选项。 希腊字母请参见下表： 名称 大写 Tex 小写 Tex alpha AA A αα \alpha beta BB B ββ \beta gamma ΓΓ \Gamma γγ \gamma delta ΔΔ \Delta δδ \delta epsilon EE E ϵϵ \epsilon zeta ZZ Z ζζ \zeta eta HH H ηη \eta theta ΘΘ \Theta θθ \theta iota II I ιι \iota kappa KK K κκ \kappa lambda ΛΛ \Lambda λλ \lambda mu MM M μμ \mu nu NN N νν \nu xi ΞΞ \Xi ξξ \xi omicron OO O οο \omicron pi ΠΠ \Pi ππ \pi rho PP P ρρ \rho sigma ΣΣ \Sigma σσ \sigma tau TT T ττ \tau upsilon ΥΥ \Upsilon υυ \upsilon phi ΦΦ \Phi ϕϕ \phi chi XX X χχ \chi psi ΨΨ \Psi ψψ \psi omega ΩΩ \Omega ωω \omega 上标^ 与下标_上标和下标分别使用^ 与_ ，例如x_i^(空格)2：$x_i ^2$。 默认情况下，上下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{..}包裹起来的内容。 也就是说，如果使用10^10，会得到$10^10$，而10^{10}才是$10^{10}$。 同时，大括号还能消除二义性，如x^5^6将得到一个错误，必须使用大括号来界定^的结合性， ​ 如{x^5}^6：${x^5}^6$ 或者 x^{5^6}： $x^{5^6}$ 带帽符号对于单字符，\hat：x^x^，多字符可以使用\widehat,xyˆxy^.类似的还有\hat,\overline,\vec,\overrightarrow, \dot \ddot : x^xyz¯¯¯¯¯¯¯¯a⃗ x→x˙x¨x^xyz¯a→x→x˙x¨。 符号 代码 $\hat{y}$ \hat{y} $\check{y}$ \check{y} $\breve{y}$ \breve{y} $\overline y$ \overline 括号 小括号与方括号：使用原始的( )，[ ]即可，如(2+3)[4+4]：(2+3)4+4[4+4] 大括号：时由于大括号{}被用来分组，因此需要使用{和}表示大括号，也可以使用\lbrace 和\rbrace来表示。如{ab}:a∗ba∗b，\lbrace ab \rbrace：{a∗b}{a∗b}。 尖括号：使用\langle 和 \rangle表示左尖括号和右尖括号。如\langle x \rangle：⟨x⟩⟨x⟩。 上取整：使用\lceil 和 \rceil 表示。 如，\lceil x \rceil：⌈x⌉⌈x⌉。 下取整：使用\lfloor 和 \rfloor 表示。如，\lfloor x \rfloor：⌊x⌋⌊x⌋。 不可见括号：使用.表示。 需要注意的是，原始符号并不会随着公式大小缩放。如，(\frac12)：(12)(12)。可以使用\left(…\right)来自适应的调整括号大小。如下， {∑i=0ni2=(n2+n)(2n+1)6}(1.1)(1.1){∑i=0ni2=(n2+n)(2n+1)6} {∑i=0ni2=(n2+n)(2n+1)6}(1.2)(1.2){∑i=0ni2=(n2+n)(2n+1)6} 求和与积分\sum用来表示求和符号，其下标表示求和下限，上标表示上限。如，\sum_1^n：∑n1∑1n。 \int用来表示积分符号，同样地，其上下标表示积分的上下限。如，\int_1^\infty：∫∞1∫1∞。 与此类似的符号还有，\prod：∏∏，\bigcup:⋃⋃，\bigcap：⋂⋂，\iint：∬∬。 符号 代码 $\sum_1^n$ \sum_1^n $a \over b$ a \over b $\sqrt[n]{x}$ \sqrt[n]{x} 分式与根式分式 第一种，使用\frac ab，\frac作用于其后的两个组a，b，结果为$\frac ab$。 如果你的分子或分母不是单个字符，请使用{..}来分组。 第二种，使用\over来分隔一个组的前后两部分，如{a+1 \over b+1}：${a+1 \over b+1}$ 根式 根式使用\sqrt[n]来表示。如，\sqrt[4]{\frac xy} ：$\sqrt[4]{\frac xy}$ 符号 代码 $\frac ab$ \frac ab $a \over b$ a \over b $\sqrt[n]{x}$ \sqrt[n] 字体 使用\mathbb或\Bbb显示黑板粗体字，此字体经常用来表示代表实数、整数、有理数、复数的大写字母。如，CHNQRZCHNQRZ。 使用\mathbf显示黑体字，如，ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz。 使用\mathtt显示打印机字体，如，ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz。 使用\mathrm显示罗马字体，如，ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz。 使用\mathscr显示手写体，如，ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ。 使用\mathfrak显示Fraktur字母（一种德国字体），如ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ，abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz。 四则运算符 符号 代码 $\lt$ \lt (less than ) $\gt$ \gt (greater than) $\le$ \le (less equal) $\ge$ \ge (greater equal) $\ne$ \neq (not equal) $\approx$ \approx $\times$ \times $\div$ \div $\pm$ \pm (positive minus) $\mp$ \mp 可以在这些运算符前面加上\not，如\not\lt：≮≮。 特殊符号 符号 代码 $\cdot$ \cdot $\sim$ \sim $\cong$ \cong $\equiv$ \equiv $\prec$ \prec $\to$ \to $\rightarrow$ \rightarrow $\leftarrow$ \leftarrow $\Rightarrow$ \Rightarrow $\Leftarrow$ \Leftarrow $\mapsto$ \mapsto 杂乱 常见的三角函数，求极限符号可直接使用+缩写即可。如sinxsin⁡x,arctanxarctan⁡x,lim1→∞lim1→∞。 ​ 集合关系与运算：\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing ：∪∩∖⊂⊆⊊⊃∈∉∅∅∪∩∖⊂⊆⊊⊃∈∉∅∅. 代码 符号 代码 符号 代码 符号 \cup $\cup$ cap $\cap$ 表示排列使用{n+1 \choose 2k} 或 \binom{n+1}{2k}，(n+12k)(n+12k)。 ​ 逻辑运算符：\land \lor \lnot \forall \exists \top \bot \vdash \vDash ： ∧∨¬∀∃⊤⊥⊢⊨∧∨¬∀∃⊤⊥⊢⊨。 \star \ast \oplus \circ \bullet ： ⋆∗⊕∘∙⋆∗⊕∘∙。 \infty \aleph_0 ∞ℵ0∞ℵ0 \nabla \partial ∇∂∇∂ \Im \Re ImRImℜ。 模运算 \pmode, 如，a\equiv b\pmod n：a≡b(modn)a≡b(modn)。 \ldots与\cdots，其区别是dots的位置不同，ldots位置稍低，cdots位置居中。a1+a2+⋯+ana1+a2+⋯+an，a1,a2,…,ana1,a2,…,an。 一些希腊字母具有变体形式，如 \epsilon \varepsilon : ϵεϵε, \phi \varphi ϕφϕφ。 使用Detexify，你可以在网页上画出符号，Detexify会给出相似的符号及其代码。这是一个方便的功能，但是不能保证它给出的符号可以在MathJax中使用，你可以参考supported-latex-commands确定MathJax是否支持此符号。 空间通常MathJax通过内部策略自己管理公式内部的空间，因此a…b与a…….b（.表示空格）都会显示为abab。可以通过在ab间加入\,增加些许间隙，\;增加较宽的间隙，\quad 与 \qquad 会增加更大的间隙，如，abab。 结束基础部分就是这些。需要注意的是一些MathJax使用的特殊字符，可以使用\转义为原来的含义。如\$表示‘$‘，\_表示下划线。 表格使用$$\begin{array}{列样式}…\end{array}$$这样的形式来创建表格，列样式可以是clr表示居中，左，右对齐，还可以使用|表示一条竖线。表格中 各行使用\分隔，各列使用&amp;分隔。使用\hline在本行前加入一条直线。 例如， 123456789$$\begin&#123;array&#125;&#123;c|lcr&#125;n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\2 &amp; -1 &amp; 189 &amp; -8 \\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\end&#123;array&#125;$$ 结果： n123Left0.24−1−20Center11892000Right125−81+10inLeftCenterRight10.2411252−1189−83−2020001+10i 一个复杂的例子如下： min012300000101112012230123max012300123111232222333333Δ012300123110122210133210min012300000101112012230123max012300123111232222333333Δ012300123110122210133210 高级 复杂的用法 矩阵基本用法使用$$\begin{matrix}…\end{matrix}$$这样的形式来表示矩阵，在\begin与\end之间加入矩阵中的元素即可。矩阵的行之间使用\分隔，列之间使用&amp;分隔。 例如 1234567$$ \begin&#123;matrix&#125; 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \end&#123;matrix&#125;$$ 结果： 111xyzx2y2z21xx21yy21zz2 加括号如果要对矩阵加括号，可以像上文中提到的一样，使用\left与\right配合表示括号符号。也可以使用特殊的matrix。即替换\begin{matrix}…\end{matrix}中的matrix为pmatrix，bmatrix，Bmatrix，vmatrix,Vmatrix. 如pmatrix:(1324)(1234) bmatrix:[1324][1234] Bmatrix:{1324}{1234} vmatrix:∣∣∣1324∣∣∣|1234| Vmatrix:∥∥∥1324∥∥∥‖1234‖ 省略元素可以使用\cdots ⋯⋯ \ddots ⋱⋱ \vdots ⋮⋮来省略矩阵中的元素，如： ⎛⎝⎜⎜⎜⎜⎜11⋮1a1a2⋮ama21a22⋮a2m⋯⋯⋱⋯an1an2⋮anm⎞⎠⎟⎟⎟⎟⎟(1a1a12⋯a1n1a2a22⋯a2n⋮⋮⋮⋱⋮1amam2⋯amn) 增广矩阵增广矩阵需要使用前面的array来实现，如 1234567$$ \left[ \begin&#123;array&#125;&#123;cc|c&#125; 1&amp;2&amp;3\\ 4&amp;5&amp;6 \end&#123;array&#125; \right]$$ 结果： [142536][123456] 对齐的公式有时候可能需要一系列的公式中等号对齐，如： 37−−√=732−1122−−−−−−−√=732122⋅732−1732−−−−−−−−−−−√=732122−−−−√732−1732−−−−−−−√=73121−1732−−−−−−−√≈7312(1−12⋅732)37=732−1122=732122⋅732−1732=732122732−1732=73121−1732≈7312(1−12⋅732) 这需要使用形如\begin{align}…\end{align}的格式，其中需要使用&amp;来指示需要对齐的位置。请使用右键查看上述公式的代码。 分类表达式定义函数的时候经常需要分情况给出表达式，可使用\begin{cases}…\end{cases}。其中，使用\来分类，使用&amp;指示需要对齐的位置。如： f(n)={n/2,3n+1,if n is evenif n is oddf(n)={n/2,if n is even3n+1,if n is odd 上述公式的括号也可以移动到右侧，不过需要使用array来实现，如下： if n is even:if n is odd:n/23n+1}=f(n)if n is even:n/2if n is odd:3n+1}=f(n) 最后，如果想分类之间的垂直间隔变大，可以使用[2ex]代替\来分隔不同的情况。(3ex,4ex也可以用，1ex相当于原始距离）。 数学符号查询一般而言，从一个巨大的符号表中查询所需要的特定符号是一件令人沮丧的事情。在此向大家介绍一个LATEXLATEX手写符号识别系统，如下图： 尽情享用吧~ Detexify²。 空间问题在使用Latex公式时，有一些不会影响公式正确性，但却会使其看上去很槽糕的问题。 不要在再指数或者积分中使用 \frac在指数或者积分表达式中使用\frac会使表达式看起来不清晰，因此在专业的数学排版中很少被使用。应该使用一个水平的/来代替，效果如下： Badeiπ2eiπ2∫π2−π2sinxdxBettereiπ/2∫π/2−π/2sinxdxBadBettereiπ2eiπ2eiπ/2∫−π2π2sin⁡xdx∫−π/2π/2sin⁡xdx 使用 \mid 代替 | 作为分隔符符号|作为分隔符时有排版空间大小的问题，应该使用\mid代替。效果如下： Bad{x|x2∈Z}Better{x∣x2∈Z}BadBetter{x|x2∈Z}{x∣x2∈Z} 多重积分对于多重积分，不要使用\int\int此类的表达，应该使用\iint \iiint等特殊形式。效果如下： Bad∫∫Sf(x)dydx∫∫∫Vf(x)dzdydxBetter∬Sf(x)dydx∭Vf(x)dzdydxBadBetter∫∫Sf(x)dydx∬Sf(x)dydx∫∫∫Vf(x)dzdydx∭Vf(x)dzdydx 此外，在微分前应该使用\,来增加些许空间，否则TEXTEX会将微分紧凑地排列在一起。如下： Bad∭Vf(x)dzdydxBetter∭Vf(x)dzdydxBadBetter∭Vf(x)dzdydx∭Vf(x)dzdydx 连分数书写连分数表达式时，请使用\cfrac代替\frac或者\over两者效果对比如下： x=a0+12a1+22a2+32a3+44a4+⋯(\cfrac)(\cfrac)x=a0+12a1+22a2+32a3+44a4+⋯ x=a0+12a1+22a2+32a3+44a4+⋯(\frac)(\frac)x=a0+12a1+22a2+32a3+44a4+⋯ 方程组使用\begin{array} … \end{array}与\left{…\right.配合，表示方程组，如： ⎧⎩⎨⎪⎪a1x+b1y+c1z=d1a2x+b2y+c2z=d2a3x+b3y+c3z=d3{a1x+b1y+c1z=d1a2x+b2y+c2z=d2a3x+b3y+c3z=d3 同时，还可以使用\begin{cases}…\end{cases}表达同样的方程组，如： ⎧⎩⎨a1x+b1y+c1z=d1a2x+b2y+c2z=d2a3x+b3y+c3z=d3{a1x+b1y+c1z=d1a2x+b2y+c2z=d2a3x+b3y+c3z=d3 对齐方程组中的 = 号，可以使用 \being{aligned} .. \end{aligned}，如： ⎧⎩⎨a1x+b1y+c1za2x+b2ya3x+b3y+c3z=d1+e1=d2=d3{a1x+b1y+c1z=d1+e1a2x+b2y=d2a3x+b3y+c3z=d3 如果要对齐 = 号 和项，可以使用\being{array}{列样式} .. \end{array}，如： ⎧⎩⎨⎪⎪a1x+b1y+c1za2x+b2ya3x+b3y+c3z=d1+e1=d2=d3{a1x+b1y+c1z=d1+e1a2x+b2y=d2a3x+b3y+c3z=d3 颜色命名颜色是浏览器相关的，如果浏览器没有定义相关的颜色名称，则相关文本将被渲染为黑色。以下颜色是HTML4与CSS2标准中定义的一些颜色，其应该被大多数浏览器定义了。 \color{black}{text}\color{gray}{text}\color{silver}{text}\color{white}{text}\color{maroon}{text}\color{red}{text}\color{yellow}{text}\color{lime}{text}\color{olive}{text}\color{green}{text}\color{teal}{text}\color{aqua}{text}\color{blue}{text}\color{navy}{text}\color{purple}{text}\color{fuchsia}{text}texttexttexttexttexttexttexttexttexttexttexttexttexttexttexttext\color{black}{text}text\color{gray}{text}text\color{silver}{text}text\color{white}{text}text\color{maroon}{text}text\color{red}{text}text\color{yellow}{text}text\color{lime}{text}text\color{olive}{text}text\color{green}{text}text\color{teal}{text}text\color{aqua}{text}text\color{blue}{text}text\color{navy}{text}text\color{purple}{text}text\color{fuchsia}{text}text 此外，HTML5与CSS3也定义了一些颜色名称，参见。 同时，颜色也可以使用#rgb的形式来表示，r、g、b分别表示代表颜色值得16进制数，如： #000#F00texttext#0F0#FF0texttext#00F#F0Ftexttext#0FF#FFFtexttext#000text#00Ftext#0F0text#0FFtext#F00text#F0Ftext#FF0text#FFFtext HTML色彩快速参考手册 公式标记与引用使用\tag{yourtag}来标记公式，如果想在之后引用该公式，则还需要加上\label{yourlabel}在\tag之后，如： a:=x2−y3()()a:=x2−y3 1\eqref&#123;rlabel&#125; a+y3=(*)x2a+y3=(*)x2 可以看到，通过超链接可以跳转到被引用公式位置。 个人常用备忘记录自己有时候遇到的。 公式 结果 2^{i-1} 2i−1 O(n\mathrm{log}n) O(nlogn) \Theta(1) Θ(1) a_{1} a1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据类型介绍]]></title>
      <url>%2F2017%2F03%2F10%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F90_%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%2F10_%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[介绍各种数据类型（data_type)； 字符数据类型 长度固定：当输入的数据长度没有达到指定的长度时将自动以英文空格在其后面填充，使长度达到相应的长度 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点 一般来说，如果含有中文字符，用nchar/nvarchar，如果纯英文和数字，用char/varchar。 类型 特点 容量 char 长度固定，8000个英文，4000个汉字 1字节 varchar 长度可变，8000个英文，4000个汉字 1字节 nchar 长度固定 Unicode编码，存储4000个字符 2个字节 [不论是英文还是汉字] nvarchar 长度可变 Unicode编码，存储4000个字符 2个字节 [不论是英文还是汉字] text 长度可变 1字节 ntext 长度可变 Unicode编码 2字节 Unicode或非Unicode​ 数据库中，英文字符只需要一个字节存储就足够了，但汉字和其他众多非英文字符，则需要两个字节存储。如果英文与汉字同时存在，由于占用空间数不同，容易造成混乱，导致读取出来的字符串是乱码。 ​ Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。而前缀n就表示Unicode字符，比如nchar,nvarchar，这两种类型使用了Unicode字符集。 数值类型 数据类型 说明 大小 Bit 1或0 1位 Tinyint 0~255整数 1字节 Smallint -32,768~32,767 整数 2字节 Int -2,147,483,648~2,147,483,647 整数 4字节 Bigint -2$^{63}$ ~ 2$^{63}$-1 的整数 8字节 Decimal / Numeric -10$^{38}$ +1 的固定精度数值 根据长度而变化 Money -2$^{63}$ ~ 2$^{63}$-1 的数值，精确到万分之一 8字节 SmallMoney -2,147,483,648~2,147,483,647 的数值，精确到万分之一 4字节 近似数据类型 DATA TYPE FROM TO Float -1.79E+308 ~1.79E+308 的浮点数值 4或8字节 Real 24位精度的浮点值 4字节 0（默认值） 最多包含 6 位。 根据需要使用科学记数法。 1 始终为 8 位值。 始终使用科学记数法。 2 始终为 16 位值。 始终使用科学记数法 浮点数：伴随着因为无法精确表示而进行的近似或舍入。 在计算机科学中，浮点（英语：floating point，缩写为FP）是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数（计算机中通常是2）的整数次指数得到。以这种表示法表示的数值，称为浮点数。这种表示方法类似于基数为10的科学计数法。 浮点指的是带有小数的数值。 大部分计算机采用二进制（b=2）的表示方法。位（bit）是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。 日期和时间数据 数据类型 说明 字符大小 Datetime 1553年1月1日开始至9999年；Jan 1, 1753，精度3毫秒 8字节 Smalldatetime 1900年至2079年6月6日；精度1分钟 Jun 6, 2079 Date 0001年至9999年； 3字符 Time(2) 时间值，精度可变 3-5字节 Datetime(2) 0001年至9999年，精度可变，从0.01秒到100纳秒 6-8字节 Datetimeoffset 二进制类型杂项数据类型 DATA TYPE Description sql_variant Stores values of various SQL Server-supported data types, except text, ntext, and timestamp. timestamp Stores a database-wide unique number that gets updated every time a row gets updated uniqueidentifier Stores a globally unique identifier (GUID) xml Stores XML data. You can store xml instances in a column or a variable (SQL Server 2005 only). cursor Reference to a cursor object table Stores a result set for later processing]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库_数据库概述]]></title>
      <url>%2F2017%2F03%2F09%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F90_%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%2F10_%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[简单介绍了数据库的基本概念、结构等信息。 数据库 what：按照数据结构来组织、存储和管理数据的建立在计算机存储设备上的仓库。简单来说是本身可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、截取、更新、删除等操作。 why ：数据库的优点 数据结构化且统一管理 查询迅速、准确，且有多种表达与传输方式 数据冗余度小；在文件系统中，为了满足一个应用程序对数据的需要，常常在不同地方重复存放同一个或同一组数据。 具有较高的数据独立性； 数据独立性是指用户应用程序与存储在数据库中数据的相互独立性。当人们利用应用程序调用数据库进行数据处理时，只涉及数据的逻辑结构，而不涉及其存储方式和物理结构。 当数据的物理存储方式和结构改变时，数据库管理系统将自动处理这种改变，而应用程序不必改变。 数据的共享性好 数据库管理系统 what：是一种针对对象数据库，为管理数据库而设计的大型电脑软件系统。(DBMS - Database Management System) Oracle、Microsoft SQL Server、Access、MySQL及PostgreSQL 数据库类型关系型数据库 - SQL what：采用关系模型作为数据组织方式的数据库 why ：特点在于它将每个具有相同属性的数据独立地存储在一个表中。对任一表而言，用户可以新增、删除和修改表中的数据，而不会影响表中的其他数据。 ​ 非关系型数据库 - NoSQL what：泛指非关系型的数据库；(Not Only SQL) 数据库模型 what：描述了在数据库中结构化和操纵数据的方法，模型的结构部分规定了数据如何被描述（例如树、表等） how ：分类 概念模型 层次模型（轻量级数据访问协议） 用一颗“有向树”的数据结构来表示表示各类实体以及实体间的联系，树中每一个节点代表一个记录类型，树状结构表示实体型之间的联系。 网状模型（大型数据储存） 用网络结构表示实体类型及其实体之间联系的模型。 关系模型 面向对象模型 半结构化模型 平面模型（表格模型，一般在形式上是一个二维数组。如表格模型数据Excel) 数据库架构数据库的架构可以大致区分为三个概括层次： 物理数据层（内层）：物理存贮设备上实际存储的数据的集合。这些数据是原始数据，是用户加工的对象，由内部模式描述的指令操作处理的位串、字符和字组成。 概念数据层（概念层）：介于两者之间的间接层，是数据库的整体逻辑表示。 指出了每个数据的逻辑定义及数据间的逻辑联系，是存贮记录的集合。 用户数据层（外层）：用户所看到和使用的数据库；表示了一个或一些特定用户使用的数据集合，即逻辑记录的集合 数据库不同层次之间的联系是通过映射进行转换的。 数据库索引索引实际上是一种特殊类型的表，其中含有关键字段的值(由用户定义)和指向实际记录位置的指针，这些值和指针按照特定的顺序(也由用户定义)存储，从而可以以较快的速度查找到所需要的数据记录。 数据库操作 : 事务 what：用户定义的一个数据库操作序列； how ：这些操作要么全做，要么全不做，是一个不可分区的工作单位 A（atomicity-原子性） C（consistency-一致性） I（isolation-隔离性） D（durability-持久性）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server_系统结构]]></title>
      <url>%2F2017%2F03%2F08%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FSQL-Server%2FSQL-Server_%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[SQL Server 的特殊结构：表变量、临时表 表变量与临时表表变量 what：微软在BOL (Declare @local_variable)中定义其为一个类型为表的变量；定义表变量的语句是和正常使用Create table定义表语句的子集。只是表变量通过DECLARE @local_variable 语句进行定义。 它的具体定义包括列定义，列名，数据类型和约束。 表变量中可以使用的约束：主键约束，唯一约束，Null约束和Check约束 (外键约束不能在表变量中使用) why ： how ： 表变量只能在一个批处理中生成，超出了这个边界表变量就不存在了； 以@或者@@为前缀 一个@为前缀的表变量（@aa）是本地的，因此只有当前用户会话才可以访问 两个@为前缀即@@的表变量（@@aa）是全局的，通常都是系统变量 表变量只能在一个批处理中生成，超出了这个边界表变量就不存在了 存放在内存中，因此用户访问表变量的时候SQL Server是不需要生成日志的。同时变量是不需要考虑其他会话访问的问题，因此也不需要考虑锁机制，对于非常繁忙的系统来说，避免锁的使用可以减少一部分系统负载。 临时表 what：以#或者##为前缀； 一个 # 为前缀的临时表(#a)是本地的，只有当前用户会话才可以访问 ## 为前缀的临时表(##a)是全局的，所有用户会话都可以访问该临时表 why ：临时表以会话为边界，会话结束则临时表移除；如果需要提前销毁临时表，可以使用DROP TABLE命令 how ：因为存放在tempdb，所以可能造成物理IO，在修改时也需要生成日志来确保一致性，同时锁机制也是不可缺少的 ​ ​ 表变量 vs. 临时表 临时表是利用了硬盘(tempdb数据库) ，表名变量是占用内存，因此小数据量当然是内存中的表变量更快。当大数据量时，就不能用表变量了，太耗内存了。大数据量时适合用临时表。 一般对于大的数据集推荐使用临时表，同时创建索引，或者通过SQL Server的统计数据自动创建和维护功能来提供访问SQL语句的优化； 如果需要在多个用户会话间数据交换，临时表就是唯一的选择了。在SQL Server临时表的定义中，我们知道临时表是存放在tempdb中的，因此需要注意tempdb的调优 特性 表变量 临时表 作用域 当前批处理 当前会话，嵌套存储过程，全局：所有会话 析构方式 批处理结束后自动析构 显式调用 DROP TABLE 语句. 当前会话结束自动析构 (全局临时表: 还包括当其它会话语句不在引用表.) 使用场景 自定义函数，存储过程，批处理 自定义函数，存储过程，批处理 索引 不可创建（索引必须在表定义时建立） 可以创建索引 约束 PRIMARY KEY, UNIQUE, NULL, CHECK约束可以使用，但必须在表建立时声明 PRIMARY KEY, UNIQUE, NULL, CHECK. 约束可以使用，可以在任何时后添加，但不能有外键约束 统计数据 不创建统计数据，所以所有的估计行数都为1,所以生成执行计划会不精准 创建统计数据，通过实际的行数生成执行计划。 数据插入方式 INSERT 语句 (SQL 2000: 不能使用INSERT/EXEC). INSERT 语句, 包括 INSERT/EXEC. SELECT INTO 语句. 回滚 不会被回滚影响 会被回滚影响 事务 只会在更新表的时候有事务，持续时间比临时表短 正常的事务长度，比表变量长 创建方式 DECLARE statement only.只能通过DECLEARE语句创建 CREATE TABLE 语句 SELECT INTO 语句. 列类型 可以使用自定义数据类型；可以使用XML集合 自定义数据类型和XML集合必须在TempDb内定义 表名长度 最多128字节 最多116字节 Collation 字符串排序规则继承自当前数据库 字符串排序规则继承自TempDb数据库 表建立后使用DDL (索引，列) 不允许 允许. Insert explicit values into identity columns (SET IDENTITY_INSERT). 不支持SET IDENTITY_INSERT语句 支持SET IDENTITY_INSERT语句 Truncate table 不允许 允许 存储过程重编译 否 会导致重编译 作为参数传入存储过程 仅仅在SQL Server2008, 并且必须预定义 user-defined table type. 不允许 显式命名对象 (索引, 约束). 不允许 允许，但是要注意多用户的问题 动态SQL 必须在动态SQL中定义表变量 可以在调用动态SQL之前定义临时表 CTE what：通用表表达式 why ：在同一个语句中，一次定义，可以多次引用。 专业词汇及缩写 字段名 全程 含义 dbo Database Owner 每个数据库的默认用户 db database 数据库 dt datetime 数据库数据类型（日期） etl Extract-Transform-Load 数据仓库技术; 抽取-转化-加载 ext Extended file system 延伸文件系统/ 扩展文件系统 DDL Database Definition Language 数据库定义语言 DML Database Manipulation Language 数据库操作语言 DCL 数据控制语言 TCL 事务控制语言 dbo： 每个数据库的默认用户，具有所有者权限，即DbOwner；Database Owner 通过用DBO作为所有者来定义对象，能够使数据库中的任何用户引用而不必提供所有者名称 比如：你以User1登录进去并建表Table，而未指定DBO，当用户User2登进去想访问Table时就得知道这个Table是你User1建立的，要写上User1.Table，如果他不知道是你建的，则访问会有问题。如果你建表时把所有者指给了Dbo，则别的用户进来时写上Dbo.Table就行了，不必知道User1。 DML 查询(Select)、插入(Insert)、修改(Update)、删除(Delete) OLE DB what ：对象链接嵌入数据库（Object Linking and Embedding Database），是微软为以统一方式访问不同类型的数据存储设计的一种应用程序接口。 是一组用组件对象模型（COM）实现的接口，而与对象连接与嵌入（OLE）无关。 why ：它被设计成为ODBC的一种高级替代者和继承者，把它的功能扩展到支持更多种类的非关系型数据库，例如可能不支持SQL的对象数据库和电子表格（如Excel）。 how ：一组抽象概念（包括数据源、会话、命令和行集）将数据的存储从需要访问数据的应用中分离出来。 这是因为不同的应用需要访问不同数据类型和数据源，但是并不需要了解具体如何使用特定技术的方法访问这些数据。 OLE DB 在概念上分为两种： 消费者 ：是那些需要访问数据的应用程序 提供者 ：是实现了那些接口并将数据提供给消费者的软件组件。 OLE DB是微软数据访问组件（MDAC）的一部分。 MDAC是一组微软技术，以框架的方式相互作用，为程序员开发访问几乎任何数据存储提供了一个统一并全面的方法。 OLE DB的提供者可以用于提供像文本文件和电子表格一样简单的数据存储的访问，也可以提供像Oracle、SQL Server和Sybase ASE一样复杂的数据库的访问。 OLE DB同样可以提供对层次类型的数据存储（如电子邮件系统）的访问。 组件对象模型 what ：微软的一套软件组件的二进制接口标准。（Component Object Model，COM） why ：使得跨编程语言的进程间通信、动态对象创建成为可能。 how ： 数据库名、表明、字段名12345678910# 获取数据库所有类型select name from systypes -----------------------------------------------------# 获取所有用户名SELECT name FROM Sysusers where status=&apos;2&apos; and islogin=&apos;1&apos;islogin=&apos;1&apos;表示帐户islogin=&apos;0&apos;表示角色status=&apos;2&apos;表示用户帐户status=&apos;0&apos;表示糸统帐户 1234567891011121314# 获取所有数据库名Select Name FROM Master..SysDatabases order by Name；-----------------------------------------------------# 获取所有表名Select Name FROM SysObjects Where XType=&apos;U&apos; ORDER BY Name XType=&apos;U&apos;:表示所有用户表; XType=&apos;S&apos;:表示所有系统表;SELECT name FROM sysobjects WHERE type = &apos;U&apos; AND sysstat = &apos;83&apos;注意：一般情况只需要type = &apos;U&apos;，但有时候会有系统表混在其中（不知道什么原因），加上后面一句后就能删除这些系统表了# 获取指定数据库名下的所有表名select Name from 数据库名..sysobjects where xtype=&apos;u&apos; and status&gt;=0 12345678910# 获取所有字段名Select Name FROM SysColumns Where id=Object_Id(&apos;TableName&apos;)；或者select name from syscolumns where id =(select id from sysobjects where type = &apos;u&apos; and name= &apos;TableName&apos;) -----------------------------------------------------# 获取主键字段SELECT name FROM SysColumns WHERE id=Object_Id(&apos;表名&apos;) and colid=(select top 1 keyno from sysindexkeys where id=Object_Id(&apos;表名&apos;))；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server_常用查询]]></title>
      <url>%2F2017%2F03%2F07%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FSQL-Server%2FSQL-Server_%E6%9F%A5%E8%AF%A2%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[SQL 逻辑流Select 语法 Select语句的From部分将所有数据源组装进一个结果集，然后由Select语句的剩余部分对结果集执行操作。 Where子句作用于From组装的记录集，根据条件筛选某些行。 聚合函数对数据集执行求和操作。 Group by 子句根据在该子句中指定的列将大量数据集分组成较小的数据集。 Having 对较小的数据组执行聚合函数。 Order by 子句确定结果子的排列顺序。默认为升序； 12345678Select [Distinct] [Top(n)] *, columns, or expressions [From data source(s)] [Join data source ON condition] (may include multiple joins) [Where conditions] [Group by columns] [Having conditions] [Order by columns]; 查询语句的逻辑流数据源(From) —— 条件(Where) —— 列/表达式 (col/exp) —— Order by — 谓词 From，查询首先组装初始数据集。 Where，筛选；筛选过程实际上是选择符合标准的行的where子句。 Group by，组合数据的子集 [若要分组，先对数据排序，然后根据排序后的数据进行聚合] 聚合，Aggregations，选择性地对数据进行聚合；如求平均值，按列中的值对数据分组以及筛选组； Having，筛选数据的子集 列表达式：处理Select列，并计算任何表达式 [ 这个时候才涉及到列 ] Order by，排序 Over，窗口函数和排名函数通过与其他聚合函数一起提供结果的单独排序的视图 Distinct，从结果集中删除任何重复的行 Top，选定行后，执行计算，并按所需的顺序排序 Insert,Update,Delete，最后一个逻辑步骤是将数据修改操作应用到查询结果。 Output，选择插入和删除的虚拟表，并返回给客户端 Union，堆叠或合并多个查询的结果 SQL编写标准 若需要多个表合成一个表，必须确定【唯一标识符】或者说是联接的表，从联接表中去寻找联接的字段 最后合并的中都必须要有这个字段 若出现多个主条件，先将主条件的区分变量统一到一个表中 其他表与这个表进行联接 先把各个字段单独用Select写出来 再合并为一个Select语句 运算符介绍优先级Not &gt; 算术运算符(+-) &gt; 条件运算符(where) &gt; And &gt; Or 电脑中字符优先级： 数字&gt;字母 1a &gt; a1 &gt; a11 &gt; aa1 通配符 运算符 含义 示例 % 任意长度的字符串 Email Like ‘%@%.com’ ‘_’ 任意一个字符 AuthorName Like ‘张_’ [ ] 在指定范围内的任意一个字符 A Like ‘A6C8[1-5]’ [^] 不在指定范围内的任意一个字符 A Like ‘A6C8[^1-6]’ 查找含通配符的表达式： 必须使用Like字符 把通配符放入方括号[ ] 内 在其之前放一个转义符 注意事项与通用规则方括号 [ ] why ：表名或字段名如果引用了sql server中的关键字，数据库会不识别这到底是关键字还是表名（还是字段名）时就必须要加； 查询语句的表中加上方括号[ ] ， 目的是以声明其不是保留字 ； 如果表名不是关键字，不用加方括号 12345# 一个表名叫user，user在sqlserver中属于关键字，那么查询的时候必须要这样select * from [user] ;# 若表名user中没有user的列，则无需加方括号select * from user ; 合并：字段+表格12345# 字段合并 +SELECT 机构+客户名称 FROM allzjb where 结算日期&gt;&apos;2015-11-15&apos;SELECT RTRIM(LastName) + &apos;,&apos; + SPACE(2) + LTRIM(FirstName) FROM Person.Person--剪裁姓氏，并将逗号、两个空格和 Person 中的 AdventureWorks2012 表列出的人员名字串联起来 使用“ + ”连接多个字段，合并成一列 前后类型应兼容； 如果+连接数值类型，结果是数值之和 如果+连接字符串类型，结果是字符串的连接 123456# 表格合并 - insert into A1 select ... INSERT INTO table2 SELECT * FROM table1; -- 把table1的数值插入到table2中# 只插入某一列的值INSERT INTO table2 (column_name) SELECT column_name FROM table1 ; 123# 合并为一个字符串 - concat()Select Concat(Null, &apos;Patrick &apos;, 1, &apos; LeBlacn&apos;)--隐式地将所有值转换为字符串，将空值转为空字符串 Where条件 最佳实践：找到事物的最好办法就是查找，而不是先排除不是该事物的所有东西。即where条件，声明肯定的限制条件优于否定的限制条件； 1where col &gt;= 10 ; 优于 where col !&lt; 9 惊叹号! ，不是ANSI标准的SQL； 布尔逻辑运算的优先次序： NOT &gt; AND &gt; OR 若where子句中同时出现 and 和 or 条件，一定要把整个or条件子句用括号括起来 12345678910Where name Like &apos;Chain%&apos; or ProductID Between 320 And 324 And name Like &apos;%s%&apos; --1. 先执行And，即找出name中 带有 s 的名字；--2. 再在其中寻找 name中有Chain 或者 ProduceID在[320,324]------------------Where (name Like &apos;Chain%&apos; or ProductID Between 320 And 324 ) And name Like &apos;%s%&apos;--1. 先执行括号，即先找出name中有Chain 或者 ProduceID在[320,324]--2. 再在其中找出name中 带有 s 的名字； 不能在Where 子句中使用聚合函数。此时应用子查询来进行限定 先进行联合，再进行where条件的执行 123Select * From A Left Join B On A.name = B.name ----因为先进行联合，再进行where条件选择，若在表B中存在不满足where条件的观测值，最后不会被选中 Where B.col = &apos;x&apos; Between and1234567891011121314151617181920212223# 使用带有日期时间值的 BETWEEN WHERE RateChangeDate BETWEEN &apos;2001-12-12&apos; AND &apos;2002-01-05&apos;; # 特别注意，若涉及到最小单位为小时的情况，则必须考虑多加一天；BETWEEN &apos;2001-12-12&apos; AND &apos;2002-01-05&apos;; # 表示选择的范围为 2001-12-12 00:00:00 ~ 2002-01-05 00:00:00 ; 1月5日的 09:00:00是不包含在内的【即1月5日的不包含】----上面的示例检索所在的行【datetime值】可以介于&apos;20011212&apos;和&apos;20020105&apos;(含） 之间;因为在查询中的日期值和datetime值存储在RateChangeDate而无需在日期的时间部分中指定了列。-- 下面是结果集：BusinessEntityID RateChangeDate3 2001-12-12 00:00:00.0004 2002-01-05 00:00:00.000----未指定时间部分时，将默认使用 12:00 A.M。 --请注意，若某行的时间部分晚于 2002-01-05 12:00 A.M.， 则由于它处于范围之外，因此此查询不返回该行。Select Distinct 结算日期 From [exchange].[GFFCC_YTX].[v_jsmx] Where 结算日期 between &apos;2017/6/12&apos; and &apos;2017/6/15&apos; order by 结算日期--返回的结果为2017-06-12,2017-06-13,2017-06-14 --返回的日期不包括6月15日，因为该表达式表示为 小于等于 2017-06-15 00:00 ALL、SOME、ANY ALL，相当于And；如果子查询可能返回一个空值，那么使用ALL会判断为fasle，使用时要小心； 循环 一个if，一个命令的执行；并且没有Then和End来终止if命令； 123456789If condition Statement;----------------------------------If 1=0Print &apos;Line one&apos;;Print &apos;Line two&apos;;--结果返回Line two； if语句之后没有分号； if语句实际上是后面语句的提前； 使用Begin / End 有条件地执行多条语句 1234If condition Begin; Multipie Line; End; --每个都有分号 使用If Exists()作为基于存在性的条件 If Exists() 结构使用从SQL Select语句返回的每一行作为条件。 因为If Exists() 结构会查找每一行，所以Select语句应当选择所有的列。一旦一个单行满足了If Exists()，查询就会继续执行 12345If Exists (Select * From production.product Where quantity = 0) Begin; Print &apos;Relpenish Inventory&apos;; End; 使用If / Else 执行替换语句 可选的Else定义了if条件为False时的执行代码；Else可控制下一个单个命令，后者Begin/End块 1234If condition Single line or Begin/End block of code; Else Single line or Begin/End block of code; while,break,continue的使用 设置重复执行 SQL 语句或语句块的条件。只要指定的条件为真，就重复执行语句。可以使用 BREAK 和 CONTINUE 关键字在循环内部控制 WHILE 循环中语句的执行。 Break ：导致从最内层的WHILE循环中退出。将执行出现在END关键字后面的任何语句，END 关键字为循环结束标记。 如果嵌套了两个或多个 WHILE 循环，内层的 BREAK 将导致退出到下一个外层循环。首先运行内层循环结束之后的所有语句，然后下一个外层循环重新开始执行。 Continue ：使 WHILE 循环重新开始执行，忽略 CONTINUE 关键字后的任何语句。 1234567891011121314151617181920212223242526272829303132333435363738while 当条件为ture时循环代码；----WHILE Boolean_expression &#123; sql_statement | statement_block &#125; --若有Select语句，必须用圆括号（） --若要定义语句块，请使用控制流关键字 BEGIN 和 END。 [ BREAK ] --导致从最内层的WHILE循环中退出。将执行出现在END关键字后面的任何语句，END 关键字为循环结束标记。 --如果嵌套了两个或多个 WHILE 循环，内层的 BREAK 将导致退出到下一个外层循环。首先运行内层循环结束之后的所有语句，然后下一个外层循环重新开始执行。 &#123; sql_statement | statement_block &#125; [ CONTINUE ] -- 使 WHILE 循环重新开始执行，忽略 CONTINUE 关键字后的任何语句。 -----------------------------------------------------------------------------A. 在嵌套的 IF...ELSE 和 WHILE 中使用 BREAK 和 CONTINUE 如果平均价格少于 $30，WHILE 循环就将价格加倍，然后选择最高价。如果最高价少于或等于 $50，WHILE 循环重新启动并再次将价格加倍。该循环不断地将价格加倍直到最高价格超过 $50，然后退出 WHILE 循环并打印一条消息。USE pubs GO while (select avg(price) from titles) &lt;$30 begin update titles set price=price*2 select max(price) from titles if(select max(price) from titles) &gt;$50break elsecontinueendprint &apos;too much for the marker to bear&apos; B. 在带有游标的过程中使用 WHILE declare @i int set @i=1 while @i&lt;30 begin insert into test (userid) values(@i) set @i=@i+1 end 创建与变更格式视图1234567----创建 视图Create View schemaname.viewname[(column)]AsSelect ...From ...;----删除视图Drop View name 变更格式1234567891011121314151617181920212223242526272829303132----变更列的类型ALTER TABLE table_nameALTER COLUMN column_name data_type----添加新列1 ALTER TABLE table_name2 ADD column_name data_type NULL -- 表示 允许为NUll----删除某列ALTER TABLE table_nameDROP COLUMN [COLUMN_NAME] --drop column set4_time----重命名列名 下面的示例将 TerritoryID 表中的 Sales.SalesTerritory 列重命名为 TerrID。EXEC sp_rename &apos;Sales.SalesTerritory.TerritoryID&apos;, &apos;TerrID&apos;, &apos;COLUMN&apos;; ----重命名表exec sp_rename &apos;[原表名]&apos;,&apos;[新表名]&apos;----添加主键Alter table [表名] add constraint [ 约束名] primary key( [列名])----添加唯一约束Alter table [表名] add constraint [ 约束名] unique([列名])----添加表中某列的默认值Alter table [表名] add constraint [约束名] default(默认值) for [列名]----添加外键约束Alter table [表名] add constraint [约束名] foreign key(列名) referencese 另一表名(列名)----删除约束Alter table [表名] drop constraint [约束名] 插入、更新、删除、合并数据创建数据12345Create Table table.name(col_name1 [Int] Identity(1,1) Not Null, col_name2 datetime,Constraint PK_table.name_col_name1 Primary Key CLUSTERED (col_name1)) --IDENTITY [ (seed , increment) ] --在表中创建一个标识列。 --seed,第一行所用的值； increment,增量值 若要重新定义主键，则必须首先删除与现有主键之间的任何关系，然后才能创建新主键。 此时，将显示一条消息警告您：作为该过程的一部分，将自动删除现有关系。 12--创建新列ALTER TABLE dbo.doc_exa ADD column_b VARCHAR(20) NULL, column_c INT NULL ; 插入数据12345678910111213141516171819202122232425# 插入简单的值行Insert [Into] schema.table [ (colums, ...) ] Values (value,...), (value,...);# 在标识列中插入数据，要使用Set Identity_insert on / off关键字Set Identity_insert dbo.address On Insert Into dbo.address (AddreddID, Addressl, city, state, county) Valuse(999, )Set Identity_insert dbo.address Off------------------------------------------------------------------------------------# 从Select语句中插入结果集Insert [Into] schema.table [ (colums,...)] Select columns From data [Where conditions];--1. schema.table 必须存在--2. into schema.table中的列必须与之后Select中的列相同--3. 若schema.table中有5列，只选取其中3列插入，则其他2列的观测值对NULL------------------------------------------------------------------------------------# 从存储过程插入结果集Insert [Into] schema.table [ (colums,...)] Execute storedprocedure; – 123# 在插入数据时创建表Select colums Into newtable From data [where conditions]; SQL中合并列，只要选择对应的列即可 Select a.*, b.* From a Full Join b 更新数据1234567891011121314# 更新单个表Update schema.table Set column = expression, column = value [From data] [Where conditions];----------------------------------------------------------------------------------# 执行全局搜索与替代# replace(data, &apos;aaa&apos;, &apos;bbb&apos;)Update address Set county = Replace(county, &apos;sun&apos;, &apos;dark&apos;) -- 将county列中所有的sun替换为dark Where county Like &apos;%shine&apos; ; 删除数据12345678910111213141516# deleteDelete [From] schema.table /*[From data] SQL Server 特有的T-SQL扩展，用来进行联接；正常情况下应在where子句中创建子查询*/ [Where conditions];# 删除所有行Delete From schema.table--不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：---------------------------------------------------------------------------------# 删除表中所有行 - truncateTruncate Table dbo.address---------------------------------------------------------------------------------# 删除整个表Drop table schema.table truncate 、delete与drop区别 相同点 truncate和不带where子句的delete、以及drop都会删除表内的数据drop、truncate都是DDL语句(数据定义语言)，执行后会自动提交。Delete是DML语句(数据库操作语言) 不同点 truncate 和 delete 只删除数据不删除表的结构(定义)；drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。 delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动。drop 语句将表所占用的空间全部释放。truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。 速度：drop&gt; truncate &gt; delete TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同：二者均删除表中的全部行。但TRUNCATE TABLE 比DELETE速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 安全性： 想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。 小心使用 drop 和 truncate，尤其没有备份的时候 使用上，想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大 想删除表,当然用 drop 对于由FOREIGN KEY 约束引用的表，不能使用TRUNCATE TABLE，而应使用不带WHER 子句的DELETE语句。由于 TRUNCATE TABLE不记录在日志中，所以它不能激活触发器。 TRUNCATE TABLE不能用于参与了索引视图的表。 判断是否存在后删除123456----临时表if Object_id(N&apos;tempdb.dbo.#a4&apos;,N&apos;U&apos;) Is Not Null Drop table #a5----判断数据表是否存在,若存在则删除数据表IF EXISTS (SELECT * FROM sys.objects WHERE name = &apos;Table_Name&apos;) DROP TABLE Table_Name; 合并数据 Meger语句。使用 MERGE 语句在一条语句中执行插入、更新或删除操作。 有条件地在目标表中插入或更新行。 如果目标表中存在相应行，则更新一个或多个列；否则，会将数据插入新行。 同步两个表。根据与源数据的差别在目标表中插入、更新或删除行。 12345678910111213141516171819Meger flightpassengers As f -- MERGE 子句用于指定作为插入、更新或删除操作目标的表或视图 Using checkin as c --USING 子句用于指定要与目标联接的数据源 On c.lastname = f.lastname --ON 子句用于指定决定目标与源的匹配位置的联接条件 And c.firstname = f.firstname And c.flightcode = f.flightcode And c.flightdate = f.flightdate When Matched Then Update Set f.seat = c.seat When Not Matched By Target --当Soucre表与Target表（基准表）不匹配时，对Target表进行操作 Then Insert (Firsrname, Lastname, Flightcode, flightdate, seat) When Not Matched By Source --当Target表与Soucre表（基准表）不匹配时，对Target表进行操作【相同】 Then Delete;--WHEN 子句（WHEN MATCHED、WHEN NOT MATCHED BY TARGET 和 WHEN NOT MATCHED BY SOURCE）基于 ON 子句的结果和在 WHEN 子句中指定的任何其他搜索条件指定所要采取的操作。--OUTPUT 子句针对插入、更新或删除的目标中的每一行返回一行。--必须由分号进行终止--必须是一对一匹配；一对多匹配是不允许的--联接条件必须是确定性的，也就是可重复的 返回修改后的数据 Output子句可以访问插入的和删除的虚拟表，以及任何在From自引用的数据源来选择要返回的数据。 Output子句有一个较为高级的应用，可以把输出数据传输到外查询。 1234567891011121314151617181920212223242526272829303132333435363738# 从插入返回数据Insert Into personlist Output Inserted.* -- Inserted. Valuse(7777, &apos;Jane&apos;, &apos;Doe&apos;);# 从更新返回数据 -- 可同时返回更新前、更新后的数据Update personlist Set firstname = &apos;Jane&apos;, Lastname = &quot;Doe&quot; Output Deleted.firstname oldfirstname, Deleted.lastname oldflastname, --Deleted.column oldcolumn Inserted.firstname newfirstname, Inserted.lastname newlastname Where businessentityID = 7777# 从删除返回数据Delete From personlist Output Deleted.* Where ...# 从合并返回数据... Output deleted.column, deleted.column, $action, -- 显示数据库操作的行为（为Insert、Delete、Update) inserted.column, inserted.column ;# 把数据库返回到表中Declare @Deletedperson Table( businessentityID Int Not Null Primary Key, lastname Varchar(50) Not Null, firstname Varchar(50) Not Null)Delete dbo.personlist Output Deleted.colunm, Deleted.column Into @Deletedperson Where bussinessentityID = 2; 1. 查询：字符串 函数名 功能描述 举例 LEN 返回指定字符串的字符个数(而不是字节)，其中不包含尾随空格 SELECT LEN(‘李丽然作者’) 返回:5 DATALENGTH 返回指定字符串的字节数 SELECT DATALENGTH(‘中国人’) 返回：6 UPPER 将小写字符转换成大写字符 SELECT UPPER(‘book图书表’) 返回:BOOK图书表 LTRIM 返回去掉左侧空格的字符串 SELECT LTRIM(‘ Authors’) 返回: Authors CHARINDEX 查找一个指定的字符串在另一个字符串中的起始位置 SELECT CHARINDEX(‘L’, ‘HELLO’, 1) 返回:3 LEFT 返回字符串中从左边开指定个数的字符 SELECT LEFT(‘zhangsan’, 2) 返回:zh Substring 返回字符串的一部分：从字符串串的起始位置连续取指定个数的子串 SELECT SUBSTRING(‘我爱我的家乡’,3, 2) 返回：我的 Replace 替换一个字符串中的字符 SELECT REPLACE(‘我爱我的家乡家乡’, ‘家乡’, ‘学校’) 返回: 我爱我的学校学校 Stuff 将一个字符中删除指定数量的字符，并插入另一个字符 Concat 将多个字符串组合为单个字符串 使用字符串字面量时，通过输入两个单引号转化为一个单引号 Replace(name, ‘’’’, ‘’) ; Life’’s Great! 被解释为 Life’s Great! 行数&amp;字符数12345678# 返回观测值的行数 - count [非空值的个数]SELECT COUNT(name) FROM my_contacts;# 返回字符串的字符个数 - lenSELECT LEN(&apos;中国人&apos;) ; # 返回:3# 返回字符串的字节数 - datalengthSELECT DATALENGTH(&apos;中国人&apos;); # 返回：6 去空格12# 去空格 - ltrim / rtrimselect ltrim(rtrim(&apos; &quot;左右都没有空格&quot; &apos;)); # 左右去空格 12345# 生成空格 - spaceselect space(2); # 生成2个空格SELECT RTRIM(LastName) + &apos;,&apos; + SPACE(2) + LTRIM(FirstName) FROM Person.Person# 剪裁姓氏，并将逗号、两个空格和 Person 中的 AdventureWorks2012 表列出的人员名字串联起来 取子串1234567891011# 取子串：特定位置 - substringselect substring(name,1,2); # 返回na;# 取子串：左/右 - left /rightselect left(ltrim( name), 3); # 返回nam;-------结合Charindex 返回特定符号之前的值Select left(&apos;text&apos;, charindex(&apos;%&apos;,&apos;text&apos;,1)-1) -- 第二个为返回 % 出现的位置Select left(&apos;text&apos;, len(&apos;text&apos;)-1 ) --若指定符号为最后一个时 返回特定位置12345678910111213# 返回位置：起始位置 - charindexselect charindex(&apos;L&apos;, &apos;HELLO&apos;, 1); # 返回:3; 1表示从第一个位置开始选取--charindex(serach string, string ,starting position) ；第三个参数默认为1，可不写# 返回位置：表达式中某模式第一次出现的起始位置 - patindexpatindex(&apos;%123%&apos;,&apos;abc123def&apos;); # 返回4--允许通配符的使用--返回第一个数字的位置Select patindex(&apos;%[0-9]%&apos;,&apos;字段名&apos;)--返回第一个数字的位置，并进行截取substring(合约,1,patindex(&apos;%[0-9]%&apos;,合约)-1), 取出一个字符串中最后一个特殊字符右边的字符 涉及 翻转 reverse 和 charindex 12345678DECLARE @aa VARCHAR(30)SET @aa = &apos;10*20*300&apos;-- 取最后一个*后的所有字符SELECT RIGHT(@aa, CHARINDEX(&apos;*&apos;,REVERSE(@aa)) - 1) -- 取定长字符串，如*后的3个字符SELECT SUBSTRING(@aa, LEN(@aa) - CHARINDEX(&apos;*&apos;,REVERSE(@aa)) + 2, 3) 替换1234567891011# 替换 - replaceselect replace(&apos;abcdef&apos;,&apos;cde&apos;,&apos;xxx&apos;); 返回 abxxxfUpdate address Set country = replace(County, &apos;sun&apos;, &apos;dark&apos;) --colname列中每个单元格的aaa值替换为bbb值，并返回colname列# 删除&amp;替换 - stuff()Select stuff(&apos;abcdef&apos;, 3, 2, &apos;123&apos;) -- 返回ab123ef；从第三个位置开始删除2个字符，并插入123--stuff(string, insertion position, delete count, string inserted); 合并123# 合并为一个字符串 - concat()Select Concat(Null, &apos;Patrick &apos;, 1, &apos; LeBlacn&apos;)--隐式地将所有值转换为字符串，将空值转为空字符串 格式转换123456789101112131415# 转换：大小写 - upper/lowerselect upper(&apos;abc&apos;); # 返回 ABC# 转换：反转 - reverseselect reverse(&apos;abc&apos;); # 返回&apos;cba&apos;# 转换：字符形式 - charselect char(213);# 转换：字符串形式 - strselect str(123.45, 6,1); # 把数值转换成字符串格式--返回123.5； 将123.45转为6个位置的字符串，数字的小数部分舍入为1为小数；# 转换：ascii码 - asciiselect ascii(123) as &apos;123&apos; 格式转换 - Convert CONVERT (data_type[(length)], expression [, style]) length： nchar、nvarchar、char、varchar、binary 或 varbinary 数据类型的可选参数。 style：日期格式样式，借以将 datetime 或 smalldatetime 数据转换为字符数据（nchar、nvarchar、char、varchar、nchar 或 nvarchar 数据类型）；或者字符串格式样式，借以将 float、real、money 或 smallmoney 数据转换为字符数据（nchar、nvarchar、char、varchar、nchar 或 nvarchar 数据类型）。 123456789101112131415161718192021222324# 格式的转换、显示 - convert : 将第2个参数转换为第1个参数所指定的类型 / 用不同的格式显示日期/时间数据。-- CONVERT (data_type[(length)], expression [, style]) ;-- [,style] 日期格式样式--------------------日期转换------------------------SELECT CONVERT(DateTime, &apos;2020-09-09&apos;); # 返回: 2020-09-09 00:00:00.000SELECT CONVERT(varchar(5), 92.89); # 返回：92.89SELECT CONVERT(varchar(11), GETDATE(), 121); # 返回：2010-03-24常用日期格式： - 23 ：日期格式 yy-mm-dd - 111：日期格式 yy/mm/dd - 120：日期格式 yyyy-mm-dd hh:mi:ss(24h) - 121：日期格式 yyyy-mm-dd hh:mi:ss.mmm(24h) - 105：日期格式 dd-mm-yy - 110：日期格式 mm-dd-yy-------------------其他格式转换-------------------Select Convert(int, &apos;3&apos;)Select COnvert() Data_type : INT / DECIMAL(10,2) / CHAR() / VARCHAR() / 格式转换 - Cast CAST ( expression AS data_type ) data_type 目标系统所提供的数据类型，包括 bigint 和 sql_variant。不能使用用户定义的数据类型。 1select CAST(&apos;123&apos; as int) -- 123 字符串 - 正则表达式 regexp_like(x,pattern[,match_option]) ：查看x是否与pattern相匹配 可选的参数match_option字符串说明默认的匹配选项。match_option的取值如下: ‘c’ 说明在进行匹配时区分大小写（缺省值）； ‘i’ 说明在进行匹配时不区分大小写； ‘n’ (.)点号能表示所有单个字符,包括换行(俺还不知道什么地方有用到换行.只知道sql里面可以用chr(10)表示换行. ‘m’ 字符串存在换行的时候当作多行处理.这样$就可匹配每行的结尾.不然的话$只匹配字符串最后的位置. 1234567--可以查找ename中以a开头以n结尾的行select * from emp where regexp_like(ename,&apos;^a[a-z]*n$&apos;);--例如ename为arwen或arwin或anden.但Arwen不能被匹配.因为默认是区分大小写.如果是select * from emp where regexp_like(ename,&apos;^a[a-z]*n$&apos;,&apos;i&apos;)--则可以查找ename为Arwen的行记录. regexp_replace regexp_substr regexp_instr 2. 查询：数字相关 函数名 功能描述 举例 ABS 返回表达式绝对值 SELECT ABS(-90) 返回：90 ROUND 按指定的精度进行四舍五入 SELECT ROUND(56.629, 2) 返回：56.630 SQRT 返回指定表达式的平方根 SELECT SQRT(9) 返回：3 FLOOR 返回小于或等于指定数值表达式的最大整数 $\le$ SELECT FLOOR(23.9) 返回: 23 CEILING 返回大于或等于指定数值表达式的最小整数 $\ge$ SELECT CEILING(23.9) 返回：24 POWER 次方；返回x的y次方 SELECT POWER(2,3) ; 返回8 EXP 指数；e的x次方 SELECT EXP(2) 返回e$^2$ LN /LOG(x,y) 对数； SELECT LN(e) ；返回1 MOD 返回x除以y的余数 SELECT MOD(9,2); 返回1 % 返回x除以y的余数 SELECT 9%2 SIGN 判断正负；若x为正返回1；若x为负 返回-1 ; 若x为0 返回0 SELECT SIGN(2); 返回1 3. 查询：聚合函数 聚合是在对From和Where子句筛选后的数据集进行聚合计算；即运营逻辑是在其之后执行 聚合函数，它的对象是多个观测值，但只返回一个值；若要出现多个观测值的聚合值，需要用到Group by 函数 一旦查询包含了聚合函数，那么每一列必须参与到聚合函数中。 SELECT语句中除聚合函数外，所有列应写在Group By语句后面。否则将出现错误 函数名 功能描述 AVG 平均值 SUM 求和 MAX/MIN 求最大值/最小值 COUNT 计算非空单元格（ 返回 int 数据类型值） count_big 计算非空单元格（返回 bigint 数据类型值） VAR 方差 # 平方 varp 总体方差 STDEV 标准差 stdevp 总体标准差 除Count(*)外，所有聚合函数均忽略空值NULL； avg( ) $\ge$ $sum( ) \over count(*)$ Count(*)，计数时也将NULL计入；Count(Null) 返回0；所有与NULL的计算，都返NULL 其他所有聚合函数，包括Count(col_name)的形式，计算时均已排除了NULL 表a，观测值10行，其中2个NULL；Count(*) # 返回10； Count(列名) # 返回8 除非，可用 isnull() 函数进行转换，来计算； 例如，对表a求平均值，若直接用avg() ，其分母为8； 若想使得其分母变成10，应添加 case when isnull(col_name,0) then col_name else end 4. 查询：日期相关 函数名 描述 Getdate 返回当前服务器的日期和时间 Current_timestamp 除了ANSI标准，等同于Getdate Getutcdate 返回当前服务器的日期和时间，并转化为格林威治标准时间 Sysdatetime 返回当前服务器的日期和时间 Sysutcdatetime 返回当前服务器日期，并转化为格林威治标准时间 Sysdatetimeoffset 返回Datetimeoffset值 日期处理函数 函数名 描述 Dateadd 在指定的日期上累加数值得到新的日期；dateadd(datepart,number,date) SELECT DATEADD(yyyy, 4, ‘01/09/2003’) 返回：2007-01-09 datepar是参数的格式：datepart=yy(年)，mm(月)，qq(季度)；date 参数是合法的日期表达式。number 是您希望添加的间隔数；对于未来的时间，此数是正数，对于过去的时间，此数是负数。 DATEDIFF 返回两个日期的差值 ； datediff(datepart,startdate,endate) SELECT DATEDIFF(dd, ‘02/05/2003’, ‘02/09/2005’) 返回：735 DATEPART 返回指定日期部分的整数（整数形式） SELECT DATEPART(dd, ‘01/09/2003’) 返回：9 DATENAME 返回指定日期部分的字符串（字符串形式）；工作日(dw)、周(wk)、日(dd)、月(mm) SELECT DATENAME(dw, ‘02/02/2009’) 返回: 星期一 Eomonth 返回针对指定开始日期的月份的最后一天 Select Eomonth(‘5/27/1998’) YEAR 返回指定日期“年”部分整数 SELECT YEAR(GETDATE()) 返回：当前年份整数 MONTH 返回指定日期“月”部分整数 SELECT MONTH(GETDATE()) 返回：当前月份整数 DAY 返回指定日期“日”部分整数 SELECT DAY(GETDATE()) 返回：当前日期整数 查询：日期的应用12345678910111213141516171819202122232425262728293031323334353637383940414243# 获取当前时间 - getdateselect getdate();# 返回指定的时间 - dateaddselect dateadd(mm, -1, &apos;2017-03-31&apos;); ----返回 2017-02-31 # datepart：yy/qq/mm/ww/dd/hh/mi/ss/ms ; # num为正或为负；--dateadd()仅接受提取日期部分# 计算两个时间差 - datediffselect datediff(dd,&apos;2016-06-01&apos;, &apos;2017-01-31&apos;); # yy/qq/mm/ww/dd/hh/mi/ss/ms--datediff(date_type,startdate , enddate)# 取出时间的某一部分 - datename/datepart --只能取出 年 或者 月 或者 日 select datename(dd, &apos;2017-01-31&apos;); # datename 字符串形式select datepart(dd, &apos;2017-01-31&apos;); # datepart 整数形式Select Convert(varchar(),,120) ---- 可以取出前面的所有部分--返回上一个月 Select Convert(varchar(7), dateadd(mm,-1,getdate()),120)# 返回星期几 - detenameSelect datename(dw, &apos;2017-01-31&apos;)# 获取日期的年份/季度/月度/日期等 select year(getdate()); quarter/month/day# 查看轴select datepart(week,getdate())-- 按周分组select datepart(week,convert(datetime,dateTimeCloumn,121)) &apos;周&apos;,count(distinct users) &apos;人数&apos;# 返回针对指定开始日期的月份的最后一天 - EomonthSelect Eomonth(&apos;2016-02-32&apos;,1) # 返回 2016-03-31Select EOmonth(getdate(),-1)--Eomonth(start_date, month_to_add) 时间戳 时间戳就是一个从1970-01-01 08:00:00到时间的相隔的秒数 dateadd(s, string, format)：时间戳转日期格式 datediff(s,format,time)：普通时间转时间戳 12345-- 时间戳转日期格式SELECT DATEADD(S,1160701488,'1970-01-01 08:00:00') --普通时间转换成时间戳SELECT DATEDIFF(S,'1970-01-01 08:00:00', GETDATE()) 注解：北京时间与GMT时间关系 1.GMT是中央时区,北京在东8区,相差8个小时 2.所以北京时间 = GMT时间 + 八小时 12&gt; select DATEADD(second,1268738429 + 8 * 60 * 60,'1970-01-01 00:00:00')&gt; 1unix_timestamp(time) 这个转换成时间戳，from_unixtime(unix_timestamp(time)) 这个转换成datetime Datepart 设置周末为第一天12345678910111213141516171819202122-----2014-01-05为周日-- The default first date in a week is Sunday, the value is 7SELECT @@DATEFIRST -- Default DATEFIRST is SundaySELECT DATENAME(WEEK,&apos;2013-12-31&apos;) AS WeekName -- 53SELECT DATENAME(WEEK,&apos;2014-01-01&apos;) AS WeekName -- 1SELECT DATENAME(WEEK,&apos;2014-01-05&apos;) AS WeekName -- 2-- Change the DATEFIRST to 1, Monday will be the first day of week.SET DATEFIRST 1 SELECT @@DATEFIRST -- 1-- After change the DATEFIRST to MondaySELECT DATENAME(WEEK,&apos;2013-12-31&apos;) AS WeekName -- 53SELECT DATENAME(WEEK,&apos;2014-01-01&apos;) AS WeekName -- 1SELECT DATENAME(WEEK,&apos;2014-01-05&apos;) AS WeekName -- 1 要注意的是 SET DATEFIRST 只在当前执行中有效，也就说比如新开一个查询页面继续查询 SELECT @@DATEFIRST 则还是显示默认值 7。 参考：日期缩写参考 datediff / datename / datepart /dateadd 日期部分 缩写 year yy, yyyy quarter qq, q month mm, m dayofyear dy, y # 查询date在当年是第多少天. 一年中的第几天； day dd, d week wk, ww # 查询date在当年中是第几周 / 以周为单位的间隔数 weekday dw # 一周中的第几天(星期几) Hour hh minute mi, n second ss, s millisecond ms convert - style的参考值 一位或两位数字样式提供两位数的年份；3位数字样式提供4位数字的年份； 代码 Style 格式 100 或者 0 mon dd yyyy hh:miAM （或者 PM） 101 mm/dd/yy 102 yy.mm.dd 103 dd/mm/yy 104 dd.mm.yy 105 dd-mm-yy 106 dd mon yy 107 Mon dd, yy 108 hh:mm:ss 109 或者 9 mon dd yyyy hh:mi:ss:mmmAM（或者 PM） 110 mm-dd-yy 111 yy/mm/dd 112 yymmdd 113 或者 13 dd mon yyyy hh:mm:ss:mmm(24h) 114 hh:mi:ss:mmm(24h) 120 或者 20 yyyy-mm-dd hh:mi:ss(24h) 121 或者 21 yyyy-mm-dd hh:mi:ss.mmm(24h) 126 yyyy-mm-ddThh:mm:ss.mmm（没有空格） 130 dd mon yyyy hh:mi:ss:mmmAM 5. 查询：表格相关限定行数 - TOP123456# TOP n( 前n行 )SELECT TOP 5 * FROM allzjb; # 查询所有数据的中前5个------------------------TOP n PERCENT ( 按百分比取数据 )SELECT Top 30 PERCENT * FROM allzjb ; With Ties 允许最后的位置包含多行，但这多行是完全相同的 1Select top (10) With Ties listprice From ... 随机行选择 使用Top(1) 返回单行，且用Newid()随机排序结果；每次将返回一个随机值 涉及到较大的表时，可用Tablesample( n Percent/Rows)选项 由于是随机选择，可通过Repeatable()来指定 [效果同R语言中的set.seed()] 123Select top(1) Lastname From person.person Tablesample(10 Percent) -- 随机选择10%的 Repeatable(1234) Order by Newid(); --随机排序结果集 分组&amp;排序分组 Group by 会根据某一列的值将数据集自动分成子集。 对分组集来说，汇总行是每个子集中的每个唯一值组成的行 数据集被分成子组之后，聚合函数在每一个子组上执行。 对于Group by子句，空值NULL被认为是相等的，并被分组到单个结果行 Group by不局限于对列分组，也可以对表达式执行分组（但该表达式必须与Select中的相同） 分组后筛选HAVING what ：指定组或聚合的搜索条件；HAVING 通常在 GROUP BY 子句中使用，对Group by 之后的表单进行条件筛选；但针对的是所有group by 的字段，而非第一个 1234Select 交易账号,建平仓,[交易间隔(s)] From #b11 where [交易间隔(s)] &lt; &apos;60&apos; group by 交易账号,建平仓,[交易间隔(s)] having count([交易间隔(s)]) &gt;= 2 --指的是对满足所有group by字段的观测值进行计数统计；因为每个观测值都已经按照分组划分为不完全相同的观测值（每行中必定有一个不相等），所以结果为0 如果不使用 GROUP BY 子句，则 HAVING 的行为与 WHERE 子句一样。 123456--HAVING 子句从 SalesOrderID 表中检索超过 SalesOrderDetail 的每个 $100000.00 的总计SELECT SalesOrderID, SUM(LineTotal) AS SubTotal FROM Sales.SalesOrderDetail GROUP BY SalesOrderID HAVING SUM(LineTotal) &gt; 100000.00 ORDER BY SalesOrderID ; 排序 Select 指定的每一列都应该出现在Group By子句中，除非对这一列使用了聚合函数； 排序：Order by 可以使用表达式来指定顺序 可以使用列别名指定顺序 可以使用列的顺序位置来进行排序 1234567# 按某个组分组并排序group by nameorder by name;----------------------GROUP BY nameORDER BY first_name, last_name DESC, SUM(age); # 默认为升序排序（ASC） 窗口函数 - Select Over()聚合子句1234567891011Sum(cola) Over(partition by col1 order by col2)--其他聚合函数：avg/max/min /count # 根据分组求和Over(Partition by col1) --根据col1的分组对cola进行求和； [若同一组别有多个维度，则求和的值是相同的]# 根据排名求累计和Over(Order by col2)--根据col2的顺序对cola列累计求和； [若同一组有多个维度，求和的值是累加的]# 根据分组后的排名，求累积和Over(Partition by col1 order by col2) --根据Col1的分组进行排名得出Col2的次序，并按col2的次序对cola进行分组求和 12# 移动平均CONVERT(varchar(20),AVG(SalesYTD) OVER (ORDER BY DATEPART(yy,ModifiedDate)),1) AS MovingAvg 在窗口内分区：Partition by 执行逻辑：先对查询结果进行排序，之后通过Partition by的列进行分区； 窗口函数只能在Select 或者 Group by 子句中 排名 - rank子句12345678910111213141516171819202122232425262728# 排名：无重复排名 - Row_number（组内连续的唯一的)row_number() over (order by col2); # 对所有进行排名row_number() over (partition by col1 order by col2); # 根据COL1分组，在分组内部根据 COL2排序-------------------------------------------------# 排名：有重复排名 - Rank （若出现字段值相同，序号一样，下一个跳过1位[排名是非连续的]）rank() over([partion by col1] order by col2); 对所有进行排名ProductID Name LocationID Quantity Rank 494 Paint - Silver 3 49 1 495 Paint - Blue 3 49 1 493 Paint - Red 3 41 3 -------------------------------------------------# 排名：有重复排名 - Dense_rank （若出现字段值相同，序号一样，后一个不跳过[排名是连续的]）dense_rank() over([partion by col1] order by col2)ProductID Name LocationID Quantity Rank 494 Paint - Silver 3 49 1 495 Paint - Blue 3 49 1 493 Paint - Red 3 41 2 -------------------------------------------------# 排名：对序号进行分组处理 - Ntilentile (4) over ([partion by col1] order by col2); # (4)表示分为4组 ntile函数的分组依据（约定）： 首先系统会去检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配就完成分组了；若不能，则会先分出一个组，这个组分多少条记录呢？就是 （总记录数/总组数）+1 条，之所以分配 （总记录数/总组数）+1 条是因为当不能进行平均分组时，总记录数%总组数肯定是有余的，又因为分组约定1，所以先分出去的组需要+1条。 分完之后系统会继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若不能，则再分出去一组，这个组的记录数也是（总记录数/总组数）+1条。 举个例子，将53条记录分配成5组，53%5 = 3不能平均分配，则将余数3平均分配到前3组 （余数 = 分配的组数），然后比较余下的 53-(11*3)=20 条记录能否平均分配给未分配的2组，能平均分配，则剩下的2组，每组各20/2=10 条记录，分配完成，分配结果为：11，11，11，10，10。 分页12345# Offset &amp; Fetch 必须结合使用Select ... From Order by Offset n rows # 表示跳过n行 Fetch Next 20 rows only # 表示返回之后的20行 条件查询 case when 最大的优点是可以与Select语句“内联” 若else缺失，表示其他值返回NULL Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略； 所以，如果根据金额大小来判定等级，必须要最高的金额写在最前面； 1234567891011121314151617 ## 两者区别1. 输入表达式，只能用于等同性(=)检查2. 布尔表达式，不局限于等同行(=)检查--用输入表达式，将与每个where子句中的值比较Case &lt;input expression&gt; --只能用于等同性检查，而不进行其他比较 when &lt;when exp&gt; then &lt;result exp&gt; [n...] [else &lt;result exp&gt;]End--给每个when子句提供一个布尔表达式，求值为TRUE或FALSE [布尔值是“真” True 或“假” False 中的一个] Case when &lt;Boolean exp&gt; then &lt;result exp&gt; [n...] [else &lt;result exp&gt;]End – 12345678910111213141516171819202122232425262728293031323334353637383940414243## 1.简单Case语句# 在SELECT语句中，CASE 简单表达式只能用于等同性检查，而不进行其他比较SELECT ProductNumber, Category = CASE ProductLine --表示如果 ProductLine = R 则返回 Road； Case之后的变量，为比较的变量 WHEN &apos;R&apos; THEN &apos;Road&apos; WHEN &apos;M&apos; THEN &apos;Mountain&apos; WHEN &apos;T&apos; THEN &apos;Touring&apos; WHEN &apos;S&apos; THEN &apos;Other sale items&apos; ELSE &apos;Not for sale&apos; END, Name FROM Production.Product ； --Select top 10 SalesOrderID % 10 As &apos;OrderLastDigit&apos;,ProductID % 10 As &apos;ProductLastDigit&apos;,&quot;How Colse ?&quot; = CASE SalesOrderID % 10 WHEN ProductID % 1 THEN &apos;Exact Match&apos; -- 可在When子句中引用第二个列来做判断 WHEN ProductID % 1-1 THEN &apos;Within 1&apos; WHEN ProductID % 1+1 THEN &apos;Within 1&apos; ELSE &apos;More Than One Apart&apos; END FROM Sales.SalesOrderDetail ；-- % 表示返回余数； 5%2 返回1-- 变量名在Case之前使用双引号（“”）说明，该变量是新创建的变量;但不建议如此；------------------------------------------------------## 2. 搜索Case语句-- 没有输入表达式（即Case关键字与第一个When之间的部分）-- When表达式必须求值为一个 布尔值；（Case简单语句中，When的表达式可以为1、3、Price+1[含运算]）Select top 10 SalesOrderID % 10 As &apos;OrderLastDigit&apos;,ProductID % 10 As &apos;ProductLastDigit&apos;,&quot;How Colse ?&quot; = CASE -- 没有输入表达式 WHEN (SalesOrderID % 10) &lt; 3 THEN &apos;Ends With Less Than Threes&apos; WHEN ProductID =6 THEN &apos;ProductID is 6&apos; -- 可在When子句中引用第二个列来做判断 WHEN ABS(SalesOrderID % 10 - ProductID) &lt;= 1 THEN &apos;Within 1&apos; ELSE &apos;More Than One Apart&apos; END FROM Sales.SalesOrderDetail ；# Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略# 可在条件表达式中混合搭配的字段# 可执行为任何表达式，只要最后的结果为布尔值 搭配其他函数用法 12345678910111213141516171819202122232425262728293031323334353637383940# SELECT CASE WHEN 用法select userID , count(CASE WHEN letterType=&apos;干部介绍信&apos; then &apos;1&apos; end)干部介绍信数, count(CASE WHEN letterType=&apos;转递档案通知单&apos; then &apos;1&apos; end)转递档案通知单数 from T_LettersRecord GROUP BY userID ------------------------------------------------------# WHERE CASE WHEN 用法SELECT l.letterType, u.realName FROM T_LettersRecord as l, T_User as u WHERE (CASE WHEN l.letterType = &apos;干部介绍信&apos; AND u.userID = &apos;1&apos; THEN 1 WHENl.letterType = &apos;干部介绍信&apos; AND u.userID &lt;&gt; &apos;1&apos; THEN 1 ELSE 0 END) = 1 ------------------------------------------------------# 在 ORDER BY 子句中使用 CASE --计算 SalariedFlag 表中 HumanResources.Employee 列的值。SalariedFlag 设置为 1 的员工将按 BusinessEntityID 以降序顺序返回。 SalariedFlag 设置为 0 的员工将按 BusinessEntityID 以升序顺序返回SELECT BusinessEntityID, SalariedFlag FROM HumanResources.Employee ORDER BY CASE SalariedFlag WHEN 1 THEN BusinessEntityID END DESC ,CASE WHEN SalariedFlag = 0 THEN BusinessEntityID END;------------------------------------------------------# GROUP BY CASE WHEN 用法SELECT CASE WHEN salary &lt;= 3000 THEN &apos;T1&apos; WHEN salary &gt; 3000 AND salary &lt;=8000 THEN&apos;T2&apos; WHEN salary &gt; 8000 AND salary &lt;=12000 THEN&apos;T3&apos; WHEN salary &gt; 12000 AND salary &lt;= 20000 THEN &apos;T4&apos; ELSE NULL END 级别名称, -- 别名命名 COUNT(*) FROM t_userSalary GROUP BY CASE WHEN salary &lt;= 3000 THEN &apos;T1&apos; WHEN salary &gt; 3000 AND salary &lt;=8000 THEN&apos;T2&apos; WHEN salary &gt; 8000 AND salary &lt;=12000 THEN&apos;T3&apos; WHEN salary &gt; 12000 AND salary &lt;= 20000 THEN &apos;T4&apos; ELSE NULL END; 联接与联合 what：将两个数据集相乘，并对结果进行限制。这样只返回两个数据集的交集。 why ：横向合并两个数据集，并通过匹配一个数据源的行与另一个数据源的行，从组合中产生新的数据集。 ​ 内联接Inner Join 在连接条件中使用等于号（=）运算符，其查询结果中列出被连接表中的所有列，包括其中的重复列。 在连接条件中使用除等于号之外运算符（&gt;、&lt;、&lt;&gt;、&gt;=、&lt;=、!&gt;和!&lt;） 多个数据源的联接（顺序并不重要） 所要获得字段的表要写在最前面；即From之后； 可实现A联接B，B联接C，C联接D； 12345Select cst.companyname, prod.name From Customre As a Inner join salesorderhead As b On a.customerid = b.customerid Inner join salesorderdetail As c On b.salesorderid = c.salesorderid Inner join product As d On c.productid = d.productid SQL内在处理逻辑：(按照排列顺序进行联接) 先扫描a Inner Join 表a 和 表b 然后将 a和b 联合表单 与表c Inner Join 最后将上面联合表 与 表d Inner Join ​ 外联接 可多条件连接；即在原来连接的基础上再进行连接 123456&gt; From #a2 As a&gt; Left Join [exchange].[GFFCC_YTX].[v_qhkh] As b&gt; On a.手机 = b.手机&gt; Left Join [ADHOC_YTX].[zhangcm].[期货客户属性表] As c&gt; On b.资金号 = c.投资者代码&gt; what：以一个表为基准表，进行联接； 若使用外联接，顺序非常重要 慎用 不等连接 on a.id &lt;&gt; b.id ，因为会对每一条记录a无法匹配的b表中的行生成一条记录，最后会生成 $a \times b$ 行 1234567select * form tab1 left join tab2 on (tab1.size != tab2.size)tab1.id tab1.size tab2.size tab2.name1 10 20 BBB2 10 20 CCC2 10 (null) (null)3 20 10 AAAA...... ​ how ：无论是否匹配，外联接都包含所有数据 How ：数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。 中间表是 左表与右表的所有字段 on 与 where 的区别 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录 select * form tab1 left join tab2 on (tab1.size = tab2.size and tab2.name=’AAA’) 表示同时满足这两个条件才能匹配到记录（必须用括号()括起来） ，但条件不为真也会返回左表中的记录； 可通过where子句限定 b.x Is Not Null 来返回该条记录 或 where tb2.name=’AAA’ where条件是在临时表生成好后，再对临时表进行过滤的条件。条件不为真的就全部过滤掉。 关于 “A LEFT JOIN B ON 条件表达式” 的一点提醒 ON 条件（“A LEFT JOIN B ON 条件表达式”中的ON）用来决定如何从 B 表中检索数据行。 如果 B 表中没有任何一行数据匹配 ON 的条件,将会额外生成一行所有列为 NULL 的数据 在匹配阶段 WHERE 子句的条件都不会被使用。仅在匹配阶段完成以后，WHERE 子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。 12345678910111213141516171819202122232425select * form tab1 left join tab2 on (tab1.size = tab2.size) where tab2.name=’AAA’/*1.中间表：on条件: tab1.size = tab2.size tab1.id tab1.size tab2.size tab2.name1 10 10 AAA2 20 20 BBB2 20 20 CCC3 30 (null) (null) 2.再对中间表过滤：where 条件：tab2.name=’AAA’ tab1.id tab1.size tab2.size tab2.name1 10 10 AAA*/select * form tab1 left join tab2 on (tab1.size = tab2.size and tab2.name=’AAA’) --表示同时满足这两个条件才能匹配到记录(条件不为真也会返回左表中的记录) /*1. 中间表 ： on条件: tab1.size = tab2.size and tab2.name=’AAA’tab1.id tab1.size tab2.size tab2.name1 10 10 AAA ----仅同时满足的进行匹配，但仍然会返回所有的观测行；2 20 (null) (null)3 30 (null) (null) */ 其实以上结果的关键原因就是left join,right join,full join的特殊性，不管on上的条件是否为真都会返回left或right表中的记录，full则具有left和right的特性的并集。 而inner jion没这个特殊性，则条件放在on中和where中，返回的结果集是相同的。 当涉及多个联接时 一定要用较小规模的数据对查询进行单元测试； 并坚持使用左外联接 外联接中的条件设置（执行逻辑） 当条件位于Join子句中，先包括外表的所有行，然后用条件包括第二个表中的行 当条件位于Where子句中，先执行联接，然后将条件应用于联接行 123456789101112131415 # 条件位于Join子句 Select a.col, b.col From table As a Left join table2 As b On a.id = b.id And a.Lastname = &apos;Adams&apos; --该条件限制的是第二个表中的行 [And a.Lastname = b.name] --也可以再进行限制------------------------------------------# 条件位于Where子句中Select a.col, b.col From table As a Left join table2 As b On a.id = b.id Where a.Lastname = &apos;Adams&apos; --该where条件是对联接后的表进行限制 Left [Outer] Join 返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。 必须要表基准表放在左侧，非常重要！否则会产生大量NULL值。 Right [Outer] Join 恰与左连接相反，返回右表中的所有行，如果右表中行在左表中没有匹配行，则结果中左表中的列返回空值。 建议左/右外联接不要混合使用 Full [Outer] Join 返回左表和右表中的所有行。即返回两个数据集的所有数据。当某行在另一表中没有匹配行，则另一表中的列返回空值 交叉联接Cross Join 不带WHERE条件子句，它将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积 （例如：T_student和T_class，返回4*4=16条记录） 如果带where，返回或显示的是匹配的行数。 差集查询 Left Join / Null what：分析两个数据集之间相关性的查询； why ：用于查找不存在或不匹配的数据 how ：一般需分两步来执行 联接 设置第二个数据集的主键为NULL 涉及where子句，or的条件子句一定要用括号()括起来 123456789101112131415161718-- 左差集查询--不在右表中的左表数据集；【可用Inner Join 中不等号为条件进行联接 &lt;&gt;】Select c.customerid, so.ordernumber From customer As a Left join salesorder As b On a.customerid = b.customerid Where b.ordernumer Is Null; --设置第二个表的主键为NULL-- 返回在右表中的左表的值where so.ordernumer Is Not Null; --设置第二个表的主键为不为NULL，即与之# 全差集查询Select c.customerid, so.ordernumber From customer As c Left join salesorder As so On c.customerid = so.customerid Where so.customerid Is Null or c.customerid Is Null --设置两个表的的主键为NULL Not In Like ( ) ：小范围使用 12345678910SELECT name FROM my_contacts WHERE name [NOT] IN LIKE (&quot;A%&quot;,&quot;B%&quot;,&quot;C%&quot;)----联合SELECT name FROM my_contacts WHERE name NOT IN (Select name From B)----子查询 查询选修了c02号课程的学生的姓名和所在系，学生表(student)，课程表(sc)SELECT Sname, Sdept FROM student WHERE Sno IN (SELECT Sno FROM sc WHERE Cno = &apos;C02&apos;); # 可在IN之前加NOT；即 WHERE sno NOT IN ... Exists &amp; Not Exists ：两个表之间； Exists ：返回仅在左表中的数据 Not Exists ：外层查询结果不存在于关联表里的方法（返回左边不在右表里面的观测值） 注意 Where 之后没有限定列名, 条件限定在 子查询中 1234---- 常用于外层查询结果不存在于关联表里的方法--注意 Where 之后没有限定列名,条件限定在 子查询中SELECT TNAME,DEPART FROM teacher WHERE NOT EXISTS (SELECT * FROM course WHERE teacher.TNO = course.TNO); EXCEPT： 返回在坐标中存在，但不在右表中的行； 从左查询中返回右查询没有找到的所有非重复值。 12345SELECT ProductID FROM Production.ProductEXCEPTSELECT ProductID FROM Production.WorkOrder ; 联合 - Union 返回每个结果集中的所有行 Union ，表示删除重复行 Union ALL ，表示不考虑是否存在重复行 每个Select必须具有相同的数量、类型； 列名或别名由第一个Select确定 Order by子句放在最后，并且对所有结果进行排序，且列名必须是第一个Select语句中存在的 可用Select Into，但Into必须放在第一个Select语句中 列的xml数据类型必须为等效。 所有的列必须类型化为 XML 架构或是非类型化的。 如果要类型化，这些列必须类型化为相同的 XML 架构集合。 子查询非相关子查询 what：子查询是独立运作的； how ：运行逻辑 非相关子查询被执行一次 结果传输到外查询 外查询被执行一次 1Select (Select 3) As subqueryvalue; ​ 公用表表达式- CTE what：CTE (Comman Table Expression ) why ：确定查询结果可当做临时视图来使用；即后续的查询可以引用公共表表达式中的表及字段； how ：CTE使用With子句，而With子句定义了CTE；在With子句内分别是名称、别名、AS、括号、Select查询语句 CTE自身只是一个不完整的SQL语句 一旦With子句中定义了CTE，查询的主要部分就可以使用其名称引用CTE；就像CTE是其他任何表源一样； 若将多个CTE包含在相同的查询中，在主查询之前确定CTE的顺序，并用逗号分隔,；并且后面的CTE可以引用在它之前定义的任何CTE CTE不能嵌套 12345678910111213# With子句的表达式格式With CTEname [Col Aliases] As (Select ...From ... ), CTEname2 [Col] As (Select) ----多表共同表达式Select ...From ...------------------------------------------------------With CTEname1 (col names) As (Select) , ----用逗号分隔 Ctename2 (col names) As (Select)Select ... From CTEname1 Inner join CTEname2 On 相关子查询 what：先执行外查询，相关子查询的运行要引用外查询中的列 why ：对于复杂的Where条件来说很有用 how ：执行逻辑 先执行一次外查询 在外查询中对每一行执行一次子查询，把外查询中的值取代为子查询的每一次执行 子查询的结果要整合到结果集中 子查询可出现在Select子句中，也可以出现在Where 子句中； 判断是否为相关子查询的标准为是否引用了外查询中的列； 没有引用外查询中的列，为非相关子查询；先于外查询运行 引用了外查询中的列，为相关子查询，后于外查询运行 数据透视 - Pivot123456789101112131415161718--------------------SELECT &lt;非透视的列&gt;, ---------第一个Select 表示从 From 中的数据中返回的值 [第一个透视的列] AS &lt;列名称&gt;, [第二个透视的列] AS &lt;列名称&gt;, ... [最后一个透视的列] AS &lt;列名称&gt;,FROM (&lt;生成数据的 SELECT 查询&gt;) ---------第二个Select 表示从 Pivot所要用到的数据 AS &lt;源查询的别名&gt; -----As 的别名不可以省略PIVOT( &lt;聚合函数&gt;(&lt;要聚合的列&gt;) -----要计算的列FOR[&lt;包含要成为列标题的值的列&gt;] ---------观测行所在的列名 IN ( [第一个透视的列], [第二个透视的列], --------------上列中观测行的名称；可以理解为分类 ... [最后一个透视的列])) AS &lt;透视表的别名&gt; -----As 的别名不可以省略&lt;可选的 ORDER BY 子句&gt;; 示例1 1234567891011121314151617181920212223242526272829--------原始数据结算日期 多空罗盘 期初权益 盈亏 佣金 损佣比 佣金转化率2017-08-25 0 32889.532389 -99.282000 120.902355 -0.821175 0.0036762017-07-28 1 12964.049298 -80.327000 45.525612 -1.764435 0.0035112017-09-01 1 24381.504055 -109.686000 70.774820 -1.549788 0.0029022017-08-01 0 36143.075381 -410.239000 55.022701 -7.455813 0.0015222017-08-30 0 33944.379618 -35.971500 94.818393 -0.379372 0.0027932017-07-19 1 9448.754481 22.619500 25.076349 0.902025 0.0026532017-08-29 0 33323.606632 -55.551000 129.617184 -0.428577 0.0038892017-08-21 1 17932.778420 -234.807000 83.943086 -2.797216 0.004680--------Pivot转换Select 结算日期 , [1] As 期初权益_开通产品 , [0] As 期初权益_未开通 From (Select 结算日期,多空罗盘,期初权益 From [ADHOC_YTX].[caihf].[多空罗盘_交易数据]) As a Pivot (Max(期初权益) For 多空罗盘 In([1],[0])) As b------------多个列合并Select b1.*, b2.* From (Select 结算日期,多空罗盘,期初权益 From [ADHOC_YTX].[caihf].[多空罗盘_交易数据]) As a1 Pivot (Max(期初权益) For 多空罗盘 In([1],[0])) As b1, ----------用逗号分隔符即可 (Select 结算日期,多空罗盘,期初权益 From [ADHOC_YTX].[caihf].[多空罗盘_交易数据]) As a2 Pivot (Max(期初权益) For 多空罗盘 In([1],[0])) As b2) 示例2 1234567891011121314151617181920212223242526----------未加工的数据SELECT DaysToManufacture, AVG(StandardCost) AS AverageCost FROM Production.ProductGROUP BY DaysToManufacture;DaysToManufacture AverageCost0 5.08851 223.882 359.10824 949.4105----------Pivot转化后的数据-- Pivot table with one row and five columnsSELECT &apos;AverageCost&apos; AS Cost_Sorted_By_Production_Days, [0], [1], [2], [3], [4]FROM(SELECT DaysToManufacture, StandardCost FROM Production.Product) AS SourceTablePIVOT(AVG(StandardCost)FOR DaysToManufacture IN ([0], [1], [2], [3], [4])) AS PivotTable;Cost_Sorted_By_Production_Days 0 1 2 3 4 AverageCost 5.0885 223.88 359.1082 NULL 949.4105 unpivot UNPIVOT 并不完全是 PIVOT 的逆操作。PIVOT 会执行一次聚合，从而将多个可能的行合并为输出中的单个行。而 UNPIVOT 不会重现原始表值表达式的结果，因为行已经被合并了。另外，UNPIVOT 的输入中的空值不会显示在输出中，而在执行 PIVOT 操作之前，输入中可能有原始的空值。 数据清洗去重复值12--Distinct # 去除完全重复的值SELECT DISTINCT 机构 FROM allzjb ; 1234567--Row_number() over(partation by col1 order by col2) 某个字段有重复值--【先根据某相同字段分组，根据其他字段排序，创建临时表；在提取排序=1的信息】# 对于相同的交易账号，取激活时间最前面的那一个账户的相关信息；Select *, Row_number() Over(partition by 交易账号 order by 激活时间) as 排序 Into #11 From exchange.ytx.ext_激活客户归属表; Select * Into #2 From #11 where 排序 = &apos;1&apos;; NULL what：空值NULL表示不存在的值，是一个未知值；并不表示0； how ：包含空值的任何表达式结果均是一个未知值 Null + 1 = Null 聚合函数中SUM( ) 与AVG( ) 会自动排除NULL进行计算； Count( * ) 会计算空值；但Count( col )会排除空值 123456# 测试空值 - IS NULLSELECT * FROM allzjb where 机构 is null ;-------------------------------------------------------# ISNULL 将NULL替换为某个值SELECT AVG(ISNULL(Weight, 50)) FROM Production.Product; # 将Weight中的NULL替换为50 isnull(col, 0 )：将col列中NULL值替换为0 12345678910111213## 处理空值 # Isnull() --将NULL替换为某个值Select Isnull(col, 0) -- 对col列进行搜索，并将空值NULL转换为0；也可以是其他任意值/字符串--isnull(soucre_expression, prlacement_value) # isnull是T-SQL特有的函数-----------------------------------------------------------------------------# Coalesce()Select Coalesce(Null, Null+1, 1+2, &quot;abc&quot;) 返回3--Coalesce(expression, expression,... ) # 接受一系列表达式或列，返回第一个非空值-----------------------------------------------------------------------------# Nullif() NULL ：未定义的值 / 不存在NA ：缺失数据NaN ：无意义的数，比如sqrt(-2)， 0/0。Inf ：正无穷大-Inf ：负无穷大 表是否存在123456789101112# SQL SERVER中查询某个表或某个索引是否存在IF OBJECT_ID(N&apos;表名称&apos;, N&apos;U&apos;) IS NOT NULL DROP TABLE 表名称;--注意，普通表和临时表的使用差别：--若希望删除TEST库中的dbo.TestTable表，直接将dbo.TestTable作为表名即可。--若希望删除临时表dbo.#temp_table，需要以tempdb.dbo.#temp_table作为表名。# 查询表上的某个索引是否存在SELECT 1 FROM sys.indexes WHERE object_id=OBJECT_ID(@tname, N&apos;U&apos;) and NAME=@iname其中：@tname表示建索引的表名，@iname表示索引名。 在每一个数据库中都有sys.sysobjects用于包括在数据库中创建的每个对象（例如约束、默认值、日志、规则以及存储过程）。详细的说明信息参看MSDN上的帮助文档：sys.sysobjects OBJECT_ID的作用是返回架构范围内对象的数据库对象标识号。如果找不到数据库或对象的名称，例如相应名称不存在或拼写不正确，则会返回NULL。 sys.indexes用于保存每个表格对象（例如，表、视图或表值函数）的索引或堆，详细的说明信息参看MSDN上的帮助文档：sys.indexes 数据运算与其他两行观测值相减1234567--根据某个字段先排序进行编号，创建为#a1；复制为另一个表#a2；通过联合，使得联合的条件为 #a1.rank+1 = #a2.rankSelect *, order by 成交时间 as rank --报错 into #a1 From [exchange].[YTX].[v_allcj] as cj;Select * into #a2 From #a1;Select a1.*, datediff(ss,#a1.成交时间,#a2.成交时间) s [交易间隔(s)] From #a1 Left join #a2 On #a1.rank = #a2.rank +1 12345678910111213----根据某个字段【分组】后排序编号；再通过唯一列联接，再设置条件 a.rank+1=b.rank 进行相减 【理论上应该是 a.rank=b.rank+1】--若a.rank=b.rank+1, 表示a表的rank=1 与b表的rank=2比较； --若a.rank+1=b.rank,表示a表的rank=1 变更为rank=2 与表b进行比较Select *, Row_number() over(partition by 交易账号 order by 成交时间) as [rank] into #a1 From [exchange].[YTX].[v_allcj] as cj;Select * into #a2 From #a1;Select #a1.*, datediff(ss,#a1.成交时间,#a2.成交时间) as [交易间隔(s)] From #a1 Left join #a2 On #a1.交易账号 = #a2.交易账号 where #a1.rank+1 = #a2.rank and datediff(ss,#a1.成交时间,#a2.成交时间) &lt; &apos;60&apos; 已知交易日计算差值123456# 已知交易日，计算未交易的交易日间隔；Select Max(结算日期) As 最后交易日期 FromSelect Count(1) From -----------计数 Inner Join b On 最后交易日 &lt; 结算日期 判断表单存在并删除12If Object_id(N&apos;tempdb.dbo.#b1&apos;,N&apos;U&apos;) Is Not Null Drop table #b1--若非临时表，无需加 数据库名 计算累加和12Select Sum([求和列]) Over(Partition by [分组列] Order by [排序列]) From ... 选取重复值 通过group by 之后 having count(*)&gt;1 来进行筛选 123456789101112131415161718--1.查某一列(或多列)的重复值(只可以查出重复记录的值---查找stuid，stuname重复的记录Select stuid，stuname from stuinfo group by stuid，stuname having(count(*))&gt;1--2.查某一列有重复值的记录 (所有重复的记录，如果有两条记录重复的，就查出两条))--查找stuid重复的记录select * from stuinfo where stuid in (select stuid from stuinfo group by stuid having(count(*))&gt;1 )/*--3.查某一列有重复值的记录(只显示多余的记录，也就是说如果有三条记录重复的，就显示两条) —— 实际意义？？--查找stuid重复的记录; 前提：需有一个不重复的列，此示例为recno。select * from stuinfo s1 where recno not in (select max(recno) from stuinfo s2 where s1.stuid=s2.stuid)*/ 取出一个字符串中最后一个特殊字符右边的字符 涉及 翻转 reverse 和 charindex 12345678DECLARE @aa VARCHAR(30)SET @aa = &apos;10*20*300&apos;-- 取最后一个*后的所有字符SELECT RIGHT(@aa, CHARINDEX(&apos;*&apos;,REVERSE(@aa)) - 1) -- 取定长字符串，如*后的3个字符SELECT SUBSTRING(@aa, LEN(@aa) - CHARINDEX(&apos;*&apos;,REVERSE(@aa)) + 2, 3) 问题 - 函数的长度参数无效 用逗号的位置得到的参数-1后是负数，不能做 LEFT和SUBSTRING的参数。 通过排序来进行查看，并且用Where进行限定 12345Select *, Convert(varchar(10), createTime, 120) As createTime2 , left(department, charindex(&apos;后&apos;, department,1)-1) As 老师 From [crm].[YTX].[t_wx_contact_monitor] where tag = &apos;v11.JY.JY-QH-WECHAT-QY.0&apos; and error_code= 0 and charindex(&apos;后&apos;, department,1)-1 &gt;0 问题 - 遇到 “遇到以零作除数错误” 屏蔽了“遇到以零作除数错误” 的错误信息，这样的话，遇到0是除数的情况，就是赋值为Null 12345678910SET ANSI_WARNINGS OFF;SET ARITHIGNORE ON;SET ARITHABORT OFF;GOSELECT 1 / 0SELECT Total/CountNr FROM dbo.TmpA1-----------NULL 系统查询相关通过字段找表名1234------SELECT sb.name FROM syscolumns s JOIN sysobjects sb ON s.id=sb.idWHERE s.name='你的字段名' 注释 -- 双连字符；从开始到行尾均为注释；对于多行注释，必须在每一个开头多使用 /*……*/ 正斜杠 星号； 可在同一行，可另起一行；在这之间的全部内容均为注释（可跨行）； 可在代码内执行 参照文档 1234select * from #100pivot(sum(人数) for 资金等级 in ([100万以下])) as B 转置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[王阳明的心法_罗辑思维]]></title>
      <url>%2F2017%2F03%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E7%8E%8B%E9%98%B3%E6%98%8E%E7%9A%84%E5%BF%83%E6%B3%95_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_20170315%2F</url>
      <content type="text"><![CDATA[社会本质是一个协作系统。当你发起一个项目，跟他人建立起联系之后，就不仅仅是个人的事。 创业，不是你有一套成功的商业方法。而是你有一个可能的目标，然后我们一群人去求证它，逼近它。 人活着，两个目的。 意义：我为什么要活着 规范：我怎么活着 儒学：做圣人，做君子（它的终极目标）向外求，通过外界的经历来不断雕刻自己 王阳明：向内求。每个人都是圣贤人，人人平等。 ​ 每个人都有圣贤的品质或种子，你要做的是把那些污染物给剔除。 知行合一。行才能真正体现你的知的水平。但认知的提升是一件极其困难的事。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown使用_typora_高阶]]></title>
      <url>%2F2017%2F03%2F05%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FMarkdown%2FMarkdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C_Typora_%E9%AB%98%E9%98%B6%2F</url>
      <content type="text"><![CDATA[关于Typora的其他设置。 Control TOC LevelsJune 25,2016 by typora.io About where to put those CSS, please follow AddCustom CSS. Intypora [TOC] will generate “Table of Contents”, by default itwill show headings from h1~h6. Tohide low level headings, for instance, h6, you would append css: 123.md-toc-h6 &#123; display: none;&#125; 来自 http://support.typora.io/TOC-levels/ Footnotes 脚注Youcan create footnotes like this[^footnote]. [^footnote]: Here is the textof the footnote. will produce: Youcan create footnotes like this 1. Mouse on the‘footnote’ superscript to see content of the footnote. Here is the text of the footnote. ↩ Underline 下划线Underline ispowered by raw HTML. &lt;u&gt;Underline&lt;/u&gt; becomes Underline. Subscript 下标To use thisfeature, first, please enable it in Preference Panel-&gt; Markdown Tab. Then use ~ to wrap subscript content,for example: H~2~O, X~long\ text~/ H~2~O, X~long\ text~/ eg： u~0~ Superscript 上标To use this feature, first, please enable itin Preference Panel -&gt; Markdown Tab. Then use ^ to wrap superscriptcontent, for example: X^2^. X^2^ Highlight 高亮To use thisfeature, first, please enable it in Preference Panel-&gt; Markdown Tab. Then use == to wrap highlight content,for example: ==highlight==. ==highlight== Inline Mathuse thisfeature, first, please enable it in Preference Panel-> Markdown Tab. Then use $ to wrap TeX command, forexample: $\lim_&#123;x \to \infty&#125; \exp(-x) = 0$ will be rendered as LaTeXcommand.```12345678To triggerinline preview for inline math: input “$”, then press ESC key, theninput TeX command, a preview tooltip will be visible like below:## Math Blocks 公式块 You can render LaTeX mathematical expressions using MathJax.Input $$, then press ‘Return’ key will trigger an input field which accept Tex/LaTex source. Following is an example:V1×V2=∣∣∣∣∣i∂X∂u∂X∂vj∂Y∂u∂Y∂vk00∣∣∣∣∣V1×V2=|ijk∂X∂u∂Y∂u0∂X∂v∂Y∂v0|In markdown source file, math block is LaTeX expression wrapped by ‘$$’ mark:$$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}$$12345678## Picture 图片大小Typora allows to use **\&lt;img&gt;** tag for displaying images, such it can also be used to adjust the size of images.For example, you could specify the `width` or `height` attribute of an \&lt;img&gt; tag, or set the width/height in its `style` attribute: # 百分比缩放 # 指定像素 12Another common user case is that when you try to insert a retina image, and want to scale it to a “correct” size according, then you could specify a `zoom` factor in its `style` attribute. # 验证后失效``` Above syntax can be understand and displayed by Typora, you could also set other css properties in its style attribute, they will be ignored when you edit or preview by Typora, but could affect the exported HTML or PDF.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL：安装卸载]]></title>
      <url>%2F2017%2F03%2F04%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FMySQL%2FMySQL_%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[彻底卸载MySQL-windows1.首先在windows服务中将mysql服务删掉，使用命令 sc delete mysql 2.在控制面板中卸载掉mysql。 3.清理mysql安装目录的ini文件。 4.清理注册表（win+R : regedit)： HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL目录删除 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL目录删除 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL目录删除（我卸载的时候没有找到，略过后仍达到完全卸载的目的。） 5.有一些mysql的数据文件也必须删除干净，比如说：C:\Documents and Settings\AllUsers\Application Data\MySQL 6.重启电脑。重新安装即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL:常见错误与解决办法]]></title>
      <url>%2F2017%2F03%2F04%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FMySQL%2FMySQL_%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
      <content type="text"><![CDATA[mysqldump不是内部命令或外部命令，也不是可执行的命令需转到对应的.exe的文件的目录下才能执行；譬如我把mysql装在了c盘，就到c:\mysql\bin下才能运行。 通过CMD命令行切换到mysql安装文件夹里的bin目录（该path可通过“我的电脑—管理—服务—MySQL—可执行文件的路径”中查找），然后在CMD命令中输入如下代码 cd C:\Program Files\MySQL\MySQL Server 5.7\bin\ 更改MySQL数据库存储路径1# 打开MySQL默认的安装文件夹C:\Program Files\MySQL\MySQL Server 5.1中的my.ini文件，点击记事本顶部的“编辑”，“查找”，找到datadir="C:/Documents and Settings/All Users/Application Data/MySQL/MySQL Server 5.1/Data/"即是默认的数据库存储主路径设置，现将它改到C:\mysql\data（你希望的）文件夹，正确的设置是datadir="C:/mysql/data/" 。 【引号+反斜杠，最后还有一个斜杠，并且文件夹必须是英文】，保存 将老的数据库W存储主路径中的数据库文件和文件夹复制到新的存储主路径 ​ 将C:/Documents and Settings/All Users/Application Data/MySQL/MySQL Server 5.1/Data/文件夹中的所有文件和文件夹拷贝到你新建的文件夹目录下。 重启MySQL服务；电脑-管理-服务-MySQL-重新启动 验证更改数据库存储主路径的操作是否成功 打开Mysql 输入Show variables like &#39;%datadir%&#39;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL梳理_结构与关联]]></title>
      <url>%2F2017%2F02%2F19%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FMySQL%2FMySQL_%E7%BB%93%E6%9E%84%E4%B8%8E%E5%85%B3%E8%81%94%2F</url>
      <content type="text"><![CDATA[1. 数据库设计1.1 外键 What：表中的某一列；但该列是引用到另一个表的主键列 Why ：用于确定一张表中的行与另一张表中的行相对应的值 How ：创建外键 1234567891011121314151617（1）创建带有外键的表CREATE TABLE intersts( int_id INT NOT NULL ATUO_INCREMENT PARIMARY KEY, interests VARCHAR(50) NOT NULL, cont_id INT NOT NULL, # 新建的列名 CONSTRAINT my_contacts_fk # 约束名_fk为父表中的列 FOREIGN KEY (cont_id) # 指定外键 REFREENCE my_contacts (contact_id) # 引用外键的 父表名 (列名) ON DELETE casecade ON UPDATEA casecade # 设参数casecade跟随父键改动);---（2）在已有表中建立外键ALTER TABLE interestsADD CONSTRAINT 约束名_fkFOREIGN KEY (外键名)REFERENCE 父表名 （列名） 1.2 联接表 What：储存两个相关表的主键的表 How : 用Select来创建 1234CREATE TABLE link AS SELECT var FROM table_name GROUP BY var ORDER BY var; 2. 联接2.1 内联接 What：通过查询的条件，移除某些结果数据行后的交叉联接； 2.1.1 交叉联接CROSS JOIN What：返回两张表每一行相乘的所有结果 可用逗号（，）来表示 12SELECT * FROM table1 , table2 WHERE table1.name = 'xiaoming'; 2.1.2 自然联接NATURAL JOIN What：自然识别出表中相同名称的列，并返回符合记录的值； 2.1.3 相等联接INNER JOIN…ON… What：利用条件判断中的比较运算符结合两张表，只有符合记录的值才会返回； 123SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id WHERE table1.name = 'xiaoming'; 2.1.4 自联接 What：同一张表引用两次 12SELECT c1.name, c2.name AS boss FROM clown AS c1 INNER JOIN clown AS c2 ON c1.boss_id = c2.id; 2.2 外联接 What：返回某张表所有行 + 带有另一张表的条件相符的行 一定会提供数据行，若出现NULL则表示未发现匹配的行 顺序很重要 2.2.1 左外联接 What：以左表为基准，右表与之匹配 123SELECT g.girl, t.toy FROM girls AS g # girls为左表，即基准表 LEFT OUTER JOIN toys AS t # toys为右表，去匹配左表的值 ON g.toy_id = t.toy_id; 2.2.2 右外联接123SELECT g.girl, t.toy FROM girls AS g # girls为左表，去匹配右表的值 RIGHT OUTER JOIN toys AS t # toys为右表，即基准表 ON g.toy_id = t.toy_id; 3. 联合 What：将多个行合并都一张表中，并自动清除重复值 Why ：可以把从不同表中查询的内容，放到同一个表中 How：注意内容 每个select语句中列的数量、列的类型、统计函数必须相同 只接受一个ORDER BY语句，且位于最后 若使用UNION ALL则返回未清除重复值的所有行 123456SELECT title FROM job_currentUNIONSELECT title FROM job_desiredUNIONSELECT title FROM job_listingsORDER BY title; 4. 子查询4.1 内查询12SELECT name FROM job_current WHERE jc.title NOT IN (SELECT title FROM job_listings); IN 可以替换为其他符号；=, !=, &gt;, &gt;= 4.2 外查询 What：子查询在第一个SELECT语句中，表示某个欲选取的列； 1SELECT name, (SELECT state FROM zip_code WHERE mc.zip_code = zip_code) FROM my_contact AS mc; 5. 子查询 VS. 联接 联接比子查询更有效率，并且子查询只能返回当前表中的变量 12345查询“张旭“教师任课的学生成绩；对应教师表(teacher)，课程表(course)，成绩表(socre)---# 子查询SELECT DEGREE FROM score # WHERE CNO = (SELECT CNO FROM course WHERE TNO = (SELECT TNO FROM teacher WHERE TNAME = '张旭')); 【联接，并可返回不同表中的变量】 SELECT score.degree, teacher.tname FROM score ...12345678910# 联接 SELECT score.DEGREE FROM course # 自然联接 NATURAL JOIN score NATURAL JOIN teacher WHERE teacher.TNAME = '张旭'; --SELECT score.DEGREE FROM score,course,teacher # 交叉联接 WHERE course.CNO = score.CNO AND course.TNO = teacher.TNO AND teacher.TNAME = '张旭'; 当使用统计函数时，子查询更有效率 12345查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序SELECT * FROM score WHERE CNO = '3-105' AND DEGREE &gt; (SELECT MIN(DEGREE) FROM score WHERE CNO = '3-245') ORDER BY DEGREE DESC; 6.#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[统计学_基本概念]]></title>
      <url>%2F2017%2F02%2F19%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F10_%E7%BB%9F%E8%AE%A1%E5%AD%A6%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[1. 基本概念1.1 方差Varience what ： 各值与均值距离的平方和除以(n-1)； $s^2=\frac{\sum(X-u)^2}{(n-1)}$ why ： 说明数据的离散程度 1.2 贝叶斯定律Baye’s Rule what ： P(B|A)=P(A∩B)/P(A) why ： 将一个未知的条件概率转化为一个已知的条件概率 1.3 置信系数Confidence Coefficient what ： （1-α） why ： 一个随机选取的置信区间，它包含了所有总体参数的概率 置信区间CI：置信系数的百分比表达形式 how : 根据置信系数（1-α）来确定置信区间CI; 当（1-α）=0.90, α=0.1, α/2=0.05,表示对于分布右尾处面积为0.05是置信区间之外的面积； 求当[0,0.45]这一侧的Z值，得出Z=1.645 置信区间右侧 = X + 1.645*（标准差/sqrt(n)) 样本统计量 与 置信区间 what : 样本统计量，根据 误差范围(ME)和置信区间来确定 how : 误差范围 = 置信区间的一半/单侧 ME = α/2处的Z得分 *（标准差/sqrt(n)) 1.4 检验统计量 what ： 一个样本统计量；Ｚ＝（样本均值－给定的ｕ）／（标准差／$\sqrt{(n)}$） why : 利用这个样本统计量在原假设与备择假设之间做出选择。用来检验该拒绝还是接受假设的一个度量值 ​ 1.5 拒绝域 what : 检验统计量可能取值的一个集合；其对应的概率为 α ; 拒绝域可以自己选择；例如，拒绝域：Z&gt;1.645，对应的 α =0.05； why : 当检验统计量的值落入这个集合时，研究者会拒绝原假设而接受备择假设；​ 1.6 显著性水平p值P值是指当原假设为真时，所得到的观察结果或更为极端结果出现的概率，简单讲它是在假设原假设为真时计算出来的一个区间里的概率。（p-value is the probability we get this sample or a more extreme sample under H0） α错误，它是指当原假设为真时我们却拒绝原假设所犯的错误。 即在原假设为真的情况下，观测到某个值的概率为P值；若P值非常小，说明这个事件出现的概率是非常小的。但实际情况却出现了，所以我们拒绝原假设 https://www.zhihu.com/question/21429785 P值就是由原假设为真时推论的样本结果，与实际观察的样本结果相一致的概率。如果P值很小，说明实际观察的样本结果与推论的样本结果相一致的概率很低，在事实面前，这个原假设是否合理就值得怀疑。P值越小，怀疑的可信性越强，证据越充分。 现在假设你接受了一个原假设，然后我们用现有的数据检验这个假设是否正确。 在这个原假设成立的条件下，如果得到现有观测值的概率非常小，我们可以说小概率事件 在一次实验中不可能发生，而现在这个小概率事件发生了。那么说明数据不是来自我们假设的那个分布，从而拒绝原假设。p值就是原假设成立的条件下 得到比现有观测数据更极端的观测值的概率。如果这个p值很小，说明原假设不成立 https://d.cosx.org/d/13605-13605/6 what ：观测到检验统计量至少与原假设相矛盾，从而支持备择假设的概率；p值在[0,1]之间； p值 = P（Z&gt;z）；z为检验统计量；即p值为检验统计量右侧的尾部面积； why ：用于判断是否拒绝原假设而支持备择假设；数值越低，说明否定原假设的证据越充分； 假设检验中，p值与给定的 α值进行比较； 比如说我们经常定的α＝0.05，表明我们容忍有5%的概率出现该总情况。 当p为0.06大于α时，表示出现这种极端情况的概率有6%，但我们有5%的容忍，所以不能拒绝原假设。 当p为0.02小于α时，表示出现这种极端情况的概率为2%，低于可以容忍出现的概率5%，所以拒绝原假设。 当p值落入拒绝域对应的概率 α 中（p &lt; α），则拒绝原假设；【若为双侧检验，则应为p &lt; α/2 ） 从图形上去理解，α为右侧尾部的面积 例如你计算出P值为0.01，那么P值就告诉你，即使你对检验量和总体真实参数的差异宽容到概率为99%的区间，这个检验量还是落在了这个区间以外，因此你就需要怀疑这个总体参数是不是真的你原先设想的那个。 P值就只是方便你判断检验统计量是否落在拒绝域，犯第一类错误的风险是否低于可以接受的标准，α就是预先给自己定下一个标准，这个风险必须少于多少，才能相信这个检验的结果。 1.7 相关系数 what : [-1, 1]之间的值 why ： 用于衡量两个定量变量之间线性关系的强弱；​ 1.8 协方差Covariance what : 一个样本的值的偏离程度，会对另一个样本的值的偏离程度产生多大的影响； why ： 衡量两个变量的总体误差；如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 若协方差为0，表示两者不相关，相互独立； 方差是一种特殊情况，表示两个变量相同；​ 1.9 离差/误差 what : 单个数值与平均值之间的差； $\sum(离差)$=0 why : 离差/误差平方和（SSE)，可以用来反映数据的离散程度； SSE = Sum of Squares for error 1.10 残差 what : 实际观测值 与 模型预测值 之间的差 $\sum(残差)$=0 why : 残差平方和，可以反映拟合直线的好坏；因为它反映了数据的离散程度； 1.11 均值的标准误 What：估计来自同一总体的多个样本所得到的样本均值之间的差异性；MSE = Mean Standard for error Why ：反映的是样本之间的变异性；而标准差反映的是单个样本内的变异性； 1.12 方差-协方差矩阵 What：计算不同变量之间协方差的一个对称矩阵； Why ：可以导出一个变换矩阵，这个矩阵能够使数据完全去相关化；也就是说，可以找出一组最佳的基于紧凑的方式来表达一组数据；在主成分分析中有很大的应用； 1.13 偏态与峰度偏态：Skewness What：指非对称分布的偏斜状态;指统计总体当中的变量值分别落在众数左右两边，呈非对称性分布。 Why ：衡量随机变量概率分布的不对称性。 How ： 偏态为负（负偏态/左偏态），说明概率密度函数左侧的尾部比右侧的长，绝大多数的值（包括中位数在内）位于均值的右侧。 偏态为正（正偏态/右偏态），说明概率密度函数右侧的尾部比左侧的长，绝大多数的值（但不一定包括中位数）位于均值的左侧； 偏态为零，表示数值均匀地分布在平均值的两侧，但并不一定意味着就是对称分布； 若分布对阵，平均值=中位数，偏度为零；（若为单峰分布，平均值=中位数=众数） 峰度 What：数据呈现的一种形状； Why ：表示分布的波峰与尾部**相对于正态分布的区别**； How ： 峰度值为正，说明相比于正态分布，该分布具有更重的尾部和更陡的峰值，即中间更窄且高； 峰度为负，说明相比于正态分布，该分布具有更轻的尾部和更平缓的峰值，即中间更宽且低； 2017/2/8 标准误差 （各样本的均值）的标准差 标准误差（英文：Standard Error），也称标准误，即样本统计量的标准差（英文：Standard Deviation），是描述对应的样本统计量抽样分布的离散程度及衡量对应样本统计量抽样误差大小的尺度[1]。（读者注意：Standard Error是样本统计量的Standard Deviation，而不是样本的Standard Deviation，此处作者英文引用的位置不恰当。） 概述标准误差针对样本统计量而言，是某个样本统计量的标准差。当谈及标准误差时，一般须指明对应的样本统计量才有意义。以下以样本均值（样本均值是一种样本统计量）作为例子： 例如， 样本均值是总体均值的无偏估计。但是，来自同一总量的不同样本可能有不同的均值。 于是，假设可以从总体中随机选取无限的大小相同的样本，那每个样本都可以有一个样本均值。依此法可以到一个由无限多样本均值组成的总体，该总体的标准差即为标准误差。 在很多实际应用中，标准差的真正值通常是未知的。因此，标准误这个术语通常运用于代表这一未知量的估计。在这些情况下，需要清楚业已完成的和尝试去解决的标准误差仅仅可能是一个估量。然而，这通行上不太可能：人们可能往往采取更好的估量方法，而避免使用标准误，例如采用最大似然或更形式化的方法去测定信赖区间。第一个众所周知的方法是在适当条件下可以采用学生t-分布为一个估量平均值提供置信区间。在其他情况下，标准差可以有效地利用于提供一个不确定性空间的示值，但其正式或半正式使用是提供置信区间或测试，并要求样本总量必须足够大。其总量大小取决于具体的数量分析[2]。 平均值标准误差“样本均值的估计标准误差”，简称平均值标准误差（standard error of the mean, SEM），或平均数标准误差。必须记得在简称的背后总是意指“样本的”。 如果已知母体的标准差(σ)，那么抽取无限多份大小为 n 的样本，每个样本各有一个平均值，*所有这个大小的样本之平均值*的标准差可证明为（注意！不是一份样本里观察值的标准差（那是下面公式里的））： 但由于通常σ为未知，此时可以用研究中取得样本的标准差 (S) 来估计(https://wikimedia.org/api/rest_v1/media/math/render/svg/bef6d7a33e7d36b1d1734ef70e11c91f5f5ac13d)： 其中，S为样本的标准差，n为样本数量（大小）。 名词比较： 注意： 标准误差也可定义为残差的标准差[3][4]。 无论是标准误差还是小型样本的标准差，都往往低估了母体的标准误差和标准差：平均数的标准误差是总量标准误差的一个有偏估计量。当样本总量 n = 2时，低估率大概为25% ；但 n=6 时，低估率只有5%。基于此，古尔兰（Gurland）和特里帕蒂（Tripathi）对此公式作了改进努力[5]。 统计量 统计量是基于样本的，而非基于所有数据 统计量 或 抽样统计量 是样本)测量的一种属性（例如，计算样本算术平均值）。 它计算的通过对数据集进行某种函数（统计算法）的运算后得到的值。 统计学定义一个统计量为一个总体参数的点估计量。统计量的函数本身可以用于计算全体数据，而统计量则将抽取的样本作用于这一函数。统计量不同于统计参数。统计参数通常由于数量过大而不便于统计计算。而统计量仅仅统计抽出来的样本。统计量可以用于对统计参数进行估计。 例如，在计算样本的算术平均值时，算法会先将所有数据的值累加，然后除以样本数。 如果我们计算的是样本的平均值，我们就可以称其为统计量；这个值用于估计整体数据的平均值。 算数平均值本身之所以不能被叫做统计量因为其计算了全部数据而不仅仅是样本。 极大似然估计 what：就是利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。 why ： How ：求样本所有观测的联合概率最大化，是个连乘积，只要取对数，就变成了线性加总。此时通过对参数求导数，并令一阶导数为零，就可以通过解方程（组），得到最大似然估计值。 例如：一个麻袋里有白球与黑球，但是我不知道它们之间的比例，那我就有放回的抽取10次，结果我发现我抽到了8次黑球2次白球，我要求最有可能的黑白球之间的比例时，就采取最大似然估计法： 我假设我抽到黑球的概率为p,那得出8次黑球2次白球这个结果的概率为： $$p(黑=8) = p ^8 (1-p)^{(10-8)}$$现在我想要得出p是多少啊，很简单，*使得P(黑=8)最大的p就是我要求的结果，接下来求导的的过程就是求极值的过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[统计学_分析方法]]></title>
      <url>%2F2017%2F02%2F19%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F10_%E7%BB%9F%E8%AE%A1%E5%AD%A6%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6_%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1. 相关性 What：显示两个随机变量之间线性关系的强度和方向； Pearson相关系数 Spearman相关系数：衡量两个有序尺度变数的相关性； Kendall等级相关系数：衡量两个人为认定的有序尺度变数的相关性 Kappa一致性系数：衡量两个类别尺度变数的相关性； Why ：用来衡量两个变量相对于其相互独立的距离； 1.1 相关系数R - cor() cor(data, use=&quot;everything&quot;, method=&quot;pearson&quot;) use,表示对缺失值的处理方式， everything - 结果为missing all.obs - 报错 complete.obs - 行删除 pairwise.complete.obs - 成对删除 method = “spearman” / “kendall” 组与组之间的相关系数 123x &lt;- data[, c("var1","var2")]y &lt;- data[, c("var3","var4","var5")]cor(x,y) 1.2 协方差R - cov() cov(data) 1.3 偏相关 What：控制一个或多个变量时，另外两个定量变量之间的相互关系 Why ：控制其他变量，单独研究某两个变量之间的关系 R - ggm包 - pcor() pcor(data[,c(1,5,2,3,4)], cov(states)) u，一个数值向，前两个数值表示要研究的两个变量，其余的数值表示要排除影响的条件变量 S 对应的协方差矩阵，同时也表明了对应的数据 pcor(u, S) 2. 均值的假设检验2.1 t 检验 What： 一种用于小样本（样本容量&lt;30）的两个平均值差异程度的检验方法； Why ： 通过 t 理论来推断差异发生的概率，从而判断两个平均数的差异是否显著（μ~1~ - μ~2~= 0）； How ： 适用条件 正态分布（常用于标准差σ未知） 样本独立随机 2.1.1 单样本 t 检验 Why1 ： 用于比较 抽样样本所代表的未知的总体均值μ 与 已知的总体均值μ~0~ 或 指定值的差异程度； Why2 ： 用于计算 可能的总体均值的范围（估计置信区间）； R 语言 -t.test(y, [conf.levle=0.95]) Excel - 描述统计量 - 根据（ 均值 ± 置信度 ）来确定 2.1.2 双样本 t 检验 What ：针对两个独立的样本； Why1 ： 确定两个独立组的均值是否存在差异（μ~1~ - μ~2~= 0）； Why2 ： 计算两个总体均值之间的差值的范围； R - t.test(x1, x2, alternative=&quot;two.side&quot;, var.euqal=F) alternative 可选 less; greater; var.equal = F 默认两方差不相等； var.equal = T ，等方差 t 检验 2.1.3 双样本配对 t 检验 What：针对两个不独立的样本 Why1 ： 确定两个配对样本之差的均值不等于0（或目标值）（μ~1~ - μ~2~= 0）； Why2 ： 计算可能包含差异总体均值的范围； R - t.test(x1, x2, alternative=&quot;&quot;, paired=T , var.equal = F) x1, x2 为已经分组的两个数值型向量 t.test(x~y, data= ) x为一个数值型变量，y为一个二分变量(分组变量)；即此时数据框的格式为长格式，所有的数据y在一列中 paired = T ,表示配对； 默认为F Excel - t检验：平均值的成对二样本分析 2.2. z 检验 What： 一种用于大样本的两个平均值差异程度的检验方法； Why ： 通过 Z 理论来推断差异发生的概率，从而判断两个平均数的差异是否显著（μ~1~ - μ~2~= 0）； How ： 适用条件 - 正态分发（常用于标准差σ未知） 3. F 检验 What：方差齐性检验；通过比较两个数据的方差，来确定它们的精密度是否有差异性检验； Why ：检查两个样本的方差是否有显著差异；通过F检验来确定选择何种 t 检验（等方差双样本、异方差双样本）以及确定方差检验ANOVA条件中的等方差性 5. 方差分析 What：基于使用方差来确定均值是否存在误差的一种方式；ANOVA 通过将 组均值之间的方差（SST） 与 组内方差（SSE） 进行比较来确定这些组都是一个更大总体的一部分还是分属具有不同特征的单独总体； 组间因子：一个自变量，把每个观测值分配到对应的一个组别中，一个观测值只能属于一个组别；常称为单因素方差分析；例如：把治疗方案分为方案1，方案2，把每个观测值随机抽取放到方案中； 组内因子：一个自变量，不对观测值进行划分，而对所有观测值重复测量不同水平下的情况；常称为重复测量方差分析或组内方差分析；例如，把时间分为1个月，3个月，所有的观测值都要观察这两个时间维度下的情况； SST ：组间均值之间的差异性；对每个组的均值与所有样本观测值的总体均值之间距离的平方，乘以该组内观观测值的数量，最后把所在的结果加总；Sum of Squares for Treatments; SSE ：组内均值之间的差异性；对每个响应观测值和自身所处组的均值之间距离的平方进行加总，然后对所有观测值的奖惩的平方求和；Sum of Squares for error; Why ：检验两个或多个总体均值相等的这一假设；通过比较不同因子水平下的响应变量均值来评估一个或多个因子的重要性； 因子水平：指的是不同的自变量； 例如，球杆（一个因子水平），球（一个因子水平），击球人（一个因子水平） 因子水平可以有不同的取值；球杆（木球杆，铁球杆） How ：试验条件 样本独立随机 近似正态分布（稍有偏离也并不影响F检验的结果） 等方差性（敏感） 方差分析类型 模型和设计属性 单因子 一个固定因子（由调查员设置水平），每个处理可具有不等（不平衡）或相等（平衡）的观测值数。 平衡 模型可包含任意数量的固定和随机因子（水平是随机选择的），以及交叉和嵌套因子，但要求平衡设计。 一般线性模型 通过允许不平衡设计和协变量（连续变量）来扩展平衡方差分析。 5.1 单因素方差分析 What：针对只有一个因变量的方差分析，并且观测值被分到不同的组别中的设计实验；该变量因子也称为组间因子； R - aov() fit &lt;- aov(y~x) y为数值型因变量，x为类别型组间因子，且必须为因子格式 data$var &lt;- factor(data$var) summary(fit) Excel - 方差分析-单因素方差分析 分组方式： 行/列； 即 组间因子 标志：指的是自变量 5.2 随机区组方差分析 What：引入区组均值 区组均值：区组中的平均值 SSB：每个区组均值 与 所有样本观测值的总体均值 之间的差异的平方求，再乘以每个区组内观测值的个数，最后加总； Sum of Squares for Blocks； Why ：减少每个区组内试验单元的抽样变异性，降低误差值； 5.3 双因素方差分析 What：有两个自变量，观测值被分配到两个变量的交叉类别组中的方差分析；例如自变量A有a个水平，自变量B个b个水平，存在一个ab个可能的处理； 主效应：判断各因素对因变量的影响； 交互效应：判断因素的组合对因变量的影响； How ： 分析 若拒绝原假设，得出两个均值不同的结论； 查看交互效应 2.1 若拒绝交互效应的原假设，得出两个变量之间有交互影响； ​ 2.2.1 比较组间均值的配对 2.2 若无法拒绝，说明两个变量之间没有交互影响； ​ 2.2.1 分别查看变量A 、变量B 单独对因变量的影响， ​ 2.2.2 使用多重比较来比较均值的配对，得出哪个变量对均值的影响大 R - aov() fit &lt;- aov(y ~ x1*x2, data= ) y为因变量，x1,x2 均需为因子，故x1,x2 都被当做 组间因子来对待factor(x1)，而非协变量； summary(fit) Excel - 方差分析：无重复双因素方差分析 5.4 双因素重复测量方差分析 What：观测值不是被分配到不同的组中，而是针对同一个自变量的多个不同水平重复测量；常为一个 组间因子 + 一个组内因子 的设计试验； R - aov() fit &lt;- aov(y~x1*x2+ Error(对象列/x2), data= ) Error(Subject/x2) 表示x2为组内因子; 对象列，表示用以代表重复的标记列 summary(fit) R处理重复测量时，需先将数据格式转为长格式； library(reshape) melt(data,id=”var1”, measure=”var2,var3”) id用于确定基准列，measure用于确定哪些变量组合进id列，若缺失则代表所有变量 Excel - 方差分析：重复双因素方差分析 每一样本的行数：表示重复测量值所在的行数（若为3，表示第4行为其他区组的观测值） 5.5 稳健的方差分析 Why ：当方差分析的前提假设无法满足时，或者担心过多的离群点，可以用稳健或非参数的MANOVA检验 R - 5.x 均值的多重比较 Why ：在发现均值不等的前提下，得出各个均值的排序大小； R - rrcov包 - Wilks.test() 得出各组均值的大小 - 可视化（gplots包）- plotmeans() 123&gt; library(gplots)&gt; plotmeans(y~x)&gt; &gt; 得出各组均值的大小 + 两组均值差异的显著情况 Tukey HSD成对检验 TukeyHSD()12345&gt; TukeyHSD(fit) #观察p值，若p&lt;0.05，说明这两个组均值之间存在差异&gt; par(las=2) #横纵坐标轴转换&gt; par(mar=c(5,8,4,2)) #增加左侧的边界&gt; plot(TukeyHSD(fit)) #可视化&gt; 可视化(multcomp包) 123456789&gt; library(multcomp)&gt; par(mar=c(5,4,6,2)) #默认为(5,4,4,2) 增大顶部边界面具&gt; tuk &lt;- glht(fit, linfct = mcp(trt='Tukey')) #trt，组间因子&gt; plot(cld(tuk, level=0.05), col="lightgrey")&gt;&gt; 图形解读：&gt; 2. 各均值大小的分布图&gt; 2. 有相同的字母，说明均值差异不显著&gt; &gt; 6. 确定统计量 7. 回归分析 Regression Analysis What：一个建立自变量与因变量之间的关系模型；一个或多个自变量来预测因变量的方法； Why ： 描述两者相关性，它们相关的强度与方向； 挑选与因变量相关的自变量 生成一个等式，用来预测因变量 How ：一般形式为 y = f(x,ε)，结果解释 Intercept：截距 Estimate/Cofficients：系数 St.Error标准误：抽样分布的标准误差，说明抽样的离散情况； p值：回归分析会进行统计检验以针对每个自变量的关联系数计算出一个称为 p 的概率值；零假设为：系数与零之间无显著差异（在所有情况下，该系数均为零，因此，关联的解释变量对于模型不起任何作用） 决定系数$R^2$或 Adj $R^2$：给出了模型对于原数据的解释程度；越接近1，说明模型拟合越好； Adj $R^2$，调整的多元判定系数，不会因为变量数目的增加而趋向于1；在多元分析中，若使用$R^2$必须确保样本变量数量 &gt; 模型参数个数；并且$R^2$会随着模型个数的增加而增加，也就是说即使模型对预测y不能提供任何作用，也能迫使$R^2$增加到1； Residual残差：表示模型无法解释的部分（指的是实际值与模型预测值的差），表示为随机误差项；可以用于确定模型的拟合程度；残差越小，说明拟合越好； 回归方程 自变量 因变量 简单线性回归 一个（定量） 一个（定量） 多项式回归 一个（定量），n阶 一个（定量） 多元线性回归 两个及以上（定量） 一个（定量） Logistic回归 一个或多个 一个（二值型类别） 7.1 简单线性回归 What：一个量化的自变量预测一个量化的因变量； Why ：判断两个变量之间相关的强度和方向； ​ R - lm() 123456fit &lt;- lm(y~x, data=) #formula y ~ x1+x2+...x4summary(fit) fitted(fit) #fitted() 返回拟合模型的预测值residuals(fit) # 返回残差值（即 实际值 - 模型预测值）plot(data$x, data$y)abline(fit) #模型可视化 Excel - 回归 7.2 多项式回归 What：一个量化的自变量解释一个量化的因变量，模块的观察是n阶多项式 R - lm() 1234fit &lt;- lm(y ~ x + I(x^2), data= ) I()，表示以算术的角度来解释括号中的元素summary(fit) #查看是否有不显著的变量(p&gt;0.05)plot(data$x, data$y) lines(x, fitted(fit)) #fitted() 返回拟合模型的预测值 7.3 多元线性回归 What：两个或多个量化的自变量预测一个量化的因变量；当自变量个数大于等于2个； How ：结果解释 回归系数的含义为：当一个自变量增加一个单位，其他自变量保持不变时，因变量增加的数量； R - lm() 12fit &lt;- lm(y ~ x1 +x2 + x3 + ..., data= )summary(fit) 7.4 有交互项的多元线性回归7.5 Logistic回归 What：一个或多个自变量来预测一个二值型类别因变量； R - glm() 1234567data$var &lt;- with(data,&#123;ifelse(var &gt; n, 1,0)&#125;) #赋值二分法data$var &lt;- factor(data$var) 因子化fit &lt;- glm(y ~ ., family=binomial, data= ) # ~. 表示除因变量之外的所有变量； bionmial，表示逻辑回归summary(fit) #查看是否有不显著的变量(p&gt;0.05)fit.reduced &lt;- setp(fit) #采用逐步逻辑回归生成一个包含更少自变量的模型；目的是通过增加或移除变量来得到一个更新的AIC值coef(fit.reduced) #查看回归系数，含义是当其他自变量不变时，一单位自变量的变化引起的因变量的对数优势比的变量exp(coef(fit.reduced)) # 将回归系数指数化，自变量增加n个单位，变为引起因变量的指数比的变化为 x^n ； 若n=1，则直接乘以x 9. 多种条件假设检验9.1 独立性检验 常规情况下可通过经验来判断各个变量是否独立；例如，我们没有理由去相信，一位女性的体重会影响我们选取的下一位女性的体重； Durbin-Watson检验 What：通过确定两个相邻误差项的相关性是否为零，来检验回归残差是否存在自相关； Why ：可以检测误差的序列相关性； How ：该检验适用于时间独立的数据 滞后项（lag=1），表示数据集中的每个数据都是与后一个数据进行比较的 p值，若p值&gt;0.05，说明不拒绝假设；即说明两者之间相关性为0，即独立； R - durbinWatsonTest - car包 1durbinWatsonTest(fit) 9.2 正态性检验 What：当自变量固定时，因变量呈正态分布；所以，残差值也应该是一个均值为0的正态分布； 正态Q-Q图：在正态分布对应的值下，显示标准化残差的概率图； 样本分位数(Sample Quantiles)-纵轴；理论分位数(Theoretical Quantiles)-横轴 How ：若满足正态性假设，标准化残差的概率点应该落在呈45度角的直线上； R - plot() 1plot(fit) #观察正态Q-Q图 R - qqPlot() - car包 123qqPlot(fit, labels=row.names(states), id.method="identify", simulate=T, main="Q-Q plot") id.method="identify"，表示能够交互式绘图 simulate=T, 表示95%的置信区间用参数自助法生成 纵坐标为学生化残差值； rstudent(fit)[“Nevada”] 特定行的学生化残差值 9.3 方差齐性检验R - bartlett.test() 12&gt; bartlett.test(y ~ x , data= ) # 若p&lt;0.05，说明变量方差之间有差异，不满足方差齐性；&gt; &gt; R - plot() 12&gt; plot(fit) #观察位置尺度图（预测值vs√标准化残差 图）&gt; &gt; 若水平线周围的点是随机分布的，则说明方差相等； R - nevTest() - car包 123&gt; nevTest(fit) &gt; spreadLevelPlot(fit)&gt; &gt; 观察p值，若p&gt;0.05，说明接受原假设，即方差是相等的； 观察图形，若点在水平的最佳拟合曲线周围呈水平随机分布，说明方差是相等的； 9.4 线性检验R - plot() plot(fit) 观察 预测值vs残差图； 若两者之间没有任何关联，则说明是自变量与因变量是线性的； 因当自变量与因变量线性相关，则残差值（实际值-模型预测值）与模型预测的值就没有任何关系； R - crPlots() - car包 crPlots(fit) 得出成分残差图； 若两条线很接近，说明数据是线性的； 9.1-9.4 线性模型的综合检验 R - gvlma() - gvlma包 123&gt; gvlma(fit)&gt; summary(gvlma(fit))&gt; &gt; 观察p值，若p&gt;0.05，说明是满足假设的； Skewness偏度：对应正态性 Kurtosis峰态： Link Function线性； Heteroscedasticity异方差性； 9.5 异常值9.5.1 离群点 What：地域预测模型效果不佳的点，它们通常有很大的正或负的残差； Why ：正的残差（观测值-预测值）说明模型低估了因变量； How1：一种简单的判别方法是，标准化残差值大于2或小于-2的点可能是离群点。 How2：Q-Q图中落在置信区间带外部的点； R - outlierTest() - car包 123&gt; outlierTest(fit) #fit为拟合后的对象 &gt; 若p&lt;0.05，说明有离群点；当p&gt;1时，将产生NA；&gt; &gt; 该函数只判断单个最大（正或负）残差值的显著性来判断是否有离群点； 若不显著，说明没有离群点； 若显著，必须要删除离群点，然后再检验是否有离群点； 9.5.2 高杠杆值点 What：与其他自变量有关的离群点；它们是有许多异常的预测变量值组合起来的，但是与因变量没有关系； How ：可以通过帽子统计量（hat statistic）来判断； 9.5.3 强影响点 What：对模型参数估计值影响比较大的的点；例如，若移除一个观测点，会对模型产生很大的影响； How1：Cook距离/D统计量； How2：变量添加图 9.6 相关性检验 Why ：得出相关系数后，对其进行显著性检验，H~0~ ：变量间不相关，相关系数=0 两变量 cor(x,y, alternative=&quot;two.side&quot;, method=&quot;pearson&quot;) less/greater; pearson/spearman/kenall; 每一次只能检验一种相关系数 多变量两两检验 123library(psych) #加载psych包corr.test(table, use="", method="") use="complete","pairwise" #针对缺失值的处理，行删除/成对删除 偏相关检验 123library(ggm) #加载ggm包pcor.test(r, q_num, n_num)# r，pcor得到的相关系数； q_num，要控制的变量数（以数值表示位置）； n，样本大小； 10. 多种模型评判10.1 多重共线性 What：自变量之间存在一定的相关性； Why ：会导致模型参数的置信区间过大，使单个系数解释起来困难； How ：用方差膨胀因子VIF(Variance Inflation Factor)进行检测；$\sqrt {VIF}$ 表示变量回归参数的置信区间能膨胀为与模型无关的预测变量的程度。 ​ R - vif() - car包 123&gt; &gt; vif(fit)&gt; &gt; sqrt(vif(fit))&gt; &gt; &gt; 若$\sqrt {vif}$ &gt; 2，表明存在多重共线性问题； 12. 时间序列 What：数据随着时间的变化反复测量变量值； Why ：1.对数据的描述（这段时间发生了什么？）；2.对数据的预测（接下来会发生什么？） 生成时序对象 R - ts() 123456&gt; &gt; tsales &lt;- ts(scale, start=c(2003,1), frequency=12) #生成时序对象&gt; &gt; tsales&gt; &gt; plot(tsales)&gt; &gt; start(tsales)/ end(tsales) / frequency(tsalse) #可通过这三个函数查看性质&gt; &gt; tsales.subset &lt;- window(tsales, start=c(2003,5), end=c(2004,6)) # 取子集&gt; &gt; &gt; ts(data, start=, end=, frequency= ) start/end=可以是一个数值a，或一个含两个整数的向量c(a,b) frequency= 1-数据对应年度数据；4-数据对应季度数据；12-数据对应月度数据； 12.1 简单移动平均 Why ：对数据进行平滑处理，移除那些波动，从而探究总体趋势； 居中移动平均 What：每个数据用这一点和其前后两个点的平均值来表示；它的代价是会损失最后(k-1)/2个观测值； $$S_t = (Y_{t-q}+...+Y_t+Y_{t+q})/(2q+1)$$ $S_t$是时间点t的平滑值； k=2q+1，每次用来平均的观测值的个数，一般设置一个奇数； R - ma() - forecast包 12345678&gt; &gt; opar &lt;- par(no.readonly=T)&gt; &gt; par(mfrow=c(2,2))&gt; &gt; ylim &lt;- c(min(Nile), max(Nile))&gt; &gt; plot(Nile)&gt; &gt; plot(ma(Nile, 3))&gt; &gt; plot(ma(Nile, 7))&gt; &gt; plot(ma(Nile, 15))&gt; &gt; &gt; ma(data, k) 随着k的增加，图像会越来越平滑；我们需要尝试多个k值，再决定一个最好的k值； 12.2 季节性分解 What：对于间隔大于1的时序数据（季度数据、月度数据），会存在季节性情况；可以被分解为趋势因子、季节性因子、随机因子； 趋势因子（Tread Component）：能捕捉到长期变化 季节性因子（Seasonal Component）：捕捉到一年内的周期性变化 随机误差因子（irregular/error Component）：捕捉那些不能被趋势和季节性效应解释的变化； Why ：观察数据的季节性波动 + 总体趋势； How ：通过相加 或 相乘 来分解数据 相加模型：$Y_t = Trend + Seasonal + Irregular$ 相乘模型：$Y_t = Trend $ $\times$ $Seasonal $ $\times$ $Irregular$ ;相乘模型以比例的形式来呈现，很多时候效果更好； R - stl() 12&gt; &gt; stl()&gt; &gt; &gt; 12.3 指数预测模型12.3.1 单指数平滑 What：根据现有的时序值的加权平均对未来值做短期预测；权数选择的标准是使得距离现在越远的观测值对现在的影响越小； 阻尼$\alpha$：控制权数下降的速度；$\alpha$越接近1，表明近期观测值的权重越大；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL梳理_基本语法]]></title>
      <url>%2F2017%2F02%2F19%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%2FSQL%2FMySQL%2FMySQL_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1. 数据库1.1 创建123456CREATE DATABASE gregs_list;USE gregs_list;CREATE TABLE my_contact;CREATE VIEW view_c; 1.2 删除123DROP DATABASE gregs_list;DROP TABLE my_contacts;DROP VIEW view_c 1.3 展示123SHOW DATABASE; # 显示所有数据库SHOW TABLES; # 显示当前数据库所有的表SHOW TABLES FROM geregs_list; # 显示该数据库中的所有表 1.4 创建过程1SHOW CREATE TALBE my_contacts; 展示表的结构 DESC my_contacts 2. 表的基本操作2.1 创建2.1.1 直接创建12345678910CREATE TABLE my_contacts( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY # 非NULL,自动填充数字，并设为主键 name VARCHAR(10), # VARCHAR 可变动字符串，长度最大为10，若有abc，则只占用3个字符 sex CHAR(2)， # CHAR,固定字符串，长度为2；若只有a，则另一个用空格来表示 age INT, birthday DATA, # DATA,日期 pirce1 DEC(3,2), # Decimal数字，数字共3位，其中2为位是小数点后的 price2 DEC(3,2) DEFAULT 1.00, # DEFAULT 默认的格式 interests BOLG, # BOLG 大文本); 其他文本属性 12345678其他PRIMARY KEY (id) # 创建主键UNIQUE # 唯一值时间格式TIME # 时间DATETIME # 日期与时间TIMESTAMP # 当下时刻 2.1.2 AS SELECT 创建12CREATE TABLE table AS SELECT col_name FROM table GROUP BY col_name ORDER BY col_name; # 直接复制原表单的格式 2.2 新增2.2.1 值INSERT INTO 插入123456INSERT INTO my_contacts(name,sex)VALUES(&quot;小明&quot;,&quot;男&quot;), # 用逗号分隔(&quot;小红&quot;,&quot;女&quot;), (); 2.2.2 列(值)ADD COLUMN1ALTER TABLE my_contacts ADD COLUMN name VARCHAR(30); # 新增列 UPDATE…SET… 直接新增1UPDATE TABLE my_contacts SET interset1 = LEFT(interset,4); SELECT 多表返回1SELECT mc.*, projcet.color FROM mc CROSS JOIN projcet; # 返回原表格所有的值 + 其他表单中的列值 1SELECT mc.*, &apos;100&apos; AS c FROM mc; # 插入固定值为100的列，并命名为c； 2.3 删除2.3.1 删除行123DELETE FROM my_contacts; # 删除所有行DELETE FROM my_contacts WHERE age = 30 AND/OR sex=&quot;男&quot;; # 删除特定行 2.3.2 删除列1ALTER TABLE my_contacts DROP COLUMN name; 2.4 格式2.4.1 结构展示1DESC my_contacts; 2.4.2 改变表的名称1ALTER TABLE my_contacts RENAME TO new; 2.4.3 改变列的格式CHANGE 改变列的 名称、格式 1ALTER TALBE my_contacts CHANGE name new_name VARCHAR(30); # CHANGE 改变列的 名称、格式 MODIFY 改变列的 格式、位置12ALTER TALBE my_contacts MODIFY name VARCHAR(30) BEFORE id; # MODIFY 改变列的 格式、位置 位置属性可为 BEFOR/AFTER/FIRST/SECOND 2.5 替换UPDATE…SET12UPDATE my_contacts SET price = 3 WHERE projcet = &apos;ball&apos; AND/OR sex = &apos;男&apos;; UPDATE…SET…CASE WHEN…THEN…123456UPDATE my_contacts SET price = CASE WHEN projcet ='ball' THEN 3 WHEN project = 'sing' THEN 5 ELSE '0'END; 3. 查询3.1 单元格属性3.1.1 行数-count()1SELECT COUNT(name) FROM my_contacts; 3.1.2 字符串长度-length()1SELECT LENGTH(name) FROM my_contacts; 3.2 单元格的值3.2.1 左部分 -left()1SELECT LEFT(name,3) FROM my_contacts; 3.2.2 右部分-right()/substr()12SELECT SUBSTR(name,3) FROM my_contacts; # SBUSTR(strings,length_num) 返回移除前3个长度的值之后，余下右侧的值 3.2.3 指定位置的值-substring()12SELECT SUBSTRING(name,1,2) FROM my_contacts; # SUBSTRING(strings,start_num,length_num) 返回从指位置1开始，长度2的值 3.2.4 特定符号之前的值-substring_index()12SELECT SUBSTRING_INDEX(name,&apos;x&apos;,2) FROM my_contacts; # SUBSTRING_INDEX(string,&apos;x&apos;,num) 返回单元格中x第二次出现之前的值 3.2.5 去除空格的值-trim()1SELECT TRIM(name) FROM my_contacts; # TRIM 去除两边的空格； LTRIM/RTRIM 去除左侧/右侧的空格 示例1：提取 Kadet(102)AD, Cide(31)DF 两侧的值 123UPDATE my_contacts SET side = SUBSTRING_INDEX(name,&quot;(&quot;,1) # 返回第一个左括号（之前的值city = SUBSTR(name,LENGTH(SUBSTRING_INDEX(name,&quot;)&quot;,1)+1) #返回第一个右括号）之前的长度，加上右括号的长度 示例2：分列，提取同一列football, sing, reading 中的值 12345UPDATE my_contacts SET interest1 = SUBSTRING_INDEX(interset, &quot;,&quot;, 1) # 返回第一个逗号之前的值 interest = SUBSTR(interest, LENGTH(interest1)+1) # 移除第一个兴趣的字符串 + 逗号 长度的值 interset2 = SUBSTRING_INDEX(interest,&quot;,&quot;, 1) interest3 = SUBSTR(interest, LENGHT(interest2)+1); 3.3 特定条件的值3.3.1 特定范围(含日期)123456SELECT name FROM my_contacts WHERE name &gt;= &quot;L&quot; AND name &lt;&quot;N&quot; ; # 名字开头为L-M的人---SELECT name FROM my_contacts WHERE BETWEEN &quot;L&quot; AND &quot;M&quot;; # 大于等于L，小于等于M 3.3.2 通配符-like12SELECT name FROM my_contacts WHERE [NOT] name LIKE &quot;A%&quot; / &quot;_A%&quot;; # 返回名字以A为开头字母的人/ 第二个字母为A的人 3.3.3 相等&amp;不相等的值小范围 12SELECT name FROM my_contacts WHERE name [NOT] IN LIKE (&quot;A%&quot;,&quot;B%&quot;,&quot;C%&quot;) 两个表之间 查询选修了c02号课程的学生的姓名和所在系，学生表(student)，课程表(sc) 123# 子查询SELECT Sname, Sdept FROM student WHERE Sno IN (SELECT Sno FROM sc WHERE Cno = &apos;C02&apos;); # 可在IN之前加NOT；即 WHERE sno NOT IN ... 1234# 联接SELECT st.Sname, st.Sdept FROM student AS st INNER JOIN sc ON st.Sno = sc.Sno WHERE sc.Cno = &apos;C02&apos;; 两个表之间 - 不相等：not exists 查询所有未讲课的教师的Tname和Depart 12SELECT TNAME,DEPART FROM teacher # 一种常用于外层查询结果不存在于关联表里的方法 WHERE NOT EXISTS (SELECT * FROM course WHERE teacher.TNO = course.TNO); 4. 查询：表格相关4.1 分组、排序分组 GRUOP BY 排序 ORDER BY name, degree DESC, SUM(age) DESC # 默认为升序排序（ASC） 12GROUP BY nameORDER BY name where 用于分组之前 having 用于分组之后 4.2 显示数量-limit()LIMIT LIMIT n1 # 返回前n1行，并且MySQL是从0开始的 LIMIT n1,n2 # 返回从第n1+1行(MySQL从0开始)，之后的n2行 LIMIT n1,n1 # 返回特定行的值 Limit结合排序Order by 往往有不错的效果 5. 数字处理5.1常规统计函数 rand() [0,1]之间的随机值, round(x,[y]) 取整；y为小数位数，y可以为负数, floor(x) 向下取整，小于x的最大整数, ceiling(x) 向上取整 truncate(x,[y]),截断至y指定的小数位数后的值 mod(x,y) x/y的余数 sum(), avg(), sqrt()平方根, exp()指数, ln(x) / log(x,y) 对数, power(x,y) x的y次方, abs() 绝对值, pi() π 6. 数据清洗6.1 缺失值删除缺失值 12DELETE FROM my_contacts WHERE name IS NULL OR sex IS NULL; 6.2 重复值/唯一值返回唯一值：distinct() 1SELECT DISTINCT(name) FROM my_contacts; 7. 日期SELECT NOW(); 返回当前日期与时间 SELECT MONTH(NOW()); 返回当前月份 SELECT YEAR(NOW()); 返回当前年份 计算年龄 1SELECT YEAR(NOW())-YEAR(birthday) AS age FROM my_contacts; 8. 账户与安全]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown使用手册]]></title>
      <url>%2F2017%2F02%2F07%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FMarkdown%2FMarkdown%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[Markdown 使用手册[what] - 一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）.HTML 是一种发布的格式，Markdown 是一种书写的格式。 [why] - 使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。 区块元素（一）段落和换行1. 段落 由一个或多个连续的文本行组成，它的前后要有一个以上的空行； 空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行。 相邻两行文本，如果中间没有空行会显示在一行中（换行符被转换为空格） 2. 换行 如果需要在段落内加入换行（而非换段落）（&lt;br&gt;）,可以在前一行的末尾加入至少两个空格，然后换行写其它的文字 3. 大段落 可加入&lt;br&gt; 普通段落不该用空格或制表符来缩进。 （二）标题支持两种标题的语法： 1. 类atx形式：在行首插入1-6个#，对应到标题的1到6阶；一阶 #二阶 ##三阶 ###四阶 ####五阶 #####六阶 ######2. 类Setext形式:底线形式，利用 =（最高阶标题）和 -（第二阶标题）;一阶 二阶 （三）区块引用 Blockquotes###1. 常规引用：在每行的最前面加上 &gt; &gt;This is a blockquote with two paragraphs.Lorem ipsum dolor sit ame, &gt;consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. This is a blockquote with two paragraphs. Lorem ipsum dolor sit ame, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. 2.嵌套引用：根据层次加上不同数量的 &gt;&gt; This is the first level of quoting. &gt; &gt;&gt; This is nested blockquote. &gt; &gt; Back to the first level. This is the first level of quoting. &gt; This is nested blockquote. Back to the first level. 3. 引用区块中可以使用其他的Markdown语法&gt; ### 这是一个标题 &gt; &gt; 1. 这是第一行列 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 这是一个标题 这是第一行列 给出一些例子代码： return shell_exec(“echo $input | $markdown_script”); （四）列表1. 有序列表：使用数字接着一个英文句点，然后加一个空格或制表符1. Bird 2. McHale 3. Bird McHale ​ 2. 无序列表：使用星号*、加号+或是减号-作为列表标记，后接一个空格* 列表 + 列表 - 列表 - 列表 列表 列表 列表 列表 3. 你在列表标记上使用的数字并不会影响输出的 HTML 结果如果你的列表标记写成：​ 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。 4. 项目标记也可以缩进，最多三个空格 Lorem ipsum dolor sit amet, consectetueradipiscingelit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 5. 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符1. This is a list item with two paragraphs. 1. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 6. 如果要在列表项目内放进引用，那 &gt; 就需要缩进* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. A list item with a blockquote: This is a blockquote inside a list item. 7. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符* 一列表项包含一个列表区块： &lt;代码写在这&gt; 8. 避免项目列表自动出现（数字-句点-空格），可在之前加\1986\. What a great season （五）代码区块程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用&lt;pre和code`标签来把代码区块包起来。 1. 建立方法：缩进 4 个空格或是 1 个制表符这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除； 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾） 2. 代码中的特殊符号在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了​ &copy; 2004 Foo Corporation 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 3. 代码区块中，一般的 Markdown 语法不会被转换，像星号便只是星号4. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符* 一列表项包含一个列表区块： &lt;代码写在这&gt; 5. 代码块：这里使用###1​&lt;p&gt;code here&lt;p&gt; ​12```&lt;p&gt;code here&lt;p&gt; **三个 12345### 6. 代码高亮：在第一组 ``` 之后添加代码的语言 ### ​```sql select * from table ​ 12USE st2; select * from table; （六）分割线+删除线1. 分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西； 也可以在星号或是减号中间插入空格。​ *** - - - ​ 2.删除线~~删除线~~ 删除线 （七）表格1. 单元格与表头 使用 | 来分隔不同的单元格 使用 - 来分隔表头和其他行 name | age ---- | --- LearnShare | 12 Mike | 32 name age LearnShare 12 Mike 32 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了） 2. 对齐在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： :--代表左对齐 :--: 代表居中对齐 ---: 代表右对齐 | left | center | right | | :--- | :----: | ----: | | aaaa | bbbbbb | ccccc | | a | b | c | left center right aaaa bbbbbb ccccc a b c 如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现） 3. 插入其他内容表格中可以插入其他 Markdown 中的行内标记： | name | age | blog | | ------------ | --- | ------------------------------- | | _LearnShare_ | 12 | [LearnShare](http://xianbai.me) | | __Mike__ | 32 | [Mike](http://mike.me) | name age blog LearnShare 12 LearnShare Mike 32 Mike 区段元素（一）强调1.使用星号（）和底线（_）作为标记强调字词的符号，被 或 包围的字词会被转成用&lt;em&gt;标签包围，用两个 * 或 `` 包起来的话，则会被转成 strong*single asterisks* _single underscores_ **double asterisks** __double underscores__ ***double asterisks*** single asterisks single underscores double asterisks double underscores double asterisks 2. 强调也可以直接插在文字中间un**frigging**believable unfriggingbelievable 3. 如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号；或者利用反斜线\* single asterisks * \* single asterisks single asterisks * * single asterisks （二）代码1. 标记行内代码，你可以用反引号把它包起来（`）Use the `printf()` function. Use the printf() function. 2. 代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段``There is a literal backtick (`) here.`` `There is a literal backtick (`) here.` There is a literal backtick (`) here.There is a literal backtick () here.` 3. 代码区段的起始和结束端都可以放入一个空白,就可以在区段的一开始就插入反引号A backtick-delimited string in a code span: `` `foo` `` A single backtick in a code span: `foo` 4. 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体Please don’t use any &lt;blink&gt; tags. &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. （三）图片1. 行内式 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 ![图片名称](/path/to/img.jpg &quot;Optional title&quot;) ![图片名称](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;) 2. 参考式 「id」是图片参考的名称![Alt text][id] [id]: url/to/image &quot;Optional title attribute&quot; 3. 指定图片大小通过直接插入&lt;img&gt;标签来指定相关属性 &lt;img src=&quot;https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100&quot; alt=&quot;GitHub&quot; title=&quot;GitHub,Social Coding&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; ​ （四）链接1. 行内式：[link text](URL &#39;title text&#39;) （1）普通链接 [Google](http://www.google.com/) Google （2）指向本地文件的链接 [icon.png](./images/icon.png) icon.png （3）包含 ‘title’ 的链接​ Google Google 2. 参考式参考式链接的写法相当于行内式拆分成两部分，并通过一个识别符来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。 （1）定义链接 [Google][1] 这个链接用 1 作为网址变量 Google第二个方括号内为链接独有的 识别符，可以是字母、数字、空白或标点符号。识别符是 不区分大小写 的； （2）定义链接内容 [1]: http://www.google.com/ &quot;Google&quot; 然后在文档的结尾为变量赋值（网址） 其格式为：[识别符]: URL &#39;title&#39; （3）也可以省略 识别符，使用链接文本作为 识别符 [Google][] [Google]: http://www.google.com/ &quot;Google&quot; 参考式相对于行内式有一个明显的优点，就是可以在多个不同的位置引用同一个 URL。 3. 超链接使用 &lt;&gt; 括起来的 URL 或 邮箱地址 会被自动转换为超链接 &lt;http://www.google.com/&gt; &lt;123@email.com&gt; http://www.google.com/&#x31;&#x32;&#51;&#64;&#101;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d; 该方式适合行内较短的链接，会使用 URL 作为链接文字。 其他（一）转义符反斜线（\）用于插入在 Markdown 语法中有特殊作用的字符 \ ` * _ {} [] () # + - . ! (二)页内跳转1. MarkDown实现* [主标题1](#1) * [副标题1.1](#1.1) * [次级副标题1.1.1](#1.1.1) * [副标题1.2](#one-point-two) &lt;h1 id=&quot;1&quot;&gt;主标题1&lt;/h1&gt; 文本内容。。。 &lt;h2 id=&quot;1.1&quot;&gt;副标题1.1&lt;/h2&gt; 文本内容。。。 &lt;h3 id=&quot;1.1.1&quot;&gt;次级副标题1.1.1&lt;/h3&gt; 文本内容。。。 &lt;h2 id=&quot;one-point-two&quot;&gt;副标题1.2&lt;/h2&gt; 这是为了演示id也可以设置成英文字母 主标题1 副标题1.1 次级副标题1.1.1 副标题1.2 主标题1文本内容。。。 副标题1.1文本内容。。。 次级副标题1.1.1文本内容。。。 副标题1.2这是为了演示id也可以设置成英文字母 2.html标签实现:利用 HTML 元素创建 “锚”（1）定义一个锚(id)： &lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt; 区块元素 （2）使用markdown语法： [点击跳转](#jump) 区块元素* [主标题1](#1) * [副标题1.1](#1.1) * [次级副标题1.1.1](#1.1.1) * [副标题1.2](#one-point-two) &lt;span id=&quot;1&quot;&gt;&lt;/span&gt; # 主标题1 文本内容。。。 &lt;span id=&quot;1.1&quot;&gt;&lt;/span&gt; ## 副标题1.1 文本内容。。。 &lt;span id=&quot;1.1.1&quot;&gt;&lt;/span&gt; ### 次级副标题1.1.1 文本内容。。。 &lt;span id=&quot;one-point-two&quot;&gt;&lt;/span&gt; ## 副标题1.2 这是为了演示id也可以设置成英文字母 3. Markdown 原生支持的页内跳转* [Cat and dog](#cat-and-dog) * [Cat](#cat) * [A little cat](#a-little-cat) * [Dog](#dog) ## Cat and dog 一只单身狗和一只高冷猫的故事。。。 ### Cat 有一天高冷猫遇见了单身狗。。。 #### A little cat 高冷猫生的很小巧但是脾气不是很好。。。 ### Dog Cat and dog Cat A little cat Dog Cat and dog一只单身狗和一只高冷猫的故事。。。 Cat有一天高冷猫遇见了单身狗。。。 A little cat高冷猫生的很小巧但是脾气不是很好。。。 Dog4. MarkdownPad2 原生支持的页内跳转&lt;a name=&quot;myAnchor&quot;&gt;&lt;/a&gt; ## My Header ## This is some content in my first section. [Go To Section One](#myAnchor) My HeaderThis is some content in my first section.Go To Section One]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Excel数据处理]]></title>
      <url>%2F2017%2F02%2F07%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FOffice_Excel%2FEXCEL%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[EXCEL数据处理标签：D数据分析 Excel [TOC] 1. 单元格格式1.1 转为指定格式的文本text() 1.2 文本转为数值 2. 单元格结构2.1 单元格长度len() # 返回单元格字符串的长度 2.2 指定字符的位置find(&quot;M&quot;, A1, 2) # 返回第2个字母M的位置数 find(text, within_text, num) 3. 返回值3.1 左/右部分left(A1,n)； right(A1,n) 3.2 指定位置的值mid(A1,1,2) # 从第一个字符开始，返回2个字符的值 mid(text, start_num, num_chars) 3.3 特定条件的值vlookup(A1, A1:D3, 2, 0) # A1在区域A1：D3中查询，并且返回区域A1：D3中从左到右第2列的值；0为精确匹配，即FALSE； vlookup(lookup_value, table_array, col_index_num, [range_lookup]) 4. 替换4.1 常规替换Ctrl + H 4.2 指定位置的值replace(A1,3,4,&quot;*&quot;) # 从第三个字符开始，之后的4个字符串替换我*号 replace(text,start_num,num_chars,new_text) 4.3 指定符号的值substitute(A1,&quot;^&quot;,&quot;*&quot;,2) # 对第2个出现的^号替换为* substitute(text, old_text, new_text,[num]) 5. 分列与合并5.1 分列数据 - 分列 5.2 合并5.2.1 常规合并使用符号 &amp; 5.2.2 函数合并concatenate(A1,A3,A4) # 将多个单元格中的值合并为一个单元格中的值 concatenate(text1,text2,…) 表中的结构与位置单元格数量非空单元格counta(A1:A3) # 返回区域中非空单元格的数量 数值单元格count(A1:A3) # 返回区域中数值单元格的数量 满足特定条件的单元格countif(A1:B3,&quot;&lt;&gt;&quot;&amp;A1) # 返回区域中不等于A1的值的单元格数量 countif(range, condition) 满足多区域，多条件的单元格countifs(A1:A3,&quot;是&quot;, B1:B3,500) # 返回同时满足区域A1:A3中等于“是”，B1：B3中数值为500的单元格数量 countifs(rang1, condition1, range2, condition2,…) 排序的位置rank(1,A1：B2 ,0) # 返回数值1在区域A1：B2中的相对位置； 默认按降序排列（0） rank(num, range, 0/1) 1，表示按升序排列 2. 空值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown使用手册_typora]]></title>
      <url>%2F2017%2F02%2F07%2F%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6%2FMarkdown%2FMarkdown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C_Typora%2F</url>
      <content type="text"><![CDATA[概述Markdown是由Daring Fireball创建的，原来的指导方针就在这里。然而，其语法因不同的解析器或编辑者而异。Typora正在使用GitHub Flavored Markdown。 请注意，markdown源中的HTML片段将被识别，但不会被解析或呈现。另外，保存后的原始降价源代码可能会重新格式化。 概述 块元素段落和换行符标题块引用列表任务列表（围栏）代码块数学块表脚注水平规则YAML前线事宜目录（TOC） 跨度元素链接内部链接参考链接网址图片重点强大码删除线强调表情：快乐：内联数学下标上标突出 块元素段落和换行符一段只是一个或多个连续的文本行。在markdown源代码中，段落由多个空白行分隔。在Typora中，您只需要按Return创建一个新的段落。 按Shift+ Return创建一个换行符。但是，大多数markdown解析器将忽略单行中断，使其他分解器识别您的换行符，您可以在行尾留下两个空格或插入``。 标题标题在行开始使用1-6个散列字符，对应于标题级别1-6。例如： 12345# This is an H1## This is an H2###### This is an H6 在typora中，输入’＃’后跟标题内容，Return按键将创建一个标题。 块引用Markdown使用电子邮件风格&gt;字符进行块引用。它们被表示为： 1234567&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt;&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. 在typora中，只需输入’&gt;’后跟引用内容就会生成一个块引用。Typora将为您插入适当的“&gt;”或换行符。通过添加额外的“&gt;”级别可以允许在另一个块引用内嵌一个引号。 列表输入* list item 1将创建一个无序列表，该*符号可以替换为+或-。 输入1. list item 1将创建一个有序列表，它们的markdown源代码如下： 123456789## un-ordered list* Red* Green* Blue## ordered list1. Red2. Green3. Blue 任务列表任务列表是标有[]或[x]（不完整或完整）的项目的列表。例如： 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed 您可以通过单击项目之前的复选框来更改完整/不完整的状态。 （围栏）代码块Typora只支持Github Flavored Markdown中的栅栏。不支持标记中的原始代码块。 使用栅栏很容易：输入“”并按return`。在12 Here’s an example: ​1234function test() &#123; console.log(&quot;notice the blank line before this function?&quot;);&#125;​ syntax highlighting:​1234require 'redcarpet'markdown = Redcarpet.new("Hello World!")puts markdown.to_html​ 12345678910### 数学块您可以 使用**MathJax**渲染 *LaTeX*数学表达式 。****输入`$$`，然后按“返回”键将触发一个接受*Tex / LaTex*源的输入字段。以下是一个例子：V1× V2= |||||一世∂X∂你∂X∂vj∂Y∂你∂Y∂vk00|||||V1×V2=|一世jk∂X∂你∂Y∂你0∂X∂v∂Y∂v0|在markdown源文件中，数学块是由&apos;$$&apos;标记包裹的*LaTeX*表达式： $$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}$$ 12345678910### 表输入`| First Header | Second Header |`和`return`按键将创建一个带有两列的表。创建表之后，将重点放在该表上将弹出一个表的工具栏，您可以在其中调整大小，对齐或删除表。您还可以使用上下文菜单来复制和添加/删除列/行。以下描述可以跳过，因为表的markdown源代码是由typora自动生成的。在markdown源代码中，它们看起来像： First Header Second Header Content Cell Content Cell Content Cell Content Cell 1234您还可以包括内联Markdown，如链接，粗体，斜体或删除线。最后，通过包含冒号：在标题行中，您可以定义要左对齐，右对齐或中心对齐的文本： Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 1234最左侧的冒号表示左对齐的列; 最右侧的结肠指示右对齐的柱; 两侧的结肠表示中心对齐的柱。### 脚注 You can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. 1234567891011121314151617181920212223242526272829303132将产生：你可以创建这样的脚注[1](http://support.typora.io/Markdown-Reference/#fn:footnote)。鼠标在“脚注”上标上查看脚注的内容。### 水平规则输入`***`或`---`空白行，按下`return`将画一条水平线。------### YAML前线事宜Typora支持[YAML Front Matters](http://jekyllrb.com/docs/frontmatter/)。输入`---`文章顶部，然后按下`Enter`将会介绍一个。或从菜单中插入一个元数据块。### 目录（TOC）输入，`[toc]`然后`Return`按键将创建一个“目录”部分，从一个人的写作中提取所有标题，其内容将自动更新。## 跨度元素您的打字后，Span元素将被解析并呈现。在这些span元素的中间移动光标将这些元素扩展为markdown源。以下将介绍这些span元素的语法。### 链接Markdown支持两种风格的链接：内联和引用。在两种样式中，链接文本由[方括号]分隔。要创建内联链接，请在链接文本的关闭方括号后立即使用一组常规括号。在括号内，将链接所在的网址与链接的可选标题一起放在引号中。例如： This is an example inline link. This link has no title attribute. 12345678910111213141516将产生：这是[一个](http://example.com/%22Title%22)内联链接[示例](http://example.com/%22Title%22)。（`This is [`](http://example.com/)）[此链接](http://example.net/)没有标题属性。（`[This link](http://example.net/) has no`）#### 内部链接**您可以将href设置为标题**，这将创建一个书签，允许您在单击后跳转到该部分。例如：命令（在Windows上：Ctrl）+单击[此链接](http://support.typora.io/Markdown-Reference/#block-elements)将跳转到标题`Block Elements`。要查看如何写，请移动光标或点击该`⌘`按钮，将该元素展开为markdown源。#### 参考链接参考样式链接使用第二组方括号，您可以在其中放置您选择的标签来标识链接： This is an example reference-style link. Then, anywhere in the document, you define your link label like this, on a line by itself: 123456在typora中，它们将被渲染为：这是[一个示例](http://example.com/)参考样式的链接。隐式链接名称快捷方式允许您省略链接的名称，在这种情况下，将链接文本本身用作名称。只需使用一组空白的方括号 - 例如，将Google“Google”链接到google.com网站，您可以简单地写： GoogleAnd then define the link: 1234567891011121314在typora中，点击链接将扩展它进行编辑，命令+单击将打开Web浏览器中的超链接。### 网址Typora允许您将URL作为链接插入，用`&lt;`括号括起来`&gt;`。``成为[i@typora.io](mailto:i@typora.io)。Typora将自动链接标准URL。例如：www.google.com。### 图片图像看起来与链接类似，但`!`在链接开始之前需要一个额外的char。图像语法如下所示： 12345678910您可以使用拖放来从图像文件或浏览器插入图像。并通过点击图像修改markdown源代码。如果图像与当前编辑文档在同一目录或子目录中拖放时，将使用相对路径。如果您使用markdown构建网站，则可以在本地计算机中`typora-root-url`为YAML Front Matters中的属性指定用于图像预览的网址前缀。例如，`typora-root-url:/User/Abner/Website/typora.io/`在YAML Front Matters中输入，然后`![alt](/blog/img/test.png)`将被视为`![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)`类似的。![拖放图像](http://typora.io/img/drag-img.gif)### 重点Markdown将星号（`*`）和下划线（`_`）作为重点的指示。用一个包装的文本`*`或`_`将被HTML ``标签包装的文本。例如： single asterisks single underscores 1234567891011121314输出：*单个星号**单个下划线*GFM将忽略通常用于代码和名称的单词中的下划线，如下所示：&gt; wow_great_stuff&gt;&gt; do_this_and_do_that_and_another_thing。要在一个位置上产生一个文字星号或下划线，否则它将被用作强调分隔符，您可以反斜杠逃避它： *this text is surrounded by literal asterisks* 123456Typora建议使用`*`符号。### 强大double *或_将包含HTML ``标签，例如： double asterisks double underscores 123456789101112输出：**双星号****双重下划线**Typora建议使用`**`符号。### 码要指示代码跨度，用反引号引号（`）包装。与预格式化的代码块不同，代码段表示正常段落中的代码。例如： Use the printf() function. ``` 将产生： 使用该printf()功能。 删除线GFM添加语法来创建删除线文本，这在标准的Markdown中是缺少的。 ~~Mistaken text.~~ 成为 错误的文字。 强调下划线由原始HTML提供支持。 Underline成为下划线。 表情：快乐：使用语法输入表情符号:smile:。 用户可以通过ESC按键触发表情符号的自动填写建议，或者在首选面板上启用后自动触发。此外，还支持从Edit- &gt; Emoji &amp; Symbols从菜单栏直接输入UTF8表情符号字符串。 内联数学要使用此功能，请先在Preference面板 - &gt; Markdown选项卡中启用该功能。然后$用来包装TeX命令，例如：$\lim_{x \to \infty} \exp(-x) = 0$将被渲染为LaTeX命令。 要触发内联数学的内联预览：输入“$”，然后ESC按键，然后输入TeX命令，预览工具提示将如下所示可见： 下标要使用此功能，请先在Preference面板 - &gt; Markdown选项卡中启用该功能。然后使用~包标内容，例如：H~2~O，X~long\ text~/ 上标要使用此功能，请先在Preference面板 - &gt; Markdown选项卡中启用该功能。然后^用来包含上标内容，例如：X^2^。 突出要使用此功能，请先在Preference面板 - &gt; Markdown选项卡中启用该功能。然后==用来包装高亮内容，例如：==highlight==。 这里是文本的的注脚。 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优秀员工离职原因分析与预测_R]]></title>
      <url>%2F2017%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F20_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E4%B8%93%E9%A2%98%E5%88%86%E6%9E%90%2F%E4%BC%98%E7%A7%80%E5%91%98%E5%B7%A5%E7%A6%BB%E8%81%8C%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E4%B8%8E%E9%A2%84%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[优秀员工离职原因分析与预测 一、背景1.公司大量优秀且有经验的员工过早的离开 2.数据来源：kaggle 3.变量 satisfaction: Employee satisfaction levelevaluation: Last evaluationproject: Number of projectshours: Average monthly hoursyears: Time spent at the companyaccident: Whether they have had a work accidentpromotion: Whether they have had a promotion in the last 5 yearssales: Departmentsalary: Salaryleft: Whether the employee has left 4.分析目的与衡量标准： （1）分析并得出优秀员工离职的主要可能的原因（2）构建预测模型，预测下一位将会离开的优秀员工是谁 二、数据分析所需包导入 library(readr)library(dplyr)library(ggplot2)library(gmodels) （一）导入数据并查看## 1.1 数据导入 library(readr)hr &lt;- read_csv(“HR_comma_sep.csv”)hr &lt;- tbl_df(hr)View(hr)str(hr) Classes ‘tbl_df’, ‘tbl’ and ‘data.frame’: 14999 obs. of 10 variables: $ satisfaction_level : num 0.38 0.8 0.11 0.72 0.37 0.41 0.1 0.92 0.89 0.42 …$ last_evaluation : num 0.53 0.86 0.88 0.87 0.52 0.5 0.77 0.85 1 0.53 …$ number_project : int 2 5 7 5 2 2 6 5 5 2 …$ average_montly_hours : int 157 262 272 223 159 153 247 259 224 142 …$ time_spend_company : int 3 6 4 5 3 3 4 5 5 3 …$ Work_accident : int 0 0 0 0 0 0 0 0 0 0 …$ left : int 1 1 1 1 1 1 1 1 1 1 …$ promotion_last_5years: int 0 0 0 0 0 0 0 0 0 0 …$ sales : chr “sales” “sales” “sales” “sales” …$ salary : chr “low” “medium” “medium” “low” … ## 1.2 变量重命名 hr_good &lt;- filter(hr, evaluation&gt;=0.75 &amp; year&gt;=4 &amp; project&gt;= 4) colnames(hr) &lt;- c(“satisfaction”,”evaluation”,”project”,”hours”,”years”,”accident”,”left”,”promotion”,”sales”,”salary”) ## 1.3 因子化 hr$sales &lt;- factor(hr$sales)hr$salary &lt;- factor(hr$salary, levels=c(“low”,”medium”,”high”)) ## 1.4 查看数据 sum(is.na(hr)) # [1] 0 summary(hr) satisfaction_level last_evaluation number_project average_montly_hoursMin. :0.0900 Min. :0.3600 Min. :2.000 Min. : 96.01st Qu.:0.4400 1st Qu.:0.5600 1st Qu.:3.000 1st Qu.:156.0Median :0.6400 Median :0.7200 Median :4.000 Median :200.0Mean :0.6128 Mean :0.7161 Mean :3.803 Mean :201.13rd Qu.:0.8200 3rd Qu.:0.8700 3rd Qu.:5.000 3rd Qu.:245.0Max. :1.0000 Max. :1.0000 Max. :7.000 Max. :310.0 time_spend_company Work_accident left promotion_last_5yearsMin. : 2.000 Min. :0.0000 Min. :0.0000 Min. :0.000001st Qu.: 3.000 1st Qu.:0.0000 1st Qu.:0.0000 1st Qu.:0.00000Median : 3.000 Median :0.0000 Median :0.0000 Median :0.00000Mean : 3.498 Mean :0.1446 Mean :0.2381 Mean :0.021273rd Qu.: 4.000 3rd Qu.:0.0000 3rd Qu.:0.0000 3rd Qu.:0.00000ax. :10.000 Max. :1.0000 Max. :1.0000 Max. :1.00000 sales salarysales :4140 low :7316technical :2720 medium:6446support :2229 high :1237IT :1227product_mng: 902marketing : 858(Other) :2923 （二）根据定义选取优秀员工的子集，并做初步分析优秀员工的定义：（1）评价(evaluation)&gt;=0.75（2）项目数量(project)&gt;=4（3）有经验的(year)&gt;=4 ## 2.1 根据定义选取子集 hr_good &lt;- filter(hr, evaluation&gt;=0.75 &amp; years&gt;=4 &amp; project&gt;= 4) ## 2.2 对比总体与选取子集中离职员工的占比情况 【结论】：优秀员工离职情况非常严重1.在总离职员工中，优秀员工的数量占了(1778/3571=) 50%；2.在优秀员工子集中，离职的数量高达(1778/2753=) 64%； CrossTable(hr$left) Total Observations in Table: 14999 CrossTable(hr_good$left) ## 2.3 了解优秀员工子集的统计量 summary(hr_good) ## 2.4 了解优秀员工子集中各变量之间的相关性 【结论】：离职与满意度呈负相关，且相关度最高 hr_good_corr &lt;- select(hr, -sales,-salary) %&gt;% cor()corrplot(hr_good_corr, method=”circle”, tl.col=”black”,title=”离职与满意度呈负相关，且相关度最高”,mar=c(1,1,3,1)) （三）逐个变量分析员工离职、满意度与其他变量之间的关系## 3.1 查看满意度的分布图 hr_good$left &lt;- factor(hr_good$left, levels=c(0,1), labels=c(“stay”, “left”)) ggplot(hr_good, aes(satisfaction, fill=left)) + geom_histogram(position=”dodge”) + scale_x_continuous(breaks=c(0.1,0.13,0.25,0.50,0.73,0.75,0.92,1.00)) + theme3 + theme(axis.text.x=element_text(angle=90)) + labs(title=”满意度在[0.1,0.13]与[0.73,0.92]两个区间离职人数非常多”) ## 3.2 收入、工作时间、满意度之间的关系 【结论】：工作超长时间的员工满意度低，且离职率高1.低&amp;中等薪资水平中较高工作时间的员工大量离职2.超长工作时间的员工满意度都很低且几乎都已离职 ggplot(hr_good, aes(salary, hours, alpha=satisfaction, color=left)) + geom_jitter() + theme3 + labs(title=paste(“低&amp;中等薪资水平中较高工作时间的员工大量离职”,”\n”,”超长工作时间的员工满意度都很低且几乎都已离职”)) ## 3.3 晋升、满意度与离职的关系 【结论】：高评价的员工几乎没有人晋升，离职人员也主要集中在未晋升中 ggplot(hr_good, aes(promotion, evaluation, color=left)) + geom_jitter() + theme3 + scale_x_discrete(limits=c(0,1)) + labs(title=paste(“高评价的员工几乎没有人晋升”,”\n”,”离职人员也主要集中在未晋升中”)) ## 3.4 工作年限、满意度与离职的关系 【结论】：1.低满意度(0.1)水平下，4年司龄的员工大量离职2.大量高满意度员工在第5年与第6年离职3.7年以上的员工没有人离职 ggplot(hr_good, aes(years,satisfaction, color=left)) + geom_jitter() + scale_x_discrete(limits=c(4,5,6,7,8,9,10)) + theme3 + labs(title=paste(“低满意度(“,”0.1)”,”水平下，4年司龄的员工大量离职”,”\n”,”大量高满意度员工在第5年与第6年离职”)) ## 3.5 部门、项目数与离职的关系 【结论】：对于6个以上的项目无论在哪个部门离职率都非常高 ggplot(hr_good, aes(sales,fill=left)) + geom_bar(position=”fill”) + facet_wrap(~factor(project),ncol=1) + theme3 + theme(axis.text.x=element_text(angle=270)) + labs(y=”number projcet”,title=”对于6个以上的项目无论在哪个部门离职率都非常高”) ## 3.6 部门与离职的关系 【结论】：各部门离职人员均高于在职人员，管理部门除外 ggplot(hr_good, aes(sales, fill=left)) + geom_bar(position=”dodge”) + coord_flip() + scale_x_discrete(limits=c(“management”,”RandD”,”hr”,”accounting”,”marketing”,”product_mng”,”IT”,”support”,”technical”,”sales”)) + labs(title=”各部门离职人员均高于在职人员，管理部门除外”) + theme3 三、构建预测模型1：分类## 数据分割 library(caret)set.seed(0001)train &lt;- createDataPartition(hr_good$left, p=0.75, list=FALSE)hr_good_train &lt;- hr_good[train, ]hr_good_test &lt;- hr_good[-train, ] （一）Logistic回归## 1. 构建逻辑回归并验证 ctrl &lt;- trainControl(method=”cv”,number=5)logit &lt;- train(left~., hr_good_train, method=”LogitBoost”, trControl=ctrl)logit.pred &lt;- predict(logit, hr_good_test, tyep=”response”)confusionMatrix( hr_good_test$left, logit.pred) ​ Confusion Matrix and Statistics Reference Prediction stay left stay 213 33 left 8 436 Accuracy : 0.940695% CI : (0.9203, 0.957)No Information Rate : 0.6797P-Value [Acc &gt; NIR] : &lt; 2.2e-16Kappa : 0.8675Mcnemar’s Test P-Value : 0.0001781Sensitivity : 0.9638Specificity : 0.9296Pos Pred Value : 0.8659Neg Pred Value : 0.9820Prevalence : 0.3203Detection Rate : 0.3087Detection Prevalence : 0.3565Balanced Accuracy : 0.9467‘Positive’ Class : stay ## 2. 评价模型，绘制ROC/AUC曲线 library(pROC)roc(as.numeric(hr_good_test$left), as.numeric(logit.pred), plot=TRUE, print.thres=TRUE, print.auc=TRUE, col=”black”) （二）决策树## 1. 构建决策树 library(rpart)dtree &lt;- rpart(left~., hr_good_train, method=”class”,parms=list(split=”information”))dtree$cptable CP nsplit rel error xerror xstd 1 0.55209743 0 1.00000000 1.00000000 0.029509112 0.12855210 1 0.44790257 0.44790257 0.022568053 0.08254398 3 0.19079838 0.19079838 0.015512044 0.02300406 4 0.10825440 0.10825440 0.011867375 0.01000000 5 0.08525034 0.08525034 0.01057607 plotcp(dtree) dtree.pruned &lt;- prune(dtree, cp=0.01)library(partykit)library(grid)plot(as.party(dtree.pruned),main=”Decision Tree”) dtree.pruned.pred &lt;- predict(dtree.pruned, hr_good_test, type=”class”)confusionMatrix(hr_good_test$left, dtree.pruned.pred) Confusion Matrix and Statistics Reference Prediction stay left stay 236 10 left 13 431 Accuracy : 0.966795% CI : (0.9504, 0.9788)No Information Rate : 0.6391P-Value [Acc &gt; NIR] : &lt;2e-16Kappa : 0.9275Mcnemar’s Test P-Value : 0.6767Sensitivity : 0.9478Specificity : 0.9773Pos Pred Value : 0.9593Neg Pred Value : 0.9707Prevalence : 0.3609Detection Rate : 0.3420Detection Prevalence : 0.3565Balanced Accuracy : 0.9626‘Positive’ Class : stay ## 2. 评价模型，绘制ROC/AUC曲线 roc(as.numeric(hr_good_test$left),as.numeric(dtree.pruned.pred), plot=TRUE, print.thres=TRUE, print.auc=TRUE,col=”blue”) （三）随机森林## 1. 构建随机森林 library(randomForest)set.seed(0002)forest &lt;- randomForest(left~., hr_good_train, importance=TRUE, na.action=na.roughfix)forest Call: randomForest(formula = left ~ ., data = hr_good_train, importance = TRUE, na.action = na.roughfix) Type of random forest: classificationNumber of trees: 500No. of variables tried at each split: 3OOB estimate of error rate: 1.35% Confusion matrix: stay left class.errorstay 731 8 0.01082544left 20 1314 0.01499250 importance(forest, type=2) **MeanDecreaseGini** satisfaction 315.455428evaluation 63.101527project 51.659717hours 307.201129years 168.530576accident 6.232136promotion 1.897123sales 20.666829salary 12.338717 forest.pred &lt;- predict(forest, hr_good_test)confusionMatrix(hr_good_test$left, forest.pred) ​ Confusion Matrix and Statistics Reference Prediction stay left stay 241 5 left 4 440 Accuracy : 0.98795% CI : (0.9754, 0.994)No Information Rate : 0.6449P-Value [Acc &gt; NIR] : &lt;2e-16Kappa : 0.9715Mcnemar’s Test P-Value : 1Sensitivity : 0.9837Specificity : 0.9888Pos Pred Value : 0.9797Neg Pred Value : 0.9910Prevalence : 0.3551Detection Rate : 0.3493Detection Prevalence : 0.3565Balanced Accuracy : 0.9862‘Positive’ Class : stay ## 2. 评价模型，绘制ROC/AUC曲线 roc(as.numeric(hr_good_test$left), as.numeric(forest.pred), plot=TRUE, print.thres=TRUE, print.auc=T, col=”green”) （四）支持向量机SVM## 1. 构建SVM library(e1071)set.seed(0003)svm &lt;- svm(left~., hr_good_train)svm.pred &lt;- predict(svm, na.omit(hr_good_test))confusionMatrix(na.omit(hr_good_test)$left, svm.pred) Confusion Matrix and Statistics Reference Prediction stay left stay 211 35 left 11 433 Accuracy : 0.933395% CI : (0.9121, 0.9508)No Information Rate : 0.6783P-Value [Acc &gt; NIR] : &lt; 2.2e-16Kappa : 0.8515Mcnemar’s Test P-Value : 0.000696Sensitivity : 0.9505Specificity : 0.9252Pos Pred Value : 0.8577Neg Pred Value : 0.9752Prevalence : 0.3217Detection Rate : 0.3058Detection Prevalence : 0.3565Balanced Accuracy : 0.9378‘Positive’ Class : stay ## 2. 评价模型，绘制ROC/AUC曲线 roc(as.numeric(na.omit(hr_good_test)$left), as.numeric(svm.pred), plot=T, print.thres=T, print.auc=T, col=”orange”) （五）对比模型，选择准确性最高的模型 【结论】：随机森林的拟合度最高，选择该模型为预测模型 roc(as.numeric(hr_good_test$left), as.numeric(logit.pred), plot=TRUE,col=”black”,main=paste(“ROC曲线:”,”Logitis(black)”,”dtree(blue)”,”randomForest(green)”,”SVM(orange)”,sep=” “))roc(as.numeric(hr_good_test$left),as.numeric(dtree.pruned.pred), plot=TRUE, col=”blue”, add=T)roc(as.numeric(hr_good_test$left), as.numeric(forest.pred), plot=TRUE, col=”green”, add=T)roc(as.numeric(na.omit(hr_good_test)$left), as.numeric(svm.pred), plot=T, col=”orange”, add=T) （六）模型应用 importance(forest,type=2) MeanDecreaseGini satisfaction 315.455428evaluation 63.101527project 51.659717hours 307.201129years 168.530576accident 6.232136promotion 1.897123sales 20.666829salary 12.338717 ## 1. 剔除明显不重要的因子，重新构建模型 forest2 &lt;- randomForest(left~.-promotion-accident-salary-sales, hr_good, na.action=na.roughfix, importance=TRUE)importance(forest2, type=2) MeanDecreaseGini satisfaction 462.97925evaluation 72.49430project 71.09463hours 417.63782years 231.64080 forest2.pred &lt;- predict(forest2, hr_good_test)confusionMatrix(hr_good_test$left, forest2.pred, positive=”left”) Confusion Matrix and Statistics Reference Prediction stay left stay 244 2 left 1 443 Accuracy : 0.995795% CI : (0.9873, 0.9991)No Information Rate : 0.6449P-Value [Acc &gt; NIR] : &lt;2e-16Kappa : 0.9905Mcnemar’s Test P-Value : 1Sensitivity : 0.9959Specificity : 0.9955Pos Pred Value : 0.9919Neg Pred Value : 0.9977Prevalence : 0.3551Detection Rate : 0.3536Detection Prevalence : 0.3565Balanced Accuracy : 0.9957‘Positive’ Class : stay ## 2. 评价模型，绘制ROC/AUC曲线 roc(as.numeric(hr_good_test$left), as.numeric(forest2.pred), plot=TRUE, print.thres=T, print.auc=T, main=”Random Forest”, col=”green”) （七）结论1.调整后的随机森林预测模型员工离职的准确性达99.5%；其中离职的员工被正确预测的概率为99.5%，被预测离职的员工中，实际离职的概率为99.8%； 2.剔除不重要的变量（promotion,accident,sales,salary）并不会对模型造成影响； 3.满意度（satisfaction）、月平均工作时间（hours）、工作年限（years）是影响优秀员工离职的主要三个变量 四、构建预测模型2：主成分分析（一）判断主成分个数【结论】：根据结果，选择主成分个数为2个 library(psych)hr_pc &lt;- select(hr,-left,-sales,-salary)fa.parallel(hr_pc, fa=”pc”, n.iter=100, show.legend=FALSE, main=”Scree plot with parallel analysis”) ## Parallel analysis suggests that the number of factors = NA and the number of components = 2 （二）提取主成分【结论】：1.选择后的主成分RC1解释了数据33%的方差，RC2解释了16%；2个主成分共解释了数据49%的方差；2.RC1与”satisfaction,years”正相关，与”project, hours”负相关，称为综合因子13.RC2与”accident, promoion”正相关，与”evaluation”负相关，可称为综合因子2 hr.good.rc &lt;- principal(hr_good_pc, nfactors=2, scores=T)hr.good.rc Principal Components Analysis Call: principal(r = hr_good_pc, nfactors = 2, scores = T) Standardized loadings (pattern matrix) based upon correlation matrix RC1 RC2 h2 u2 com satisfaction 0.84 -0.19 0.74 0.26 1.1evaluation 0.25 -0.66 0.49 0.51 1.3project -0.85 0.03 0.73 0.27 1.0hours -0.64 -0.30 0.50 0.50 1.4years 0.61 0.10 0.39 0.61 1.1accident 0.14 0.55 0.32 0.68 1.1promotion 0.08 0.50 0.26 0.74 1.1 RC1 RC2 SS loadings 2.30 1.12Proportion Var 0.33 0.16Cumulative Var 0.33 0.49Proportion Explained 0.67 0.33Cumulative Proportion 0.67 1.00Mean item complexity = 1.2Test of the hypothesis that 2 components are sufficient.The root mean square of the residuals (RMSR) is 0.14with the empirical chi square 2283.14 with prob &lt; 0Fit based upon off diagonal values = 0.66 （三）获取主成分得分【结论】：优秀员工离职人员在如下两个范围出现**1.范围1：RC1[-2,-1], RC2[-1,1]**2.范围2：RC1[0,1], RC2[-1.5,0] hr.good.rc.scores &lt;- as.data.frame(hr.good.rc$scores)hr.good.rc.scores$left &lt;- hr_good$leftggplot(hr.good.rc.scores, aes(RC1,RC2,color=factor(left))) + geom_point() 五、构建预测模型3：聚类 library(cluster)library(fpc) （一）选择合适的数据，并进行标准化 hr_good_cl &lt;- select(hr_good,-left,-sales,-salary)hr_good_cl_scale &lt;- as.data.frame(scale(hr_good_cl)) （二）选择合适的聚类数量【结论】：根据图形与pamk的值，选择聚类个数为6 source(“wssplot.r”)wssplot(hr_good_cl_scale) set.seed(0004)pamk.best &lt;- pamk(hr_good_cl_scale)pamk.best$nc # [1] 6 （三） 拟合聚类，并查看分类结构 fit.pam &lt;- pam(hr_good_cl_scale, k=6)cl.pam &lt;- table(hr_good$left, fit.pam$clustering)cl.pam 1 2 3 4 5 6 stay 228 72 150 138 364 33 left 326 83 8 502 87 21 4 hr_good$clustering &lt;- fit.pam$clusteringggplot(hr_good, aes(clustering, fill=factor(left))) + geom_bar(position=”dodge”) + scale_x_discrete(limits=c(1,2,3,4,5,6)) + theme3 + labs(title=”类别2和类别3中，离职人员比例远高于其他分类”) clusplot(fit.pam, main=”基于PAM算法得到的六组聚类图”) （四） 评价聚类:兰德指数【结论】：聚类结果与实际离职与否的结果吻合度不是很高；从之前的数据分析来看，优秀员工的离职与否在两种不同情境下都有较高的比例； library(flexclust)randIndex(cl.pam) ARI0.1742728 （五）根据聚类的分类进行子集细分，并描述统计情况1. 查看各个聚类的统计量 【结论】：从统计量（均值）上看，如下两个情况的员工离职意向很高1.离职比例最高的类别2(left=0.92)，satisfaciton非常低(0.11)，项目数量最高(6.17)，月均工作时间最长(274.6)2.离职比例次高的类别3(left=0.77)，评价极高(0.96)，满意度(0.78)、月均工作时间(238.9)，工作年限(5.0) hr_good &lt;- as.data.frame(hr_good)hr_good$left &lt;- as.integer(hr_good$left)hr_good$left &lt;- ifelse(hr_good$left==1,0,1)select(hr_good,-sales,-salary) %&gt;% group_by(., clustering) %&gt;% summarize_all(.,mean) # A tibble: 6 × 9 clustering satisfaction evaluation project hours years accident left promotion1 1 0.7574729 0.8453791 4.673285 246.5036 5.223827 0.0000000 0.588447 02 2 0.1114945 0.8714176 6.167033 274.6451 4.137363 0.0000000 0.920879 03 3 0.7809969 0.9649080 4.605828 238.9632 5.170245 0.0000000 0.769938 04 4 0.5258667 0.8865778 4.960000 219.9511 5.142222 1.0000000 0.386667 05 5 0.5542078 0.8585714 4.446753 161.2779 5.088312 0.0000000 0.054545 06 6 0.5908108 0.8648649 4.864865 225.5135 5.567568 0.1891892 0.108108 1 ## 2. 选择类别2和类别3的子集 hr_good_cl_select &lt;- filter(hr_good, clustering %in% c(2,3))summary(hr_good_cl_select) satisfaction evaluation project hours years accidentMin. :0.090 Min. :0.7600 Min. :4.000 Min. :137.0 Min. : 4.000 Min. :01st Qu.:0.100 1st Qu.:0.8525 1st Qu.:5.000 1st Qu.:243.0 1st Qu.: 4.000 1st Qu.:0Median :0.110 Median :0.9200 Median :6.000 Median :260.0 Median : 4.000 Median :0Mean :0.391 Mean :0.9104 Mean :5.515 Mean :259.8 Mean : 4.569 Mean :03rd Qu.:0.790 3rd Qu.:0.9700 3rd Qu.:6.000 3rd Qu.:282.0 3rd Qu.: 5.000 3rd Qu.:0Max. :1.000 Max. :1.0000 Max. :7.000 Max. :310.0 Max. :10.000 Max. :0left promotion sales salary clusteringMin. :0.000 Min. :0 sales :408 low :895 Min. :2.0001st Qu.:1.000 1st Qu.:0 technical :341 medium:628 1st Qu.:2.000Median :1.000 Median :0 support :213 high : 39 Median :2.000Mean :0.858 Mean :0 IT :129 Mean :2.4173rd Qu.:1.000 3rd Qu.:0 product_mng:104 3rd Qu.:3.000Max. :1.000 Max. :0 accounting : 94 Max. :3.000 (Other) :273 ## 3. 逐一分析子集的变量分布 ## 3.1 满意度分布 hr_good_cl_select$clustering &lt;- factor(hr_good_cl_select$clustering)ggplot(hr_good_cl_select , aes(satisfaction,fill=factor(left))) + geom_histogram() + facet_wrap(~clustering,ncol=1) + theme2 + scale_x_continuous(limits=c(0.1,0.25,0.50,0.75,0.9,1.0)) ## 3.2 评价分布 ggplot(hr_good_cl_select , aes(evaluation,fill=factor(left))) + geom_histogram() + facet_wrap(~clustering,ncol=1) + theme2 + scale_x_continuous(breaks=c(0.77,0.79,0.8,0.84,0.85,0.88,0.89,0.91,0.93,0.94,0.98,1.0)) + theme(axis.text.x=element_text(angle=90),panel.grid.minor=element_blank()) ## 3.3 项目数量分布 ggplot(hr_good_cl_select , aes(project,fill=factor(left))) + geom_bar() + facet_wrap(~clustering,ncol=1) + theme2 ## 3.4 月均工作时长分布 ggplot(hr_good_cl_select , aes(hours,fill=factor(left))) + geom_histogram() + facet_wrap(~clustering,ncol=1) + theme2 + scale_x_continuous(breaks=c(160,200,220,245,275,310)) + theme(panel.grid.minor=element_blank()) ## 3.5 工作年限分布 ggplot(hr_good_cl_select , aes(years,fill=factor(left))) + geom_histogram(binwidth=0.5) + facet_wrap(~clustering,ncol=1) + theme2 + scale_x_continuous(breaks=c(4,5,6,7,8,10)) ## 3.6 工作事故分布 ggplot(hr_good_cl_select , aes(accident,fill=factor(left))) + geom_bar(width=0.3) + facet_wrap(~clustering,ncol=1) + theme2 ## 3.7 晋升情况分布 ggplot(hr_good_cl_select , aes(promotion,fill=factor(left))) + geom_bar() + facet_wrap(~clustering,ncol=1) + theme2 + scale_x_discrete(limits=c(0,1)) ## 3.7 部门分布 ggplot(hr_good_cl_select , aes(sales,fill=factor(left))) + geom_bar() + facet_wrap(~clustering,ncol=1) + theme2 + theme(axis.text.x=element_text(angle=270,vjust=0.5)) ## 3.7 薪资水平分布 ggplot(hr_good_cl_select , aes(salary,fill=factor(left))) + geom_bar(width=0.5) + facet_wrap(~clustering,ncol=1) + theme2 + scale_y_continuous(breaks=c(0,20,100,200,300,400,500)) + theme(panel.grid.minor=element_blank())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间的朋友2016_罗辑思维]]></title>
      <url>%2F2017%2F01%2F21%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B%2F%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B2016_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_20170121%2F</url>
      <content type="text"><![CDATA[罗振宇2017年跨年演讲《时间的朋友》。 2016年12月31日 下半场：互联网红利基本消失。现在要由找用户，到让用户留下来。侧重点将发生改变。你要做的是，如何在有限的空间里发掘除 最大的价值。今后的互联网。 有限的时间/无线的信息=0 以后，一天信息传递出去将趋向于传递不出去 巨头的思维：害怕没有未来。创业者的思维：必须活好现在 国民总时间，27.5h/w 每个人的上网时间 竞争：围绕时间的竞争。 时间价值 行为设计 看电影不在是碎片时间的花费。而现在看电影花费的时间价值太高了。因为相同的时间你可以做更多的选择。空间价值 向 时间价值 而转变。 不确定的失去让人恐惧，不确定的得到让人兴奋。游戏的随机奖励让人会愿意花更多的时间。微信朋友圈你等待他人的点赞，评论，转发等反馈而会一天几十次分点亮你的屏幕。 未来的消费升级，你要告诉我我需要什么。一种父爱的逻辑。更好的专业分工里给我最优质的服务。在消费者不知道的环境里，给你不知道的东西。这种粗暴的消费。这种直接给我结果的消费。我哪里需要什么健身卡，我需要的是能够有人监督我的每一顿饭每一天的生活，帮我减肥成功。出版业产生的是产品，不是服务。他要的是你要不要购买这个产品，买完怎么用怎么服务不是他所关心的。 人工智能与深度学习 如何辨别这是一只猫。（大数据） ​ 之前是叠加n个条件，来判断这是一只猫。现在是直接输入100万张图片，我不知道怎么识别，但我告诉你这就是你猫。然后，你用自己的算法来实现辨别。图片输入越多，就越精准。这是这样一种算法，来无限逼近真实。我们不需要它是怎么知道的，但它给出了结果。算法不在重要，重要的是大量的数据与图片。 我们人类也是这样来认识这个世界的。 无用之物，勿增实体。 我们人类的思维，怎么简单怎么来。那些伟大的科学家，牛顿，爱因斯坦。抽象来理解这个世界。 而计算机是怎么复杂怎么来。 人工智能，将会极大改变整个社会的关系？所以以某种技能为优势的行业，都将被人工智能所替代。比你优秀的人还比你勤奋。我们能做的，是整合的能力，是跨界的能力，是领导力，是创造力。 认知的叠代 网红-自我赋权 世界是碎的，就是我们会不知道对面另一个碎片的世界里发生着什么。 2016年房价飞涨，网上骂声一片。但社科院的一份报告指出，91%的家庭是有房的，他们是高兴的。那些呈现在网上的观点，可能只是那一小部分而已。 媒体的世界，并不一定就是真实的世界。（数据分析，大数据，能帮我们更加深刻地认识这个世界。） 这个世界最值钱的，是共同的认知。 人是悬挂在自己编织的意义之网的动物。——马克思·韦伯 维生素片，牛奶。我们并不关心真实的世界，我们关心的是共同的认知。但随着互联网的涌入，信息的暴增，而我们的认知带宽是有限的。所以，争夺带宽是下一个世界商人所言争夺的。钻石💎，双11 这些原本是一个普通的物质与日子，但有人赋予了它含义。编织了一个新的意义。当你构建起一个认知，后人想要进入是极其困难的。刘强东构建了一个新的认知，我是阿里的唯一竞争对手。 小米，决不在是一个手机，现在已经构建了它的品牌价值，它的认知，性价比高。所以现在它的产品线是非常长的。在消费者带宽认知种占据了一席之地。聪明的创业者，应该是占领认知。 王石——学习：学习饮食，学习睡眠（保持充沛的精力，睡眠是最重要的） 【去学习，去践行。只有你付诸行动才说明你真的认识到它的重要性。否则，也可能并没有真的有所认知。】 posr truth.后真相。1992年出现，2016年11月之后大幅出现， 后真相，并不是说没有真相，而是说真相不在那么重要。 ​ 本来的含义:情绪的影响力超过真相本身。 共同体的认知，解体与重建。人类社会的文明也正在发生这样的变化。 时间战场 服务升级 智能革命 认知税 共同体危机 自律。强烈的时间管理的能力。吴军。说做几分钟就做几分钟，说现在思考就现在思考。 自律，是让自己变好然后再把事做好。死磕，是为了把事做好，而不管辛苦自己。 自律。强烈的时间管理的能力。强烈的自律能力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[箱线图]]></title>
      <url>%2F2017%2F01%2F20%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F10_%E7%BB%9F%E8%AE%A1%E5%AD%A6%2F%E7%AE%B1%E7%BA%BF%E5%9B%BE_20170120%2F</url>
      <content type="text"><![CDATA[介绍了箱线图的基本概念与意义 概念 - What利用五个统计量（最小值、第一四分位数、中位数、第三四分位数，最大值）来描述数据；一个【类别型】变量与一个/多个【连续型】变量的关系 四分位差IQR：上下四分位之间的距离； 第p个百分位点（指的是有p%个测量值在它的下面，而有（100-p）%个测量值在它的上面） 其宽度说明数据的【中间数据】的离散程度；宽度越窄，说明中间的数据越集中 IQR-Interquatile Range; 上下四分位之间的距离； 下四分位-25%，上四分位-75% 内栏：1.5倍IQR / 外栏：3倍IQR 胡须：在【内栏】内的最大/最小观测值为顶端 且是在内栏范围内的极值；若有极值超过内栏(1.5IQR)，则选取在1.5IQR内的第二大极值 较长的胡须暗示数据的偏态 异常值 1.5-3.0倍IQR之间的值~潜在异常值*表示 外栏之外-异常值-0表示 意义 - Why[why] - 了解连续变量是如何随着分类变量水平的变化而变化；作用： 识别异常值 1.5-3.0倍IQR之间的值~潜在异常值*表示 外栏之外-异常值-0表示 判断数据的偏态的和尾重（但不能提供精确测量） 对称：中位数位于方盒中央，即关于上下四分位数对称 偏态：中位数越偏离中心位置，偏态性越强； 左偏：异常值集中在较小这一侧，左偏；即尾部在左侧；说明数据位于均值左边的比较少，因为有少量数值比较小，把均值往左拉，使得均值&lt;中位数 比较几个数据的形状 四分位距大小（正常值的分布是集中还是分散）：观察方盒和线段的长短 偏态情况：分析中位线和异常值 应用 - How12ggplot(data, aes(x=类别型变量, y=连续型变量, fill=分组因子变量))+ geom_boxplot() # outer.color= , 异常值颜色(可为NA，表示不显示） 手动移除异常值 123456qnt &lt;- quantile(temp6$budget, p=c(0.25,0.75), na.rm=T)h &lt;- 1.5* IQR(temp6$budget,na.rm=T)temp6$budget &lt;- with(temp6,&#123; ifelse(budget&lt;(qnt[1]-h),NA,budget) ifelse(budget&gt;(qnt[2]+h),NA,budget)&#125;)temp6 &lt;- na.omit(temp6)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年新年目标：做一个自律的人]]></title>
      <url>%2F2017%2F01%2F16%2F%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97%2F2017%E5%B9%B4%E5%BA%A6%2F2017%E5%B9%B4%E6%89%93%E7%A0%81%E8%AE%B0%E5%BD%95%20-%20%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E5%BE%8B%E7%9A%84%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[2017年新年目标：每一天都有规律的作息（23:30前入睡，07:30前起床），并同时做好每天的记录（个人日志、学习成长） 做一个自律的人； 强大的自制力，就是告诉自己当下要做什么，那就做什么； 对自己说，现在去跑步，那就现在去； 对自己说，现在去睡觉，那就放下电脑与手机，去睡觉。 对自己说，现在看书30分钟，那就看30分钟； #以下打码记录# a-表示晚睡晚起； b-表示未做记录；如果晚睡晚起，写出你的原因 1月 2月 3月 4月 5月 6月 1.7 2.1-a 5.1-b 6.1-a 1.8-a 2.2-a 5.2-b 6.2 1.9 2.3-a 5.3 1.10-a 2.4-a 5.4-a 1.11 2.5-a 3.5 4.5-a 5.5 1.12 2.6-a 4.6-a 5.6a 6.6 1.13 2.7 3.7 4.7-a 5.7a 1.14 2.8 3.8 6.8 1.15 2.9-a 3.9 6.9-a 1.16 2.10-a 3.10 5.10 6.10-a 1.17-b 2.11-a 4.11-a 5.11-a 6.11-a 2.12-a 4.12 6.12-a 1.19-a 2.13 3.13 4.13-a 6.13 1.20-a 3.14-a 4.14 6.14 1.21-a 3.15-a 6.15-a 1.22 3.16-a 5.16-a 6.16 1.23 3.17 4.17-a 5.17-a 6.17 1.24-a 4.18-a 5.18 6.18 1.25 2.19-b 4.19-a 5.19 6.19 1.26-a 2.20-b 3.20-a 4.20-a 6.20-a 1.27 2.21-b 3.21-a 4.21 5.21-a 6.21-a 1.28-a 2.22-b 3.22 5.22-a 6.22-a 1.29-a 2.23-b 3.23 523-a 6.23-a 1.30 2.24-b 3.24-a 4.24 5.24-a 2.25-b 4.25 5.25 6.5-b 2.26-b 4.26 5.26 6.26-a 2.27-b 3.27-a 4.27 6.27 2.28-b 3.28 4.28-a 5.28-a 6.28 3.29-a 4.29-b 5.29-a 6.29 3.30 4.30-b 6.30 3.31 7月 8月 9月 10月 11月 12月 8.1-a 9.1-a 11.1 12.1 7.2-a 8.2-a 11.2-a 7.3-a 8.3 9.3-a 11.3-a 7.4-a 8.4-a 9.4 7.5-a 9.5 12.5 7.6-a 9.6-a 11.6-a 12.6 7.7-a 9.7 11.7-a 12.7 9.8-a 11.8-a 12.8-a 7.9-a 8.9-a 10.9 11.9 7.10-a 8.10 10.10-a 11.10 7.11-a 9.11-a 10.11-a 12,11-a 7.12 9.12-a 10.12-a 12.12-a 7.13-a 9.13–a 10.13 11.13 12.13-a 7.14-a 8.14-a 9.14-a 11.14-a 12.14-a 7.15-a 8.15-a 9.15-a 11.15 12.15-a 8.16 10.16-a 11.16-a 8.17-a 10.17-a 11.17-a 12.17-a 7.18 8.18-a 9.18-a 10.18-a 12.18-a 7.19 8.19-a 9.19-a 10.19-a 7.20 8.20-a 9.20-a 10.20-a 11.20-a 12.20 7.21 8.21 9.21-a 12.21 8.22-a 9.22-a 11.22-a 12.22 7.23-a 8.23-a 10.23-a 12.23 7.24 8.24-a 11.24-a 12.24-a 7.25 8.25-a 10.25 12.25-a 7.26 10.26 12.26-a 7.27-a 9.27-a 10.27 11.27-a 12.27-a 8.28-a 11.28-a 12.28-a 8.29 10.29 11.29 12.29-a 8.30-a 10.30-a 11.30 12.30-a 7.31 8.31-a 10.31 不能因为是周末，就可以晚睡晚起，甚至熬夜； 5.8~5.13：期货考证 3.25-3.26：无锡群游 2.11-2.14：杭州随游 2.19-2.28：上海求职]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书籍_2008-2012年度]]></title>
      <url>%2F2017%2F01%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB_2008-2012%E5%B9%B4%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[2008-2012年度共阅读11个大类（不完全统计），共计83本，读书笔记47本； [TOC] 类别 《书名》_作者 / 阅读时间 - 读书笔记链接 《原名》 - 原作者 一句话概括整本书的核心内容，最多不超过三句话。这个是原则。 关于一本书的概括，暂未做补充。 心理学、社会认知与发展史 《社会心理学》_周晓虹 / 2009-09 《天下大道》_奥修 / 2009-11 《道德的理由》_詹姆斯.雷切尔斯 / 2009-12 《世界简史》_中山大学历史系 / 2009-12 《101个道德难题》_马丁.科恩 / 2010-01 《汤普森谈判学》_利·汤普森 / 2010-07 《潜规则：中国历史中的真实游戏》_吴思 / 2010-07 《中国大历史》_黄仁宇 / 2010-09 《赫逊河畔谈中国历史》_黄仁宇 / 2010-09 《社会学的想象力》_赖特.米尔斯 / 2010-10 《意识形态与乌托邦》_卡尔.曼海姆 / 2010-10 ​ 思维意识与生活态度 《做人有学问》_李镇 / 2009-01 《开放你的人生》_王辉耀 /2010-03 《杠杆思考术》_[日] 本田直之 / 2011-3 《秘密》_朗达·拜恩 / 2012-03 Rhonda Byrne ​ 工作与学习方法 《像咨询顾问一样思考》_王佑 / 2010-06 《金字塔原理》_巴巴拉·明托 / 2010-09 ​ 个人与团队管理 《卓有成效的管理者》_[美] 彼得·德鲁克 / 2008-12 《卡耐基精英之道》_[美] 戴尔.卡耐基 / 2009-01 《卡耐基沟通与人际关系》_[美] 戴尔.卡耐基 / 2009-05 《一分钟自我表现术》_杰夫 / 2009-06 《团队管理》_[美]马蒂·布隆斯坦 / 2009-07 《铁军：如何打造一支过得硬的团队》_程冲 / 2009-07 《有效沟通》_桑德拉黑.贝尔斯 / 2009-09 《有效沟通：管理者的沟通艺术》_余世维 / 2009-09 《他们为什么效忠希特勒》_英克.布罗德森 / 2009-10 《时间管理》_[美]波利·伯德 / 2009-12 《时间管理：高效人士的成功利器》_朱信凯 / 2009-12 《个人效率提升系统》_赵明 / 2009-12 《培训培训师：TTT全案》_刘永中 / 2010-01 《打造无敌团队》_[英] 莱斯利.雷 / 2010-02 《培训学习手册》_[美] 大卫.梅尔 / 2010-02 《高效团队24法则》_小文斯.隆巴迪 / 2010-06 《打造高绩效团队》_余世维 / 2010-06 《哈佛团队》_向洪 / 2010-06 《忠仆：领导就是服务》_詹姆斯.C.亨特 / 2010-06 企业发展与管理 《影响世界的西方管理思想》_斯图尔特.克雷纳 / 2009-02 《IBM营销革命》_保罗.甘布尔 / 2009-03 《门槛：创业，从准备到行动》_赵延忱 / 2009-09 《营销：来自世界一流企业的4C营销方案》_方全 / 2009-10 《新直销营销》_李野新 / 2009-10 《与成功签约：CCTV赢在中国创业自问》_CCTV赢在中国项目组 / 2009-10 《史玉柱点评创业》_CCTV赢在中国项目组 / 2009-10 《只有CEO才能做的事》_雷福礼 / 2009-11 《马云点评创业》_CCTV赢在中国项目组 / 2009-11 《牛根生创业人生》_CCTV赢在中国项目组 / 2009-11 《创业企业融资》_杰弗里.蒂蒙斯 / 2009-12 《战略与竞争分析：商业竞争分析的方法与技巧》_[加]弗莱舍 / 2010-03 《麦肯锡传奇》_伊丽莎白·哈斯·埃德莎姆 / 2010-04 《麦肯锡意识》_艾森·拉塞尔 / 2010-04 《麦肯锡方法》_艾森·拉塞尔 / 2010-04 《咨询学》_余明阳 / 2010-06 《顶级咨询》_卡尔弗特.马克汉姆 / 2010-07 《管理咨询行业指南》_苏格塔.比斯沃斯 / 2010-07 《打败麦肯锡》_王瑶 / 2010-07 《从优秀到卓越》_[美] 吉姆.柯林斯 / 2010-09 《追求卓越》_[美] 汤姆.彼得斯 / 2010-09 《咨询的谎言》_[美] 马丁.基恩 / 2012-03 ​ ​ 经济学 《世纪末金融风暴》_韩文高 / 2009-11 《小的是美好的》_E.F.舒马赫 / 2009-11 《经济学原理：微观经济学分册》_N.格里高利·曼昆 / 2010-04 《经济学原理：宏观经济学分册》_N.格里高利·曼昆 / 2010-04 《增长的困惑》_[英] 理查德.杜韦斯特 / 2012-02 投资理财 《彼得·林奇的成功投资》_彼得·林奇 / 2009-11 《投资者的未来》_[美]杰里米.J.西格尔 / 2009-12 《漫步华尔街》_伯顿 G·马尔基尔 / 2009-12 ​ 人物传记 《马云创造：颠覆传统的草根创业者传奇》_杨艾祥 / 2008-12 《林肯》_[德] 艾密尔.鲁特维克 / 2009-01 《105亿传奇：黄光裕和他的国美帝国》_吴阿仑 / 2009-11 《杰克.韦尔奇自传》_[美]杰克.韦尔奇 / 2010-11 《史蒂夫.乔布斯传》_[美] 沃尔特.艾萨克森 / 2012-03 ​ 文学小说 《莎士比亚四大悲剧》_[英] 威廉.莎士比亚 / 2010-02 《哈姆雷特》《奥赛罗》《李尔王》《麦克白斯》 《围城》_钱钟书 / 2010-03 《狼图腾》_姜戎 / 2010-10 《不能承受的生命之轻》_米兰·昆德拉 / 2011-03 Milan Kundera 哲学 《超越神话：古希腊人的哲学智慧》_曹兴 / 2008-12 《逻辑学》_[德] 黑格尔 / 2009-02 《逻辑学基础教程》_南开大学哲学系 / 2009-02 《逻辑》_雍琦 / 2009-07 军事 《二战十六大战役故事秘档全公开》_侯鲁梁 / 2009-03 《孙子兵法全集》_陈才俊 / 2012-03 《三十六计全集》_陈才俊 / 2012-03 《三十六计全鉴》_东篱子 / 2012-03]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书籍_2013-2016年度]]></title>
      <url>%2F2017%2F01%2F05%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB_2013-2016%E5%B9%B4%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[2013-2016年度共阅读8个大类，共计38本（不完全统计），读书笔记29本；罗辑思维音频若干； [TOC] 类别 《书名》_作者 / 阅读时间 - 读书笔记链接 《原名》 - 原作者 一句话概括整本书的核心内容，最多不超过三句话。这个是原则。 关于一本书的概括，暂未做补充。 心理学、社会认知与发展史 《影响力》_[美] 罗伯特.西奥迪尼 / 2015-03 《意志力》_[美] 罗伊.鲍迈斯特 / 2015-04 《沟通的艺术》_[美] 罗纳德.B.阿德勒 / 2015-12 《少有人走的路1：心智成熟的旅程》_ M.斯科特.派克 / 2016-07 M.Scott Peck 《稀缺：我们是如何陷入贫穷与忙碌的》_塞德希尔·穆来纳森 / 2016-10 Sendhil Mullainathan ​ ​ 数据分析 《深入浅出数据分析》_迈克尔.米尔顿 / 2016-09 《深入浅出SQL》_[美] 贝里 / 2016-09 Beighley L. 《商务与经济统计学》_詹姆斯·麦克拉夫 / 2016-10 James T.McClave 《R语言实战》_卡巴科弗 / 2016-10 Robert I.Kabacoff 《ggplot2：数据分析与图形艺术》_哈德利·威克姆 / 2016-11 Hadley Wickham 《精通Web Analytics 2.0》 / 2016-11 《数据挖掘导论》 / 2016-11 （未完） ​ ​ 思维意识与生活态度 《地头力：从结果出发思考问题》_[日] 细谷功 / 2014-05 《锻炼“地头力”：打造你的黄金自考力》_[日] 细谷功 / 2014-07 《高效能人士的七个习惯》_[美]史蒂芬·柯维 / 2014-11 《思考的艺术》_[美]文森特·赖安·拉吉罗 / 2015-03 Vincent Ryan Ruggiero 《每周工作4小时》_蒂莫西.费里斯 / 2016-07 《80/20法则》_[英] 理查德.科克 / 2016-08 工作与学习方法 《用图表说话》_[美]基恩·泽拉兹尼 / 2013-05 Gene Zelazny 《餐巾纸的背面》_丹·罗姆 / 2014-12 《如何阅读一本书》_莫提默·J.艾德勒 &amp; 查尔斯·范多伦 / 2015-03​ ​ 企业发展与管理 《商业模式新生代》_亚历山大·奥斯特瓦德 / 2013-11 《竞争战略》_迈克尔·波特 (Michael E. Porter) / 2013-12 《市场营销原理》_菲利普·科特勒 &amp; 加里·阿姆斯特朗 / 2014-02 《领导梯队：全面打造领导力驱动型公司》_[美] 拉姆·查兰 / 2014-07 《从0到1》_[美] 彼得.蒂尔 / 2015-07 《参与感：小米口碑营销内部手册》_黎万强 / 2015-09 《星巴克：关于咖啡、商业和文化的传奇》_泰勒.克拉克 / 2016-06 Taylor Clark ​ ​ 投资理财 《巴比伦富翁的理财课》_乔治·克拉森 / 2014-12 《富爸爸穷爸爸》_罗伯特·清崎 &amp; 莎伦·莱希特 / 2015-01 《小狗钱钱》_[德] 博多.舍费尔 / 2015-01 《The Millionaire Fastlane》_MJ.DeMarco / 2016-06 虽然是一本全英文书籍，但内容很好。 ​ 文学小说 《假如给我三天光明》_[美] 凯勒 / 2014-08 《何以笙箫默》_顾漫 / 2014-11 《活出生命的意义》_[美] 维克多.弗兰克尔 / 2015-03 《小王子》_[法] 圣埃克苏佩里 / 2015-05 《皮囊》_蔡崇达 / 2016-04 自然科学 《狭义与广义相对论浅说》_[美] 阿尔伯特·爱因斯坦 / 2015-01]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《8020法则》读书笔记_Richard-Koch]]></title>
      <url>%2F2016%2F08%2F21%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A8020%E6%B3%95%E5%88%99%E3%80%8B_%E7%90%86%E6%9F%A5%E5%BE%B7.%E7%A7%91%E5%85%8B_Richard.Koch%2F%E3%80%8A8020%E6%B3%95%E5%88%99%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_Richard-Koch_20160821%2F</url>
      <content type="text"><![CDATA[第1章：80/20法则欢迎你 内燃机是80/20法则的极好诠释。在燃烧过程中，80%的能量被浪费掉，只剩下20%的能量产生动力，而这20%的投入却收获了100%的产出。 运用80/20法则取得的成就 1963年，IBM公司发现，一台电脑大约80%的工作时间是在执行大约20%的代码程序。该公司立即更新了它的操作软件，使这20%的程序更易于操作、更人性化。通过这一改革，在大多数应用领域，IBM公司电脑比缺爱竞争对手的产品更高效、快捷。 企业家，就是将经济资源从生产力低下的领域转移到生产力和产出相对高的领域。 第2章：80/20引发的思考 为谁工作比做什么工作更重要 在咨询业，80%的发展业绩主要来自于那些仅拥有20%业内精英的小公司，而且在少数公司里才会有80%的快速晋升机会。 关键一：对大多数公司而言，80%的利润来自20%的客户。在咨询业，意味着两种客户：大客户、长期客户；对大多数公司而言，赢得新客户是工作重点。但在我的公司里，真正的精英是那些长期面对大客户的人。 关键二：80%的可用咨询结果集中于来自20%最重要的问题。 投资获得的财富比工作赚的钱更胜一筹 长期投资组合所得到的收益中，80%来自20%的投资； 传统观念：不要把所有的鸡蛋放在一个篮子里 80/20法则：仔细挑选一个篮子，把所有鸡蛋都放进去，然后像老鹰一样盯紧它 柱状图显示80/20关系最佳 80/20分析法的妙用 关注引发某一结果的关键性原因 第9章：轻松自如 追求享受生活 大多数“成就”兴趣、快乐以及渴望幸福的“副产品”； 大多数人他们花很多时间和那些自己不喜欢的人在一起，做很多自己并不爱做的工作，花了很多时间在一些无趣的活动中。反过来说，他们并没有花时间和自己最喜欢的人相处，没有从事自己最喜欢的工作，也没有把大部分时间花在那些最有趣的活动上。所有这些都很奇怪。有些人会说这是经验对希望的“胜利”，可这种经验是自我构筑起来的，他们更多源自我们对外部世界的理解而非客观事实本身。也可以这样说，内疚胜于喜悦，遗产胜于智慧，宿命胜于选择，的更现实的层面上，死亡胜于生存。 80/20思维法具有非线性特点 如果你不开心，不要考虑现在的处境，多想想曾经开心的时光，并置身于当时的状态中。 如果你事业不顺，不要在细节上花费过多的心力，例如换间更宽敞的办公室、换辆更名贵的车、少工作会儿、投奔一位更体恤下属的老板；应该多想想生命中属于自己的那少数但重要的成就，并再接再厉； 适用于个人的80/20思想 80%的快乐和成就出现在我们生活中的20%的时间里，这部分时间还可以大幅提升。 每个人都能取得一些要成就。秘诀并不是努力，而是找到适合自己的目标。一个人有能力做好某些事情，但如果把大量精力用于那些自己不擅长的事情上，必然会事倍功半。 很多失败都发生在那些别人要我们参与的竞争中。相应的，多数成功也发生在那些我们自己想参与的竞争中。 人生中一个最重要的决定之一就是选择盟友。选择盟友方面失败的极端例子就是选错了重要朋友或人生伴侣。很多人有一大群朋友，但不懂得挑选核心朋友并强化这层关系。 很少有人认真思考如何获得属于自己的快乐。他们通常只是寻找一些间接目标，例如金钱和晋升。 80/20 第10章：时间革命 十大低效时间运用法 别人要你做的事 循规蹈矩完成的事 你不擅长的事 你比喜欢做的事 总是被打断的事 很少有人感兴趣的事 如你所料已经花费了2倍时间去做的事 与不可靠或办事效率低的合作伙伴一起做的事 可预期进程的事 接电话 十大高效时间运用法 推进人生目标的事 你一直想做的事 符合80/20时间结果关系的事 用创新法做那些能大幅节省时间或提高品质的事 他人告诫你不可能完场的事 他人已经在其他领域取得成功的事 运用自己创造力办事 别人可以替你做而降低自身工作强度的事 以独特方式运用时间的伙伴一起做的事 千载难逢或稍纵即逝的事 第11章：心想事成 从生活方式开始 问题 回答1（定义对你来说什么是合适？） 回答2 是否在与适合自己的人共同生活？ 现在一个人生活，很少主动联系朋友 是否在合适的地方生活？ 国内来说的话，就是“成就导向”，以能够让自己职业发挥的城市，eg：上海、深圳 健全的基础设施； 高素质的人群； 并非如此；目前在福州 工作时间长短是否合适？符合我理想的工作、娱乐节奏以及我的家庭和社会需要？ 第一阶段：对于“成就导向”的我，更多的时间在于提升自己，努力学习/工作会更适合； 第二阶段：希望将自己从工作的时间中解放出来，但做的事依然会围绕提升自我，可能是阅读，可能是旅游，也可能是继续工作 把握住自己的生活了吗？ 一直都没有把握自己的生活，因为她的原因，一直都比较混乱 能随意活动和沉思吗？ 周围的环境总让我感到放松和舒服吗？ 很多情况下，是把自己封闭；过自己一个人的生活。 我的生活方式是否有助于发挥自己的创造力和潜能？ 没有 我的钱够用吗？所有事情是否都安排得仅仅有条而无需我操心？ 钱不够用。 我的生活方式有益于改善我想帮助的人的生活吗？ 我能经常见到自己的好朋友吗？ 可以；但主要是自己没有主动去联系； 生活中出差旅行的频率合适吗？不太多也不太少吗？ 这种生活方式也适合我的搭档和家庭吗？ 已经拥有想要拥有的一切了吗？ 没有 关于工作：那种事业最让人快乐 事业的六种类型 喜欢在组织里工作 喜欢做自主创业的专营商 喜欢组织或雇佣别人 追求成就期望值-高 有雄心，但他们更喜欢在有组织背景、管理机制健全的公司上班 他们是专业人士，渴望得到同行认可并成为该领域的领头人； 他们希望独立经营，不适应组织生活，除非该组织对他们采取近乎放纵的态度。这类人喜欢单打独斗，既不希望在专业方面受制于人； 富有干劲和雄心，不喜欢被雇佣但又不想过单打独斗的生活。 他们能超越传统，成为建设者，希望建造自己的网络和结构； 追求成就期望值-低 某有事业心，但喜欢和别人工作的人。 没有雄心，但在工作中要求高度自主的人； 他们更适合成为自由职业者，为别人做项目，自己自由自在 很多老师、社会工作者、义工都属于这一类，并且很好地扮演了自己的角色；对他们而言，过程重于结果 关于成就 想想你过去的成就 那些市场反响最为强烈的成就，以及那些好评如潮的成就，它们是否仅占工作量的20%却收到80%的好评？你从中得到了多少真正的满足感？ 对你而言，什么方法曾经最有效？谁是合作伙伴？谁是观众？ 然再想想80/20法则，那些只能产生一般满足感的时间或努力都应该抛弃，想想那些很轻松就完成的高水平表现。不要把自己就局限于过去 工作经历，把你的时间当成学生、旅行者或者朋友。 展望未来，什么是能让你骄傲而别人却无法轻松实现的成就？ 如果现在你身边有100个人都在做这件事情，什么是你花20%的时间而他们却要花80%的时间才能完成的？在这20%的时间你处于什么样的位置？更确切点，什么事是你用20%的时间做的比他们花费80%时间做的还好的？请相信我，它们都有答案！人在不同领域中的能力千差万别。 【做规划，整体计划，信息的输出，数据的处理】 如果快乐可以衡量，你比绝大多数同行更喜欢的事是什么？又有什么事你比他们做的更好？什么样的成就满足上述两个条件？ 第12章：交友贵在精 绘制20个最重要的人际关系表 按照重要顺序依次写下对你最重要的20个人的名字（包括你的朋友、爱的人、你有最重要关系的人） 重要意味着这种人际关系的深度和亲密度：这种关系给过你什么程度的帮助；它对你认识自己是什么样的人、有何作为而言有什么意义 从利益角度来看，你的爱人或搭档排在表里的什么位置？ 假设现在共有100分，你需要按照重要程度依次给这些人打分。比如，如果你觉得第一个人跟接下来的19个人加起来的重要性一样，那就打50分。但要确保总数是100分 再仔细回想与每个人相处、交谈或者共同做事所花费的时间有多少。把花在这20个人身上的时间分成100份，然后分摊给这20个人 第13章：聪明和懒惰 多挣钱少工作的关键在于选择合适的事去做，而且只做获益最多的事。 职业成功的十大律条 在较小的职业环境中精益求精，培养核心技能 要想找到属于自己的领域并不是一件容易的事，但这却是唯一能让你活动高额回报的方法 找一份自己喜欢的工作，脱引而出，有朝一日成为公认的领导 明白“知识就是力量”的道理 确定你的市场区域和核心客户，全力服务 你的市场是那些购买你只是的人 核心客户是那些最看重你的服务的人 不管你受雇于人还是自主创业，你都有核心客户，而他们正是你维持成功的关键 找出在哪一领域能用20%的努力取得80%的回报 向最出色的人学习 尽早自主创业 尽可能多地雇佣创造净产值的员工 除了核心技能外，其他业务尽可能外包 依据杠杆原理进行资本运作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《每周工作4小时》读书笔记_蒂莫西.费里斯]]></title>
      <url>%2F2016%2F08%2F18%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%2F%E3%80%8A%E6%AF%8F%E5%91%A8%E5%B7%A5%E4%BD%9C4%E5%B0%8F%E6%97%B6%E3%80%8B_%E8%92%82%E8%8E%AB%E8%A5%BF.%E8%B4%B9%E9%87%8C%E6%96%AF_Timoth.Ferriss%2F%E3%80%8A%E6%AF%8F%E5%91%A8%E5%B7%A5%E4%BD%9C4%E5%B0%8F%E6%97%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E8%92%82%E8%8E%AB%E8%A5%BF.%E8%B4%B9%E9%87%8C%E6%96%AF%2F</url>
      <content type="text"><![CDATA[问题和行动【加入自己的思考和行为模式中】 2.改变规则的规则 “现实主义”和“责任心”如何把你阻挡在你想要的生活之外？ 做你“应该”做的事情，如何减少了你的人生经历，又如何使你后悔没尝试其他事情？ 查看自己现在做的事情，然后问自己一个问题：“如果我做的事情与周围的人做的截然相反，那会发生什么？如果按照现在的轨迹继续工作5年、10年、20年，我会失去什么？” 3.躲避攻击 你下决心做你现在想做的事情，最坏的情形是什么？用1-10级来评级，这种影响是几级？这种状况是永远的吗？发生这个情况的概率是多少？ 对于要发生的糟糕情况，你能采取什么补救措施？如何能让事情回到正轨，哪怕只是暂时性的？ 事实是，事情总比你想象的容易。 无论是暂时还是永久，最可能发生的事情的好处/结果是什么？并对他们评级，可能性是多少？ 如果今天你被解雇了，你靠什么来维持？ 考虑一下，如果你因尝试其他选择而辞职，日后又不得不重返旧业，那你怎么办？ 你因恐惧而迟迟未进行的计划是什么？ 通常，我们最恐惧的事恰恰是我们最应该做的事。 推迟行动的代价是什么？ 具体衡量出来 你在等什么？ 比“最坏结果分析”更进一步的思考 【书面化】不仅仅是大体思考一下，而必须是可以用书面表达出来的那种明确的想法 ———分割线————– 写在前面 巧妙利用汇率差，或者尽可能将琐事外包出去 为什么要把人生最好的年华花费在畅想最后那几年的幸福上？ 先找到市场再生产产品，远比反过来聪明得多 第一步：D-定位 1.警告与对照 新贵阶层NR VS. 延期生活者D NR D 使别人为自己工作 为自己工作 绝不为工作而工作，花最小的代价达到最大的效果 想工作的时候工作 定期分配一生的休假期和冒险期（迷你退休）； 意识到完全休息并不是目标，做令人兴奋的事才是真正的目标。 尽早退休或趁年轻退休 既不当老板也不做员工，只做拥有者。 就好比拥有一辆火车，但雇佣别人来保证火车按时运行。 当老板，不做雇员，希望成为有掌控力的一方 赚很多钱，但要有质量的赚钱，避免杂乱无章。 拥有大量资金储备，但同时心里清楚，大多数物质需求只是为在不紧要的事物上消磨时间提供的一个借口。 赚很多钱 目标宏大，但确保每日收入稳定。现金流第一，日进斗金次之； 获得最大的利益 从不得不做不喜欢的事情的状态中解脱出来，同时有追求梦想的自由和决心； 从不得不做不喜欢的事情的状态中解脱出来 首先原则是不错欺骗自己，而你自己是最容易被欺骗的人。——理查德·费曼 一旦你表示能接受备选方案，通常事情就果真如此了。——约翰·F.肯迪尼（1917-1963，美国第35任总统） 2.改变规则的规则 3.躲避攻击 做还是不做？尝试还是不尝试？无论他们认为自己勇敢与否，大部分人会投反对票。未来的不确定性及失败的可能性，总会令人恐慌和焦虑，在不确定性与不快乐之间，大部分人会选择不做，也不尝试。 只有工作到了像炼狱一般的程度，人们才会去真正有所行动。只要还没到那个地步，人发明都会有足够的耐心和理性忍受下去。【很多事情都有一个临界点，很多事情我们没有采取行动，不是人们不明白，更可能是还没有到达那个难以忍受的临界点。】 和一年之前相比，你的状况真的改善了吗？和一个月前比呢？一周前又如何？ 如果答案是否定的，那么事情显然不会自己变好。如果你一直在自欺欺人，那么现在是时候清醒并准备好改变了。 我是个老人，我也听说过相当多的磨难，但它们大部分并未发生。——马克·吐温（1835-1910） 4.重置系统 理性的人让自己适应世界，非理性的人坚持让世界适应自己。所以，所有的进步都靠非理性的人。——萧伯纳（1856-1950，爱尔兰剧作家，诺贝尔奖获得者） 《致革命者的箴言》 做一个不现实的人更容易（非理性和不现实的目标更容易实现的原因） 不要总是高估对手而低估赞成，你比赞成想象的要强的多；只要相信它不难就可以； 当你有了宏大的目标，同时就拥有了为达到这个目标而克服考验和磨难的毅力； 大多数人工作到死的那一天的原因很可能是：有了X元之后我就不干了，我就做自己想做的事情。 如果没有明确“我想要什么”的替代事物（什么事情让我充满激情），那个这个替代维度里的空白所带来的对不确定性的恐惧，就会使这个X的数额无限增长。 第二步：E-精简 第三步：A-自控 第四步：L-解放 写在后面]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《少有人走的路》读书笔记_M.斯科特.派克]]></title>
      <url>%2F2016%2F06%2F28%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F30_%E8%A1%8C%E4%B8%BA%E5%BF%83%E7%90%86%E5%AD%A6%2F%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_M.%E6%96%AF%E7%A7%91%E7%89%B9.%E6%B4%BE%E5%85%8B_20160628%2F</url>
      <content type="text"><![CDATA[序 人可以拒绝任何东西，但绝对不可以拒绝成熟。拒绝成熟，实际上就是在回避问题、逃避痛苦。 几乎人人都有心理问题，只不过程度不同而已；几乎人人都有程度不同的心理疾病，只不过得病的时间不同而已； 逃避问题，心灵就会永远停滞不前。 第一部分 自律P16 问题和痛苦 人生苦难重重，这是个伟大的真理。它的伟大之处在于，一旦我们领域了这句话的阵地，就能从苦难中解脱出来，实现人生的超越。只要我们真正理解并接收了人生苦难重重的事实，那么我们就会释然，再也不会对人生的苦难耿耿于怀。 解决人生问题的关键——自律。 人生是一个不断面对问题、并解决问题的过程。“唯有痛苦才能给人带来教益。” 所谓自律，就是主要要求自己以积极的态度去承受痛苦，解决问题； 推迟满足感 承担责任 忠于事实 保持平衡 P19 推迟满足感 按一天7个小时算，1个小时的痛苦加上6个小时的幸福，显然比1个小时的幸福加上6个小时的痛苦更划算 推迟满足感 = 面对问题并感受痛苦 + 解决问题并享受更大的快乐 P22 子不教，谁之过 在孩子明显需要培养自律能力的时候，我们不是挑起担子，而是不耐烦地说道：“我没精力管你们，你们想怎么样，就怎么样吧！”到头来，当孩子犯下错误逼我们不得不采取行动的时候，我们就会把满腔怒火发泄到他们头上，不是打就是骂。我们根本不愿去调查问题的本质，也不考虑什么样的方式才算适合。父母习惯用严厉的体罚教训孩子，本质上不是教育，而是发泄自己心中的怨气和不满。【孩子的教育】 父母的爱，决定这家庭教育的优劣。父母付出的努力越大，孩子就会意识到自己在父母心中的价值。 “我是一个有价值的人”——像这样对自我家孩子的认可，是心理健康的基本前提。如果我们认为自己很有价值，就会认为我们的时间也很有价值。 孩子到了六个月大，就会意识到自己是一个独立的个体。【孩子小时候若只得到父母口头上的承诺而父母没有兑现的话，孩子会缺乏安全感，然后宁肯提前透支将来的快乐和满足，也不愿意推迟满足感。】 P28 解决问题的时机 发现问题，直面问题。不要逃避，更不要认为问题会随着时间而自行消失。 P37 神经官能症与人格失调症 神经官能症：为自己强加责任；归因于自己； 挂在嘴边的话，“我本来可以”“我或许应该”“我本不应该” 人格失调症：不愿承担原本属于自己的责任；归因于他人； 挂在嘴边的话“我不能”“我不可能”“我不得不” P41 逃避自由 为个人行为承担责任，难处在于它会带来痛苦，而我们却像躲开这种痛苦。【意愿与结果的冲突】 P47 移情：过时的地图 移情：把产生和适用于童年时间的那些感知世界、对世界做出反应的方式，照搬到成年后的环境中，尽管这些方式已经不再适用于新的环境。 最初的结论是“我不能相信父母，他们是不值得信任的。”后来进一步移情为“我不能相信任何人，没有谁是靠得住的” 【启发“爱的语言”不同，跟每个人的童年有关；我自己是“有品质的时间”，这是因为小时候基本都是一个人度过，缺少朋友与父母的旁陪伴】 P52 迎接挑战 接受心理治疗，大概是一种最违反人类本性，却又最具有人性的行为。 P63 保持平衡 保持平衡的最高原则就是“放弃”。经过人生旅途的急弯时，都必须放弃某些快乐，放弃属于自己的某一部分。除非永远留在原地，中止生命之旅，否则这样的放弃是不可避免的。 各阶段需要方式的东西 无需对外界要求做出回应的婴儿状态 无所不能的幻觉 完全占有父亲或母亲（或二者）的欲望 童年的依赖感 自己心中被扭曲了的父母形象 青春期的自以为拥有无穷潜力的感觉 无拘无束的自由 青年时期的灵巧与活力 青春的性吸引力 长生不老的空想 各种各样暂时性的权力 身体永远健康 自我以及生命本身 P67 放弃与新生 消除由个人经验产生的成见之后，才会获得成熟的认识。 一个人是否杰出和伟大，视其承受痛苦的能力而定，而杰出和伟大本身，则会给人带来快乐和幸福。——这表面上一种悖论，其实不然。 第二部分 爱P78 爱的定义 爱，是为了促进自己和他人心智成熟，而不断拓展自我界限，实现自我完善的一种意愿。 爱与非爱最显著的区别： 首先，就在与当事人意识和潜意识中的目标是否一致。 其次，爱是一个长期、渐进的过程。 第三，真正意义上的爱，既是爱自己，也是爱他人。 爱一个人却没有付诸行动，就等于从未爱过。在付出爱的时候，一定是出于自觉自愿的选择，即主动选择去爱，而不是一种被动的强迫。 P81 坠入情网 永远活在自我界限中，只会给人带来孤独。 在某种意义上，坠入情网是情感和心灵的一种退化。与心爱的人结合在一起，跟童年时与父母相伴的记忆彼此呼应，让我们仿佛又体验到幼年时无所不能的快感，又感觉到自强大有力，似乎没有什么能组织我们实现愿望。情侣只有在脱离情网之后，才能够真正相爱。 当恋爱的激情到来时，你可以凭借愿望和意志力来控制恋爱的激情，却不能凭空穿创造出激。倾心于自我界限以外的对象，就会使之占据我们的心灵。 P90 再谈自我界限 被自我界限之外的对象所吸引，促使我们产生冲动，想把激情乃至生命献给对方，这种状态称之为“精神贯注”。 P94 依赖性 没有别人就无法身生存，意味着你是个寄生者，而对方是寄主。真正的爱是自由的选择。真正相爱的人，不一定非要生活在一起，只是选择生活在一起罢了。 他们不在乎依赖的对象是谁，只要有人可以以来，就会心满意足。 所谓消极性依赖，是指患者只在乎别人能为他们什么，却从不考虑自己能为对方付出多少。 仅仅把得到别人的爱当成最高目标，你就不可能获得成功。想让别人真正爱你，只有让自己成为值得爱的人。 童年时得到父母持续关爱的孩子，成年后就懂得珍惜自己，并坚信自己是值得爱的，是有价值的。 P102 精神贯注 我们真正爱的对象应该是人，并且只能是人。我们看重的，是宠物对我们的依赖性。 P105 自我牺牲 爱绝不是无原则地接收，也包括必要的冲突、果断的拒绝和严厉的批评。 受虐狂还有一种错误观念：他们一厢情愿，把自己我牺牲当成是真正的爱。 很多时候，我们自称为别人着想，可能知识为了逃避责任呢，满足自己的愿望：我们所做的一切都是出自个人的意愿，核心动机是满足自我的需求；不管为别人做什么事，真正的原因都是为了自己。我们真心去爱某个人，是因为我们自己需要去爱别人；我们生儿育女，是因为我们想要孩子；我们爱自己的孩子，是因为我们渴望自己成为充满爱心的父母。真正的爱能够使人发生改变，在本质上是一种自我扩展，而非纯粹的自我牺牲。 区别爱与非爱的关键不是自私或是无私，而是行为的目的。真爱的目的永远都是促进心智的成熟。 第三部分 成长与信仰 第四部分 恩典]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《晨间日志的奇迹》读书笔记_佐藤传]]></title>
      <url>%2F2016%2F06%2F28%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F30_%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F%2F%E3%80%8A%E6%99%A8%E9%97%B4%E6%97%A5%E5%BF%97%E7%9A%84%E5%A5%87%E8%BF%B9%E3%80%8B_%E4%BD%90%E8%97%A4%E4%BC%A0%2F%E3%80%8A%E6%99%A8%E9%97%B4%E6%97%A5%E5%BF%97%E7%9A%84%E5%A5%87%E8%BF%B9%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%BD%90%E8%97%A4%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[The Miracle with aDaybreak Diary 序 一定要用电脑来写日志：便于查阅+开启左右脑 早上写日志的五个优点 可以做好一天的准备；（计划性） 可以准确的记录前一天发生的事情；（效率&amp;记录性） 冷静思考前一天的事情，可以中立地看待事情；（客观性） 早上的时间相对自由；对于一个午餐和晚餐都要忙于迎合客户的上班族来说，早上是自己是最自由自在的个人时间，不会让写日记的习惯中断，（持续性） 可以将过去宝贵的经验或回忆，运用在当天。（灵活性） 只是，光只是在”早上”写日记是不太够的，重要的是”写了什么样的内容”。把发生的事情记录下来，不叫做”日记”，只是单纯的”日志”而已。但是，假如你是为了实现自己的梦想而写日记，就不能忽略”情绪”这一环了。事件和情绪通常是一起被刻画在脑海里的。假如只记录下所发生的事件，而没有记录下情绪的话，要回忆当时的事件是很困难的一件事。假如能够同时记录下情绪的话，回忆事件的准确率将会提高二倍、甚至三倍以上。因为情绪比较容易在我们的脑海留下深刻的记忆。 第1章 为什么要早上写日志 “晨间日记”可分成二部分。 书写过去发生事件的”过去日记” 书写今日应做之事、及未来想执行事项的”未来日记”。 从那时候开始，我就改成以“连用日记”的形式来写日记，于是我看到去年同一天的日记内容。里面的内容记录了我去参加某位女性的结婚典礼。也就是说，这一天对这位女性来说，是第一个结婚纪念日。因此，我便在”今天”的日记栏里写下”要送花给XX小姐”的句子。 “夜晚日记”里面，不管好事或坏事，在写日记的当下，情绪都会受到当天情绪或事件的影响。因此一不小心，很容易就会变成极端的”后悔日记”或”反省日记”。变成只是一种在表现自己”今天好快乐”、”今天好好玩”的日记而已。这样子的内容，无法让自己了解到自己为什么成功，或者为什么失败。假如只单纯写下自己情绪的话，回头看日记时，无法知道自己为什么会产生那样子的情绪，也无法得知最重要的原因。根本搞不懂”为什么我自己会这么开心?”或者”为什么我自己会这么难过?”。 “未来日记”指的就是书写未来计划的日记。可以是具体的行动，也可以只是一个决心。 从今天一天的预定行程当中，选择一个最重要的行程，同时也可以写下自己想要达成的目标与决心。，写下”我今天一定要达成这件事”的字句，哪怕只写了一行也没有关系。很多人应该都有这样子的经验，前一天告诉自己”绝对要达成某件事”，但是到了当天却完全忘记了，结果到头来还是没有达成，只要借由”晨间日记”，在当天早上把自己的决心写下来，就绝对不会忘记自己应该执行的计划了。 因为“写晨间日记”的时间是介于过于与未来的”早上”，因此让我们更接近美梦成真的时点。”晨间日记”拉近了我们与美梦成真之间的距离。为什么呢?因为书写”晨间日记”可以让我们看清楚什么是最重要的问题，不会让我们像一个没有梦想的人一样，常常将自己欲执行事情的先后顺序颠倒了。常感叹梦想迟迟未能实现的人，就是因为他们只处理”很’紧急’但‘不重要’的事情”。 不是运气好的人抓住了机会，而是不懂得经常把梦想放在心上的人，让大好机会逃走了。 有一天，我在”晨间日记”里写着一行文字:”我干脆厚脸皮一点，去跟小田先生说说看好了。”小田全宏先生(日本政策FRONTIER理事长)已经在几家出版社出版了好几本书。于是，在那一天的下午，我竟然偶然地遇到了小田先生。因此，我便向他提到我想要出书的想法，小田先生便马上把我介绍给出版社。到出书之前，一切并没有很顺利，过程中也是遇到了很多困难。可是，假如我没有把”想出书”写在未来日记上的话，就算我遇到了小田先生，也无法谈及出书的话题，可能只是互相寒暄，谈谈天气就和对方道别了!最近我终于懂了，世上成功的人常常在说的”运气”，其实是成功的必要元素。成功者懂得抓住突然出现的机会，以旁观者的立场来看，也许会觉得成功的人运气真好，事实上，这是因为成功者经常把自己的梦想放在心上，懂得适时地抓住每一个机会不让良机逃走。 晨间日志给我带来改变的原因： 不知书写昨天（过去）发生的事情，也要写下自己的情绪 借由写下今天（未来）执行决心，可以改变行为模式 顺利的话，梦想有一天就会梦想成真表 过去 未来 事实 IQ Intelligence Quotient （智慧指数） NQ Network Quotient （人际关系指数） 感情 EQ Emotional Quotient （情绪指数） DQ Dream Quotient （梦想指数） 【IQ:智慧指数,智商】 将过去所发生的事情客观地写在日记里，可以冷静地分析所发生的事情，以刚才我所举的例子，因为写了”晨间日记”，我可以冷静地去思考工作人员所犯下的错误，进而了解不是工作人员的能力出问题，而是自己和工作人员之间的沟通出了问题。可以察觉到这件事，就是因为我的IQ指数变高了。 【EQ:情绪指数,情商】 在过去所发生的事件当中，可以冷静地将自己的情绪写在日记里，可以让自己更了解自己的价值观和人生观。同时也可以让自己更能够控制自己的情绪。就拿我来说好了，写了日记之后，我的想法变得跟以前不一样，态度变得更积极、更正面了，同时这也代表我的EQ指数增加了。 【NQ:人际关系指数】 写下今日执行决心的未来日记，可以帮助我们提升人际关系，提高沟通能力。在先前我举的例子当中，我写下了”AA先生，对不起!”、“要送花给XX小姐”的字句，后来也因为我真正去执行了，所以我的人际关系也变得更好了。写下未来的计划，其实只是一种”预计的企划案”而已。“人”的参与才是最重要的要素。“对某某人做某件事”、“和某某人一起做某件事”等的写法，请务必牢记在心! 【DQ:梦想指数】 写下对于未来事项的执行决心和坚定态度，可以提高实现梦想的能力。因为我写了”我干脆厚脸皮一点，去跟小田先生说说看好了“的字句，所以我实现了出书的美梦。为了实现梦想而写”晨间日记”的人，不一定每天都要写下自己当天预定执行的计划，重要的是，要把自己实践梦想的决心写下来。每天都写同样的字句也没有关系。只要每天、每天不断地写，就可以让我们常把梦想放在心上，只要能够常把梦想放在心上，就不会错过良机了。 也就是说，一个对未来满心期待的人，是可以自己早起的。相反地来说，心里对未来没有一点期待的人，就会想要赖床。实现梦想的行动或生活态度的时间，不能只是偶尔的”期待”，必须是长期的”期待”，而且是可以平稳、长期持续下去的”期待”。 “日出”的时间。我认为在太阳升起的时间，借由太阳光的唤醒而起床是最好的。所以，夏天与冬天的起床时间也是不一样的。其实同为夏天，在北海道和冲绳的起床时间是不一样的。总之，配合大自然的韵律很重要。 早上是自己与自己相处的最好时间。我们只要一出家门，就会被卷入”混杂的世界”当中。 利用早上的闲暇时间，跟自己对话，可以重新检视自己真正想走的道路、也可以重新再检视大局。虽然大家都觉得和别人的沟通能力很重要，但是和自己沟通的能力也是很重要的。 “人们为了过更好的生活而庸庸碌碌，在以为打造了良好的生活品质同时，却也失去了生活。”——By 赛尼加(Lucius Annaeus Seneca) 第2章 借由日志实现梦想的方法 我和某位数一数二的现金借贷公司的董事长见面时，他说了这一番话：“这个世界上应该没有一位成功者是不写日记的吧！没有写日记习惯的成功者，就好像一位没有携带航海图，而绕行世界一周的人。” 写日记的五大优点如下： 提升写作能力 谈话题材源源不断 提高贵人运 耶鲁大学的密尔克拉姆教授，曾经提出过的“六度空间”理论。依照这个理论的说法，世界上的所有人都是联结在一起的，只要能够将自己和六位朋友之间，维持环环相扣的关系，每个人都可以和世界上的所有人接轨。 珍惜每一次与别人相遇的机会，并且将遇到对象的相关情报都详细记录下来，就可以提高自己的贵人运了。 发现自我肉体与精神的状况及模式 在自己身上挖宝，彻底改变人生 为了将写日记变成每天的习惯，一次花上三十分钟的时间来写日记，是无法让写日记成为习惯的。写好的日记，必须是可以提供自己在必要的时候，能够拿起来反复阅读的。假日有空的时候，偶尔也要拿起日记来看。每天都要写的话，必须每天写上三分钟，才可以称得上是一种“习惯”。假如没有办法让写日记变成一种习惯的话，梦想和目标都无法顺利达成，所以一星期至少要写上三分钟的日记。 日记是创作灵感的来源。 “人一过了三十岁之后，留下的只有习惯”。生活习惯是从别人身上所习得的习惯；但成功习惯，就必须靠自己培养。 “我是一个有梦想的人。而且，我的成功习惯可以帮助我实现梦想。所以，我不想把我伟大的精力花费在无谓的琐事上。我没有时间对小事犹豫。我想把自己全身上下的宝贵能量，用在实现自己的梦想上。” ​ 晨间日志的三大功效：镇静功效、健康功效、记录功效 只看眼前的事情，是无法改变现状的。改变视线的方向，看看遥远的远方，便会在意想不到的地方，突然找到突破的关键。我在自己遇到瓶颈，感到痛苦的时候，都会反复地阅读日记，有好几次看着、看着，都有一种恍然大悟的感觉。去年的今天、两年前的今天、三年前的今天……，在相同的日子里，渐渐不可思议地发现自己的共通点，例如思考方式、行为模式、乃至于情绪方面都可能出现相同的状况。在束手无策的时候，请拿起过去的日记来阅读吧！你一定会看到某一行文字，是可以帮助你突破现状的，这一行文字便可以引导你解决问题。 “晨间日记”一定要每天早上写，所以当你每天早上都打开日记的时候，看到前一天的日记之后，绝对不会忘记前一天所写的事情。【要取回顾前一天的事情】 每个人都会听到一段话，对自己来说就是十分受用的。当自己遇到这种宝贵启示时，只要简单地将它记录下来，往后随时都可以翻阅。 人类是为了做自己喜欢的事，为了活得快乐而来到世界上的。应该不是为了不造成别人的麻烦，才来到世界上的。要不要试着从”不要给别人添麻烦”这样的咒语当中，解放自己呢？ 第3章 开始写晨间日志 所谓的“连用日记”指的是，2000年的1月1日、2001年的1月1日，2002的1月1日……好几年的同一天，都显示在同一页的日记。可以让我们将去年的今天、前年的今天，所发生的事情与情绪做比较，并且记取教训，活用于未来。因此，我们不需要专程去看去年的今天、前年的今天所写的日记，只要我们想看，随时都可以找到当天的日记内容。 工作、金钱、健康、人际关系 这四个栏位，是一定要先设定的。为什么呢？因为这四点是我们追求人生幸福所必备的条件。 写“晨间日记”的时候，先写上天气（“写日记仪式”。也就是说，先借由动笔，来让写日记这件事情变得很简单。） 记录天气，可以让我们在重复阅读日记时，通过回忆当天的天气，连带想起当天所发生的事情 可以让你写日记写得更得心应手。记录天气，完全不需要想太多，每个人都可以很快地把当天的天气写下来。在写日记时，只要有两个或三个简单便可记录的内容，“写日记”这件事情就变得简单多了。 写日志的步骤 写上天气 将昨天发生的事情与情绪写在昨天那页的栏位里 看看去年或者前年的今天日志 在刚开始写“晨间日记”的前七天，请只写“好事”。 “晨间日记”变成习惯之后，当你感觉日记已经成为生活一部分的时候，再开始慢慢地反省自己就好了。即使如此，写了一个反省的地方之后，也要再写三个优点来鼓励自己。 晨间日记要素： 主体划分为两部分，用时间区别出两个维度： 即回顾过去的记录，以及立足当下并面向未来的记录，前者侧重于反省，以及便于未来回忆，后者则重在记录应做和意图执行的事项； 内容主要分为两方面，即事件与感受（情绪）； 不偏重一面——不至于因为只写情绪而让自己变得跟着情绪走，也不因为单纯的事实描述而不易唤起记忆；具体的操作中，主要是分栏，将工作、理财、健康、人脉等方面。 五个大分类 【工作方面】 自我能力开发 经营 管理 采购 与部门负责人配合学习 资格 娱乐及体育活动 策划案 创意 推广 【金钱方面】 收入 支出 购物 股票 资产 储蓄家庭支出/日常支出 信托投资 【健康方面】 饮食 日常运动 性生活 减肥 身体状况 专业健身体重 脂肪 【人际关系方面】 父母 家人孩子 亲戚 恋人 工作伙伴 朋友/熟人 其他联络事项 人际网络 【兴趣方面与其他】志愿者活动阅读 运动 服饰 美容 电影 音乐 游戏 喜欢的物品 开心的事 今天的注意事项 第4章 数位“晨间日志” 我所建议的“晨间日记”，并不是公开的日记。只是单纯为了自己而写的秘密日记。写的人是自己，看的人也是自己。而且是自己面对自己的，自己与自己对话的“真心话”日记。让自己真实地面对自己，可以让自己静静地与自己对话的日记。没有虚假，是一个充满了真心话的世界。 通常我们在拿笔的时候，只会用自己惯用的那一手来拿笔，但使用键盘打字，必须同时用到双手。所以数位的“晨间日记”，可以在一大早的时候，让你的双边大脑——右脑和左脑开始运作，同时也可以预防老人痴呆症。 制作晨间日志 直的为11列，横的为3栏。 在九个正方形的正中央的正方形上，写上自己想要写的日记类别名。 可以在各类别名字的栏位，及基本数据的栏位涂上自己喜欢的颜色。你也可以改变书写文字的颜色。 可以将自己的座右铭、自己喜欢的美辞佳句，或者每天你一定要大声念一次的一句话，也写在雏型页面上，在做成其他页面时一起复制。 用声音写“晨间日记” 昨日的日记用键盘来写； 当天的计划与决心，我使用声音输入法来写。 一是因为感觉比较多样化、比较好玩， 二是因为，通过手写和手指输入文字，可以让我们更仔细地分析过去事情。 假如我们用自己的声音大声将未来即将要执行的动作、目标念出来，反而更可以激发我们的行动力，提升自我的士气。 第5章 七天作战法 原则一：早上不要花三分钟以上的时间 到目前为止，挑战了好几次，还一直无法将写日记变成习惯的人，就是因为他们花了太多的时间在写日记上，而让写日记变成负担，最后才无法长久持续下去。所有重要的事情，只要花三分钟就可以书写完了。假如想写的内容太多，可能会超过三分钟的话，只要在自己时间较充裕的时候，再把内容补起来就可以了。 原则二：先决定书写的地点 使用笔记型电脑写晨间日记的人要特别注意了。在任何地方都能写“晨间日记的话，最后可能会变成任何地方都无法写晨间日记。 每天持续做相同的动作，便是习惯化的第一步。 因为要写的是自己面对真实自己的晨间日记，所以最好选择一个听不到电视声音、听不到窗户外面公车声音的地方。 原则三：写一个字也没关系 作战守则一：开心日记作战法 在写日记还没有变成习惯之前，记得只要写“快乐的事情”就可以了。 作战守则二：ONE TWO作战法 让写日记变成是一个很自然的动作。比方说，从书架上将日记薄取下，再将日记薄放在桌子上的动作，跟日记薄一开始便放在桌上相比，哪一种模式比较容易让自己开始写日记呢？ 简单的ONE、TWO两个动作，是最容易变成习惯的。 作战守则三：“巴甫洛夫的狗”作战法 作战守则四：奖励自己作战法 作战守则五：宣告众天下作战法 作战守则六一一千日作战法 作战守则七：为别人努力作战法 “成功完成大事的秘诀只有一个，那就是努力地实现每一件小事。” 第6章 DQ Power 有梦的人、没有梦的人 假如自己没有明确的前进方向，一切会变得如何呢？ “总之，先拿个证照吧！” “总之，先以争取上位为目标吧！” “总之，先找个工作吧！” “总之，先念英文吧！” 总之，总之，总之……。 这简直和待在猴山里的猴子一样，看能不能尽量地爬到猴山顶端去。 “为什么你要以登上猴山顶端为目标呢？” “因为其他的猴子也是这样啊！” 给现在的自己打一百分：总觉得自己还有某些部分是不足的，所以，有些人会觉得，只要把自己不足的部分补齐，“应该”就可以了。 “假如我有车的话，应该就会很快乐！” “假如我有房子的话，应该就会很幸福！” “假如我能拿到一张证照，应该就会很吃香！” “假如我找到了另一半，内心的空洞应该就可以补齐了吧！” 可是，事实真的是这样吗？ 只是看自己没有的东西，我想，永远没有满足的一天吧！反而会每天都陷于“无法补足空洞”的焦虑中，一直无法从“未达成”的不安情绪中逃脱出来。 吃亏或占便宜都无法获得幸福 这就是DQ(Dream Quotient)，我把它取名叫做“梦想指数”。自己的梦想指数过低的话，只能过每天被眼前事物追着跑的生活。一天结束，当自己会意过来时，竟然发现自己一整天所过的生活，竟然只是回电子邮件和整理文件而已。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《活出生命的意义》读书笔记_维克多.弗兰克尔]]></title>
      <url>%2F2016%2F06%2F21%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F30_%E8%A1%8C%E4%B8%BA%E5%BF%83%E7%90%86%E5%AD%A6%2F%E3%80%8A%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%BB%B4%E5%85%8B%E5%A4%9A.%E5%BC%97%E5%85%B0%E5%85%8B%E5%B0%94_20160621%2F</url>
      <content type="text"><![CDATA[《活出生命的意义》_[美]维克多.弗兰克尔 《Man’s Search of Meaning》_V.E. Frankl ——阅于2015年3月 内容均为摘抄 前言 “知道为什么而活的人，便能生存。”——尼采 找到生命意义的三个途径：（1）工作[做有意义的事]；（2）爱[关爱他人]；（3）拥有克服困难的勇气 苦难本身毫无意义，但我们可以通过自身对苦难的反应赋予其意义。 ​ 自序 生命在任何条件下都有意义，即便是在最为恶劣的情形下。 一切行为服从良心，并用知识是实现它。 “荣耀你的父母，地上的生命将能得到延续。”——十诫 在集中营的经历 旁观者可能具有客观性，但这并不意味着他一定能够做出有价值的判断。 勇气一旦失去，几乎就不可能在挽回。 爱是人类终身追求的最高目标。 拯救人类要通过爱与被爱。 世上一无所有的人只要有片刻的时间思念爱人，那么他就可以领悟幸福的真谛。 人是如此关注自己和亲人的生命，以至于精神高度紧张，这种紧张可能会摧毁他所有的价值观念，使他怀疑一切。 人类一直拥有在任何环境中选择自己态度和行为方式的自由。 如果说生命有意义，那么遭受苦难也有意义。苦难和死亡是生活不可剥离的组成部分。没有苦难和死亡，人的生命就不完整。 看不到未来的人之所以自甘沉沦，是因为他发现自己总在回忆。 对自己的未来丧失信心的人，注定要走向毁灭。/他缩在自己的躯壳里，不再关心任何事情。（对于失去希望的人，他的免疫系统会迅速下降） 我们期望生活给予什么并不重要，重要的是生活对我们有什么期望。/生命最终意味着承担与接受所有的挑战，完成自己应该完成的任务这一巨大责任。 你必须承认，即使在经受磨难时，你也是独特的、孤独的一个人。 我们早就过了质问生命意义的阶段，已经不是天真地想通过积极地创造某种有价值的东西实现某个目标的年龄了。对我们来说，生命的意义包含着从生到死受苦受难这一更广阔的循环。 我们有太多的苦难要经受，因此，必须直面所有的苦难，不能软弱，眼泪是无用的，但也不必 讳言流泪，因为眼泪见证了人们承受痛苦的巨大勇气。 每个人都应该问自己一个问题：我们所遭受的难以挽回的损失是什么？/只要还活着，就有希望。健康、家庭、幸福、职业能力、财富、社会地位——所有这一切都有可能重新获得或恢复原状。 “那没能杀死我的，会让我更强壮。”——尼采 你所经历的，世人夺不去。 我们已经丧失了感受快乐的能力，要慢慢地重新培养这种能力。/得到解放的犯人最初的感觉叫“人格解体”。一切都显得不真实、不可能，像是梦中一样。/多少年的心理压力一旦消失了，听他说话，你会觉得他是不得不说，他抑制不住说话的欲望。/对于回家的犯人来说，最重要的体验是他经受了那么多苦难之后，除了上帝，他不再畏惧任何东西，那种体验有着无与伦比的美妙感觉。 意源性神经官能症 意义疗法着眼于未来，着眼于患者在将来应当完成的意义。/着眼于人类存在的意义以及对这种意义的追求。 意义疗法把人看作这样的一种存在：他主要担忧的是实现某种意义，而不仅仅是满足欲望和本能的需求，或者是调和本我、自我和超我之间欲望的冲突抑或适应社会和环境，在这一点上，它与心理分析分道扬镳。 心理——动力 人实际需要的不是没有紧张的状态，而是为追求某个自由选择的、有价值的目标而付出的努力和奋斗。 ​ 生命之意义 因为生命的意义在每个人、每一天、每一刻都是不同的，所以重要的不是生命之意义的普遍性，而是在特定时刻每个人特殊的生命意义。/人不应该问他的生命之意义是什么，而必须承认是生命向他提出了问题。 ​ 存在之本质 要实现生命的潜在意义，是想强调生命的真正意义要在世界当中而不是内心去发现，因为它不是一个封闭的系统。 所谓自我实现，绝不是指某种可以实现的目标，因为人越是追求这个目标，越是容易失去它。自我实现可能是自我超越唯一的副产品。 发现生命之意义的三种方式：（1）通过创立某项工作或从事某种事业；（2）通过体验某种事情或面对某个人；（3）在忍受不可避免的苦难时采取某种态度。 ​ 苦难之意义 人主要关注的不是获得快乐或避免痛苦，而是看到其生命的意义。（事例：一位年迈的、患有严重抑郁的全科医生向我咨询，他无法接受妻子的死亡[她在两年前去世，他爱她胜过一切]。我怎么才能帮助他？我该告诉他些什么？我努力克制自己，不说别的，而是对他提出一个问题：“医生，如果你先她而去，而你太太在你死后还活着，那会怎么样？”“那她可就受苦了，她怎么受得了呀！”他说。我马上回答：“你看医生，她免除了这样的痛苦，你替代了她的痛苦——当然，代价是你现在还活着，并且陷入了深深的痛苦中。”他没在说话，摇了摇头，悄然离开的了我的办公室。在一定意义上，一旦找到了意义[比如牺牲的意义]，痛苦就不再是痛苦了。） 人应当幸福，而不幸福是调适不当的结果。这样一种价值体系可能会造成这样的后果：不可避免的不幸之重负由于对不幸感到不幸而变得更加严重。 作为一项技术的意义疗法（矛盾意向法） 对失眠的恐惧对入睡的过度关注反倒让患者更加难以入睡。 为悲剧性的乐观主义辩护 即便一千个患者中只有一个出现了这样的转机，谁敢保证这种转机不会发生在你身上呢？但是首先你得活到那一天，所以你应该活着，等待那一天的到来，而且你从今天开始，你就有责任活下去。 100%的毒品依赖患者认为“生命中的一切事物看起来都没有意义。” 生命的每时每刻都包含着死亡，而每一时刻都不会在重复。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《The Millionaire Fastlane》读书笔记_MJ.DeMarco]]></title>
      <url>%2F2016%2F06%2F08%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%2F%E3%80%8AThe%20Millionaire%20Fastlane%E3%80%8B%2F%E3%80%8AThe%20Millionaire%20Fastlane%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_MJ.DeMarco(%E5%8F%82%E8%80%83)%2F</url>
      <content type="text"><![CDATA[这本书是去年花了三个月读完的。因为英文书很容易读着读着就忘了逻辑，所以就一边读着一边写着啦，没想到噼里啪啦地写了这么多。虽然这类书籍难免落入读完一切如初的境地（说的就是我，哈哈哈），然而读的过程中，感觉自己“酣畅淋漓”地被洗了一顿脑呢，非常值得推荐。本书评已发表个人微信号mmqm-qiqi，文章链接：http://mp.weixin.qq.com/s?__biz=MzAwOTk2MzY5Nw==&amp;mid=2247483676&amp;idx=1&amp;sn=3e651642844fe4188f2267e0cf130b01&amp;scene=1&amp;srcid=0604NQlX4W5yvKbqAZlZr190#wechat_redirect 在知乎看到一篇文章，回答：你为什么会穷？前面洋洋洒洒卖了一堆关子，到最后才提到这本书。于是上豆瓣来搜，发现只有英文版，心想又是一块硬石头……但是那位知乎的同学说得实在是太好了，而且豆瓣的书评也是一片赞，于是手里还砸了好几本英文原版书的我，还是硬着头皮入了这本……我也是一向对于看书这件事，比较乐观……希望这本书不要变成坑。（2015.8.1） 找到源地址：http://www.zhihu.com/question/26980862/answer/34857629 书名很俗气，可以译为《快速致富手册》，但是正像作者说的，这本书不是教你如何投资房地产之类，而是教你哲学和数理学。我看到这里觉得这本书大概是一本哲学类书籍吧，属于那种然并卵，不会像消炎药立即生效，但是也许会长久地潜意识地影响人心。我还是很喜欢这种哲学书的。 读到简介里的一段话，打开新世界的感觉！这句话是： 停！如果你现在不富有，那么停下你现在做的事情！ 这个结论来自一个谚语：如果你想得到你目前得到的，那么就继续做你目前做的事情。翻译过来就是一个字：停！停止你现在的行为，现在的观念，现在的习惯，因为这些都带给你了不富有的状态。你需要再教育到一个新的方向上面来（当然是关于寻求财富的方向） 我的总结也就是一个字：改！——赶紧改！ 我们被灌输的传统观念：去读书，考高分，找工作，存钱，买养老保险，节俭持家，然后在65岁我们就会成为有钱人了。这是一种通往财富的慢车道。其实，我觉得即使完全照着上面做，也没法在年老的时候变得有钱，我在这方面还是挺悲观的。你的现在是你所有过去的结果。这么看，我过去走的路，是一条通往财富的泥泞牛车道……更要及时刹车，改一条路了。 书里讲的这一点我是完全同意的：改变逻辑的第一步是知道这潜在影响自己的逻辑是什么。看懂这篇文章，我做到了第一步。就像当年看《少有人走的路》一样，我今天才明白为何当初对那本书如此痴迷——因为它讲了很多深藏在我心中，一直指挥我的“逻辑”。这么忽然一下子被他揭穿，我才发现那些“逻辑”多么的可笑可怕。于是对手凸显出来，我才可以对付它。不然像第一段写的那样，我连对手的具体形状都不知道，怎么下爪去对付它呢？ 这条通往财富的快车道是你自己的，必须你自己走，且需要你的勤劳付出。作者只是指路人。 ★第一章不要走慢车道！ 竟然作者也和我一样悲观。 前面提到的传统观念：“去读书，考高分，找工作，存钱，买养老保险，节俭持家，然后在65岁我们就会成为有钱人了”，作者也觉得，即使你真的能接受到了老年才能享受生活或者在低收入工作中虚度光阴，最后也有可能事与愿违——疾病、失业、经济崩溃……都可以让你无法沿这条慢车道走到财富。 财富慢车道根本就是一个骗局，好吗！ ★第二章作者的财富人生 作者小时候就是个“堕落少年”，对啥都不感兴趣，除了坐电视机前吃零食，肥的不像话……直到有一天看到一位年轻人开着兰博基尼，而人家既不是体育明星也不是娱乐明星，忽然一下子开窍了，想当一个年轻的有钱人。 于是开始各种看财富书籍，研究年轻富豪的发家史，大学毕业也不去公司工作（因为那是上面提到的“不靠谱的慢车道”），各种尝试做生意，各种失败，只能靠打零工为继。持续这种状态，直到一个暴风雪夜，他意识到再也不能做这么下去，他必须改变！ 从芝加哥搬去凤凰城，因为阴冷多雨的芝加哥加重了作者的抑郁。出于重新掌控生活的目的，他选择主动改变了自己的居住地，搬去了每年有330个晴天的亚利桑那州。然后自学网络语言，做了自己的豪华轿车租赁网站，并且在2001年网络经济泡沫崩溃前夕，将自己的网站以120万美元售出。但钱到了手上立即投资股票失败，变成30万。后来在网络泡沫崩溃之后，又以25万将自己的网站买回来，继续运营，并且取得优良业绩，达到财务自由。 这一章完全就在讲作者自己的财富人生，我发现两点，还蛮有意思的： 第一，作者对于致富有持久和极度的热情。 第二，作者对财务自由有着很深度的理解，即拥有一颗它自己会开花结果的树。当初作者帮别人做网站，三天挣一千美元的时候，并没有高兴，他知道这不是财务自由，因为这虽然赚，但需要他付出巨大劳动和时间。后来他重新接管网站，并开展业务之后，发现不管作者是一天只工作一小时，或者在拉斯维加斯潇洒，还是生病卧床，公司都可以自行运转变钱，这才叫财务自由。 ★第三章这不是一条容易的路！（2015.9.5） 1，财富是一个复杂的公式，由很多元素组成。 2，这条路通向的结果是风光的，但风光背后需要付出辛勤努力。 3，这条路不会一帆风顺，没有捷径，也无人可替代。 毕竟，富人是少数，这条路会逐渐淘同行人。 在讲第一条的时候，作者做了一个很形象的比喻，我蛮喜欢的：追求财富，就好比做曲奇。你需要的不仅仅是糖，还需要面粉，酵母等等，有了这些原料，你还需要配方。而所有致富书籍都聚焦在获得财富这个美好结果上，就好比烹饪书如果只教你用糖，你是永远做不出曲奇的。重要的是，除了糖，还要有其他原料和配方！ 另外，作者算是在这章把整个后面章节的脉络做了一个说明。财富这个复杂公式有四个关键要素： 路线图、车、路、速度。 后面的所有章节将会围绕这四个关键元素依次做详细说明。 ★第四章路线图的重要性（2015.9.13） 这一章很短，四页纸，讲了一件事情：roadmap很重要。 你目前的经济状况由你目前的roadmap所决定。因为你的roadmap决定了你的思维方式，你的思维方式决定了你的选择，你的选择决定了你的财务状况。 简而言之：如果想要改变你的经济状况，需要首先改变你的roadmap，也就是思维方式 or 信条 or 观念（诸如此类）。 作者提到：如果roadmap是人行道，那么会导致贫穷；如果roadmap是慢车道，那么会带来中产；如果roadmap是快车道，那么会指向富裕。 想要改变思想，首先要了解潜在左右你的思想。就像我在上文提到的“改变逻辑的第一步是知道这潜在影响自己的逻辑是啥”。所以在后面的章节，他会分别解析这三种不同的roadmap。 ★第五章人行道路线图（2015.9.15） 作者提到，大多数人都是选择走人行道，这类人的特点是用今天的欢愉去替代明天的安全。说白了就是及时行乐型。 这类人的一些特性（看看你有没有哦）：即时满足，好像没有明天那样去消费，毕业之后不再学习，财富=收入+债务，无财务计划。 人行道必然通向贫穷，不能抵抗风险。 另外，不仅仅是低收入者走人行道，有些高收入者也走人行道。因为再多的钱也治愈不了财务管理匮乏症。穷人可以月光，富人也可以月光。 ★第六章你的财富观念正确吗？（2015.9.15） 这一章真的是让我对作者的看法大为改观。 这本书从书名到第一章的内容，处处都透着：俗。作者在本书开头，大吹自己的香车美女生活，如何如何，给人一种位数略低的感觉。 这章的卷首名言，我超级喜欢：Wealthis the ability to fully experience life.——Henry David Thoreau 作者也在本章坦言，因为社会为财富做了很多错误的预定义：财富就是拥有奢侈品（豪宅，跑车，奢华生活）。所以，作者在本书前面做了很多兰博基尼之类的描述，为了勾引大家的阅读兴趣。 其实，作者认为，真正的财富是三因素：关系，健康，自由。 社会的这种错误财富定义，导致有人只是想看起来富裕，而不是想真的富裕。 只是想看起来富裕的人，完全认同错误的财富定义——消费奢侈品，让别人觉得自己很富有。而这会让一些人负担超出水平的物质资料，进而伤害真正的财富：关系，健康，自由。而他们会认为，这些损失都是财富的必须代价。 结论：伪装的富裕会伤害真正的富裕。 说句题外话，刚刚在85度C坐着看这一章的时候，我忽然跳跃地想到，我想要加州生活——四季如春和充满阳光，但我以前都是想过去工作而已。忽然觉得这种想法好狭隘，为什么不是拥有财富之后，而自由地选择去加州生活呢——只是选择我喜欢的地方生活，而不仅仅是工作谋生。 ★第七章钱和幸福有关吗？（2015.9.16） 钱能换来幸福吗？不行。那贫穷就能换来幸福？也不行。 要回答钱和幸福的关系，得首先知道幸福是啥。 作者的定义：幸福和真正的财富一样，有三要素，分别是关系，健康，自由。这一条很重要！只有在这里能够达成共识，也就是三观一致了，后面才有得聊。 而钱可以换来其中一个要素：自由——选择陪着孩子成长的自由，选择建立美好关系的自由，选择实现自己疯狂梦想的自由，选择让世界变得不同的自由，选择做自己喜欢事情的自由。 而没钱就没有自由——你讨厌那份工作但没法辞职，你希望多陪陪孩子但是周末又要出差，你想要一个私人录音棚想唱多久唱多久但是没有钱。 所以，结论来了：虽然钱不能买来幸福，但是它确实可以买来自由。关键看你怎么用！如果你用钱去换做自己喜欢事情的自由，OK；如果你用钱去消费负担不起的奢侈生活，NO！ 为什么同样是花钱，前者就买得到幸福，后者就买不到幸福呢？因为后者会伤害自由，进而伤害幸福——金钱被错用了。 这里想到一个笑话，一位姑娘在早高峰的北京地铁里大喊“都别挤我！我这LV是真的！” 如果你认为幸福就只是奢侈生活，那本书到此为止，可以不读了。 这里当然有人会说了，我同意幸福三要素是关系，健康，自由，而我要的自由就是选择奢侈生活的自由啊，难道不可以吗？完全可以，只要你负担得起。 如何定义负担得起？消费了之后，对你的生活没有影响。或者说消费的时候你完全想都不用想。比如，一个年收入3万美元的人买一盒3美元的口香糖，想都不用想。一个年收入300万美元的人买一辆20万美元的宾利，其实是一样的。 选择奢侈生活的自由，也是自由，也能带来幸福感——前提是你负担得起。而在你尚未负担得起的时候，就动用选择的自由，那是一种虚假的自由，会损害真正的自由。很多富人不幸福的原因不是钱多，而是消费了负担不起的生活，被这种生活绑架，从而失去自由、健康、关系。 作者的建议是：善用金钱会获得幸福，错用金钱会伤害幸福。所以你需要做长期规划，延后满足，消费你目前能负担得起的生活方式。 ★第八章财富才不是只因为幸运呢（2015.9.18） 这章就讲了一件事儿：财富靠的是努力，不是幸运！ 人行道人们都骨子里相信一件事，几乎成了信仰了，那就是：财富只是因为幸运。因为他们只爱结果，不爱过程。 基于这种错误信仰，人行道人们迷恋“赌”：彩票，赌博，股票从30涨到60……那些深夜致富广告和诈骗集团的目标客户正是他们——想要财富，也就是喜欢结果，但逃避过程。 比尔盖茨的财富只因为运气吗？运气能给他一行行写出Windows代码吗，运气能为他管理一个公司吗，运气能制定出市场竞争方案吗…… 应该正确看待“结果”和“过程”： 爱“赌”的人们，属于结果驱动型，而不是过程驱动型。 幸运来源于过程——越努力越幸运。 财富是过程不断累积的结果。 只有你自己可以创造真正的财富，别指望有人白送给你。 ★第九章为自己的财务状态负责（2015.9.19） 这一章作者列举了人行道人们的另一种心态：受害者——我的财务状态不佳，主要是因为别人：政府无能，雇主剥削，坏人诈骗…… 我比较没有这种心态，知道他说的这是个理儿。不过虽然不大感兴趣，但还是读完了。 作者通篇就讲了一个意思：你需要对自己负起完全的责任，别给自己找借口。 说到责任，他指出responsibility和accountability是有区别的。我查了一下字典，中文都翻译为责任，但是前者只是对结果负责任，后者还有对结果有交代有解释的意思。是不是很昏？还是不懂？我读了大半章也是很挫败地发现不明白啊。不过作者举了一个例子，完美地解释了两者的区别：把钱包随意地放在餐厅的桌上导致它被偷了，responsibility是完全承认这是我的责任，。 只有做到对错误负起解释和交代的责任，错误才会变成智慧，否则错误只会变成受害者挂在胸前的徽章。 ★第十章慢车道的谎言（2015.9.20） 前面5-9章分析了人行道人们的内在逻辑和行为模式，从这一章开始讲慢车道了。 其实前面讲人行道人们的那些：今宵有酒今宵醉、懒惰、无责任感……解析起来并不难，因为这些行为一向是整个社会批驳的，是非曲直都非常明显。而从这一章开始讲慢车道，要解构出它的内在逻辑和行为模式是错误的，就更加有难度一些。人行道人们的即时满足——不对，这个我们都知道，社会就是这么教的；慢车道人们的延后满足——有问题吗？社会不是一直要求我们这样吗？ 整个主流社会和形形色色的理财书就是这么说的呀：“去读书，考高分，找工作，存钱，买养老保险，节俭持家，然后在65岁我们就会成为有钱人了”。说白了就是教大家一种模式：不要抱着不切实际的空想，要老老实实地打工赚钱、存钱、理财、然后积累积累再积累、等着时间的玫瑰、最后你就富裕了。我从小就这么被教育的，所以我现在就是这么想的啊！不然呢？ 如果这种模式是你奔向富裕的全部方案，那是有问题的。如作者本书开篇就提到的，即使你真的能接受到了老年才能享受生活或者在低收入工作中虚度光阴，最后也有可能事与愿违——疾病、失业、经济崩溃……都可以让你无法沿这条慢车道走到财富。财富慢车道根本就是一个骗局！这种模式是注定失败的，因为它取决于时间和一些你无法控制的因素。 ★第十一章你的工作是一场罪恶的交易（2015.9.22） 好吧，这章也是够颠覆的，作者在这章向工作狠狠开炮了。 工作，这个词在我们毕业找工作的时候，多么美好。收到工作offer，是一件多让人开心又有安全感的事情。我终于可以赚钱养活自己了，终于可以去买我喜欢那款包包了，终于可以计划去小巨蛋看演唱会了！是不是感觉收到offer，等于收到了做喜欢的事情的自由？！ 但是作者告诉你，相反的，这是一纸卖身协议，六点理由： 时间游戏。工作是用时间换金钱，你工作就有收入，不工作就没有，且收入不够养老； 经验固化。螺丝钉式的工作模式，让你在工作初期完成学习和提高之后，变成工具，只是不断重复前面的经验。而社会需要复合经验，不是狭窄的经验。经验来源于生活，而不是工作。 不受控制。你就是在赌博，其实你也不知道公司会什么时候裁掉你。 办公室斗争。不管在哪工作，办公室斗争永远存在，你不得不去玩这个游戏。 税后收入。这一点针对美国这种高福利国家，收入的一大部分被政府和养老金计划盘剥，可以支配的工资少得可怜。 收入固定。工程师、销售、一线经理，不管什么工作都会被圈定一个价格范围，而这个不是你可以制定的，你只有接受的份儿。 最后，作者反复强调：如果你想脱离慢车道，奔去快车道，那么丢弃工作吧。 好吧，看完这章我表示，你说的这些我都懂，可是我还在工作的原因是，不然呢？希望看完本书之后有答案。 ★第十二章慢车道为啥不靠谱（2015.9.23） 这章应该算是精华。前面作者空口白牙地说了一大堆，慢车道就是个骗局啊，行不通的，balabalabala。这章开始分析：为啥它不靠谱！ 慢车道的财富公式：财富 = 工作薪水 + 理财收益 这两个因素都：受限于时间，且无法控制。 工作薪水：首先说说受限于时间。本质上说靠工作就是用时间换金钱，所谓年薪制嘛——工作一年得一年的薪水。而时间是天然受限的，每个人的工作时间一天不可能超过24小时，一生的工作年限不会超过50年。一个人，一辈子，可以工作的时间是有限的，且总体来说是很少的。然后来说无法控制，你没法控制这些和工作相关的裁员，经济崩溃，涨薪幅度…… 投资收益：主流理财书一定会神秘的告诉你“复利的神奇”——今年的一万，以年化15%的收益进行40年，就变成了250万！但书里没有告诉你的是，连续40年的高收益是不可能的！你活不了那么久！40年货币贬值后钱还值多少！第一点，你可以连续40年获得15%年化收益吗？看到这里，我忽然想起来去百度了一下，巴菲特的伯克希尔哈撒韦从1965年至今的50年中，复合平均年化收益率为19.4%，这算是一个巨大的成功。而世界上只有一个巴菲特，他被称为股神。如果一个机构承诺你一年15%的收益，请擦亮双眼，不要落入类似伯纳德·麦道夫或者查尔斯·庞兹的骗局里。我去百度了一下，觉得这里值得说一下。伯纳德·麦道夫是纳斯达克交易所前主席，庞氏骗局的主谋，他骗了不少有钱有势的人，知道他承诺的收益是多少吗？——每年保证10%，这是非常稳健的超常回报；查尔斯·庞兹，庞氏骗局的始作俑者，从1919年开始他宣称，所有的投资在90天之内都可以获得40%的回报，骗了有4万名想发财的波士顿市民。好吧，回到作者的思路上，40年？每年都平均15%收益？如果你对自己的投资水平和经济大环境有这种预期，也许你在赌博。我又忍不住毒舌两句：双色球的500万大奖，每周开三次，也总有人中的啊；赛马场那种赔率50:1的黑马跑赢了的，也有人买到了啊…… 复利之所以不靠谱是因为，它赖以生存的两大要素：时间和年收益，分别是受限和无法控制的。 简单地说，对于财富慢车道的公式，你既没有那么多时间去累积，也无法控制。如果一个计划方案是不可控的，那么它基本上只能依靠希望了。这个公式受困于数学的监狱，时间就是围栏。 也许你会说，作者说得都在理，但是就第一个因素“工作薪水”来说，虽然人的工作年限是受限的，但是人获得薪水的能力是无限的呀。我可以控制薪水的高低啊！那就是下一章要聊到的问题了：教育。 ★第十三章靠高教为啥不靠谱（2015.9.26） 上一章说了，慢车道财富公式里，唯一可能受控的是工作薪水，所以大家追求高薪水让自己的慢车道公式看起来靠谱一点。很多人因此选择高等教育。 我觉得这一章更加针对的是美国高额的高教学费。作者表示，在美国大多数的高校学生负担了高额的助学贷款，他们在毕业后，为了还款而不得不选择被工作奴役，失去自由。而且高教的专业特性，也一定程度上把毕业生就业的选择限制在了一个狭窄的范围。 你没看错，这一章就是这么短！结束！哈哈！所以我今天看了两章。 ★第十四章理财导师为啥不靠谱（2015.9.26） 理财导师为啥不靠谱？很简单，他们虚伪。 他们写在书里的步骤，并不是他们真正致富的方法，根据市场需求写书才能畅销（事实上他们很多人是因为写书致富的），他们写得只不过是大众喜闻乐见的幻象。 你按照导师的办法经营财富，而当经济危机来临多年积累损失殆尽的时候，导师们又开始写书教大家“重建”或“重新开始”，反正导师们要不停写书有人买才能赚钱。 而作者自己呢，他也写书啊？他表示自己已经是富人，不是为了讨好大众写书挣钱，虽然可能这本书会让他更加富有…… ★第十五章总结章：慢车道就是赌博（2015.9.29） 还是那句话（我要写三遍吗…）：“去读书，考高分，找工作，存钱，买养老保险，节俭持家，然后在65岁我们就会成为有钱人了”，即使你真的能接受到了老年才能享受生活或者虚度光阴在低收入工作中，最后也有可能事与愿违——疾病、失业、经济崩溃……都可以让你无法沿这条慢车道走到财富。 作者啊，你说的我都同意，我一点也不信能沿着慢车道能走向财务自由。能不要说三遍吗…… 好吧，既然作者又洋洋洒洒写了一大章去说明慢车道的不靠谱，那我还是给大家搬砖过来吧。 前面说到慢车道不靠谱，主要是因为它受限且不可控。作者举了威胁慢车道的七大因素：健康、工作、房子、公司、生活方式、经济、堕入人行道。其中，只有第5和第7是可控的，但是第5会让你变成一个守财奴，而仅仅做个吝啬鬼没法让你变成富人。 因为慢车道虽然也有成功范例：收入的激增并且控制消费，确实会给你带来财富。比如收入增长100倍，消费只同期增长10倍，但最重要的是收入要激增！如果你的天赋极高、过度工作、并且运气不错，最终成为名人或CEO等，会达到这个结果。可是这个过程是非常艰难且可遇不可求的，不幸的是大多数人放着快车道不走，宁可在开在慢车道上面去拼运气、天赋和辛苦。而剩下一小部分慢车道赢家，会在年老的时候过上中产阶级的生活，可那不能称之为富裕。 好了，作者终于把慢车道如何不靠谱，反反复复地说完了。就一句话：它很慢，吞噬时间，且高风险。 ★第十六章财富快车道（2015.10.1） 前面分别解构了人行道和慢车道，现在终于讲到快车道了。 读到这里，我开始发现作者其他都好，就是有点话痨……好了，我们再次复习一下前面的内容：人行道是享受当下，牺牲未来；慢车道是牺牲当下，“享受”未来（未必能享受得到），如下所示，作者觉得慢车道成功比率只有16%（话说我也不知道这数据他自个儿怎么捣鼓得来的） 人行道：1000万，立即兑现，成功率0.0000016% 慢车道：50万，40年兑现，成功率16% 快车道：1000万，7年兑现，成功率14% 如上所示，奔向财富的道路有三条，不管走哪条路成功率都不算太高（好吧，富人还是少数）。另外，人行道那种中彩票模式我们就不讨论了，比起慢车道的漫长等待（40年），明显地快车道致富之路要短暂得多（7年），这里作者反复强调了这种“Get Rich Quick”是他推崇的，但他从来没有说过“GetRich Easy”哦！ 快车道的思维方式（只摘几条我觉得很重要的）：债务可以帮我建立生钱系统；终身学习非常重要；创造出东西…… 快车道的财富公式：财富 = 净收益 + 资产价值 快车道是一个生钱系统，慢车道是一个工作。快车道的关键是要为自己建立一个生钱系统，让这个系统帮你挣钱，而不是自己亲力亲为，每天“搬砖”赚钱。 ★第十七章生产者和消费者！（2015.10.3） 其实这章挺短的，就讲了一件事：生产者和消费者。 我们大多数人生来就自然而然地扮演着消费者的角色，而只有少数人是扮演生产者的角色，这也是为什么富人只占少数。 如果你想从慢车道转到快车道，需要改变自己——从一个消费者转到生产者。 你需要转变视角来看待这个世界。比如，不去掘金，而是去卖铁锹；不去上课，而是去教课；不去借钱，而是去放贷。用生产者的视角看待世界，去看消费者需要什么——消费者是需要被满足的大多数人。 当然了，富人们也不是不消费，只不过顺序应该是：先做一个生产者，然后做一个消费者。可大多数人本末倒置，只看到了消费。 那么如何做一个生产者呢？这其实并不容易。你需要做一个创业者、一个创新家、一个前瞻者，你需要创造一个生意，为世界提供价值。 慢车道的核心是工作，快车道的核心是生意。（注：小生意不是这里指的“生意”，在菜场卖鱼一个月稳定收入2万这种，还是“工作”） ★第十八章快车道的致富秘密（2015.10.4） 解密快车道的财富公式：财富 = 净收益 + 资产价值，如何使人致富。 在第十二章里，作者指出慢车道的财富公式：财富 = 工作薪水 + 理财收益，是不靠谱的，主要原因是公式的变量受限且不可控。而快车道财富公式靠谱的主要原因也是因为变量不受限且可控。 解构一下这个公式先： 净收益 = 销量 x单元净收益； 资产价值 = 净收益 x行业系数。 净收益：这个很好理解，我卖一种产品/服务，一个可以净赚2元，一年卖100万个，那么我一年的净收益就等于200万。我的单元净收益和年销量都是不受限且可控的。 不像慢车道的工薪收入受限在时间——所谓工薪族，就是按时间（日/月）计费工资，一天只有24小时可以干活（就算你不睡觉），人人都一样。我可以通过降低成本或者创造更新更好的产品/服务来提高单元净收益，同样的我也可以通过扩大市场影响力和增加生产能力来提高销量，这些都是没有明显上限的。 就像晓晓同学微商卖内衣一样，假设卖一件内衣挣100，第一个月一个月只卖掉8件就只赚800，但是可以通过提高朋友圈曝光率、亲友二次传播、召集下线代理商来拉升销量，这个销量是不受限制且可以人为控制的，自然净收益也就不受限且可控了（可控程度依赖于市场和商业手段，但比起时间，至少可以控制啊。你能把一天的工作时间从24小时变成26小时吗？一定没可能嘛）。上一章最后提到了，小生意不算。又来了，我为什么那么爱举卖鱼的例子……你在菜场摆个小鱼摊，一天能卖100条鱼就顶天了，销量不高且有上限嘛。快车道生意的关键是销量！它必须是潜力巨大且增长迅速的，最好能呈指数级爆炸增长，这个取决于你的产品/服务的市场。 资产价值：首先说说资产。 慢车道人们的资产是消费品，汽车、电子产品、珠宝、时装、包包等，这种资产从购买之日开始就是贬值的；快车道人们的资产是增值的，生意、品牌、知识产权、商业模式、不动产等。 那资产价值是什么呢？回到上面的公式，它由净收益和行业系数决定。净收益上面说过了，那行业系数又是个啥呢。行业系数用来衡量特定行业的走势，系数越大代表行业潜力越大。作者在这里提这个概念，实际上是向未来考虑了：把生意做大之后，如果被收购的话，估值是如何计算的。因为作者认为，被收购才是把纸面上的价值变成真金白银了。假设你从事的是互联网行业，系数是4，资产价值= 净收益 x 行业系数，如果每年净收益200万，乘以4之后，你的资产价值就是800万。其中200万是你每年真正赚到的钱，800万是市场对你的估值和预期，如果被收购这800万就能变现。 快车道的财富加速器基于创造或者买入合适的资产，为它添加价值并控制变量，然后卖出。 ★第十九章在财富中剥离开时间（2015.10.6） 这一章的主旨内容在第二章提到过，只不过这里把它发散来讲了。 先把第二章的观点照抄下来，我觉得他讲得还是很清楚的：作者对财务自由有着很深度的理解，即拥有一颗它自己会开花结果的树。当初作者帮别人做网站，三天挣一千美元的时候，并没有高兴，他知道这不是财务自由，因为这虽然赚，但需要他付出巨大劳动和时间。后来他重新接管网站，并开展业务之后，发现不管作者是一天只工作一小时，或者在拉斯维加斯潇洒，还是生病卧床，公司都可以自行运转变钱，这才叫财务自由。 说白了，就是你的财富来源不再依赖于你投入的工作时间。财富圈一个很流行的说法是“被动收入”——你不工作也能产生的收入。如果你的“被动收入”超过了你的生活所需，你就可以不用工作了。 这颗生财树是一个生意系统，是快车道的主道。 有一点很重要：不是每一种生意都能配得上称为“生财树”！这是很多人的误区，以为自己辞职去做生意了，从打工仔变老板了，自己给自己打工了，就是有了一颗发财树了——错！如果这种生意是需要你花整天时间在里面，自己无法脱身，一不参与就没法保证收益了，这种生意不能称为“发财树”，它明显没有产生“被动收入”嘛，本质上还是在用时间换金钱。举例，某白领从工作13年的华尔街辞职，开了一家快餐厅。她需要7*24小时投入工作，本质上还是在用时间换金钱。餐厅收入有限，且要支付高额加盟费，以至于无法聘请别人替她打理店铺。想起来我和青姐年初觉得五谷鱼粉不错，想加盟一个，后来发现其实不是那么一回事。因为这种小加盟餐饮店，实际上是非常耗费劳力的，后厨最少要请1个厨师吧，高峰时间得2个，还有请1个人负责收银，1个人负责打扫前厅抹桌子收碗，这么看来就这么一个小小的餐厅，需要请3-4个人，且餐厅从清早开始采购食材到晚上打烊，需要从早干到晚，劳动强度巨大。现在劳动力市场一直走高，工人要的薪水高，特别那种六月天还要人家在炉子边挥汗下厨的工人，你不给人家6000块，谁给你干啊。最终我们的结论是，除非是自己和家人能吃得了苦亲自干，否则加盟一个这样的餐厅根本不划算。如果一个生意需要你每天苦哈哈得蹲那花费整天的时间来产生收益，无法产生“被动收入”，也就不是作者做的“生财树”了。 好了，既然加盟劳力密集型餐饮业不靠谱，那什么行业可行呢？作者给出了5个回答，“被动收入”指数从高到低排列如下： \1. 租赁行业：例如你作为一个房东，不管你工作与否，都可以收到房租——这是很典型的“被动收入”。当然，不仅仅局限于房屋租赁，出售音乐/照片/肖像版权也是一样的。 \2. 互联网/软件：这个很好理解了，因为技术/软件是可复制的，一次开发可以无限复制盈利，达到一定规模以后，会带来巨大的“被动收入”。 \3. 内容行业：内容和软件其实本质是一样的，一次创作，可以无限复制，复制带来的就是“被动收入”。畅销书作家致富的例子太多了，J.K.罗琳就很典型。 \4. 分发行业：有两种模式， 第一种是类似于亚马逊、沃尔玛、苹果App Store这种，可以把产品传达到千家万户，从每一个消费者身上收一笔费用，累积下来是不少的收益。 第二种是复制某种商业模式或者产品到全球各地。星巴克、麦当劳，冰雪皇后就是绝好的例子。如上文的提到的，如果你是五谷鱼粉的创办人，你不需要去开实体店，仅靠出让配方和生意体系，也可以收到加盟费。 \5. 人力资源：这是指数较低的一个行业，它可以增加或者降低其它行业的“被动收入”，管理和应用人力资源是最昂贵的。 ★第二十章钱生钱（2015.10.11） 作者前一章提了“发财树”的概念，能产生“被动收入”的生意都可以称之为“发财树”，然后列举了五个比较靠谱的行业生意。 但是这一章作者坦白，其实最好的“发财树”是钱，而不是什么生意。因为钱是最容易产生被动收入的东西，放银行定期存款或者买个什么5%的理财，就可以源源不断地产生收益，完全不用管它。而生意多少还需要一点时间去打理。作者举例说，他的互联网租车生意，虽然是一颗不错的发财树，但是他还是得每周为此工作几个小时，所以这个生意的被动指数是85%；而他放在银行的存款，完全不需要他做什么，所以被动指数是99.5%。 钱生钱的关键是两点：年利率和钱总额。在第十二章，作者反复讲了，慢车道人们迷信的年收益是多么的不靠谱，就算复利再强大，你也不可能发财，因为你的基数太少了！就算给你每年100%的绝高收益率，你有1分钱，想要变成500万，也得花30年。而如果你现在有8万，变成500万只需要7年。钱生钱的复利游戏里，基数最关键。原始资本太低，复利怎么玩都玩不动。 慢车道人们使用复利来慢慢积累财富，而快车道人们使用复利来创造收入和流动资金。富人们的财富不是通过复利积累而成的，因为他们的快车道财富公式里没有复利这一条，他们的财富是通过公式里的生意获得的。 说到底，作者的意思是，你首先必须用上一章的方法完成原始资本的积累；当你有了很多钱以后，就可以用钱这个最好的“发财树”给你产生最佳的“被动收入”。 ★第二十一章影响力法则（2015.10.14） 这章看完觉得有点重复，我觉得作者在这章提出的影响力法则就是第十八掌的重点阐述而已。 首先，作者对“吸引力法则”提出了批判：他曾经虔诚地信仰着“吸引力法则”，心中想象自己变富有，然而并没有什么卵用。想象并不会让你变富有，行动才会。类似“吸引力法则”书籍的大卖，多半是因为人类天性是怎么舒服怎么好的，这种书籍告诉你，你就想就好了，人们当然愿意相信了，虽然乐观并没有错，错的是没有具体地持续不断地行动，就是白搭。（很有启发） 于是作者把“吸引力法则”改成了“影响力法则”：影响越多的人，就可以赚更多的钱。体育明星可以获得财富，就是因为可以影响广大观众。 回到第十八章，财富公式= 净收益 + 资产价值，其中，净收益 = 销量 x 单元净收益。很明显，销量巨大，或单元净收益巨大，或两者兼有，你就能变得富有。 ★第二十二章首先拥有自己（2015.10.15） 从这章开始到第二十八章，作者开始讲如何打造行驶在快车道的汽车——你自己。 说实话这章内容有点专业。如果你是打工者，那么你的收入首先会交给国家（所得税、社保之类），所以你需要首先拥有自己——开公司（这里可能涉及到美国商业社会里一些合理避税的规则，我不懂了）。 而开公司千万不要独立法人（还是因为美国的一些商业规则） 而公司有很多的类型，不同的类型会导致不同的税务和收入模式，作者做了一个简单的说明。（我也不大懂了） 所以这章总结就是：首先你要开公司，第二不要独立法人，最后根据自己的需要选择公司的类型。完毕。 ★第二十三章选择的重要性（2015.10.15） 这章里，作者重启话痨&amp;灌鸡汤模式，长篇大论的看完，我觉得就讲了N多故事，道理咱们都懂，好吧…… 不管你现在是穷是富，都是由你的千百个选择决定的。（不要纠结富二代神马的，好吗） 同样的，财富快车道也不是一个选择决定的，它由长时间的一串的选择决定：你是好好读书还是浪费生命，勤恳思考还是纵情欢乐，…… 如果你对现状不满意，那么你只能打自己两耳光，你之前的所有决定导致了你的现状。然后，开始做更好的选择。 当你年纪越小，做出的决定影响力越大，不管是好的决定还是坏的决定。 好吧，然后作者用“蝴蝶效应”讲了一大堆故事：某同学从小不学好做坏事，受到惩罚之类的，扒拉扒拉扒拉…… ★第二十四章转变思想（2015.10.18） 看了半天，觉得和王阳明的“未有知而不行，知而不行，只是未知”是一个意思。 你的思想决定了你的选择，你的选择决定了你的行为。所以想要在行为上产生改变，必须要先转变思想。比如说你现在正在看这本书，目的就是为了转变思想，作者已经在前面二十几章写了那么多，有没有被洗脑，看个人情况呗。当然，除了看这本书，还有很多途径给自己转变思想来用，比如有意识地去了解富人——他们的财富思想，选择，行为…… 那转变了思想，还是不知道如何做决定，怎么办呢？作者提供了做选择的方法论：“最坏结果分析法”和“左右衡量分析法”。 “最坏结果分析法”：适合每天使用，用来规避做出错误的选择。在做决定之前问自己三个问题： 最坏的结果是什么？ 发生最坏结果的可能性有多大？ 这是可接受的风险吗？ “左右衡量分析法”：适合做重要选择的时候，用来在几个选择中找出最佳的。/加权平均数决策矩阵 在纸上面把所有选择的利益都列出来， 每条利益都给它按照重要程度打个优先级的分， 然后列出来几个选择在各项利益里可以得多少分， 最后加权平均一下，选择利益最大的那个。 ![计算机生成了可选文字:Weighted Average Decision Matrix (WADM) Factors Weather (10) Schools (3) Cost of Living (6) Business Climate (2) Taxes (7) Safety (4) Entertainment (8) Near Family (7) Detroit 2 2 5 6 6 3 5 [201 [61 [301 [12] [42] [12] [40] [701 232 Phoenix 8 [801 3 [42 7 [8 4 [49 7 6 2 [16] 0 0 228 The better choice 既然要转变思想，就彻底一点，不要让过去决定你的未来。 有的时候，需要学会摆脱过去，直面未来。 有的时候，需要学会转换过去，不过是什么样的经历，都可以从中吸取正面的经验。把过去转变成正面的经验来服务自己。 少给自己贴标签做定性，我就是个xxx，我就不适合xxx，我就不喜欢xxx。 ★第二十五章转变环境（2015.10.18） 无视那些悲观论者——这个不需要解释为什么吧。之前我看富兰克林自传的时候，正好富兰克林也讲到这方面的故事，顺手拿来吧。我去翻一下之前贴在豆瓣的读书笔记： 有些悲观主义者的话，听听也就算了，不要太在意，更不要被他们束缚住前进的脚步。富兰克林刚刚开展自己的印刷生意时，费城住着一位有名望的长者，看起来很渊博。他跑来跟富兰克林叨叨，这个城市必将没落，虚假繁荣持续不久，扒拉扒拉扒拉。他离开时，富兰克林闷闷不乐了，假如他在开业之前就遇到这位悲观论者，也许他永远都不会涉足这个行业了。结果，后来富兰克林回忆起他的时候，颇有点幸灾乐祸：“每一个国家都有语言国家即将毁灭的悲观主义者。他一直住在一所破烂的房子里，不肯买新房子。到了最后我高兴地看到他付出高于他刚刚倡导悲观论时可以买到的5倍的价格购买了一所房子。” 不受大众思想的影响——毕竟富人是少数，不要强求大众都那么赞同你的想法和思维方式，那样你会很累。 远离平庸的人和环境——人是受同伴和环境影响的，如果你身边全是人行道或者慢车道的人们，很难能不受影响的。作者举了史泰龙的例子，还蛮典型的。尚未成名的他，一直拒绝参加一份正常的工作，他自己是这样解释的：如果我去做一个尚可的工作，那我的梦想就完了，因为我清楚工作会把我逐渐拖到正常平凡的生活中去。 和积极的人交往——和那些对你有正面作用的人交往，他们能帮助你成长，督促你进步。尽量多参加一些创业者俱乐部，读书看相关的人物自传，找个导师，加入相关的网络论坛。 伴侣很重要——作为你最亲密的人，会对你产生最大的影响。如果你们在财富、生活等的观念不同，会极大地消耗对方的精力并消磨对方的梦想。请找一个相信你和你的目标的伴侣。就是所谓的三观要同啊！ ★第二十六章时间是快车道汽车有限的燃料（2015.10.20） 这个标题有点拗口，作者认为如果你找准了快车道，开上了大马力汽车，想要沿着快车道一路前行的话，时间就是你的燃料——它是有限的。中途不设加油站哦，亲。 所以，珍惜时间吧。好吧，你们看出来了，这章作者在熬鸡汤，但道理是没错的。 话说美国那么多人为了领价值几块钱的免费鸡块，宁愿排队几小时。作者表示完全无法理解：难道你们的时间只值这么点钱？你们的时间是无限可再生的？你们是永生的吗？如果生命只剩下几小时，你会用在排队领鸡块吗？如果你认为你的时间只值这么点钱，那么你也就只能是个穷人，因为你的时间浪费在了这些事情上面。 我还挺能理解这种心态的，以前我也干过这种事情，只不过现在年纪大了，懒得去做类似的事情了。我觉得吧，驱车40分钟去买比本地买更便宜10美元的东西，多半是因为你也不知道你的时间可以用来做什么更有价值的事情。 看看周围的亲人，朋友，同事们，他们是否珍视自己的时间？你最大的资产是时间，而不是钱。时间是死一般缺乏的，而钱是完全充裕的。 你的人生 = 自由时间 + 契约时间。两者此消彼长，如果你花太多时间在契约上，自由的时间自然就少了。契约时间指花在赚钱上的时间，自由时间指花在喜欢的事情上面的时间。钱可以换来自由时间，减少契约时间。如果你能从契约时间手里慢慢偷出自由时间，生命会有更多的乐趣。 契约时间最大的来源是寄生债务。像一辆新的豪华轿车，一件新的品牌大衣，一个新的设计感家具，都是属于寄生债务，在你没有实力消费它们的时候，购买它们会给你带来经济负担，导致你不得不赚钱，失去选择的自由，并耗尽自由时间。下次你买奢侈品的时候，想象你其实不仅仅在买一件商品，同时也在购买寄生债务。所以工薪阶层的你，在买一件ACNE的大衣，刷卡的时候请想象：首先你花了5000块钱，其次你给自己带来了50个契约小时（假设你每小时挣100元），这件大衣令你不得不交换四天的时间来工作（每天工作八小时来算）。如何控制寄生债务呢？控制它的源头：不想买就不要看，看多了就会买的；不想吃就不要买，买回来就会吃的。你需要通过遏制寄生债务，来遏制契约时间，以此来保卫自由时间。买奢侈品之前想一想，以我目前的财力，买这个东西会夺走我的自由，那我还要买吗？是要奢侈品还是要自由？这是个问题。蔡康永在《奇葩说》“该不该买房”里也说到过相同的观点：房贷很容易让你失去说不的权力，你在一个王八蛋的工作里面脱不了身，这个时候你会失去幸福感。你在做人生重要决定的时候，想一下这个决定有没有剥夺你说不的权力。 不要浪费时间去节约钱，因为时间是有限且缺乏的，而钱是充裕的。做事的时候想想，这件事是在好好地花我的时间吗？时间是最宝贵的资产，所以它应该是做决定之前最大的考量因素。快车道人们节约时间，慢车道人们节约钱。 ★第二十七章终身学习，养成习惯（2015.10.21） 在读书期间培养学习的能力非常重要！因为通向财富的大多数知识都是需要你在大学毕业之后自学的。 人行道人们在大学毕业之后就没有学习了，慢车道人们只为某份工作学习（如何做好轴轮上的一颗螺丝钉），快车道人们学习如何构建生意（如何建造轴轮）。 如何学习？信息时代了，学习越来越容易，阅读，搜索相关信息，网络教程，实践，与前辈交流，等等这些都可以做到。 没时间学习？见缝插针，把学习常态化，习惯化。比如开车或坐车的时候听有声书，排队的时候阅读。 关于学习习惯化和常态化，我最近还是有点感受的。就在看这本书的两个多月里，除开特别忙或者外出的日子，我养成了几乎每天都要花一点时间去读一章的习惯，注意：已经是习！惯！了！今天在外就餐回来已经八九点，按照我以前的习惯，我一定是第一时间洗澡，然后收拾东西，刷刷朋友圈，看看美剧或日剧，就睡觉了。而今天竟然因为最近养成的看书写笔记的习惯，毫不犹豫的首先看书写笔记，一气呵成，都不用勉强自己。这本书不算轻，而我每天出门包里一个笔记本电脑，一个电源适配器，再加上钱包和其他零碎，背包重量对于体重93斤的我来说已算不易，照我以前是特别嫌背包重的，绝对不会再塞一本书进去。但是最近半个月，我已经可以毫不纠结地出门带上书和翻译笔了。习惯的力量太强大。 要注意，那些几天的研讨会就要5万学费的，几乎都是坑钱的，不仅培训质量名不副实，而且会不断拉你去交钱学下一个课程。他们利用了人们懒惰的特点，巴不得跳过过程，直接伸手要到结果。让人们消费巨大，还美其名曰“投资自己”。太贵和免费的课程都需要谨慎参加，另外打着名人效应却不是名人自己亲自来讲授的课程也要注意。 终身学习，意味着你不断地更新自己，这会为你打开新的门路和视野。选一个感兴趣的主题，或者你急需改进的领域，然后开始学习。这方面，查理芒格有句话，“我手里只要有一本书，就不会觉得浪费时间。”《穷查理宝典》第11页。 ★第二十八章全力以赴（2015.10.22） 很喜欢这章的开篇名言：如果事情看上去无法控制，那么你需要行动得更快一点了——MarioAndretti 这章特别针对白日梦患者。如果你以为快车道很容易，赶快停下来回到慢车道去吧，虽然那条道也挺难的。哈哈哈，挺有意思的。最近挺感慨的，以前总是给自己留各种退路，做啥都不拼全力，没有什么追求，心想就混个慢车道算了，现在发现其实慢车道也不容易的。 做事仅凭兴趣和做事用承诺是有区别的：兴趣就是读一本书，承诺就是按照书里说的实践50遍。 前者是做自己喜欢的事情，完全无压力的，放佛车子挂到一档慢悠悠的前进，这件事情我喜欢就做，做多久完全凭我喜欢。 承诺不是这样，给自己定一个目标，全力以赴达成，没有借口没有拖延没有缓冲。没有谁能随随便便舒舒服服，就靠做点自己喜欢的事情，轻轻松松就成功。比如我看这本书是全凭兴趣，而无承诺，荡啊荡漾啊漾的读着，所以才一本书读两个月还没有读完，哈哈哈。好了，严肃脸，联想到我学琴和太极也是这样，简单地认为俺就是出于兴趣去学习啊，应该很欢乐吧，其实不是，自己打脸。学到一定的时候，你会发现越来越难，没有什么全凭兴趣就轻轻松松学会了啊这种事情。所以即使是出于兴趣，也得需要自己给自己承诺，否则绝对会半途而废，学成半桶水，等于没有学会。我的一位四十多岁的太极同学，就是有着一股子一定要学会的韧劲，与之相反，我就是偶尔来活动一下筋骨的样子，我比她早来学半年，啥招式都没有学，但是在她到了之后就不停地督促老师教24式，督促我们都来上课，学会24又接着督促老师教13式。现在我跟着她的进度，一个暑期就学会了24和13式，效率是我之前一个人的不知道多少倍。我的太极老师就看出来了这点，说她是个不得了的人。 全力以赴才会把你和大多数人分别开来——因为大多数人不会全力以赴，跟智商无关，只跟努力有关。今天正好看一个公众号，里面一段boss评价某位实习生的话，说得很在理：“现在你明白她为什么总是少一股劲儿了吧？因为她总是给自己太多的退路，如果没有一条道走到黑的韧劲儿，是不可能把一件事做好的。” 避免失败就是避免成功。你不得不冒险，不得不离开舒适区，不得不行动并失败。害怕失败多半是因为对失败结果过度解读了。 那么如何界定风险呢？ 优质风险，值得一试，盈利巨大，损失有限。优质风险是，如果我赢了，那么会带来巨大收益，如果我输了也不会比现在差多少。 劣质风险，不要尝试，盈利有限，损失无限。比如冒险飚车就是劣质风险，因为盈利就是一时的刺激，损失有各种可能简直无下限。 “有一天”阻止了人们全力以赴，但它永远不会来，它只存在于你的脑部剧场，它让你变得麻木，它将你困在唔知何处。 同样的，“好时机”也永远不会来，不要妄想你想做啥事情的时候，正好一路绿灯。机会来了的时候，永远不是好时候。机会来了就去吧，别等好时机了，这就是浪费时间，等着等着时光年华都过去了。前不久看日剧《拿破仑之村》里引用拿破仑的一句话：“要认真思考，但是当行动的时刻来临，要立即停止思考向前进。 ” ★第二十九章通向财富的正确之路（2015.10.22） 从这章开始的九章，要讲如何构建生意了。 如前面提到的，慢车道人们耐以生存的工作，并不是一条通往财富的大路。不幸地是，大多数生意也不是。 大多数生意都无法称之为快车道，因为他们不赚钱。那么如何判断什么样的生意能带来财富呢？作者列了五个戒律。 下面的几章内容会详述它们。 ★第三十章 戒律一：需求为王（2015.10.24） 这章好长，干货很多。捡重要的说： 这章最重要的点在于，作者驳斥了一个的误会“做你喜欢的事情”。做生意，如果只是追随爱好而已，会死很快的，永远永远要以追随需求为先。作者举了一个例子，他在一个老年人社区，看到开了一家hip-hop服装店，且周围都没有什么舞蹈中心之类的，心里盘算着这家店一年之内会倒闭，果不其然一年半它就消失了。显然，老板追随了自己的心，做的是自己喜欢的事情啊，又怎么样呢？不把需求放在首位，一切白搭。这就是为什么90%的生意会失败。 那么上一章说的五条生意戒律来了，第一条就是需求为王。生意应该以满足需求为首，要给别人提供价值和解决问题。自恋、自私的生意长远不了。人们只会在乎你的生意可以为他们做什么：解决他们的问题，让生活更舒适一点，节约他们的开支，教育他们，让他们感觉好一点（健康、魅力、…），给他们安全感，给他们希望……而你想赚钱，你想做喜欢的事情，你擅长这个领域，你想开始做生意了，你考虑投资回报率能有多少，你是否可以不需要大本钱就可以开始生意，……，对于建立一个成功的生意，完全没有一点帮助。永远站在用户的角度，而不是自己的角度，来构建一个生意。只有你开始关注别人的需求时，而不是关注自己的需求时，金钱才能被吸引过来。首先给予，然后索取。你能挣到的钱多少，和你能提供的价值有直接关系。这里联想到ElonMusk，他的贝宝、特斯拉、太阳能，火箭等生意，初衷都是解决问题或者基于人类远景的，一开始不仅不赚钱，反而都是烧钱的，但最后都非常成功。 那么如何判断生意是否符合需求戒律呢？问四个问题：生意所在的环境中是否存在需求；现存的生意是否有做得不好的地方，我是否能做得更好；我能给客户提供价值；我能给这个社区带来怎样的资产。 说完本章最重要的需求戒律，回到“做你喜欢的事情”。不是说它不重要，而是这个要放在第二位，要把需求放到第一位。如果这件你喜欢的事情，第一能解决别人的需求，第二你很擅长它，那么才可以去做。前面服装店的例子，就是不满足第一点。第二点就更明显了：我超级喜欢弹钢琴诶，但是我弹得超烂诶，我能靠弹琴挣钱嘛？！唉。 从另一个层面来说，仅仅只是“做你喜欢的事情”也不大靠谱。你喜欢做一件事情，千千万万的人也喜欢啊。当你做你喜欢的事情的时候，不要忘了会有成千上万的人和你竞争。我超级喜欢瑜伽呢，那我干脆去做一个瑜伽教练吧，可是这也不会让你变成富人，只是一份慢车道工作而已，因为市场有很多瑜伽教练啊，如果你不是辣么杰出的话，你的收入也就那样啊。且不说把爱好变成工作，会严重影响爱好的享受性。 那么要怎么办呢？作者指出，爱好不靠谱，激情才靠谱。你对让某些事变得更好拥有激情。这对每个人来说都是不同的,但当你找到它时,你会为它做任何事情。 你需要把引擎的来源从爱好转到激情上。你的目标不一定是你爱的，但一定是你有激情的。驱动激情的背后是欲望：WHY。WHY大于LOVE。如果你对目标有激情，那么你可以为它做任何事情。正好今天看微信号看到一句话，《死时谁为你哭泣》的作者罗宾·夏玛说：“不是因为某件事很难，你才不想做，而是因为你不想做，让这件事变得很难。”你的目标应该是那种可以产生激情，能够让你早上起床的。 驱动激情的背后是欲望：WHY。你的WHY是什么，它足够强大驱动你吗。WHY可以是我再也不想过住漏雨的房子那种穷日子，可以是我再也不想被老板管束，可以是我想要开兰博基尼，可以是我想住带院子的房子，可以是我要证明他是错的。这些WHY不是源自激动（欲望，我想要）就是不满（可恨的处境）。 作者说他写这本书的WHY，就是希望看到自己能激励别人成就梦想。一开始写这本书的时候仅仅是出于爱好写作，可是这个爱好并未强大到让他坚持写完，中途放弃之后，是受他帮助的人的感谢信，让他又坚持写完了本书，从一开始的爱好转到最终的激情，才能得以继续。说到这里，那些看这篇读书笔记的豆瓣网友，点赞的豆瓣网友，留言的豆瓣网友，你们也是我继续写这篇读书笔记的动力之一，虽然我写这个的初衷并不是如此。 为自己绘一个极致的梦想吧，如果人没有了梦想，也就没有了激情，失去激情也就失去了成功的机会，失去了生活的意义——生活变成行尸走肉，变成活受罪。 ★第三十一章 戒律二：要有准入门槛（2015.10.25） 这章很短，作者主要阐述了一个观点：如果这个生意的门槛很低，谁想来都可以，那么你会面临巨大竞争和人潮拥堵，会很难取得成功，除非你是最杰出那个。 典型的例子：赌场，股市，合法传销。这些都是几乎没有什么门槛就可以进入的，但是正因为如此，千千万万地人员进入了市场，如果你做得还行的话，混个饭吃应该没有问题，但是我们现在在谈快车道，不是仅仅糊口的慢车道，如果你想获得财务自由，那么做得还行是不够的，你需要杰出到极致，需要做得最好。而那些真正的富裕的，是这些生意的创建者而不是参与者：赌场拥有者，股市庄家，传销创办人。 那些准入门槛过分简单的“生意”，注册一下通过你就开始做生意了，那种把准入要求过低过程简单当成了一种优势来宣传。而人类的特性就是喜欢简单，不喜欢复杂，其实呢，进入一个生意，是一个过程，是一系列行动，绝不是一个注册就搞定的事情。 如果一个市场人人都来参与了，那你可以准备撤退了。因为有钱人永远是少数，不可能人人都富裕，泡沫就是这么个意思。如果你的水管工说他的房产最近又增值了15%，你的健身教练说他的股票两个月涨了40%，你的卡车司机表弟说投资石油很有赚头，你可以考虑赶快退出市场并准备隔岸观火了。 有一期《奇葩说》，讨论年轻人该不该买房，蔡康永最后说了一句话，我一直记得：做投资之前，想想你在整个食物链的哪个位子，如果连你都知道这件事情了，地球上还有几个人不知道这件事情，如果地球上90%的人都知道这件事了，你还有什么优势可言，你还赚得到钱吗。 一个好的生意，戒律二，准入门槛不能太低。如果你想获得卓尔不同的财富，那么不要和所有人做相同的事。 ★第三十二章 戒律三：要可控（2015.10.28） 这章作者讲到了最近很热门的微商。看了一下这本书的出版年是2011年，看来微商也不是只有我们才有啊，美国那个时候就有了。只不过人家是在facebook上卖东西，咱们是微信朋友圈。 好生意的第三条戒律：要可控。如果想要走快车道，也就是挣大钱实现财务自由然后退休，而不是慢车道的赚月薪而已的话，需要一个自己可控的生意。也就是说，在驾驶的时候你要坐在驾驶座上面，而不是副驾驶上面。前者可以控制生意可以挣大钱，后者不可控制生意只能挣小钱。 为什么参与微商不是一个好生意。产品的创新，研发，定价，市场策略这些都不在你的掌握中，你其实只是一个参与者，或者更加直白一点，你只是微商创办人的雇员——一名销售。这样的话，你并算不上是开展了一个生意，你还是在慢车道上面，靠打工生活，当然了做一名好的销售也可以挣不少钱，那些大公司的CEO也多半是销售出身，但这并不属于作者想讨论的自己开展生意的范畴，其实这个情况可以参照前面的第十九章。对于微商创办人来说，才能算是在做一门生意。他挣大钱，你挣小钱。 有人说，我实在没有可以创办一个生意的魄力和智商，那实在要冒太大风险。我就坐在副驾驶上面，让别人驾驶控制，搭搭顺风车，挣点小钱，不是也挺好吗？首先，作者认为赚小钱无异于慢车道，慢车道的风险前面已经说过了；其次，交出控制权实际上风险也不小，你对你所谓的生意，毫无说话的权力，上游的任何一次变动可能会导致你的生意倒闭，而且你没有任何抗争的权力。如果你连商品定价都无法指定，你还是老板吗？如果你连商品研发方向都无法控制，你还是老板吗？如果你连下个季度市场营销方案都无法参与制定，你还是老板吗？你是在做生意，还是在打工，不要搞错了。打工的人是不创新的，他们只管销售，执行和管理。 说到底，创业的核心是：你需要自己动脑子创新，拥有自己的生意，为自己的品牌去做投资，而不是把时间都花在给人家打工上面，得不偿失。 停止去攀爬金字塔，而是去开始构建。 ★第三十三章 戒律四：要有规模（2015.10.29） 这章的道理可以直接参照第二十一章“影响力法则”：影响越多的人，就可以赚更多的钱。还有第十八章分析快车道财富公式得出的结论：快车道生意的关键是销量！它必须是潜力巨大且增长迅速的，最好能呈指数级爆炸增长，这个取决于你的产品/服务的市场。 所以，假如你开一家快餐店，能影响和辐射的区域就是一个社区而已，一天卖出去100个汉堡顶天了，一个汉堡能赚多少？天花板效应太明显。而如果你开一个连锁快餐品牌，让你的店子开到整个美国，一天卖出去10000个汉堡，那么杠杆效应就出来了，收益能迅速提起来。 可以直接影响数量与大，进入影响力法则的小的路径 你发明了一种数百万人使用的设备 你作为一个重大选秀节目的决赛选手 你在世界100强公司担任非CFO的高管职位 你建立了一个网站 你是一个负责非法死亡案子的律师 创建一个成功的零售商店和特许经营300企业 你发明的机器检测皮肤癌 分析你快车道的方程和检查你的变量。你最大的销量和利润最大化是什么单位?你的客户池的大小是什么? ★第三十四章 戒律五：可脱离（2015.10.29） 生意的最后一条戒律：时间。工作就是用时间换金钱，其实有些所谓的生意也是如此。如果一个生意完全让你脱不开身，让你身不由己的话，其实它只能算是一个工作，而不能算是一个好的生意。因为它不能产生被动收入——你一旦不付出时间了，收入就没有了。第十九章对这个有很好的阐述，这里就不重复了。而快车道的目的是让你的收入和时间脱离开来，让你得以自由，做喜欢的事情。一个礼拜工作10小时赚6万美金，还是工作70小时赚14万美金，作者说会毫不犹豫选前者——哈哈哈！嗯嗯，我们只能说作者热爱生活，不要说他懒啊什么的。 下面作者举了一个很好的例子，个人觉得有点像前面第十九章里华尔街白领辞职去加盟连锁食品店的事情，但是这个例子更加能说明问题。某同学热爱艺术和文学，于是追随自己的内心开了一家咖啡店，很文艺的那种哦，承办一些阅读交流会啊艺术沙龙什么的，一开始还蛮兴奋热情的，但是两年之后，这位同学发现激情褪去残酷现实浮现眼前：不是她拥有生意，而是生意拥有她。每天凌晨四点起床，晚上八点闭店；全年无休；雇员来了又走，给不起太高的工资，所以好的员工留不住；自己的社交生活几乎停止，男朋友也因为她实在没空而终止来往；健身卡早就过期了，瑜伽课也是再也没有去参加。为了夺回自己的时间，她有考虑过请一个经理替她打理店铺，但是精打细算之后发现无法负担这项开支。她的这项生意，没有给她带来自由，且对她生活的消耗远远大于她的收益。在这个例子中，店主的生意并未失败，如果她想，这个咖啡店可以一直开下去，并且收入也够给她带来一般的中产生活水平。但是，她自己却失败了，她付出了自己的年华和自由，在进入这个生意之前，她没有想到最初的激情褪去之后，情况会是怎么样。“做自己喜欢的事情”和“做自己的老板”，这两句话闻起来似乎有自由的味道，但是如果这个生意违反了戒律五，反而会让你付出自由的代价。 那么如何找到可脱离的生意，形成被动收入呢？请参照第十九章提到的五个被动收入”指数较高的行业。 ★第三十五章好生意的三要素（2015.10.31） 前面提到了好生意的五条戒律，缺一不可。这章讲的是，在不违反这五条戒律的情况下，三点助力要素：互联网，创新，可复制。 互联网：天然的符合“影响力法则”了，受众规模潜力巨大，显而易见我就不多写了，虽然作者说了很多。 互联网商业模式(道路)分为7大类 基于订阅 提供用户对数据的访问、信息或软件,每月收取费用 基于内容 基于内容的模型在线新闻杂志和博客传播信息的特定的领域或行业；这些服务提供免费内容消费，出售广告方想要达到吸引眼球的目的 引导潜在顾客 我合并一个高度分散的行业到一个集中的来源,将消费者带入，并将消费者信息卖给了企业 解决两个需求 消费者希望节省时间和金钱 企业主需要找到新客户 社交网络 社交网络是纯粹的志同道合的聚合器 FaceBook、LinkedIn 经纪业务系统 经纪人将买家和卖家联系在一起,促进交易 广告 广告商接收广告的费用 搜索引擎：Google、雅虎就是这样的商业模式 电子贸易 通过网络销售货物、服务和信息 亚马逊就是这样的例子 创新：这个说得挺有意思的，作者认为创新必须包含两步，即创新和分销。首先创新：创新者的核心任务是找到一件商品，然后在其上进行改进。好玩儿吧，并不是说你要发明这件东西哦。那些发明汽车，电话和飞机的人，并未做得一个好生意，反而是那些在已有商品上面做出改造创新的人们，做得了好生意。比如有个成功的创业者，他是卖酒的。他并没有发明伏特加，而是给它们包装到一个个花花绿绿的瓶子里面，作者自己过生日的时候就收到过骷髅头包装的伏特加，有意思吧。其次分销：你创新的产品，必须通过分销手段卖到大众手里，否则就是白搭，分销手段有很多，网络商场、代理、电视购物、超市等等。 可复制：这个就是连锁快餐店模式。如果星巴克的创始人只开一家咖啡店，是没法称之为一个好生意的，但是他复制了他的成功经验，将连锁店开到全世界，取得了规模优势。比如，你在商场放一台自动糖果售卖机，可能没法赚很多钱，但是如果你在和一家商场一段时间的合作中取得了经验，如何和商场谈判分成，如何选择机器放置方位，如何定位糖果档次等等，并把这些经验应用到全市，甚至全国的商场售卖机上面，那么这项可复制的生意就会给你带来好的收益。 ★第三十六章找出一条可行的路（2015.11.1） 接着上一章讲，如何找出一个好生意。作者认为，机会不一定要是原创的新点子，已经有人想出来了并在做？没有关系，只要你做得更好或者找出一个新方向就可以。一个新点子并不会带来成功，而好的执行会。解决人们的不方便，是机会；简化流程，是机会；提供更好感受，是机会；提供舒适体验，是机会；提供更好的服务，是机会；平复痛点，也是机会。 成功的企业很少从一些传奇发展的想法。成功的企业家把现有的概念让他们更好。 你不需要一个想法从来没有有人做过。旧思想足够了,把它做得更好好像没有人! 咖啡早就有人在卖，但是霍华德·舒尔茨以“将心注入”的理念在80年代开办了星巴克；超市早就存在，而山姆·沃尔顿以“一站式”的规划在60年代开办了沃尔玛。 如何抓住机会呢？好好感受自己和他人的下列想法：这种xxx太讨厌了；我不喜欢xxx；这系统真是崩溃；要是xxx就好了……机会就来自于这些日常的小抱怨中，解决人们的问题，满足人们的需求。 失败是再正常不过的了，如果确实是走的路错了，退出来再重新选一个生意来做。更换生意是OK的，但是不要放弃快车道梦想。 ★第三十七章给自己找个目标（2015.11.2） 喜欢这章的开篇语：生活的悲剧不在于你没能实现你的目标，而在于你没有目标——本杰明梅斯。 幸福来源于选择的自由，而这自由需要足够的钱来实现。实现梦想是要付出代价的，需要你付出钱，责任和承诺。 想想你梦想的生活方式，估算一下大概每个月要多少钱能实现它，然后反推出你需要多少存款or什么样的生意产生被动收入能保证你想要的生活。比如你觉得现在的生活方式就挺不错的，现在月消费是1万元，那么算一下你需要有多少存款或者一个什么样的生意被动收入可以保证你不必上班干活，即用时间换金钱，也能维持这种生活方式。以此为目标，去努力吧。 光有目标还是不够的，需要从一点一滴开始学会赚钱。如果你想每个月赚1万，那么从每个月赚5块钱开始吧。 学习必要的财务知识，不要完全依赖财务顾问的建议，自己掌控。 利率 应税与免税收益 分期偿还的抵押贷款 支付簿的平衡 基本的百分比计算 计算投资回报率 为什么股市会起伏（原因） 为什么一个担保银行CD尖叫回报率为15%,“这是个骗局!” 股票期权是如何工作的 保险存在的原因 共同基金是如何工作的 证券是什么，他们如何兴衰 国际货币 学会量入为出，不管赚多赚少，都不要花的超过赚的。这一条建议对于慢车道人们来说是节流，对于快车道人们来说是开源。 ★第三十八章执行是王道（2015.11.2） 上面的九章内容，讲了如何构建生意。从这章开始要讲本书最后一个主题：财富加速度，即做生意的原则。 这章的内容是：执行是王道。 那些整天唧唧歪歪：“我想到了一个绝佳的点子”和“我这个主意绝世无双”的人，注意了——你的点子不是最重要的，执行才是王道！如果你有一个绝妙的点子，但是啥也不做，等着有人过来出钱出力，帮你把点子实现了，然后你就可以坐等赚大钱了，那是妄想，好嘛……前面作者已经不止一次提到，人类的特性是喜欢结果不喜欢过程，其实想出来一个点子，是一次大脑里的化学反应，是一个无需太多付出的结果；而执行才是过程，这中间包括了太多的努力、牺牲、自律、坚持。 作者把点子比喻成兰博基尼的仪表盘，上限是220mph；把执行比作实际速度。虽然兰博基尼可以开到220mph，但实际中连150mph都绝少开到。你的点子的优劣程度好比仪表盘上的速度上限，一个好的点子可以有很高的上限，但是启动汽车和踩油门这样的执行动作，才会使车子真正移动起来，并产生实际的速度。 想法是毫无价值的,执行是无价的。 很多创业者的误区也就在这里，太在乎点子而不去思考执行。而实际上，一个好点子真正的拥有者，是能把它执行好的人，而不是想出来它的人。就像eBay并不是第一个做电商的，星巴克并不是第一个做连锁咖啡店的。 ★第三十九章执行是王道-续（2015.11.3） 光说不练是不行的。如果你的想法不去市场上面执行一趟的话，你永远不知道会发生什么样的事情。如果你想知道市场会如何反应？那就把你的点子去执行一遍，市场自然会告诉你。也许你的目标是X，结果走向了Y；也许你想去大卖产品A，最后却卖出了很多产品B。 商业计划那些都是鬼扯，除非结合执行。如果你有做过执行的丰富经历，投资人会对你的商业计划另眼相看；如果你毫无执行经验，仅凭空想得出来的商业计划，是很难打动投资人的。 世界上最好的商业计划将永远是一个执行的记录。 虽然相对于执行来说，商业计划显得没有什么用，但是财务分析还是很有用的，执行之前有必要了解一些财务规范。 我开始我的公司不充裕,900美元。没有投资者,没有资金,没有帮助。事实上,如果我浪费150小时在95页的商业计划,没有人会阅读它，因为我没有经验的:我没有钱,没有记录,没有比赛了,没有完成, 没有比赛赢了。 Fastlane论坛上一个常见的问题是“我如何才能找到投资者对我的想法吗?“无论这个想法是一项发明或是一个伟大的新网站,我的答案是这些人们没有想要听到的。如果你想要投资者,并执行!创建一个原型!创建一个品牌!创建一个记录,别人能看到或触摸!深入的过程。当你有一个物理表现的一个想法,投资者将会打开他们的钱包。已经足够好了他们会努力给你钱 投资者更有可能投资于有形的东西,真实的；不是没有创意的广告或说过的话。 ★第四十章客户是上帝（2015.11.4） 很老套的标题吧。作者自称：一个老派的创业者。他认为比起花重金去争取新客户，不如花点精力留住老客户。当然了，在风投们重点看客户增长数量的今天，可能不那么容易。 所有投诉的书面记录,客户的不满与抱怨,我的生意经验的日常问题； 他们代表免费的反馈和暴露您的业务无法满足的需求。 我必须评估这个问题并采取纠正措施； 作者这章说的无非就是要：重视客户的反馈 &amp; 提供超越期望值的服务。 客户反馈。分成四种， 第一种对变化的抱怨。每当作者辛辛苦苦几个礼拜设计出新的网页界面发布之时，都会招来客户抱怨，人们天性不喜欢变化，不管是好的还是坏的。有的时候你得学会像客户妥协。 第二种是对期待不能达成的抱怨。对待这种，你要么加把劲满足他们的期望值，要么好好维护一下他们对服务的期望值——不要期望得太高。 第三种对需求的抱怨，客户告诉你他们想要什么，而你无法提供，这种是最好的机遇，了解用户的什么需要没有得到满足，是成功生意的必须。 第四种勒索，有些用户抱怨纯粹就是勒索，不幸地是，你无法避免，发生这样的事情实属平常，不要大惊小怪，不要影响心情，有理有据有节的回应它（这里作者倒是没有给什么特别有效的办法，只是告诉大家，遇到勒索是很正常的）。另外补充一点，虽然倾听客户想法很重要，但是不要妄图取悦每一个人，对待有些客户抱怨，忽略它就对了。 我不知道成功的关键,但失败的关键是你设法让每一个人都喜欢。 口碑营销：当你的客户喜欢你的业务,他们会成为你的粉丝和宣传；并且是免费而且强大的人力资源系统。 怎么做？提供超越期望值的服务； 提供大量客户的服务和激增你的业务,你需要确定客户的期望形象。 当他们接触你的业务时，他们的期望是什么？ 在你的行业，他们如何与竞争对手和类似的企业进行相关联? 做一个主观的客服服务期望； 最后，以超出客户期望（自己营造的）的服务服务他们 提供超越期望值的服务，方法有很多种，作者提到一种特别的是：尽量使公司看起来高大上但服务却很亲民。 不要外包服务，或者使用那种语音留言系统。 让客户的邮件能够分钟级得到回应，让客户电话能够里面接通真人，这些都是能提高客户满意度的方式。 不管你的公司现在是什么体量，尽量让它看起来专业一些，高大上一些，这样做不仅能够让客户得到亲民服务时更感满意，而且会让那些想进入相同领域的潜在对手，在最开始的时候选择放弃进入和你竞争的态势。这一点身边有个例子，当初彭同学的一个顺丰包裹寄丢了，她生气地找到顺丰的老大（我也不知道她怎么找到他的，我只知道她肯定和他不认识），结果人家立马响应，不仅找到了她的包裹，区域经理还亲自登门道歉，彭同学不仅火气消了，还经常跟大家说这个案例，夸奖顺丰是一个靠谱的公司。于是，我心里面也潜在得认为顺丰是一家靠谱公司了。 那些首先追逐金钱，再去寻求需求的企业家，往往把广告花费在在追求新客户的身上。 ★第四十一章避免猪一样的队友（2015.11.4） 作者认为合作者，律师，会计师，员工都是需要认真挑选的。 行动比言语更响亮。 特别是合作者，你们合伙做生意，其实和结婚并无两样。需要相同的价值观，做事的方式，看人的态度等等，否则不仅走不到最后，反而会变成仇人。比如你想要的是成就伟大的事业，而对方只想实现财务自由，在公司发展到一定规模之后，何去何从必然会有分歧。不要轻易地相信“要选择互补型个性的人做合作伙伴”，这种想法看起来很合乎逻辑，但是实际操作起来，你不一定会忍受得了对方与你的“不同”。 律师和会计师也很重要，他们可能会给你的生意和财务带来巨大影响。 员工也一样，他们是直接和最终客户打交道的人，客户服务的好坏，直接会导致客户下次是否再来。优质的服务会让人们忽略你公司的其他缺点，而再好的硬件也无法使人忽略差劲的服务。为了保证良好的客服体验，你必须与员工分享你的客户服务理念。客户服务理念是来自互动，而非挂在CEO办公室上雄心勃勃的话语。 两个重要的经验教训 提供超越期望值的服务最终必然是由你的员工去执行的 你的员工营造公众对你公司的感知； 卓越的产品特性并不能抵消/克服糟糕的服务 狂热的客户服务可以克服缺点,但狂热的特性不能克服糟糕的客户服务。 在看人选人这一点上，作者认为：不要听人怎么说，要看人怎么做。首先进行验证，然后再信任；这也许会花费你更多的时间，但是值得。 ★第四十二章专注创新（2015.11.4） 这章讲得深得我心啊。 一定要避免同质化经营，比如买机票和加汽油，用户是鲜有忠诚度可言的，一般而言：谁便宜买谁的。因为产品没有任何显著区别。如果陷入这种同质化经营模式，就不得不被迫降价经营了，这是每个经营者都不愿意陷入的生意模式。 这里就引出一个很重要的问题，你为什么去做生意？大多数人是因为错误的理由：因为我想要创业啊，因为我想当老板啊，因为我想找一件事情做啊，因为我喜欢这一行啊，因为我熟悉这个领域啊，……这些理由都是很自我的理由，而不是因为大众有需求。在第三十章“戒律一：需求为王”里作者已经讲得很清楚了，纯粹基于你想要，和基于大众需求，而建立起来的生意是有本质不同的，前者很容易变成失败的生意。 那么基于需求做生意和避免同质化经营有什么关系呢？作者认为，只要你用心在满足客户需求上，开发创新，就会让自己的生意与众不同。不要只盯着竞争对手看，他做什么你就跟进，这样的生意永远和别人一样，永远在往同质化方向发展。要聚焦在自己的心和客户需求上面，研究创新，引领行业。 成熟的公司，大部分注意力都在自身和客户需求上，但也会花一部分精力会盯着竞争对手的弱点看，他们有哪些做得不足的，我能不能避免犯同样的错误，我能不能比他做得更好，从而吸引他们的客户？ 差异化永远是同质化的天敌，而创新是差异化的来源。 ★第四十三章创建品牌，而不是生意（2015.11.6） 这章好长好长啊，作者讲了很多关于品牌的市场营销手段，我相信类似的教程比比皆是，并不是什么新鲜的经验之谈了。强势的市场营销能够让客户去购买普通的商品，可以掩盖瑕疵；作者认为一个好的市场营销手段，应该是打造品牌：生意是谋生存，品牌才是谋致富。营销和品牌是快车道中最强大的工具。 好的品牌是抵抗同质化竞争的最佳武器，因为用户只会对品牌忠诚，而不会对生意忠诚。苹果就是一个很好的例子，它并不是最便宜的，但是它是有品牌特征的，它时髦，可靠，安全。例如，我对可口可乐忠诚，不喜欢百事可乐；那我就不会在乎百事可乐是否降价了。但是，可口可乐比百事可乐吗?我不知道也不关心。 例如，当你想到沃尔沃汽车,你觉得呢?我觉得安全。保时捷吗?我认为速度。法拉利怎么样?我认为富有。大众汽车吗?实用。丰田?可靠性。这个就是品牌；【引申到自身职场的标签；努力去营造属于自己的标签】 那么靠什么来打造品牌呢？优质的服务是方法之一。 如何打造优质服务呢？五步： 一、重中之重：解决问题或者需求； 二、成为独一无二的； 三、给出特殊点并且明证它； 数字是具体的有说服力的方式；达美乐披萨没说“按时交付,”他们说,“在30分钟内不然免费。” 四、标题简洁有力； 五、利用“所有”可宣传的途径；记住，是“所有” 你的卡车,汽车,和建筑物 你的广告和宣传材料 名片、信纸的信头、信号、小册子和传单 你的网站和你的电子邮件签名 你的语音信箱系统,接待员/销售脚本,等等 六、实现它。 打造品牌的方法二：在大众中脱颖而出。也有五步： 一、偏激，两极化来引起话题和关注； 极化工作可用于极其需要流量的网站或书籍；因为当你出现一个偏激的观点时，必然会引起人们的注意 二、利用sex相关来引起话题； 关于性的话题不会过时。你可以过度使用它,但是人们总是会回应 三、激起情绪； 对于一些引起共鸣的情感，你购买某个产品可能仅仅是因为它引起了你的共鸣 四、互动（问题与回答、汽车试驾、心理问卷）； 例如，我提出一个关于快车道的话题，然后我收到了很多的来信 五、特立独行（噱头，吸引注意） 例如，你见过兰博基尼卖一美元? 其实作者写得很详细，但是鉴于这些都可以在类似营销的书籍里看到，这里我就不多做总结了。 这一条我还蛮受启发的。很讽刺的是，想要赢得快车道竞赛，需要首先抛弃自私而需要满足别人的自私。 （It’s ironic: To succeed a Fastlane we must forsake selfishnessyet satisfy the selfishness of others.） 人类天性就是自私的，所以我们的市场策略必须针对用户收益，而非产品特性。人们需要被告知到底是什么。如何将你的产品或服务帮助他们?好处是什么? 作为顾客，他们购买东西解决需求；我们从事交易来填补空洞。 当客户买裙子的时候，买的其实是一种影像；当客户买度假产品的时候，买的其实是一种体验。所以必须要把产品特性翻译成客户收益。四步： 一、找出用户，换位思考； 首先必须明白你的客户是谁？ 其次，问他们。他们想要什么? 他们担心什么?他们需要解决什么问题?或者他们只是想“感觉”什么东西吗? 两个品牌的相同的产品可以有两种不同的买家。买了巡洋舰有的心理动机与买的沃尔沃的人是不同的。虽然都是汽车,然而,跑车买家不买基本的运输。Corvette买家很可能是一个敢于冒险的人,自由职业者,独立,直言不讳,自信的。沃尔沃的买家可能是更关心家人和安全。他或她可能是保守、分析,以家庭为中心的。两个完全不同的买家资料意味着每个营销努力必须专门针对每组的欲望。 二、找出产品特性； 三、找出优势； 四、把优势翻译成收益。 案例：例如我的Web服务,我这里有几个特点:1)上传图片2)目标导致的车辆,日期和服务和3)安排车辆。 我的Web服务,“上传图片”翻译的收益为:“停止浪费客户会议在车库的时间。上传的照片你的舰队和显示你的客户你的产品!” 目标导致功能的翻译:“你目标客户想要到这一天的服务,车辆类型 安排车辆翻译成:“时间和最大化你的舰队的道路，然后根据您车辆的可用性接受引导 当每个特性转录到特定的利益，这将迫使我的买家加入。 价格暗示了产品/服务价值。作者举了一个很好玩的例子：商户清理库存，把一个橱柜扔到了街角，结果几天都无人问津，于是他去给街角的橱柜挂了一个50美金的价格标签，第二天就被人搬走了。正确的定价策略对品牌建设和营销是至关重要的。错误的价格传达错误的意义。 如何一个手提包售价4000美元时可能成本少于100美元呢? 品牌管理和营销能力。价格是品牌的构建。 最终的最终，市场营销手段种种，制造噱头，提高价格，之类的，基于的还是差异化，只有你的产品/服务有了差异点，这些策略才能奏效，而这一点需要你的生意是从解决问题和需求出发，而不是从自己的想要出发。 ★第四十四章专情一点（2015.11.7） 这章很短，作者就讲了一件事情：对待生意要专情一点，不要同时铺开好几个生意一起做，那样会分散精力，最后都难以为继。因为做生意实在是一件要全身心投入的事情，一件生意应该值得你去花所有精力，不留退路，全力以赴，那样才可以做好。分散注意力导致了散乱的结果。 ★第四十五章全书总结（2015.11.7） 你的选择是在一个时刻,但其结果将超越一生。By MJ DeMarco 这章把上面所有道理都简短梳理了一遍，我在此就不多说了，具体见如上全文。 完结撒花！（2015.11.7大风降温的周六下午，开着暖黄的床头灯，听着我最爱的虾米精选集“何以解忧，唯此静心”，腿窝在被子里，敲下完结语。很高兴这本书读完了，耗时三个月，没有因为是英文书的缘故变成坑，感谢翻译笔，感谢85度C，感谢一颗柠檬，感谢豆油，感谢自己。） 来自 &lt;https://book.douban.com/review/7556047/&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《沟通的艺术》读书笔记_罗纳德.B.阿德勒]]></title>
      <url>%2F2016%2F06%2F03%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F30_%E8%A1%8C%E4%B8%BA%E5%BF%83%E7%90%86%E5%AD%A6%2F%E3%80%8A%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B_%E7%BD%97%E7%BA%B3%E5%BE%B7.B.%E9%98%BF%E5%BE%B7%E5%8B%92%2F%E3%80%8A%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%BD%97%E7%BA%B3%E5%BE%B7.B.%E9%98%BF%E5%BE%B7%E5%8B%92%2F</url>
      <content type="text"><![CDATA[———–分割线———— 第一章 人际沟通入门 1.1 我们为什么要沟通 认同需求：我们是在别人诠释我们的过程中才逐渐明白了自己是谁。如果剥夺了与人沟通的权利，我们将无从得知自己是谁。 1.2 沟通的历程 交流沟通模式：重叠部分的“背景”很大程度上影响沟通的效力 交流式的沟通并不是我们“对”别人做了什么，而是我们“跟”别人做了什么。【在这个意义上，表明沟通必然是双向的，而非单项的信息传递】 沟通：一个交流的过程； 其参与者处于不同但又有所重叠的背景下，经由交换信息而建立关系， 关系的品质会受到外在的、生理性和心理性的噪音干扰 人际沟通与非人际沟通：两者的区分，由沟通的品质而非数量决定了人际沟通的定义；人际沟通，私人化的； 五个区分点： 非人际沟通 人际沟通 独特性 社会规则+社会角色为决定因素 特定规则+特定角色为决定因素 不可替代性 无可取代 相互依存性 公开性 公开一部分私人信息 内在回报 与参与者无关的回报（或理解为以某种目的为前提的外在的回报） 内在的情感的方面的回报 1.3 沟通的原则与迷思 原则：沟通同时具有两个向度 内容向度：双方明确讨论的信息 关系向度：表达你对对方的感觉 1.5 如何成为沟通高手 有效沟通的定义：有效性+适当性 维持或增进感情 实现自己的目标 沟通能力依情景而定；不应该以偏概全地说“我是一个失败的沟通者”，应该是“尽管我不能很好地应对这个状况，但我在其他场合能处理地更好” 沟通高手 具体描述 启发 拥有多样的行为反应 情境：对方一直在重复一个笑话，可能有关歧视或性暗示，这让你觉得被冒犯了，你可以采取： 1.保持沉默，因为你知道一旦开口了，引发冲突的风险高于它带来的好处 2.要求第三方提醒说话的人，让他注意言谈间的攻击意味 3.暗示说笑话的人，让他感受到你的不舒服 4.针对朋友感觉上的迟钝开个玩笑，期望借着幽默缓和你言语上的攻击 5.坦白说出你的不适，并要求朋友停止谈论这个话题，至少不要在你身边说 6.直接叫他不要再说 由此发现，其实处理方法不止 说or不说 这两种情况； 想成为“沟通高手”，首先在意识上应该认识到有多种反应的行为 选择适当定位的能力 根据情境、目的、对他人的认知来决定你所要做出何种反应 高EQ的人，是思考之后在几种方式中进行选择，而非出于本能的反应 表现行为的技巧 适应各个阶段： 意识觉醒期：意识层面上进行的反应 笨拙期：刚开始的行为反应 熟练期：保持联系，客服初期尝试后的尴尬阶段 整合期：当你没有特意去思考一件事情，却能表现得很好 认知复杂度 同理心 自我监控 观察自身的行为，并借此调整自身行动的过程 承诺 第二章 沟通和认同：自我的塑造与展现 2.1 沟通和自我 自我概念和自尊 自我概念：你对自己所持有的相对稳定的知觉；（你认为自己是谁，是怎么样的） 如情绪、天分、喜好、厌恶、价值观等，类似这样的一张清单，展示了自我概念中最根本的一个部分。即使是一个会让人产生不快的词，人们也往往很难放弃，而当被放弃这些最核心的感觉和认知时，大部分人会觉得害怕，会坚持说，“如果没有了这些，我就不再是我了” 自尊：你对自我价值的评估； 例如某个沟通者的自我概念包括安静的、好辩的或自律的，他的自尊高低取决于他如何看待这些概念 评估1（低自尊） 评估2（高自尊） 安静 我简直是个懦夫，所以才会说不出话来 我享受倾听甚于讲话 好辩 我太强势了，一定很惹人厌 我在自己的信念上坚定不移 自律 我太小心翼翼 在我开口说话或动手做之前，我总会深思熟虑 拥有高自尊的人，倾向于认为别人是好的，并且期望被他们接受； 不喜欢自己的人很可能认为别人也不喜欢他们；低自尊的人认为所有人都一直用批判的眼光看待他们，不管这种想象是否符合现实 自我的生物性和社会性根源 社会化与自我概念 我们每个人得出的自我概念反映的是我们认为别人看待我们的方式；而这些自我概念很大程度上来自于“重要他人”（家人&amp;好友）的影响； 此外，还通过社会比较形成我们的自我形象；即根据与他人对照的方式来评估自身； 参照群体，对如何塑造自己的观点起到了很重要的作用 自我概念的特征：主观的+抗拒改变的 自我应验预言：指如果个体对事件的发生有所预期+他接下来的行为是建立在这些预期之上的，那么这件事的发生会比没有预期更可能成功； （1）持有某种期待（对自己或别人）、（2）表现出与期望一致的行为、（3）期待如实发生、（4）强化起初的期待 1.我计划要去应聘一个渴望得到的工作，但对自己该如何表现很焦虑，也不确定自己是否有实力被录用。我向了解自己的教授和在其他朋友请教，他们都认为我非常胜任这份工作。 2.基于这些评价，我自我感觉良好，并且参加了面试。 3.我不仅镇定地表达了想法，还很自信地推销了自己。 4.我最终获得了这个职位，并得出结论“我的教授和朋友说得对，我的确是老板愿意雇佣的那种人才。” 两种自我应验类型：自我加强/他人加强的预言【可用于实践】 自我加强：自我期待对你的行为产生影响；（如果你的演讲只有一个观众来参加，或者你的内心充满了恐惧，你很可能会忘记自己的发言。这不是因为你没有做好准备，而是因为你告诉自己“我知道我搞砸了”） 他人加强：（1）观察者首先自己要相信这个为预期目标群体制造的预言；（2）更要传达出这种信任；以便使这一预言产生实质性的效果； 例如：一个老板关心一个员工的工作能力，但却没有表单出这些关心，那员工也不会被影响 \2. 2 自我的展现：沟通做为认同管理 隐私自我：觉知的自我；感知到的自我是你在真诚的自省过程中所相信的自己；这种自我是“隐私的”，因为你不可能把它对一个人全部展现出来 公开自我：即展现的自我，是一个“公开的”形象，就是我们想要别人看待我们的方式； 认同管理 致力于构建多元认同：大部分人要扮演不同的角色，“礼貌的学生/有趣的朋友/友善的邻居/有用的员工/一个父亲”，基于不同的情境，我们需要转换不同的行为模式 序号 角色 特点 要求 1 父母的独子 2 公司员工 3 彦的男朋友 4 同事 5 大学好友 6 多年好友 7 普通朋友 8 租客 9 消费者 10 11 深思熟虑 or 不知不觉： 大部分工作面试和第一次约会都是深思熟虑的； 日常大量交流中，我们对自身行为的选择不是经过深思熟虑的，而是依赖于我们随着经验发展出来的“脚本”来决定的；只有当角色不适合的时候，你才会慎重考量你需要作出的反应； 管理认同：现实&amp;虚拟世界 现实世界：行为举止、外貌、配备（汽车、房屋是否整洁） 实际上所有的对话都提供了一个舞台，沟通者通过回应他人的行为构建起对自我的认同 事实上，如果我们不提前决定自己在不同情境中所要呈现的角色，我们几乎无法进行有效的沟通；成为一个沟通高手，部分取决于他能一句不同的情境挑选出最佳的角色。【用于实践，但第一步应该是你要知道你有哪些角色可以扮演，以及他的特性是什么】 为什么要管理认同？为了开始和经营关系、为了获得的别人的顺从、为了保住别人的颜面、为了探索新的自我 2.3 在关系中的自我袒露：指有意透露与自己相关的信息； 自我袒露：有意的、重要的、关于自己不为人知的信息 自我坦露的模式： 社会穿透模式：广度、深度（一个圆） 陈词滥调&lt;陈述事实&lt;给出观点&lt;倾诉感受 陈述事实：我是镇上新搬来的居民 给出观点：我真的很喜欢这里 倾诉感受：……但是，我优势感到有些孤独 乔哈里视窗：开放区、盲视区、隐藏区、未知区 自己知道的 自己不知道的 他人知道的 开放区 盲视区 他人不知道的 隐藏区 未知区 自我袒露的优劣势 优势：宣泄、互惠、自我澄清、自我确认、关系的建立和维持、社会控制 劣势：拒绝、负面印象、降低关系满意度、丧失影响力 自我坦露的原则：这个人对我重要吗？坦露的量与方式合适吗？风险合理吗？有建设性的影响吗？你的自我坦露是互惠的吗？在道德上有义务袒露吗？【其实，所有沟通的内容与方式，应该是经过思考之后的】 2.4 自我袒露的替代选择：沉默、说谎、模棱两可、暗示 沉默：你可能会发现保留自己的想法和感受是你经常做的事情，说出全部的事实虽然符合坦诚之道，但有可能危害你和对方的关系；大多数心思缜密的沟通者都会选择保持沉默，而不是一吐为快说“你看起来糟透了”或者“你太多话了。”【可以分别记录一下自己什么时候表达、什么时候不表达意见，然后就可以对自己以来袒露和沉默的的程度有一个大致的了解；】 说谎：善意的谎言，是考虑到信息接收者的利益而说的。 模棱两可：当面临说谎还是说出一个令人不愉快的真相的困境时，沟通者通常会选择一种模棱两可的回答。【熟记并理解“真实和模棱两可的向度”】 暗示：暗示其实比模棱两可更直接；因为模棱两可的说法不一定要求改变他人的行为，而暗示旨在从他人那里得到期待的回应。 【对于回答的方式，其实都是思考之后的，选择自我袒露的程度or替代选项】 第三章 知觉：看到什么就是什么 3.1 知觉历程：选择—组织—诠释—协商 选择：身边的信息远超出所能处理的限度，所以知觉的第一各个步骤是“选择”那些能给我们留下印象的信息； 刺激的强度、重复的刺激、频繁的对比或转变、动机 组织：选择相关信息后，必须用有意义的方式组织这些信息； 诠释：以某种方式加以诠释，使之具有特定的意义。 影响我们诠释事件/行为的方式：交情深浅、个人经验、对人类行为的假设、态度、期望、信息、自我概念、关系满意度 协商：他们影响者彼此的知觉，并且试图在感知上达成一种共识； 3.2 影响知觉的因素：获取信息、生理因素、文化差异、社会角色 生理因素：感官、心理挑战、年龄、健康与疲劳、饥饿、生理循环 社会角色： 性别角色：指被社会所接纳和期待的男性行为模式； 职业角色 关系角色：个人与事件/他人之间的关系 3.3 知觉的倾向；归因，描述我们将行为赋予意义的过程； 对人严厉，对己仁慈 先入为主 以己之心，度人之心：第二章已经解释过这一原则：低自尊的人会猜想别人以不利于自己的方式看待自己，高自尊的人会猜想别人以对自己有利的方式看待自己； 我们被期待所影响：假设你参加了一门课程，却被提前告知上课的老师非常糟糕，这必然会影响对这位老师的认知；【所以，做任何项目/事情/见面之前，营造中肯&amp;良好的期望是很重要的】 最明显的最有力：容易被显而易见的事情所影响；问题在于最明显的因素不一定是事件中唯一或最重要的因素。 3.4 知觉检验：如果我们一厢情愿地认定我们队事情的解释就是事实，恐怕会产生很多严重的人际困境；知觉检验是帮助你正确了解别人的一项工具，它并不假设你的第一印象是正确的；【将知觉检验加入日常思维中，努力去实践】 知觉检验的要素： 描述你注意到的行为 列出关于此行为至少两种可能的诠释 请求对方对行为诠释做澄清 知觉检验的考量： 完整性：有时知觉检验不需要囊括所有部分也能够奏效 非语言的一致性：只有当你非语言的行为也反映出你语言所表达的那种开放的态度时，知觉检验才能成功； 文化支配：低/高语境文化【第五章】 保留颜面 知觉检验是一种比较不具威胁地指出对方行为的方式；要记住，沟通能力的一个要素是在各种方案中选择最佳选项，而知觉检验是在许多时候都有用的策略； 3.5 同理心与沟通； 同理心：从另一个人的角度来体验世界，重新创造个人观点的能力； 获得观点：采用另一个人观点的尝试，这需要中止你的诊断，将自己的意见放在另一边，试着去了解对方 情感面向：使我们更贴近地去体验别人的感受 真诚地关心：更进一步关心他们的福祉 认知复杂度：运用“枕头发”处理复杂、严重的议题 枕头法 解释 立场一 我对你错 立场二 你错我对 转换视角，尽最大可能来解释他人的观点如何与你不同 立场三 双方都对，双方都错 立场四 这个议题不重要 黄金法则：按照你所希望被对待的方式去对待别人 白金法则：按照别人所希望对对方的方式对待别人 先去了解别人是怎么想的和他们想要的是什么。 第四章 情绪：感觉、思考和沟通_2016.06.15 4.1 什么是情绪 非语言反应：会引起某些情绪状态；例如，通过改变脸部的表情，引发他们不同的情绪状态； 情绪感染力：这个过程使情绪从一个人身上传递到另一个人身上； 4.3 情绪表达的原则 辨识感觉、说话和行动之间的不同：感觉到某种情绪，并不意味着你要把它说出来；也不意味着你必须遵照它行动。 了解有感觉和发泄情绪之间的差异有助于在困境中建设性地表达你自己。 扩充你的情绪词汇 你可以用不同的方式，说出同一种感觉 使用单一的词：我在生气 描述你发生了什么：我胃好像打结了 描述你想要做什么：我想给你一个拥抱 传递暗示信息的人，面临着失去让地方了解自己的感觉以及满足需求的机会； 例如，以间接的方式说“我很孤单”，也许就变成了“我才这个周末没什么事情，加入你也不忙，可以发短信给我，我们一起出去逛逛”；类似这样的信息会非常婉转，以至于别人可能听不出你的真实想法。 如果你下定决心要表达你的感觉，你必须很清楚地确认你和你的伙伴都了解你的感觉只适用于一套特定的情境，而不是直接针对整个关系； 你应该说，“当你不守信用时，我会怨恨你”，而不要说“我怨恨你”；“当你讲到你的钱的时候，我觉得很无聊”，而不是“我和你在一起很无聊” 分享多样的感觉：我有什么感觉？我又会表达什么感觉？ 尽管我们的情绪是混合的，但我们通常只会表达其中一种，而且还是最负面的那种情绪。【所以，表达感觉是应该多样而全面地表达；这样会让你更加清楚地看清自己的情绪】 朋友在Facebook上发布了一张你的照片，一方面因为朋友展现了对你的喜爱而开心，一方面因为光线不好使得你不好看；你希望朋友可以提前问问你。 4.4 管理困恼的情绪_2016.06.20 无助益情绪的来源：生理因素、情绪记忆、自我内言 情绪记忆：只要某个事件与过去的困扰经验有一点点相似之处，即便是寻常事件也会引发无助益的情绪。 自我内言：人对一件事情所做的诠释决定了他们的感觉。 非理性思考和无助益的情绪 完美的谬误：接受完美谬误的人，相信一个好的沟通者应该有全然的信息和技巧来处理每一种情况。 赞同的谬误：认为得到别人的赞同是生活上不可或缺的事，并且十分向往得到所有人的赞同。 应该的谬误：不能区分“是什么”和“应该是什么” 过渡推论的谬误： 基于有限的证据而做出推论 夸大缺点与优点（你总是迟到；你从来不听我书） 因果论的谬误： 造成那些对沟通过渡谨慎的人的困扰，因为他们不想“引起”别人的痛苦困惑或麻烦；发生情况 ： 【当你坚信自己是引起他人感觉的唯一原因，未免太自恋了。】 - - 探望朋友或家人出于一种义务感，而不是一份想要看到他们的真诚的渴望； - 当别人的行为打扰到你时，你仍然保持沉默 - 当你快要迟到下一个约会，或觉得身体不适时，还是假装专心听那演讲者说话。 - 我们相信别人是引起我们情绪的原因。 无助的谬误：生活满意度受到超过你能控制的压力所决定；不断地视自己为受害者的人会有这样的陈述： 【只要你了解“如果你真的想做，就有许多事情可以去做”这一点；许多“不能”是不想改变】 我不能告诉上司她对我的要求太多，如果说了，我可能会失去工作 我生性害羞，想要变得外向，但是没有办法 灾难性预期的谬误：他们认定加入某件糟糕的事可能会发生，你们它就一定能够会发生。 【一旦你开始料想灾难性的后果，自我应验预言就会开始建立；其实，也是不自信的一种表现；】 假如我邀请他们参加宴会，他们或许不会想来； 假如我告诉他们我真实的感受如何，他们也许会嘲笑我； 减少无助的情绪【提供了一个可执行的步骤】 监控你的情绪反应：第一步是当你处于无助益情绪时，要会辨认它们 注意引发的事件：明确是什么事情引发了你的反应 记录你的自己的想法 重新评估你的非理性信念 触发事件 因为福州的交通很乱，车多路窄，而且经常堵车；天气变态，很热，没有秋天，夏天经常雷雨；职业上也没有好的出路，公司整体的发展不够体系化，管理也很一般，缺少正规化与系统化，更适合那种一人多职的员工，而非有专长的员工； 自我内言 公司管理与体系上不够正规化，更倾向于一人多职的员工；自己不喜欢这样的行为准则，也不喜欢这样的氛围； 离开福州，才能有更好的发展； 重新评估非理性信念 如果我认为都是公司的原因，这个是太主观了；在福州，也有正规化的公司，也有高收入人群；只是自己并不是他们的一员； 离开福州，并不是唯一的出路与选择；如果有足够的能力，依然可以在福州生活好； 对于交通和天气的问题，这个确实是一个无法改变的原因； 第五章 语言：障碍与桥梁_2016.06.20 5.2 理解和误解 理解词：语义规则 模棱两可：至少有两种以上的解释 相对语言：相对词汇，需要通过比较来获得他们的意思【多注意相对语言，正确的定义是分析的开始】 静态评价：一个人被贴上一个标签；对整个人进行系统的评价，而非针对某一个事件 抽象化：当涉及描述问题、赞赏或者要求的时候，尽量具体一点；【当你想要明确表达想法的时候，尽量用具体性的描述】 理解结构：句法规则 理解情境：语用规则 5.3 语言的影响_2016.06.21 联盟关系：沟通者会被与他们说话方式相似的人所吸引；那些想要展示联盟关系的沟通者，会通过各种方式适应对方的语言习惯，包括字词的选用、说话速率、字数和断句，以及礼貌的程度，这个过程被成为言语调节； 趋同策略 分化策略：强调他们与他人不同的说话方式，当他们想要与他人分离时 权力：高/低 语言权利形态 强势的、直接的； 委婉的、间接的； 让人混淆的语言 事实与意见混淆 事实 意见 你忘了我的生日 你一点都不关心我 你一直干扰我 你是个控制狂 事实与推论混淆 “当你不会我电话时（事实），我会以为你在对我生气（推论）。真的是这样吗？（疑惑） 情绪性的语言【所有的想法都是基于个人的】 当你认同时 当你不认同时 朴实 廉价 传统 老旧 谨慎 胆小 语言的责任性 “这件事”的陈述 | 你迟到这件事，真的让人很困扰 || —————————- || 你迟到让我很担心 | “但是”的陈述 使用“我”和“你”的语言 【使用“你”字语句易激起他人的方位；因为它只是描述自己对他人行为的反映，并没有对行为的价值做出任何判断！】 【使用“我”字的语句，表明说话者愿意为自己所表达的不满负责任】 | 你把这个地方弄得一团乱 || —————————— || 我不想一个人负责全部的打扫工作 | 使用“我们”的语言 “我们”的语言，是形成建设性氛围的催化剂 5.5 文化与语言 语言沟通的形式：低/高语境文化 低语境文化 着重于尽可能清楚及合理地表达思考、感觉和想法 高语境文化 着重于使用语言来维持社会和谐；不会为了把话说得清楚而冒犯他人，所以需要学会发现信息所在语境的含义 第六章 非语言沟通：超越字词之外的信息_2016.06.21 6.1 非语言沟通的特征 所有行为都具有沟通的价值：假设你不发出任何信息，例如不说话，闭上眼睛，离开房间？这些无声的行为也在传递信息，表示你“避免接触” 非语言沟通提供许多的功能：重复、补充、替代、强调、调整、矛盾 非语言沟通泄露了欺骗的线索：当信息的发送者说谎时，他们的非语言行为有时会出卖他们。 非语言沟通是模糊不清的；【可以通过“知觉检验”来进行修正信息】 6.3 非语言沟通的类型 物理空间： 人际距离学- 爱德华·霍尔（Edwar T. Hall 1969） 空间距离 距离 亲密距离 0-0.5m 个人距离 0.5m-1.2m 社交距离 1.2m-3.6m 公共距离 &gt;3.6m 领域性：一个不会移动的地理位置，例如工作地点、房间等； 虽然你并不真正拥有领域的所有权，却能获得一种拥有和归属的感觉；一般具有地位的人通常拥有比较大的空间与较多的个人隐私； 时间学：我们处理时间的方式可以透露很多信息； 你很晚/根本不回复对方的邮件，很容易给他们留下不值得信赖的感觉 在一个重视时间的文化中，等待可能代表这某种地位；一般来讲，地位低的人从不会让地位较高的人等待； 第七章 倾听：不只是听见 7.2 倾听过程的元素：听到、专注、理解、回应、记忆 7.3 倾听的挑战 无效倾听的类型 虚伪地倾听 表面上很专注，实际想着完全无关的事情 自恋地倾听 会尝试将沟通的主题转移到他们感兴趣的事物上 选择性倾听 只针对有兴趣的部分进行回应 隔绝性倾听 避免倾听 防卫性倾听 认为别人总是在攻击自己 埋伏性倾听 仔细地倾听，搜集他们想要的信息，借此攻击说话者的言论 鲁钝地倾听 只对信息表面的内容做出回应，忽视重要的情绪性信息 造成无效倾听的原因 超负荷的信息、心不在焉、飞快的思想、努力、外在的噪音、缺乏训练、听力问题 错误的假定： 例如，当我们遇到某个熟悉的话题时，很容易漠视对方，因为自认为已经听到；【这个情况，自己经常出现；要注意；当对方还没说完，就自己觉得已经了解的时候，首先要识别这种情况；正确的做法是把话听完】 有时候，我们会假定说话者的想法太简单、太浅显，不值得我们付出注意力，然后事实可能正好相反 缺乏明显的好处；没有倾听者会在别人打断自己之后仍然尊重对方的观点 应对有效倾听的挑战：少说话、摆脱注意力分散、不要过早评断、寻找关键意思 7.4 倾听反应的类型【首先去认识到有哪几种反应类型，然后在进行挑选，这个才是正确的方式】 借力使力式回应：涉及到“沉默和剪短的言论”来鼓舞对方多说一些话； 当你无法帮别人做决定的时候，可以使用借力使力 问话式回应：问话至少能基于提问者三个帮助 获得的答案使你对事情和细节有更深入的理解（后来又发生了什么？） 更加清楚对方的想法和感受（你是怎么想的？） 得知他们的期望（你希望我重做一份新的报表？） 虚伪的问话 给说话者设圈套的问话 “你不喜欢那部电影，是吗？”显然朋友并不赞成你的想法 捍卫自己的立场，表达不同的意见 通过说谎或模棱两可来贬低自己的反应 附加问句 像“有吗？难道不对吗？”暴露了提问者正在寻求认同而不是信息的意图 实为陈述的问话 “你会勇敢地面对他，让他接受应有的惩罚吗？” 带有隐蔽计划的问话 “你星期五晚上忙吗？”显然这种问话不是为了增进彼此的感情，而是为了随后的提议而设计的。 明智的沟通者在回答这些隐蔽计划的问话时回答都很谨慎，只会回应“看情况”或者“在回答之前，先让我听听你的想法” 寻求“正确”答案的问话 “亲爱的，你觉得我看起来胖吗？” 基于未经核实的假设的问话 “你为什么不听我说？”这句话假设了对方没有留心；这个用“知觉检验”才是更好的方法；“因为你一直盯着电视机，所以我认为你刚刚没有听我说话，也可能是我想错了。你有注意听吗？” 释义式回应：倾听者将自己所解读的信息中心说一次的做法称为释义或积极倾听 技巧的关键：用你自己的措辞重述对方的观点，以便能再一次对信息进行交叉检验。 释义信息的两个层次 事实性信息 在最基本的层面上，避免信息混淆 所以你是要这个周二开会，不是下周二，对吗？ 个人性信息 我的玩笑让你以为我不在乎你的问题？ 释义技巧 改变说话者的措辞 说话者：双语教育真是一个失败又浪费钱的政策 释义者：你看我说得对不对，你很生气是因为你觉得双语教育表面上听起来很棒，但实质上却没什么用，对吗？ 从你所接收的信息当中，抓出一个具体例子，来向说话者说明你所理解的程度 说话者：李是一个混蛋，我真不敢相信他昨天晚上所做的事 释义者：你觉得那些笑话很惹人讨厌，对吗？ 反映说话者的潜在寓意 释义者：你一直提醒我小心，听起来你好像是在担心有一些事情即将发生在我身上，对吗？ 释义前需要考虑的因素 这个问题够复杂吗？ 对你来说，有必要投入时间和关注吗？释义会占用大量时间； 你能克制住不去评价吗？如果重新表述别人的评论，极有可能把他们引导到你认为最好的立场上去； 是与你的其他反应成正比吗？ 支持式回应：同理心、同意、提供协助、赞美、恢复信心 有效的支持型回应的原则 对他人内心的挣扎提供支持，但不表达自己赞同或否定的想法； 例如：你的朋友决定要辞掉一个你认为应该保留的工作，你可以使用支持性的回应“我知道对于这件事情你已经考虑得很周全了，我想你会为你自己做最好的决定” 观察对方对你支持性回应的反应 了解到支持也不是永远受欢迎 确保你对后果已经做好了准备 分析式回应：指倾听者对说话者的内容加以解释； 我想真正困扰你的是…… 她已经在做了，因为…… 遵循原则 在提出解释前，使用试探性的口气会比绝对性的口吻更好。 确定对方愿意接受你的分析 确定自己提供分析的动机确实基于协助，而非借此凸显自己聪明 忠告式回应：原则 这个忠告有提出要来的需要吗？/如果已经采取了一些行动，在事后才给予建议是无法得到理解的 对方真的想听你的忠告吗？/人们普遍不会重视那些不请自来的忠告；所以在回应前最好问问，说话人是否有兴趣听你的想法； 你提出劝告的顺序正确吗？/如果能够先给出支持性的、释义和问话的回应，借此更好地理解了说话者和相关的情况，此时再提出劝告更可能被采纳 你的忠告是专家级别的吗？ 提出忠告的人是关系密切、值得信任的人吗？ 提出忠告的态度是谨慎的、顾全对方面子的吗？ 评断式回应：用某种方式去评价别人的行为和想法； 如下两种情况最可能被人接收 当身处困境的人向你寻求评价时 当你向对方提出评价时，动机应该是真诚的、有建设性的 第八章 沟通和关系的演变_2016.06.22 8.1 为什么要建立关系：影响选择伙伴的一些因素 外貌 长相普通但具有亲切的人格特质的人，会被评价为有吸引力 生理外表因素的重要性随着关系的增加而递减 报酬：社会交换理论；报酬-成本=结果 报酬：有形的（居住地点、高薪的工作）、无形的（名声、情绪上的支持、友谊） 成本：不受人喜欢的结果（不愉快的工作、情绪上的痛苦） 8.2 人际关系的演变模式 发展的观点-马克·克耐普；聚合期、维持期、离散期、 阶段 描述 初始阶段 愿意与人接触，相当简短的，讨论无关紧要的话题 内向的人对网络的依存性更高 试验阶段 逐步了解对方的过程，话题向个人信息方面转变 强化阶段 质化人际关系开始的阶段； 向对方表达情感的次数变多 整合阶段 放弃自己旧有的人格特质，与他人建立分享认同 结合阶段 公开关系 分化阶段 开始坚持自我特性；从“我们”变为“我”的时候； 各自阶段 分离的部分明显多于整合的部分 停滞阶段 逃避阶段 结束阶段 终止一段关系 辩证的观点 联系和自主：寻求与他人的联系，但同时不希望失去全部的自我 公开和隐私： 循例和新奇 经营辩证的张力：否认、无所适从、交替、分割、平衡、整合、再界定、再证实 8.4 对关系做沟通 关系信息的类型：亲切感、即时性、尊重感、控制性 即时性：关系表达的直接性的表现； 高程度：一个大大的拥抱和亲吻 低程度：营造一个安静愉快的环境 第九章 人际沟通中的亲密关系 9.1 关系中的亲密 亲密的向度：身体的、智力的分享、情绪的（交换重要的感觉）、共享活动 男性和女性的亲密形态【明确男女亲密形态的区别】 男性 通过共享活动、为别人或者与别人一起共事来体验和表达亲密感 女性 通过更多的自我坦露与交流来表达亲密感 9.2 家人间的沟通 家庭沟通的特性 形成性的：来自家人的信息是最早也是最重要的信息 角色驱动的：担任某种角色就拥有了一套事关如何沟通的期待； 当角色面临挑战时，沟通就有可能出现问题（如果一个家庭的规矩是“孩子应该安静地待着”，你们家人对一个健谈的、有主见的孩子会有怎样的反应） 自发的：无论再怎么疏远，他们终究是你的家人 家庭作为系统 家庭系统是相互依赖的：一个家庭成员的行为会影响到其他每一个人 家庭系统的结构是嵌套的：在每一个家庭关系内部，还有次级系统；（父亲和母亲组成独特的关系，兄弟姐妹形成他们自己的关系，家长和孩子形成次级系统） 与家人沟通的模式 谈话取现：指家人在讨论各种话题时有多开放； 高度谈话取向：把沟通视为一种表达喜爱和愉悦的方式，并借此获得放松；高度谈话取向的家庭，交流更自由、频繁，而且是自发的； 遵从取向：指家人强迫彼此的态度、价值观和信仰保持一致的意愿的强度； 高度遵从取向：目的在于寻求和谐，避免冲突，促进相互依存，以及取得服从 低度遵从取向：在沟通时以个性、独立和平为特征 一致型家庭 谈话取向高、遵从取向高的家庭，这种沟通反应出的张力在于：既存在承认且保留权威等级的压力，又存在公开沟通和探究话题的利益。在一致性家庭里，孩子可以自在地表出自己的看法，父母也乐意倾听孩子的意见；但最终的决定还取决于父母的意见。 多元型家庭 谈话取向高、遵从取向低的家庭，沟通是开放的、没有限制的； 保护型家庭 谈话取向低，遵从取向高的家庭，沟通强调对于权威的服从，不愿分享想法和感受；父母决定一切，他们的话就是最终结果。 放任型家庭 谈话取向低、遵从取向低的家庭，反应成员很少参与彼此的事务中，因为决定是很个人化的一件事。 9.3 友人间的沟通 友谊的类型 年轻的 成熟的 长期的 短期的 关系导向的 任务导向的 高度坦露的 低度坦露的 高度义务感的 低度义务感的 频繁接触的 偶尔接触的 性、性别和友谊 同性友谊 异性友谊： 互有好感的承诺：双方都想把友谊转变为恋爱关系 柏拉图式友谊：任何一方都不希望把友谊变成恋爱关系 有一方渴望爱情，同时相信自己的朋友不希望进一步发展 有一方拒绝爱情，同时他认为朋友有兴趣把友谊发展到更亲密的程度 性别考虑：性别角色 友谊和社交媒介：研究表明社交网站主要用于维持当前的友谊或者找回往日的熟人，而不是建立新关系 9.4 爱人间的沟通 伴侣的冲突类型：表明冲突是爱人间沟通的正常部分 波动型：这种恋人存在强烈的、激动的争论 回避型：这种恋人更倾向于忽略问题，而不是面对 效用型：这种恋人公开地、合作地管理冲突 爱的语言：每个人都有关于什么是爱的个人见解，并且认为如果我们没有发现自己表达爱的方式与伴侣并不匹配，那我们就会有麻烦【必须要去观察与询问对方爱的语言】 肯定的语言：包括赞美、表扬、言语支持、书面说明和书信，以及其他可以表达一个人有价值、值得被欣赏的方式 有品质的时间：指当伴侣需要你的时候，你都在场并能够提供帮助，而且在这段时间里，你能够基于对方毫无保留的、全心全意的关注；精神不集中和分心会损害你们在一起时间的“品质” 礼物：那些根据礼物衡量的人；以礼物为导向的伴侣来说，如果对方忽略了纪念某个重要的事件，就是一种关系越界行为； 服务行为：哪些服务能到得到你的赞赏；帮忙丢垃圾，做家务等； 身体接触：包括抱住对方，紧握对方双手，也包括性行为 “我们倾向于说自己的爱的语言，然后当对方不明白我们所传达的信息时，我们又变得困惑。我们知识在表达自己的爱，消息不能被很好地理解是因为我们所说的东西对他们来说是一门外语。” 9.5 改善亲密关系 关系需要维系与支持 关系维持：为了保持关系平稳地、令人满意地运行而进行的沟通；五个策略保持沟通满意度 | 积极性 | 有礼貌的和积极向上的，同时避免批评 || ——– | ——————————————– || 开放性 | 直接讨论关系的性质，坦露你的个人需求和关注 || 保证 | 从语言和非语言层面让对方知道对你来说她很重要 || 社交网络 | 关注彼此的朋友、家人和亲人 || 共享任务 | 帮助彼此打理生活中的琐事和义务 | 社会支持：情感支持、信息支持、工具支持 修复损坏的关系 策略：（但当语言和非语言行为配合一致时，道歉才会具有诚意） 表达后悔：我很抱歉 承担责任：这是我的错。 做出弥补：能做些什么才能让这一切恢复原状 真诚地忏悔：我尽量不会重蹈覆辙 请求原谅：你愿意原谅我吗？ “被伤害时我们有两条路可走，被仇恨摧毁，或是原谅。仇恨带来死亡，原谅带来治愈和重生。”——By 瓦尔斯特/R.P.Walters 第十章 增进沟通气氛_2016.06.23 10.1 沟通气氛和肯定信息 不肯定信息：视若无睹、插嘴、各说各话、无人情味、含糊其辞、表里不一 异议信息：攻击、抱怨、争辩 肯定信息：重视、承认、赞同 10.2 防卫：原因与对策 避免对他人防卫：唤起防卫/降低防卫的行为；评价和描述、策略和自发、中立和同理、优越和平等、确定和协商 唤起防卫 降低防卫 评价式沟通 用“你”的语言，给出价值判断 描述式沟通 用“我”的语言，焦点放在说话者的想法和感受上面 支配式沟通 不顾接收者需要和兴趣的情况下，自顾去解释和决定一些事情 问题导向 焦点放在满足自己和他人需求的办法上 策略 把他们真正的动机隐藏起来，当受害者发现的时候会觉得被冒犯 自发性 单纯地对别人诚实而不是操纵他们 中立/冷淡 同理 优越感 任何表达出“我比你优秀”的信息都会引起对方的防卫心理 平等 确定 将注意力放在自己所坚持的观点上 协商 一个人会有强烈的意见，但不全然认为自己一定没有错，倘若其他观点看起来更合理，愿意改变自己的观点 【需要对方帮助时，建议用自发性的语言】 10.3 保留面子 使用清晰处方【表达自己的情绪时，必须有“行为、解释、感觉、结果”这四个方面，并且还需要表明自己的意图；必须包含前四个因素；尝试所有的表达都包含这个因素，可能会很麻烦，但对于沟通必然会有良好的效果】 | 行为 | 行为描述是记录你反应的原始资料，行为描述应该是客观的，不带任何解释的 || —- | ———————————————————— || 解释 | 解释的陈述，把意义连接到行为的国策和功能；解释是主观的 || 感觉 | 增加一下对自己的感觉 || 结果 | 结果的陈述，说明沟通发生了什么结果，包括你所描述的行为、解释的内容以及随之而来的情绪 || | 说话者身上发生了什么事、接收者身上发生了什么事、其他人发生了什么事 || 意图 | 意图的陈述 || | 你所秉持的立场、对他人有所诉求、描述未来你计划如何行动 | 对批评以不防卫回应【面对批评时，采用“寻找更多信息”（询问详情、释义、行为的后果、具体错误）的情况来进行回应，可以防止事情往更糟的方向发展】 【对于质疑，首先大脑中应该知道有哪几种对应的方式，并从中进行挑选，而非自发的行为】 寻找更多信息 询问详情 那些模糊不清的攻击是没有价值的；诸如“你不公平”应该询问“我什么地方不公平了？” 推测详情 对说话者的想法给予释义 只要借由澄清或详述耐饿批评你当中懂得的观点，你就可以更了解他们的反对意见。 好处 通常持批评态度的人在领悟到他们的抱怨有人倾听的时候，会减少自己强硬的态度 批评者通常会在他们的需求没有得到满足时，增长他们的挫败感 询问批评者要的是什么 询问行为的后果 询问还有哪里出错 对说话者的想法予以释义 询问批评者要的是什么 &amp; 询问行为的后果 同意批评者的看法：当你完全了解别人对你的批评，却仍在语言上感受自己防卫的反应时； 同意事实 同意批评者的观感：试着站在他们的角度，以他们的眼光去看待问题 认同批评者的言论，却能让自己心里感到舒服的关键是：你必须了解到同意那些批评，并不意味着迫使你要向他们道歉；有时不一定要使批评者认为你要为那些令人不愉快的行为负责。 第十一章 处理人际冲突 11.1 冲突的本质 冲突的定义：至少两个相互依赖的个体在实现他们目标的过程中，其中一方察觉到彼此目标的互不相容、资源的不足和来自另一方的阻挠，并通过争斗的形式表达出来。 觉察到互不相容的目标 觉得到不足的资源 另一方的阻挠（行为上） 表达出来的 11.2 冲突的类型 | 调试（输—赢）；你的方法 | 允许别人用其方法胜过坚持自己的想法 || ————————————— | ———————————————————— || 竞争（赢—输，有时会转成双输）；我的方法 | 只在乎自己而忽略别人 || | 直接攻击、间接攻击 || 妥协（部分输—输）；各取一半的方法 | 至少给予双方少数他们想要的东西【这个是经常使用的方法，但不代表是最佳的方法】 || 逃避（输—输）：没有办法 | || 合作（赢—赢）；我们的方法 | || 合作的解决方法其实更多 | 如果他们可以决定继续一对一提携的跑步计划，然后邀请露西亚的朋友在每次路段的最后几公里才加入一起跑； 或者 制定其他挑战性较小的项目，以便露西亚的朋友也能参与进来 或者 还可以找出其他方法技能和露西亚的朋友呆在一起，又能让两人感受到乐趣 | 合作的案例 选择处理方式时所要考虑的因素 11.3 关系系统中的冲突 互补、对称和平行的形态 | 互补 | 使用不同的，相互增强的行为 | 攻击—回避 || —- | ————————– | —————– || 对称 | 使用相同的行为 | 攻击—攻击（防卫） || 平行 | 在互补和对称之间切换 | | 破坏性的冲突模式：四骑士 批评、防卫、蔑视、回避 11.5 建设性处理冲突的技巧 很少人使用双赢模式的三个理由： 缺乏洞察力，有些人习惯于竞争，误认为他们要赢就必须打败对手 冲突经常涉及到情绪性事件，人们在情绪中无法理性的思索 他们的竞争意识超过了合作意识 合作解决问题 | 确认你的问题和未满足的需求 | 用描述的方式来说明你的问题，而非用情绪性或评价性的方式 界定自己真实的需求 || ————————– | ———————————————————— || 订立约会 | 确保对方的心理状态做好要去面对冲突【事先询问，我们可以谈谈吗？如果对方没有时间，就不要开始】 || 描述你的问题和需求 | 运用“肯定式的清晰的信息”-包含行为、想法、感觉、结果、意图【确定对方能够正确理解你所说的内容】 || 思考对方的观点 | 找出对方的需求（公平；一个快乐的伙伴比较愿意去达成合作） || 商议解决之道 | 尽可能找出潜在的解决方式 逐一评估他们 选择一个最能满足每一个人的方式 || 追踪解决方案的后效 | 在过一段时间之后，要去讨论方案的进展； 必须紧跟每一个步骤，要认识到跳过任何一个步骤都会导致误解 认识到真实生活中，不会那么顺畅；做好对方会有抵抗的心理预期；必要的时候，跳回重复前面一个阶段 |]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《沟通的艺术》读书笔记_罗纳德.B.阿德勒]]></title>
      <url>%2F2016%2F06%2F03%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F20_%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%2F40_%E6%B2%9F%E9%80%9A%E4%BA%A4%E6%B5%81%2F%E3%80%8A%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B_%E7%BD%97%E7%BA%B3%E5%BE%B7.B.%E9%98%BF%E5%BE%B7%E5%8B%92%2F%E3%80%8A%E6%B2%9F%E9%80%9A%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%BD%97%E7%BA%B3%E5%BE%B7.B.%E9%98%BF%E5%BE%B7%E5%8B%92%2F</url>
      <content type="text"><![CDATA[———–分割线———— 第一章 人际沟通入门 1.1 我们为什么要沟通 认同需求：我们是在别人诠释我们的过程中才逐渐明白了自己是谁。如果剥夺了与人沟通的权利，我们将无从得知自己是谁。 1.2 沟通的历程 交流沟通模式：重叠部分的“背景”很大程度上影响沟通的效力 交流式的沟通并不是我们“对”别人做了什么，而是我们“跟”别人做了什么。【在这个意义上，表明沟通必然是双向的，而非单项的信息传递】 沟通：一个交流的过程； 其参与者处于不同但又有所重叠的背景下，经由交换信息而建立关系， 关系的品质会受到外在的、生理性和心理性的噪音干扰 人际沟通与非人际沟通：两者的区分，由沟通的品质而非数量决定了人际沟通的定义；人际沟通，私人化的； 五个区分点： 非人际沟通 人际沟通 独特性 社会规则+社会角色为决定因素 特定规则+特定角色为决定因素 不可替代性 无可取代 相互依存性 公开性 公开一部分私人信息 内在回报 与参与者无关的回报（或理解为以某种目的为前提的外在的回报） 内在的情感的方面的回报 1.3 沟通的原则与迷思 原则：沟通同时具有两个向度 内容向度：双方明确讨论的信息 关系向度：表达你对对方的感觉 1.5 如何成为沟通高手 有效沟通的定义：有效性+适当性 维持或增进感情 实现自己的目标 沟通能力依情景而定；不应该以偏概全地说“我是一个失败的沟通者”，应该是“尽管我不能很好地应对这个状况，但我在其他场合能处理地更好” 沟通高手 具体描述 启发 拥有多样的行为反应 情境：对方一直在重复一个笑话，可能有关歧视或性暗示，这让你觉得被冒犯了，你可以采取： 1.保持沉默，因为你知道一旦开口了，引发冲突的风险高于它带来的好处 2.要求第三方提醒说话的人，让他注意言谈间的攻击意味 3.暗示说笑话的人，让他感受到你的不舒服 4.针对朋友感觉上的迟钝开个玩笑，期望借着幽默缓和你言语上的攻击 5.坦白说出你的不适，并要求朋友停止谈论这个话题，至少不要在你身边说 6.直接叫他不要再说 由此发现，其实处理方法不止 说or不说 这两种情况； 想成为“沟通高手”，首先在意识上应该认识到有多种反应的行为 选择适当定位的能力 根据情境、目的、对他人的认知来决定你所要做出何种反应 高EQ的人，是思考之后在几种方式中进行选择，而非出于本能的反应 表现行为的技巧 适应各个阶段： 意识觉醒期：意识层面上进行的反应 笨拙期：刚开始的行为反应 熟练期：保持联系，客服初期尝试后的尴尬阶段 整合期：当你没有特意去思考一件事情，却能表现得很好 认知复杂度 同理心 自我监控 观察自身的行为，并借此调整自身行动的过程 承诺 第二章 沟通和认同：自我的塑造与展现 2.1 沟通和自我 自我概念和自尊 自我概念：你对自己所持有的相对稳定的知觉；（你认为自己是谁，是怎么样的） 如情绪、天分、喜好、厌恶、价值观等，类似这样的一张清单，展示了自我概念中最根本的一个部分。即使是一个会让人产生不快的词，人们也往往很难放弃，而当被放弃这些最核心的感觉和认知时，大部分人会觉得害怕，会坚持说，“如果没有了这些，我就不再是我了” 自尊：你对自我价值的评估； 例如某个沟通者的自我概念包括安静的、好辩的或自律的，他的自尊高低取决于他如何看待这些概念 评估1（低自尊） 评估2（高自尊） 安静 我简直是个懦夫，所以才会说不出话来 我享受倾听甚于讲话 好辩 我太强势了，一定很惹人厌 我在自己的信念上坚定不移 自律 我太小心翼翼 在我开口说话或动手做之前，我总会深思熟虑 拥有高自尊的人，倾向于认为别人是好的，并且期望被他们接受； 不喜欢自己的人很可能认为别人也不喜欢他们；低自尊的人认为所有人都一直用批判的眼光看待他们，不管这种想象是否符合现实 自我的生物性和社会性根源 社会化与自我概念 我们每个人得出的自我概念反映的是我们认为别人看待我们的方式；而这些自我概念很大程度上来自于“重要他人”（家人&amp;好友）的影响； 此外，还通过社会比较形成我们的自我形象；即根据与他人对照的方式来评估自身； 参照群体，对如何塑造自己的观点起到了很重要的作用 自我概念的特征：主观的+抗拒改变的 自我应验预言：指如果个体对事件的发生有所预期+他接下来的行为是建立在这些预期之上的，那么这件事的发生会比没有预期更可能成功； （1）持有某种期待（对自己或别人）、（2）表现出与期望一致的行为、（3）期待如实发生、（4）强化起初的期待 1.我计划要去应聘一个渴望得到的工作，但对自己该如何表现很焦虑，也不确定自己是否有实力被录用。我向了解自己的教授和在其他朋友请教，他们都认为我非常胜任这份工作。 2.基于这些评价，我自我感觉良好，并且参加了面试。 3.我不仅镇定地表达了想法，还很自信地推销了自己。 4.我最终获得了这个职位，并得出结论“我的教授和朋友说得对，我的确是老板愿意雇佣的那种人才。” 两种自我应验类型：自我加强/他人加强的预言【可用于实践】 自我加强：自我期待对你的行为产生影响；（如果你的演讲只有一个观众来参加，或者你的内心充满了恐惧，你很可能会忘记自己的发言。这不是因为你没有做好准备，而是因为你告诉自己“我知道我搞砸了”） 他人加强：（1）观察者首先自己要相信这个为预期目标群体制造的预言；（2）更要传达出这种信任；以便使这一预言产生实质性的效果； 例如：一个老板关心一个员工的工作能力，但却没有表单出这些关心，那员工也不会被影响 \2. 2 自我的展现：沟通做为认同管理 隐私自我：觉知的自我；感知到的自我是你在真诚的自省过程中所相信的自己；这种自我是“隐私的”，因为你不可能把它对一个人全部展现出来 公开自我：即展现的自我，是一个“公开的”形象，就是我们想要别人看待我们的方式； 认同管理 致力于构建多元认同：大部分人要扮演不同的角色，“礼貌的学生/有趣的朋友/友善的邻居/有用的员工/一个父亲”，基于不同的情境，我们需要转换不同的行为模式 序号 角色 特点 要求 1 父母的独子 2 公司员工 3 彦的男朋友 4 同事 5 大学好友 6 多年好友 7 普通朋友 8 租客 9 消费者 10 11 深思熟虑 or 不知不觉： 大部分工作面试和第一次约会都是深思熟虑的； 日常大量交流中，我们对自身行为的选择不是经过深思熟虑的，而是依赖于我们随着经验发展出来的“脚本”来决定的；只有当角色不适合的时候，你才会慎重考量你需要作出的反应； 管理认同：现实&amp;虚拟世界 现实世界：行为举止、外貌、配备（汽车、房屋是否整洁） 实际上所有的对话都提供了一个舞台，沟通者通过回应他人的行为构建起对自我的认同 事实上，如果我们不提前决定自己在不同情境中所要呈现的角色，我们几乎无法进行有效的沟通；成为一个沟通高手，部分取决于他能一句不同的情境挑选出最佳的角色。【用于实践，但第一步应该是你要知道你有哪些角色可以扮演，以及他的特性是什么】 为什么要管理认同？为了开始和经营关系、为了获得的别人的顺从、为了保住别人的颜面、为了探索新的自我 2.3 在关系中的自我袒露：指有意透露与自己相关的信息； 自我袒露：有意的、重要的、关于自己不为人知的信息 自我坦露的模式： 社会穿透模式：广度、深度（一个圆） 陈词滥调&lt;陈述事实&lt;给出观点&lt;倾诉感受 陈述事实：我是镇上新搬来的居民 给出观点：我真的很喜欢这里 倾诉感受：……但是，我优势感到有些孤独 乔哈里视窗：开放区、盲视区、隐藏区、未知区 自己知道的 自己不知道的 他人知道的 开放区 盲视区 他人不知道的 隐藏区 未知区 自我袒露的优劣势 优势：宣泄、互惠、自我澄清、自我确认、关系的建立和维持、社会控制 劣势：拒绝、负面印象、降低关系满意度、丧失影响力 自我坦露的原则：这个人对我重要吗？坦露的量与方式合适吗？风险合理吗？有建设性的影响吗？你的自我坦露是互惠的吗？在道德上有义务袒露吗？【其实，所有沟通的内容与方式，应该是经过思考之后的】 2.4 自我袒露的替代选择：沉默、说谎、模棱两可、暗示 沉默：你可能会发现保留自己的想法和感受是你经常做的事情，说出全部的事实虽然符合坦诚之道，但有可能危害你和对方的关系；大多数心思缜密的沟通者都会选择保持沉默，而不是一吐为快说“你看起来糟透了”或者“你太多话了。”【可以分别记录一下自己什么时候表达、什么时候不表达意见，然后就可以对自己以来袒露和沉默的的程度有一个大致的了解；】 说谎：善意的谎言，是考虑到信息接收者的利益而说的。 模棱两可：当面临说谎还是说出一个令人不愉快的真相的困境时，沟通者通常会选择一种模棱两可的回答。【熟记并理解“真实和模棱两可的向度”】 暗示：暗示其实比模棱两可更直接；因为模棱两可的说法不一定要求改变他人的行为，而暗示旨在从他人那里得到期待的回应。 【对于回答的方式，其实都是思考之后的，选择自我袒露的程度or替代选项】 第三章 知觉：看到什么就是什么 3.1 知觉历程：选择—组织—诠释—协商 选择：身边的信息远超出所能处理的限度，所以知觉的第一各个步骤是“选择”那些能给我们留下印象的信息； 刺激的强度、重复的刺激、频繁的对比或转变、动机 组织：选择相关信息后，必须用有意义的方式组织这些信息； 诠释：以某种方式加以诠释，使之具有特定的意义。 影响我们诠释事件/行为的方式：交情深浅、个人经验、对人类行为的假设、态度、期望、信息、自我概念、关系满意度 协商：他们影响者彼此的知觉，并且试图在感知上达成一种共识； 3.2 影响知觉的因素：获取信息、生理因素、文化差异、社会角色 生理因素：感官、心理挑战、年龄、健康与疲劳、饥饿、生理循环 社会角色： 性别角色：指被社会所接纳和期待的男性行为模式； 职业角色 关系角色：个人与事件/他人之间的关系 3.3 知觉的倾向；归因，描述我们将行为赋予意义的过程； 对人严厉，对己仁慈 先入为主 以己之心，度人之心：第二章已经解释过这一原则：低自尊的人会猜想别人以不利于自己的方式看待自己，高自尊的人会猜想别人以对自己有利的方式看待自己； 我们被期待所影响：假设你参加了一门课程，却被提前告知上课的老师非常糟糕，这必然会影响对这位老师的认知；【所以，做任何项目/事情/见面之前，营造中肯&amp;良好的期望是很重要的】 最明显的最有力：容易被显而易见的事情所影响；问题在于最明显的因素不一定是事件中唯一或最重要的因素。 3.4 知觉检验：如果我们一厢情愿地认定我们队事情的解释就是事实，恐怕会产生很多严重的人际困境；知觉检验是帮助你正确了解别人的一项工具，它并不假设你的第一印象是正确的；【将知觉检验加入日常思维中，努力去实践】 知觉检验的要素： 描述你注意到的行为 列出关于此行为至少两种可能的诠释 请求对方对行为诠释做澄清 知觉检验的考量： 完整性：有时知觉检验不需要囊括所有部分也能够奏效 非语言的一致性：只有当你非语言的行为也反映出你语言所表达的那种开放的态度时，知觉检验才能成功； 文化支配：低/高语境文化【第五章】 保留颜面 知觉检验是一种比较不具威胁地指出对方行为的方式；要记住，沟通能力的一个要素是在各种方案中选择最佳选项，而知觉检验是在许多时候都有用的策略； 3.5 同理心与沟通； 同理心：从另一个人的角度来体验世界，重新创造个人观点的能力； 获得观点：采用另一个人观点的尝试，这需要中止你的诊断，将自己的意见放在另一边，试着去了解对方 情感面向：使我们更贴近地去体验别人的感受 真诚地关心：更进一步关心他们的福祉 认知复杂度：运用“枕头发”处理复杂、严重的议题 枕头法 解释 立场一 我对你错 立场二 你错我对 转换视角，尽最大可能来解释他人的观点如何与你不同 立场三 双方都对，双方都错 立场四 这个议题不重要 黄金法则：按照你所希望被对待的方式去对待别人 白金法则：按照别人所希望对对方的方式对待别人 先去了解别人是怎么想的和他们想要的是什么。 第四章 情绪：感觉、思考和沟通_2016.06.15 4.1 什么是情绪 非语言反应：会引起某些情绪状态；例如，通过改变脸部的表情，引发他们不同的情绪状态； 情绪感染力：这个过程使情绪从一个人身上传递到另一个人身上； 4.3 情绪表达的原则 辨识感觉、说话和行动之间的不同：感觉到某种情绪，并不意味着你要把它说出来；也不意味着你必须遵照它行动。 了解有感觉和发泄情绪之间的差异有助于在困境中建设性地表达你自己。 扩充你的情绪词汇 你可以用不同的方式，说出同一种感觉 使用单一的词：我在生气 描述你发生了什么：我胃好像打结了 描述你想要做什么：我想给你一个拥抱 传递暗示信息的人，面临着失去让地方了解自己的感觉以及满足需求的机会； 例如，以间接的方式说“我很孤单”，也许就变成了“我才这个周末没什么事情，加入你也不忙，可以发短信给我，我们一起出去逛逛”；类似这样的信息会非常婉转，以至于别人可能听不出你的真实想法。 如果你下定决心要表达你的感觉，你必须很清楚地确认你和你的伙伴都了解你的感觉只适用于一套特定的情境，而不是直接针对整个关系； 你应该说，“当你不守信用时，我会怨恨你”，而不要说“我怨恨你”；“当你讲到你的钱的时候，我觉得很无聊”，而不是“我和你在一起很无聊” 分享多样的感觉：我有什么感觉？我又会表达什么感觉？ 尽管我们的情绪是混合的，但我们通常只会表达其中一种，而且还是最负面的那种情绪。【所以，表达感觉是应该多样而全面地表达；这样会让你更加清楚地看清自己的情绪】 朋友在Facebook上发布了一张你的照片，一方面因为朋友展现了对你的喜爱而开心，一方面因为光线不好使得你不好看；你希望朋友可以提前问问你。 4.4 管理困恼的情绪_2016.06.20 无助益情绪的来源：生理因素、情绪记忆、自我内言 情绪记忆：只要某个事件与过去的困扰经验有一点点相似之处，即便是寻常事件也会引发无助益的情绪。 自我内言：人对一件事情所做的诠释决定了他们的感觉。 非理性思考和无助益的情绪 完美的谬误：接受完美谬误的人，相信一个好的沟通者应该有全然的信息和技巧来处理每一种情况。 赞同的谬误：认为得到别人的赞同是生活上不可或缺的事，并且十分向往得到所有人的赞同。 应该的谬误：不能区分“是什么”和“应该是什么” 过渡推论的谬误： 基于有限的证据而做出推论 夸大缺点与优点（你总是迟到；你从来不听我书） 因果论的谬误： 造成那些对沟通过渡谨慎的人的困扰，因为他们不想“引起”别人的痛苦困惑或麻烦；发生情况 ： 【当你坚信自己是引起他人感觉的唯一原因，未免太自恋了。】 - - 探望朋友或家人出于一种义务感，而不是一份想要看到他们的真诚的渴望； - 当别人的行为打扰到你时，你仍然保持沉默 - 当你快要迟到下一个约会，或觉得身体不适时，还是假装专心听那演讲者说话。 - 我们相信别人是引起我们情绪的原因。 无助的谬误：生活满意度受到超过你能控制的压力所决定；不断地视自己为受害者的人会有这样的陈述： 【只要你了解“如果你真的想做，就有许多事情可以去做”这一点；许多“不能”是不想改变】 我不能告诉上司她对我的要求太多，如果说了，我可能会失去工作 我生性害羞，想要变得外向，但是没有办法 灾难性预期的谬误：他们认定加入某件糟糕的事可能会发生，你们它就一定能够会发生。 【一旦你开始料想灾难性的后果，自我应验预言就会开始建立；其实，也是不自信的一种表现；】 假如我邀请他们参加宴会，他们或许不会想来； 假如我告诉他们我真实的感受如何，他们也许会嘲笑我； 减少无助的情绪【提供了一个可执行的步骤】 监控你的情绪反应：第一步是当你处于无助益情绪时，要会辨认它们 注意引发的事件：明确是什么事情引发了你的反应 记录你的自己的想法 重新评估你的非理性信念 触发事件 因为福州的交通很乱，车多路窄，而且经常堵车；天气变态，很热，没有秋天，夏天经常雷雨；职业上也没有好的出路，公司整体的发展不够体系化，管理也很一般，缺少正规化与系统化，更适合那种一人多职的员工，而非有专长的员工； 自我内言 公司管理与体系上不够正规化，更倾向于一人多职的员工；自己不喜欢这样的行为准则，也不喜欢这样的氛围； 离开福州，才能有更好的发展； 重新评估非理性信念 如果我认为都是公司的原因，这个是太主观了；在福州，也有正规化的公司，也有高收入人群；只是自己并不是他们的一员； 离开福州，并不是唯一的出路与选择；如果有足够的能力，依然可以在福州生活好； 对于交通和天气的问题，这个确实是一个无法改变的原因； 第五章 语言：障碍与桥梁_2016.06.20 5.2 理解和误解 理解词：语义规则 模棱两可：至少有两种以上的解释 相对语言：相对词汇，需要通过比较来获得他们的意思【多注意相对语言，正确的定义是分析的开始】 静态评价：一个人被贴上一个标签；对整个人进行系统的评价，而非针对某一个事件 抽象化：当涉及描述问题、赞赏或者要求的时候，尽量具体一点；【当你想要明确表达想法的时候，尽量用具体性的描述】 理解结构：句法规则 理解情境：语用规则 5.3 语言的影响_2016.06.21 联盟关系：沟通者会被与他们说话方式相似的人所吸引；那些想要展示联盟关系的沟通者，会通过各种方式适应对方的语言习惯，包括字词的选用、说话速率、字数和断句，以及礼貌的程度，这个过程被成为言语调节； 趋同策略 分化策略：强调他们与他人不同的说话方式，当他们想要与他人分离时 权力：高/低 语言权利形态 强势的、直接的； 委婉的、间接的； 让人混淆的语言 事实与意见混淆 事实 意见 你忘了我的生日 你一点都不关心我 你一直干扰我 你是个控制狂 事实与推论混淆 “当你不会我电话时（事实），我会以为你在对我生气（推论）。真的是这样吗？（疑惑） 情绪性的语言【所有的想法都是基于个人的】 当你认同时 当你不认同时 朴实 廉价 传统 老旧 谨慎 胆小 语言的责任性 “这件事”的陈述 | 你迟到这件事，真的让人很困扰 || —————————- || 你迟到让我很担心 | “但是”的陈述 使用“我”和“你”的语言 【使用“你”字语句易激起他人的方位；因为它只是描述自己对他人行为的反映，并没有对行为的价值做出任何判断！】 【使用“我”字的语句，表明说话者愿意为自己所表达的不满负责任】 | 你把这个地方弄得一团乱 || —————————— || 我不想一个人负责全部的打扫工作 | 使用“我们”的语言 “我们”的语言，是形成建设性氛围的催化剂 5.5 文化与语言 语言沟通的形式：低/高语境文化 低语境文化 着重于尽可能清楚及合理地表达思考、感觉和想法 高语境文化 着重于使用语言来维持社会和谐；不会为了把话说得清楚而冒犯他人，所以需要学会发现信息所在语境的含义 第六章 非语言沟通：超越字词之外的信息_2016.06.21 6.1 非语言沟通的特征 所有行为都具有沟通的价值：假设你不发出任何信息，例如不说话，闭上眼睛，离开房间？这些无声的行为也在传递信息，表示你“避免接触” 非语言沟通提供许多的功能：重复、补充、替代、强调、调整、矛盾 非语言沟通泄露了欺骗的线索：当信息的发送者说谎时，他们的非语言行为有时会出卖他们。 非语言沟通是模糊不清的；【可以通过“知觉检验”来进行修正信息】 6.3 非语言沟通的类型 物理空间： 人际距离学- 爱德华·霍尔（Edwar T. Hall 1969） 空间距离 距离 亲密距离 0-0.5m 个人距离 0.5m-1.2m 社交距离 1.2m-3.6m 公共距离 &gt;3.6m 领域性：一个不会移动的地理位置，例如工作地点、房间等； 虽然你并不真正拥有领域的所有权，却能获得一种拥有和归属的感觉；一般具有地位的人通常拥有比较大的空间与较多的个人隐私； 时间学：我们处理时间的方式可以透露很多信息； 你很晚/根本不回复对方的邮件，很容易给他们留下不值得信赖的感觉 在一个重视时间的文化中，等待可能代表这某种地位；一般来讲，地位低的人从不会让地位较高的人等待； 第七章 倾听：不只是听见 7.2 倾听过程的元素：听到、专注、理解、回应、记忆 7.3 倾听的挑战 无效倾听的类型 虚伪地倾听 表面上很专注，实际想着完全无关的事情 自恋地倾听 会尝试将沟通的主题转移到他们感兴趣的事物上 选择性倾听 只针对有兴趣的部分进行回应 隔绝性倾听 避免倾听 防卫性倾听 认为别人总是在攻击自己 埋伏性倾听 仔细地倾听，搜集他们想要的信息，借此攻击说话者的言论 鲁钝地倾听 只对信息表面的内容做出回应，忽视重要的情绪性信息 造成无效倾听的原因 超负荷的信息、心不在焉、飞快的思想、努力、外在的噪音、缺乏训练、听力问题 错误的假定： 例如，当我们遇到某个熟悉的话题时，很容易漠视对方，因为自认为已经听到；【这个情况，自己经常出现；要注意；当对方还没说完，就自己觉得已经了解的时候，首先要识别这种情况；正确的做法是把话听完】 有时候，我们会假定说话者的想法太简单、太浅显，不值得我们付出注意力，然后事实可能正好相反 缺乏明显的好处；没有倾听者会在别人打断自己之后仍然尊重对方的观点 应对有效倾听的挑战：少说话、摆脱注意力分散、不要过早评断、寻找关键意思 7.4 倾听反应的类型【首先去认识到有哪几种反应类型，然后在进行挑选，这个才是正确的方式】 借力使力式回应：涉及到“沉默和剪短的言论”来鼓舞对方多说一些话； 当你无法帮别人做决定的时候，可以使用借力使力 问话式回应：问话至少能基于提问者三个帮助 获得的答案使你对事情和细节有更深入的理解（后来又发生了什么？） 更加清楚对方的想法和感受（你是怎么想的？） 得知他们的期望（你希望我重做一份新的报表？） 虚伪的问话 给说话者设圈套的问话 “你不喜欢那部电影，是吗？”显然朋友并不赞成你的想法 捍卫自己的立场，表达不同的意见 通过说谎或模棱两可来贬低自己的反应 附加问句 像“有吗？难道不对吗？”暴露了提问者正在寻求认同而不是信息的意图 实为陈述的问话 “你会勇敢地面对他，让他接受应有的惩罚吗？” 带有隐蔽计划的问话 “你星期五晚上忙吗？”显然这种问话不是为了增进彼此的感情，而是为了随后的提议而设计的。 明智的沟通者在回答这些隐蔽计划的问话时回答都很谨慎，只会回应“看情况”或者“在回答之前，先让我听听你的想法” 寻求“正确”答案的问话 “亲爱的，你觉得我看起来胖吗？” 基于未经核实的假设的问话 “你为什么不听我说？”这句话假设了对方没有留心；这个用“知觉检验”才是更好的方法；“因为你一直盯着电视机，所以我认为你刚刚没有听我说话，也可能是我想错了。你有注意听吗？” 释义式回应：倾听者将自己所解读的信息中心说一次的做法称为释义或积极倾听 技巧的关键：用你自己的措辞重述对方的观点，以便能再一次对信息进行交叉检验。 释义信息的两个层次 事实性信息 在最基本的层面上，避免信息混淆 所以你是要这个周二开会，不是下周二，对吗？ 个人性信息 我的玩笑让你以为我不在乎你的问题？ 释义技巧 改变说话者的措辞 说话者：双语教育真是一个失败又浪费钱的政策 释义者：你看我说得对不对，你很生气是因为你觉得双语教育表面上听起来很棒，但实质上却没什么用，对吗？ 从你所接收的信息当中，抓出一个具体例子，来向说话者说明你所理解的程度 说话者：李是一个混蛋，我真不敢相信他昨天晚上所做的事 释义者：你觉得那些笑话很惹人讨厌，对吗？ 反映说话者的潜在寓意 释义者：你一直提醒我小心，听起来你好像是在担心有一些事情即将发生在我身上，对吗？ 释义前需要考虑的因素 这个问题够复杂吗？ 对你来说，有必要投入时间和关注吗？释义会占用大量时间； 你能克制住不去评价吗？如果重新表述别人的评论，极有可能把他们引导到你认为最好的立场上去； 是与你的其他反应成正比吗？ 支持式回应：同理心、同意、提供协助、赞美、恢复信心 有效的支持型回应的原则 对他人内心的挣扎提供支持，但不表达自己赞同或否定的想法； 例如：你的朋友决定要辞掉一个你认为应该保留的工作，你可以使用支持性的回应“我知道对于这件事情你已经考虑得很周全了，我想你会为你自己做最好的决定” 观察对方对你支持性回应的反应 了解到支持也不是永远受欢迎 确保你对后果已经做好了准备 分析式回应：指倾听者对说话者的内容加以解释； 我想真正困扰你的是…… 她已经在做了，因为…… 遵循原则 在提出解释前，使用试探性的口气会比绝对性的口吻更好。 确定对方愿意接受你的分析 确定自己提供分析的动机确实基于协助，而非借此凸显自己聪明 忠告式回应：原则 这个忠告有提出要来的需要吗？/如果已经采取了一些行动，在事后才给予建议是无法得到理解的 对方真的想听你的忠告吗？/人们普遍不会重视那些不请自来的忠告；所以在回应前最好问问，说话人是否有兴趣听你的想法； 你提出劝告的顺序正确吗？/如果能够先给出支持性的、释义和问话的回应，借此更好地理解了说话者和相关的情况，此时再提出劝告更可能被采纳 你的忠告是专家级别的吗？ 提出忠告的人是关系密切、值得信任的人吗？ 提出忠告的态度是谨慎的、顾全对方面子的吗？ 评断式回应：用某种方式去评价别人的行为和想法； 如下两种情况最可能被人接收 当身处困境的人向你寻求评价时 当你向对方提出评价时，动机应该是真诚的、有建设性的 第八章 沟通和关系的演变_2016.06.22 8.1 为什么要建立关系：影响选择伙伴的一些因素 外貌 长相普通但具有亲切的人格特质的人，会被评价为有吸引力 生理外表因素的重要性随着关系的增加而递减 报酬：社会交换理论；报酬-成本=结果 报酬：有形的（居住地点、高薪的工作）、无形的（名声、情绪上的支持、友谊） 成本：不受人喜欢的结果（不愉快的工作、情绪上的痛苦） 8.2 人际关系的演变模式 发展的观点-马克·克耐普；聚合期、维持期、离散期、 阶段 描述 初始阶段 愿意与人接触，相当简短的，讨论无关紧要的话题 内向的人对网络的依存性更高 试验阶段 逐步了解对方的过程，话题向个人信息方面转变 强化阶段 质化人际关系开始的阶段； 向对方表达情感的次数变多 整合阶段 放弃自己旧有的人格特质，与他人建立分享认同 结合阶段 公开关系 分化阶段 开始坚持自我特性；从“我们”变为“我”的时候； 各自阶段 分离的部分明显多于整合的部分 停滞阶段 逃避阶段 结束阶段 终止一段关系 辩证的观点 联系和自主：寻求与他人的联系，但同时不希望失去全部的自我 公开和隐私： 循例和新奇 经营辩证的张力：否认、无所适从、交替、分割、平衡、整合、再界定、再证实 8.4 对关系做沟通 关系信息的类型：亲切感、即时性、尊重感、控制性 即时性：关系表达的直接性的表现； 高程度：一个大大的拥抱和亲吻 低程度：营造一个安静愉快的环境 第九章 人际沟通中的亲密关系 9.1 关系中的亲密 亲密的向度：身体的、智力的分享、情绪的（交换重要的感觉）、共享活动 男性和女性的亲密形态【明确男女亲密形态的区别】 男性 通过共享活动、为别人或者与别人一起共事来体验和表达亲密感 女性 通过更多的自我坦露与交流来表达亲密感 9.2 家人间的沟通 家庭沟通的特性 形成性的：来自家人的信息是最早也是最重要的信息 角色驱动的：担任某种角色就拥有了一套事关如何沟通的期待； 当角色面临挑战时，沟通就有可能出现问题（如果一个家庭的规矩是“孩子应该安静地待着”，你们家人对一个健谈的、有主见的孩子会有怎样的反应） 自发的：无论再怎么疏远，他们终究是你的家人 家庭作为系统 家庭系统是相互依赖的：一个家庭成员的行为会影响到其他每一个人 家庭系统的结构是嵌套的：在每一个家庭关系内部，还有次级系统；（父亲和母亲组成独特的关系，兄弟姐妹形成他们自己的关系，家长和孩子形成次级系统） 与家人沟通的模式 谈话取现：指家人在讨论各种话题时有多开放； 高度谈话取向：把沟通视为一种表达喜爱和愉悦的方式，并借此获得放松；高度谈话取向的家庭，交流更自由、频繁，而且是自发的； 遵从取向：指家人强迫彼此的态度、价值观和信仰保持一致的意愿的强度； 高度遵从取向：目的在于寻求和谐，避免冲突，促进相互依存，以及取得服从 低度遵从取向：在沟通时以个性、独立和平为特征 一致型家庭 谈话取向高、遵从取向高的家庭，这种沟通反应出的张力在于：既存在承认且保留权威等级的压力，又存在公开沟通和探究话题的利益。在一致性家庭里，孩子可以自在地表出自己的看法，父母也乐意倾听孩子的意见；但最终的决定还取决于父母的意见。 多元型家庭 谈话取向高、遵从取向低的家庭，沟通是开放的、没有限制的； 保护型家庭 谈话取向低，遵从取向高的家庭，沟通强调对于权威的服从，不愿分享想法和感受；父母决定一切，他们的话就是最终结果。 放任型家庭 谈话取向低、遵从取向低的家庭，反应成员很少参与彼此的事务中，因为决定是很个人化的一件事。 9.3 友人间的沟通 友谊的类型 年轻的 成熟的 长期的 短期的 关系导向的 任务导向的 高度坦露的 低度坦露的 高度义务感的 低度义务感的 频繁接触的 偶尔接触的 性、性别和友谊 同性友谊 异性友谊： 互有好感的承诺：双方都想把友谊转变为恋爱关系 柏拉图式友谊：任何一方都不希望把友谊变成恋爱关系 有一方渴望爱情，同时相信自己的朋友不希望进一步发展 有一方拒绝爱情，同时他认为朋友有兴趣把友谊发展到更亲密的程度 性别考虑：性别角色 友谊和社交媒介：研究表明社交网站主要用于维持当前的友谊或者找回往日的熟人，而不是建立新关系 9.4 爱人间的沟通 伴侣的冲突类型：表明冲突是爱人间沟通的正常部分 波动型：这种恋人存在强烈的、激动的争论 回避型：这种恋人更倾向于忽略问题，而不是面对 效用型：这种恋人公开地、合作地管理冲突 爱的语言：每个人都有关于什么是爱的个人见解，并且认为如果我们没有发现自己表达爱的方式与伴侣并不匹配，那我们就会有麻烦【必须要去观察与询问对方爱的语言】 肯定的语言：包括赞美、表扬、言语支持、书面说明和书信，以及其他可以表达一个人有价值、值得被欣赏的方式 有品质的时间：指当伴侣需要你的时候，你都在场并能够提供帮助，而且在这段时间里，你能够基于对方毫无保留的、全心全意的关注；精神不集中和分心会损害你们在一起时间的“品质” 礼物：那些根据礼物衡量的人；以礼物为导向的伴侣来说，如果对方忽略了纪念某个重要的事件，就是一种关系越界行为； 服务行为：哪些服务能到得到你的赞赏；帮忙丢垃圾，做家务等； 身体接触：包括抱住对方，紧握对方双手，也包括性行为 “我们倾向于说自己的爱的语言，然后当对方不明白我们所传达的信息时，我们又变得困惑。我们知识在表达自己的爱，消息不能被很好地理解是因为我们所说的东西对他们来说是一门外语。” 9.5 改善亲密关系 关系需要维系与支持 关系维持：为了保持关系平稳地、令人满意地运行而进行的沟通；五个策略保持沟通满意度 | 积极性 | 有礼貌的和积极向上的，同时避免批评 || ——– | ——————————————– || 开放性 | 直接讨论关系的性质，坦露你的个人需求和关注 || 保证 | 从语言和非语言层面让对方知道对你来说她很重要 || 社交网络 | 关注彼此的朋友、家人和亲人 || 共享任务 | 帮助彼此打理生活中的琐事和义务 | 社会支持：情感支持、信息支持、工具支持 修复损坏的关系 策略：（但当语言和非语言行为配合一致时，道歉才会具有诚意） 表达后悔：我很抱歉 承担责任：这是我的错。 做出弥补：能做些什么才能让这一切恢复原状 真诚地忏悔：我尽量不会重蹈覆辙 请求原谅：你愿意原谅我吗？ “被伤害时我们有两条路可走，被仇恨摧毁，或是原谅。仇恨带来死亡，原谅带来治愈和重生。”——By 瓦尔斯特/R.P.Walters 第十章 增进沟通气氛_2016.06.23 10.1 沟通气氛和肯定信息 不肯定信息：视若无睹、插嘴、各说各话、无人情味、含糊其辞、表里不一 异议信息：攻击、抱怨、争辩 肯定信息：重视、承认、赞同 10.2 防卫：原因与对策 避免对他人防卫：唤起防卫/降低防卫的行为；评价和描述、策略和自发、中立和同理、优越和平等、确定和协商 唤起防卫 降低防卫 评价式沟通 用“你”的语言，给出价值判断 描述式沟通 用“我”的语言，焦点放在说话者的想法和感受上面 支配式沟通 不顾接收者需要和兴趣的情况下，自顾去解释和决定一些事情 问题导向 焦点放在满足自己和他人需求的办法上 策略 把他们真正的动机隐藏起来，当受害者发现的时候会觉得被冒犯 自发性 单纯地对别人诚实而不是操纵他们 中立/冷淡 同理 优越感 任何表达出“我比你优秀”的信息都会引起对方的防卫心理 平等 确定 将注意力放在自己所坚持的观点上 协商 一个人会有强烈的意见，但不全然认为自己一定没有错，倘若其他观点看起来更合理，愿意改变自己的观点 【需要对方帮助时，建议用自发性的语言】 10.3 保留面子 使用清晰处方【表达自己的情绪时，必须有“行为、解释、感觉、结果”这四个方面，并且还需要表明自己的意图；必须包含前四个因素；尝试所有的表达都包含这个因素，可能会很麻烦，但对于沟通必然会有良好的效果】 | 行为 | 行为描述是记录你反应的原始资料，行为描述应该是客观的，不带任何解释的 || —- | ———————————————————— || 解释 | 解释的陈述，把意义连接到行为的国策和功能；解释是主观的 || 感觉 | 增加一下对自己的感觉 || 结果 | 结果的陈述，说明沟通发生了什么结果，包括你所描述的行为、解释的内容以及随之而来的情绪 || | 说话者身上发生了什么事、接收者身上发生了什么事、其他人发生了什么事 || 意图 | 意图的陈述 || | 你所秉持的立场、对他人有所诉求、描述未来你计划如何行动 | 对批评以不防卫回应【面对批评时，采用“寻找更多信息”（询问详情、释义、行为的后果、具体错误）的情况来进行回应，可以防止事情往更糟的方向发展】 【对于质疑，首先大脑中应该知道有哪几种对应的方式，并从中进行挑选，而非自发的行为】 寻找更多信息 询问详情 那些模糊不清的攻击是没有价值的；诸如“你不公平”应该询问“我什么地方不公平了？” 推测详情 对说话者的想法给予释义 只要借由澄清或详述耐饿批评你当中懂得的观点，你就可以更了解他们的反对意见。 好处 通常持批评态度的人在领悟到他们的抱怨有人倾听的时候，会减少自己强硬的态度 批评者通常会在他们的需求没有得到满足时，增长他们的挫败感 询问批评者要的是什么 询问行为的后果 询问还有哪里出错 对说话者的想法予以释义 询问批评者要的是什么 &amp; 询问行为的后果 同意批评者的看法：当你完全了解别人对你的批评，却仍在语言上感受自己防卫的反应时； 同意事实 同意批评者的观感：试着站在他们的角度，以他们的眼光去看待问题 认同批评者的言论，却能让自己心里感到舒服的关键是：你必须了解到同意那些批评，并不意味着迫使你要向他们道歉；有时不一定要使批评者认为你要为那些令人不愉快的行为负责。 第十一章 处理人际冲突 11.1 冲突的本质 冲突的定义：至少两个相互依赖的个体在实现他们目标的过程中，其中一方察觉到彼此目标的互不相容、资源的不足和来自另一方的阻挠，并通过争斗的形式表达出来。 觉察到互不相容的目标 觉得到不足的资源 另一方的阻挠（行为上） 表达出来的 11.2 冲突的类型 | 调试（输—赢）；你的方法 | 允许别人用其方法胜过坚持自己的想法 || ————————————— | ———————————————————— || 竞争（赢—输，有时会转成双输）；我的方法 | 只在乎自己而忽略别人 || | 直接攻击、间接攻击 || 妥协（部分输—输）；各取一半的方法 | 至少给予双方少数他们想要的东西【这个是经常使用的方法，但不代表是最佳的方法】 || 逃避（输—输）：没有办法 | || 合作（赢—赢）；我们的方法 | || 合作的解决方法其实更多 | 如果他们可以决定继续一对一提携的跑步计划，然后邀请露西亚的朋友在每次路段的最后几公里才加入一起跑； 或者 制定其他挑战性较小的项目，以便露西亚的朋友也能参与进来 或者 还可以找出其他方法技能和露西亚的朋友呆在一起，又能让两人感受到乐趣 | 合作的案例 选择处理方式时所要考虑的因素 11.3 关系系统中的冲突 互补、对称和平行的形态 | 互补 | 使用不同的，相互增强的行为 | 攻击—回避 || —- | ————————– | —————– || 对称 | 使用相同的行为 | 攻击—攻击（防卫） || 平行 | 在互补和对称之间切换 | | 破坏性的冲突模式：四骑士 批评、防卫、蔑视、回避 11.5 建设性处理冲突的技巧 很少人使用双赢模式的三个理由： 缺乏洞察力，有些人习惯于竞争，误认为他们要赢就必须打败对手 冲突经常涉及到情绪性事件，人们在情绪中无法理性的思索 他们的竞争意识超过了合作意识 合作解决问题 | 确认你的问题和未满足的需求 | 用描述的方式来说明你的问题，而非用情绪性或评价性的方式 界定自己真实的需求 || ————————– | ———————————————————— || 订立约会 | 确保对方的心理状态做好要去面对冲突【事先询问，我们可以谈谈吗？如果对方没有时间，就不要开始】 || 描述你的问题和需求 | 运用“肯定式的清晰的信息”-包含行为、想法、感觉、结果、意图【确定对方能够正确理解你所说的内容】 || 思考对方的观点 | 找出对方的需求（公平；一个快乐的伙伴比较愿意去达成合作） || 商议解决之道 | 尽可能找出潜在的解决方式 逐一评估他们 选择一个最能满足每一个人的方式 || 追踪解决方案的后效 | 在过一段时间之后，要去讨论方案的进展； 必须紧跟每一个步骤，要认识到跳过任何一个步骤都会导致误解 认识到真实生活中，不会那么顺畅；做好对方会有抵抗的心理预期；必要的时候，跳回重复前面一个阶段 |]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《物演通论》_罗辑思维_王东岳]]></title>
      <url>%2F2016%2F05%2F31%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2FOthers_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%2F%E7%89%A9%E6%BC%94%E9%80%9A%E8%AE%BA_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_20160531%2F</url>
      <content type="text"><![CDATA[《物演通论》的关于商业几个推论（来自《罗辑思维》，罗振宇）： 社群经济不可避免，且不同于工业经济； 所谓工业经济，就是推崇要将生产的产品卖到全世界，企业规模要无限增长； 社群经济，主动只做一部分人的生意，企业—用户—客户是一种伙伴的关系，前提靠价值观协同； 分工和分化的趋势不可逆，商业分工某些特定环节的价值必然上升；在现有的分化结构当中，让中间环节优化它的商业能力，而不是把中间环节干掉 例如，农超对接；农民把产品直接卖给城市居民，那我们是要把这个中间商干掉吗？如果让农民直接做中间价值的传输，他估计会干不来 一个企业在分化的总趋势中，要力争成为其他企业的依存条件，自己的存在也要获取其他依存条件，所以考虑 的是把自己的核心价值不断做好 共享经济中的某些结论并不成立；即人把一些物质性的东西跟别人共享，这个是成立的；但人的闲暇时间的共享是不成立的。递弱代偿的观点是每一个人都承担一项功能，是不断分化和残花的功能，但如果长期存在兼职的情况，这只是一个过渡现象；到后续必然成为一个 一个老太太，白天做菜多做一些，卖给邻居；一个姑娘，白天上班，晚上烤蛋糕出售；看到的现象是这样，但不一定是一个长期的现象；共享经济，把原来社会分工中的人给撬出来，然后进去一个全新的分工状态；现在看到的大量的兼职，是一个过渡的状态；如果一个老太太做饭好吃，并且体力跟时间都有的话，将来一定会演化为专门给邻里做饭的盒饭供应商；那些刚开始特有兴趣的，到后面成为一个职业的时候，就会逐渐失去对这个的兴趣； 在共享经济里创业，如果你的平台中大量的供应商都处于兼职的状态，那是一个不稳定的，不可持续的状态，你应该用一切资源尽快把他们从原来的社会分工中给撬出来，让他们进入一个更细的全新的社会分工，应该帮助他们尽快完成这个转变 企业和企业之间也会形成分化、残花、再构和的过程，未来的竞争是以群团化的状态进行的；未来的竞争将是产业链条之间的竞争； 每当商业进行一次分化和残化之后，必然会产生一个再构和的冲动；这就是一个商机； 一个企业要追求做大做强，不能局限于在体系内的要素进行合作，必须满市场去寻找更强的个体去合作；这也是一个分化、残化、再构和的过程，必然会产生一个极端不稳定的副作用； 在组织机构上必须飞速进化，以适应这种不稳定性；Eg：Google公司，强调寻找世界上最牛的人，所以非常重视招聘，但对管理的规章制度则不得不弱化，允许组织存在一种混沌的管理状态 一个企业要追求长期稳定，那分化上一定要退缩； 回到哪怕是夫妻老婆店，哪怕是一个工匠； 马云提到过，在天猫和淘宝中存在一些小而美的商业；越小而美，越加稳定]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《皮囊》读书笔记_蔡崇达]]></title>
      <url>%2F2016%2F05%2F03%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F61_%E6%96%87%E5%AD%A6%E5%B0%8F%E8%AF%B4%2F%E3%80%8A%E7%9A%AE%E5%9B%8A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E8%94%A1%E5%B4%87%E8%BE%BE_20160503%2F</url>
      <content type="text"><![CDATA[主要分为两个篇章：摘抄、人物性格 摘抄序 认心、认人的《皮囊》P5 西方之巫说：认识你自己。 认识你自己就必须认识你的他人。 在生活中、行动中遭遇的人，认识他们，照亮他们，由此你就知道自己是谁。 这就是苏珊·桑塔格所说的人的世界。人必须在人的世界里寻求意义。 【人，是社会性的动物；离开了社会，也就不能称之为人，只是一种动物而已。所以，你要做的应该是融入到社会中去，千万不可以把自己封闭起来，这是万万不能的。】 写作就是在过一边。 过一边自己，再试着过一遍他人。 皮囊P3 肉体不就是拿来用的，又不是拿来伺候的。 如果你整天伺候你这个皮囊，不会有出息的，只有会用肉体的人才能成材。 我们的生命本来多轻盈，都是被这肉体和各种欲望的污浊给拖住了。 ​ 母亲的房子P12 “在走几步看看。”这句话母亲自从说出第一次之后，就开始不断用它来鼓励她一辈子要依靠的这个男人。【在面对同样的困境下，不是与她的男人，争吵抱怨，而是默默地鼓励着他，这是一种深沉的爱。 P28 我没有说出口的话还有：其实我理解母亲了，在她的认定里，一家之主从来都是父亲，无论他是残疾还是健全，他发起了这个家庭。事实上，直到母亲坚持要建好房子的那一刻，我才明白过来，前两次建房子，为的不是她或者我的脸面，而是父亲的脸面——她想让父亲发起的这个家庭看上去是那么健全和完整。这是母亲从没表达过，也不可能说出口的爱情。 P30 我知道，即使房子终究被拆了，即使我有一段时间里买不起北京的房子，但我知道，我这一辈子，都有家可回。 ​ 残疾P35 我因此开始想象，当自己驾驭不了身体的时候，到底是怎么样的境况。我觉得有必要体验到其中种种感受，才能照顾好这样的父亲。【自己从没有去想过这样的问题。作者从这个角度去考虑问题，是情商的表现。】 P45 挫败感从那一个个细微的点开始滋长，终于长成一支军队，一部分一部分攻陷他。但他假装不知道，我们也假装不知道。【这是希望被打碎的感觉。】 P49 没有声息，但他的内心里某些东西确实完全破碎了。这声音听不见，但却真实地弥漫开。而且还带着味道，咸咸的，漂浮在家里，仿佛海水的蒸汽一般。 ​ 重病房里的圣诞节P58 在白色是床单上，在白色的窗帘边，在白色的屋顶下，他们的名字都不重要，他统一的身份是，某种病的病人。在这里，人与人的关系也被重组了，同一种疾病的病人，会被安排在邻近，经过几天的相处，他们成了最熟悉的人。【善待自己的身体】 P59 这都是最无能的疾病的作品——死亡不是疾病的目的，疾病是尽可能占有身体，用自己的秩序统治那身体。所以，简单的死和简单的创伤都是最低级的疾病。 P61 我很快知道了这里的其他小孩。知道，但不认识。有种东西，隔阂着彼此，注定无法做非常好的朋友——目光，太透彻的目光。这里的小孩脸上都有双通透的眼睛，看着你，仿佛要看进你的心里。我知道那双痛彻后的眼睛，是被眼泪洗干净的眼睛。因为，那种眼睛我也有。 P62 一开始我选择和一些病人交朋友。家属们一般忧心忡忡，病人们为了表现出果敢，却意外地阳光。【这时候，病人们可能并不是真的阳光，而是不想他最爱的人难过，才如此。想一想对方。】 我一声不吭地吃完饭，一个人爬到医院的楼顶去看落日。在上面，我发誓，不和这重症病房里的任何病人交朋友了。然后安静地回到父亲的病房，把躺椅拉开，舒服地摊在那。假装，一点悲伤都没有。 我的神明朋友P80 和世界上很多道理一样，最危险的地方看上去都有最丰厚的回报。 人最怕的是发现了自己想要的东西。【并不是很理解】 P84 说到底，母亲和神灵的交谈，从来都是自问自答，再让圣杯的组合回答是或不是。母亲提供理解这些问题的可能性，“神灵”帮她随机选了其中一种。母亲最终得到的答案是，那是你夫君的命数，但你是帮他度过的人。我知道，那其实是母亲自己想要的答案。【很多时候，很多事情，并不是我们不知道，只是那不是我们自己心中想要的那个答案，然后才不断地去否定一些事实】 P94 我知道，其实是她需要这个相信，她需要找到，还能为父亲做点什么的办法。【那些灵言，可能就是活着的人想找的一种寄托的希望或安慰】 我对母亲此时的忙碌，却有种莫名其妙的了解和鄙夷。我想，她只是不知道如何面对自己内心的难受。我觉察到她的脆弱。【所以，理解他人，情商是一个很重要的一点】 P102 “他走了。”母亲说，“他释然了，所以解脱了。”说完，母亲的眼眶像泉涌一样流出汪汪的水。我知道，有多少东西从这里流淌出来了。 ​ 阿小和阿小P131 他是在自己亲身感觉到自己的失败前，先行切割； 其实我偶尔会同情阿小，特别是熟悉后。我觉得他是个孤单的人。这种古达我觉得是他父母的错，他活在“去香港前准备”的生活里。他经历的一切，都是过渡的，无论生活、友谊还是感情； P142 留在北京不是全部故事的结束，而是所有故事的开始； 偌大的城市，充满焦灼感的生活，每次走在地铁拥挤的人群里，我总会觉得自己要被吞噬，觉得人怎么都这么渺小。而在小镇，每个人都那么复杂而有生趣，觉得人才像人。唯一能做的就是不停通过职业的成就感稍稍缓解自己。 ​ 天才文展P153 我们要创造我们的生活。 P158 你得想好自己要拥有什么样的人生，然后细化到一步步做具体规划。 P171 我为和他对话定制的策略，还是一个求教的方式，我知道，那会让他觉得安全，也会安抚到他。【这是高情商的表现，以对方的角度出发，让对方与你的相处中获得舒服；但另一面，如果你有足够强的能力，或许是另外一种个性】 P174 我基本不太想太长远的事情，很多事情想大了会压得自己难受。我只想着做好一点点的事情，然后期待，这么一点点事，或许哪天能技能成一个不错的景观。起码是自己喜欢的景观。 我做记者，是 因为，我觉得这世界上最美妙的风景，是一个个奇特的人。【这是作者真实内心的追求】 P182 在路上，我反复在想，自己此前对文展耿耿于怀的原因，是因为我有种无意识的愧疚感，仿佛我莫名其妙地过了他应该过的生活？又或许，是因为，我知道，从本质意义上，我们都是，既失去家乡又永远没办法抵达远方的人。 ​ 厚朴P186-195 不清楚真实的标准时，越用力就越让人觉得可笑。厚朴大约也是这样的小孩，他们往往是脆弱的，因为干净到甚至不知道应该要去判断和思考自己是否适合时宜。 表面上我大大咧咧、粗心大意。事实上， 我讲每句话的时候，总担心会冒犯他人。我总在拼命感知，人们希望听到什么？如何表达到位？说不出的恐惧，恐惧自己成为别人不喜欢的人。为什么这么需要让别人喜欢？或许是求生的本能。 生存现实和自我期待的差距太大，容易让人会开发出不同的想象来安放自己。我相信，他脑子里藏着另一个世界，很多人脑子里都偷偷藏着很多个世界。我自己警惕地处理着想象和现实之间的关系：任何不合时宜的想象都是不需要的，因为现实的世界只有一个。 厚朴的言行果然被当作谈资当初传播，但出乎我意料的是，他一点都没在意。他是不是没有意识到这样的谈论是嘲笑，甚至可能一位这是某种认可。【作者是一个敏感细腻的人；但厚朴可能自己没有这样认为，这也是另一种生活态度。】 我终究是务实和紧张的，我开始计算一天睡眠需要多少时间，打工需要多少时间，还有赚学分和实习……【觉得自己似乎也是在这样一直计算着】 在迅速城市化的这个国家里，似乎每个人都在急着进入对时尚生活的想象，投入地模仿他们想象中的样子。这些社团或许更准确的描述还可以是——通过假装弹吉他、跳街舞、写诗歌来集体自我催眠，一位自己变得现代、时尚的邪教组织。 实习是没有收入的，但可以看到更多的真实世界：真实的利益关系和真实的人性。要训练自己和真实的世界相处。【这是我所欠缺的。发现自己写东西或表达内容太喜欢用“可能/或许”这样的词，认为什么就是什么，你应该要有这样的自信。因为当前的观点是用你所经历的整个人生与所学知识所得出的。】 我知道他想借此告诉我什么，但这故事一听就真伪可疑，厚朴竟然全盘接收。他不知道什么是真实的世界。【就像我，不知道什么是真实的世界。我只是倔强地、自以为是地活在自己的世界里。至少，从过去到现在，基本如此。】 不合时宜的东西，如果自己虚弱，终究会成为人们嘲笑的对象，但有力量了，或坚持久了，或许反而能成为众人追捧的魅力和个性——让我修正自己想法的，产生这个判断的，是厚朴。【其实，这是源自一个人内心的坚定与坚持，如果不是你真正热爱或相信的东西，在你一开始做的时候可能就会因为他人的反对而早早放弃，并且得出自己不适合或自己是错的观点】 作者描述了厚朴组建的乐团的几个团员的特点。【作者很细腻地观察着他人，或者说是真实的世界。而对他人的观察，我是非常欠缺的。除此之外，目前一直沉浸在自己需要改变的方便，但对于自己擅长是事，却一直没有去思考，去实践。】 P198-203 虽然不愿承认，但在那一刹那，我竟然被触动到了，竟然很认真地想：自己是否也可以活的无所顾忌、畅快淋漓。【但从作者的性格特点来看，这样的想法必然只是一时的】 厚朴确实在用生命追求一种想象，可能是追索地太用力了，那种来自他生命的最简单的的情感确实很容易感染人。 王子怡成了厚朴的女朋友。得知这个消息，我吃了一惊。但一下子明白过来，这也是厚朴。有些人一门心思突破一切想抵达所谓的新世界，但砖头一看，却发觉，他们只知道用老的规则来衡量自己；才发觉，其实他们彻头彻尾地活在旧体系里了。 P205-211 我一下子明白她（张静宜）是什么样的女孩，虽然我一直看似功利地在努力测算和安排自己的未来，但骨子里头是那么厌恶这样的计算。从得失的角度，我应该把握这个女孩，而且她确实是个好女孩。等她离开之后，我突然想打电话约厚朴出来喝酒。但我最终没有打这个电话，我没搞清楚，是否每个人都要像我这样看得那么清楚。我也没把握，看得清楚究竟是把生活过得开心，还是让自己活得闷闷不乐。【所以，如何生活才是关键？】 和她的关系到底要如何发展，我确实在很理性地考虑。让我经常愧疚的是，我不是把她单独作为一个原因来考虑，而是把她纳入我整个人生的计划来考量，思考到底我是不是要选择这样的人生。 我看着她，内心却涌起一种负罪感和恶心，我知道那是我对自己的厌恶。我厌恶那个精明算计的我，我厌恶那个做了精明计算又不愿执行的我。我知道那刻我要开口说的，是上海这个无辜女孩的话。 P212-215 只是这样的宣誓，没有从心里透出来的力气，让人听了，反而感觉到无法言说的虚弱。【底气；话语的力量是从到外的。】 北京这个梦想之地，从表面上看，似乎是厚朴天然的生存之地，然而，我也知道，在北京发生的任何理想和梦想，需要的是扎扎实实，甚至奋不顾身的实践。我隐隐担心，厚朴这几年一直活在对梦想的虚幻想象中，而不是切实的现实里。我没把握，当他看到梦想背后那芜杂、繁琐的要求时，是否会有耐心，是否具有能力，是否有足够的接受度——梦想原来是卑微的执着。 我没能说出口的是：厚朴，或许能真实抵达这个世界的，能确切抵达梦想的，不是不顾一切投入想象的狂热，而是务实、谦卑的，甚至你自己都看不起的可怜的隐忍。【真实的梦想，是卑微的执着的坚持与隐忍】 他不知道，最力气的理想所需要的建筑素材就是一个个庸常而枯燥的努力。 我从辅导员那里得到厚朴父亲的电话，希望他能向厚朴分析清楚这世界的真实逻辑。他却告诉我：“没事，就让他闯闯，失败了，也当作是让他发泄发泄，他得把内心的欲望抒发完成啊，要不这一生就浪费了。” P224 一种难以形容的悲伤，迅速在胸口膨胀。张了张口，试图想发出点什么，却始终没有一点声音。我这才意识到，这几年来，对自己的管控太成功了，以至于在这个极度难过的时候，还顾虑这大声宣泄会惹来邻居的非议。 ​ 愿每个城市都不被阉割P231 当时小孩子的我一直在心里庆幸还好自己不是这里的人，而且看着大片大片望不到尽头的水泥路，我觉得好悲哀——没有各种奇特的植物没有长有小蝌蚪和五彩鱼的水池没有可以挖地道的地方。【对于孩子，需要的是各种千奇百怪的东西，来满足他们的好奇心】 ​ 我们始终要回答的问题P238 你根本还不知道怎么生活，也始终没有勇气回答这个问题。 我，或者许多人，都在不知道如何生活的情况下，往往采用最容易掩饰或最常用的借口——理想或者责任 我疯狂工作，不让自己有空余时间，除了真实的生存压力，还在于，我根本不敢让自己有空余的时间，因为时间一空下来，我就要回答怎么去填充时间，怎么去面对生活，去回答这个问题——我要怎么生活，我真正喜欢的是什么，我真正享受的是什么？ 生活从来都不是那么简单的梦想以及磨难，不是简单的所谓理想还有阴谋，生活不是那么简单的概念，真实的生活要过成什么样是我们自己要完成和回答的问题。 我不愿意和许多关心我的朋友联系，不愿意开口说话，或许也在于我不知道如何回答自己、如何和自己相处，更不知道如何和朋友相处了。 ​ 回家P247 家不仅仅是一个房子、几个建筑物，家，就是这片和我血脉相连、亲人一样的土地。 P250 从小我就喜欢闻泥土的味道，也因此其实从小我不怕死，一直觉得死是回家，是入土。我反而觉得生才是问题，人学会站立，是任性地想脱离这土地，因此不断向上攀爬，不断抓去任何理由——欲望、理想、追求。然而，我们终究需要踏着黄土。在我看来，生是更激烈的索取，或许太激烈的生活本身就是一种任性。 ​ 火车伊要开往叨位P256 任何事情只要时间一长，都显得格外残忍。 九年前，坐在这位置上的我，父亲半身瘫痪，是家境困顿到无路可去的时候。当时那个蔡崇达，想着的是如何挣钱送给父亲到美国治病，可以为了考虑是否为整天兼职而辛苦的自己加一块红烧肉而犹豫半天，还立志多挣点钱带阿太去旅游，当然还想着要赶紧牛起来，让给自己机会的当时广电报的老总王成刚骄傲。甚至曾经想象，在哪一本书畅销后，要回到做父亲做手术的福二院，对那些病患的子女讲，别放弃，生活还有希望。 九年后，那个当年的蔡崇达执着的理由全部消失，父亲、阿太、成刚的突然离世，让阿太觉得自己突然轻盈得无法触碰到真实的土地。而他唯一找打的办法，就是拼命工作。 我不相信成熟能让我们接受任何东西，成熟只是让我们更能自欺欺人。 ​ 后记P262 我常对朋友说，理解是对他人最大的善举。 写这本书，就不仅仅是“自己想要做的一件事”，而是“必须做的事情”了。【想要 vs. 必须】 人物性格作者 性格特点： 文中故事： 在面对经费不够的情况，面对三伯不理解母亲建房子的时候，在面对自己的生活很糟糕的时候，为了实现母亲的爱，而依然同意修建房子。 经历过与重症病房里面的人成为朋友后，马上遇到了对方离去的事实后，决定不在与病房里的人交朋友。 说过的话： 阿太 身份：作者外婆的母亲 出现章节：皮囊 性格特点：释怀坦然，看重心里的灵魂与思想，追求精神世界的丰盈 文中故事： 阿太白发人送黑发人（外婆），葬礼上一声也没哭； 自己手指切了，也不放在心上； 小时候为了让舅公学游泳，直接扔到海里，差点把他淹死。 说过的话： 肉体不就是拿来用的，又不是拿来伺候的。 如果你整天伺候你这个皮囊，不会有出息的，只有会用肉体的人才能成材。 我们的生命本来多轻盈，都是被这肉体和各种欲望的污浊给拖住了。” 【母亲】 身份：作者的母亲 出现章节：母亲的房子、残疾、重症病房里的圣诞节、我的神明朋友 性格特点：倔强与傲气；极强的自尊心；深爱，却不显露； 文中故事： 在生完第二个孩子出来医院之后，面对绝望的父亲，一直鼓励他，说“再走几步看看。” 为了修建家中的房子，宁可到菜市场捡人家不要的菜叶回来到家里吃，也不愿意动用已有的存款。即使当时父亲还需要医药费，她依然坚持要建房子。即使后来当时我的大学学费也不够的情况下，仍然坚持。到后来村里来了建筑工队开始逐步拆房子，在明知道会被拆迁的情况下仍然坚持建房子。 在面对家中的钱怎么花的时候，问我应该怎么做，并且说“你是一家之主。”在面对父亲的手术时，对我说“你是一家之主”，你来决定。 开加油站时，一个之前在父亲底下做事的小弟，有点嘲笑她的男人的时候，她愤怒了。即使当时我们家已经非常苦难了，只剩最后这个加油站来维持生计。 父亲死后，因为一个梦，然后到处像神明朋友请求帮助。找巫，然后依据巫的要求，把父亲“引回来”之后，便送他到寺庙做义工。 说过的话： 在多走几步看看； 人活着就是为了一口气，这口气比什么都值得； 父亲 身份：作者的父亲 出现章节：母亲的房子、残疾、重病房里的圣诞节 性格特点：担当、倔强地不愿接受事实、 文中故事： 结婚时当时没房没钱，第一次约会只是拉着母亲来到这快地，说，我会把这块地买下来，然后盖一座大房子；后来，为了盖房子跑去宁波做事情，可能外面出了其他事，但不管怎么样，攒了钱回来盖了房子。 父亲意外中风； 不愿接受这个事实，努力挣扎，想要移动，想要证明，想要回到自己还是家中顶梁柱的那个过去。 每天早起走路锻炼，通过这样的锻炼让自己另一边的身体经血活络起来。从夏天坚持到秋天，但逐渐发现这一切都变不回来了，变得愈加固执。制定更加严格的时间计划，并且把过错归咎于母亲。 面对台风，仍然坚持出门锻炼。这一次之后，终于开始妥协与接受这个残酷的事实。在他请求我开着摩托车带他兜风之后，最后终于死心了。 说过的话： 张美丽 身份：村里的一位女性 出现章节：张美丽 性格特点：个性张扬但又保守，追求自己的爱情， 文中故事： 时尚的不同于村庄打扮的姑娘，为了追求爱情离开村庄 离婚回来村庄之后开了一家餐饮店，味道很好；刚开始大家都是排斥，但渐渐都喜欢去那里吃东西 捐赠资金用来做广场拓宽、村里建设；但到后来仍然别人排挤，不接收与不认同 最后因为开的店里出现有人被打死，矛头都指向张美丽，最后还被她的母亲斥责，最后心怀着悲痛，以不被理解的心情撞墙自尽 阿小1-村里的阿小 身份：儿时玩伴 出现章节：阿小和阿小 性格特点：孤僻 文中故事： 总是躲在一个角落，不参与交际 阿小开始去主动跟香港阿小一起玩，跟着他 阿小知道香港阿小只给我写信之后，就跟我绝交了，觉得因为我的关系离间了他们之间的关系 阿小2-香港阿小 身份：转校来的伙伴 出现章节：阿小和阿小 性格特点： 文中故事： 因为我是村里最会读书的孩子，所以香港阿小的家人拜托我跟他玩 他有很多新奇的东西总是叫我去玩 之后去了香港给我写信，到之后我去香港的时候才再次见到了他，他过的并不好，交不到朋友，对城市生活的厌恶 文展 身份： 出现章节：天才文展 性格特点：有目标有规划、过于强烈的自信心 文中故事： 有兔唇，但并没有因此羞愧，反而是一个有思想、自信的人 通过召集朋友一起来玩，有目的的锻炼自己的组织能力 开导我去思考人生的目标与未来的生活 在考试之前没有考好，使得文展一度陷入非常低沉的阶段，并且不再见任何人，包括我 最后通过努力以他自己想要的方式赢得了第一场人生的战役：中考，并且开始走向了城市 文展因为父亲逝世之后回来村里做编辑，因为这对他是失败的，所以当我想靠近他的时候他一直躲着我 厚朴 身份： 出现章节：厚朴 性格特点：认真地活着、不受现实/世俗约束、不在意他人的眼光只活在自己的世界、追其梦想 文中故事： 用力地生活。很用力地打招呼，很用力地介绍自己。 对着全世界宣扬自己的追求，受到他人的谈论却毫不在意。 他依着自己的追求，参加各种社团活动。而我则开始实习打工，计划之后的人生。这是一个鲜明的对比。 虽然我们认为厚朴没有音乐才能，但他相信自己，开始买乐器，组建团队，之后甚至还在全校开了演唱会。虽然歌声不好听，但他的名字却红遍了整个校园。 厚朴成为了人们膜拜的对象，很多人都跟厚朴提自己的想法，然后说：厚朴你来带头做吧 厚朴成为了学校秘书长女儿王子怡的男朋友。因为其实他们两个本是两个世界的人。他再一次成为了大家关注的焦点。 慢慢地厚朴逐渐淡出大家的视野，但王子怡不甘接收这样的结果，逼着厚朴疯狂的联系，并且得到资助，再一次开演唱会。但结果很明显，被人骂的很惨。 他再次召集乐队，但这一次明显没有了底气。他这样做，可能只是为了继续贯彻自己的信念。 到后来，失意的厚朴回到了原来的村庄去教书；然后在几年之后死了。他是用自己的头去撞墙，然后死去的。那是因为他头脑里面的声音一直在呼喊他，而现实无法回应这样的呼喊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《巴比伦富翁的理财课》读书笔记]]></title>
      <url>%2F2016%2F04%2F13%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%2F%E3%80%8A%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%AF%8C%E7%BF%81%E7%9A%84%E7%90%86%E8%B4%A2%E8%AF%BE%E3%80%8B_%E4%B9%94%E6%B2%BB.%E5%85%8B%E6%8B%89%E6%A3%AE%2F%E3%80%8A%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%AF%8C%E7%BF%81%E7%9A%84%E7%90%86%E8%B4%A2%E8%AF%BE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[第一章 来自诺丁汉大学的两封信P14 将所有的收入划分为7-2-1； 7–日常费用的开销，并且坚持所有开销不能超过收入的7/10 2–用于偿还债务；实现部分收入清偿所有债务 1–任何收入的1/10储蓄起来；后续可用这一部分去做投资；（并且每次储蓄不要低于所得收入的1/10，这是底线，但其实你绝对可以存储比1/10更多的钱） 第四章 巴比伦放债人的忠告P84 假如你需要帮助你的朋友，你完全可以帮助，但绝不能把你朋友的负担加在自己身上，从而变成了自己的负担 P97 可以借钱给三种人：拥有财富超过其所借款项的人；拥有持续而稳定收入的人；有抵押品或可靠担保的人 不可以借钱给三种人：陷入苦闷、麻烦不断的人；欠缺知识经验和能力的人；无力偿还的人； 拥有一笔财富时，遵循两条原则：（1）保证它们安全；（2）尽量使他们增值 第六章 有才华的穷人和他的美梦P128 他们通过勤奋努力，的确在某些方面具备了某种才能，但在理财方面的知识和技能却少的可怜 第七章 巴比伦最大的富翁出场P145 所有收入的一部分一定要自己存储起来 再学习如何使你积累的财富为你效力 一定要向有智慧的人咨询商事，向每天在跟钱打交道的人寻求忠告 第八章 治愈贫穷的七大妙方P171 首先让你的钱包膨胀起来；每赚进十个钱币，至多只花掉九个 控制你的开销；永远不要将不必要的开销和你的欲望混在一起；做预算将帮助你将你最在乎的欲望付诸实践 使你的金子繁衍增值 守卫你的财富免遭损失 使你的住房成为有利可图的投资 确保你将来的收入 增进你赚钱的能力；想要成功致富，必须首先拥有这样的渴望，而且你的渴望必须是非常强烈和明确的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《富爸爸穷爸爸》读书笔记_罗伯特.清崎]]></title>
      <url>%2F2016%2F04%2F13%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86%2F50_%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%2F%E3%80%8A%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8%E3%80%8B_%E7%BD%97%E4%BC%AF%E7%89%B9.%E6%B8%85%E5%B4%8E%2F%E3%80%8A%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%BD%97%E4%BC%AF%E7%89%B9.%E6%B8%85%E5%B4%8E%2F</url>
      <content type="text"><![CDATA[《富爸爸穷爸爸》_罗伯特.清崎 第1章 富爸爸穷爸爸 P19 当你下意识的说出“我付不起”的时候，你的大脑就会停止思考；而如果你自问“我怎么才能付得起”，则会让你的大脑动起来；【这个是意识层面的区别，但也是很重要的一个区别】 贫穷和破产的区别是：破产是暂时的，而贫穷是永久的 第2章 第一课：富人不为钱工作 P40 如果你是那种没有勇气的人，生活每次推动你，你都会选择放弃。如果你是这种人，你的一生会过得稳稳当当，不做错事、假想这有事情发生时自救，然后慢慢变老，在无聊中死去。你会有许多好朋友，他们很喜欢你，因为你真的是一个努力工作的好人。你的一生过得很安稳。但事实是，你向生活屈服了，不敢承担风险。你的确想赢，但失败的恐惧超过了成功的兴奋。只有你知道，在你内心深处，你始终认为你不可能赢，所以选择了稳定。 ​ P49 大多数人为了一点点钱而勤奋工作，深信有工作就有了保障。 一开始，没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的东西，于是就形成了一种模式。起床-上班-付账-再起床；他们害怕没有钱，更没有直面这种恐惧，对此他们虽然在情感上有所反应但并没有动脑筋想办法与行动。 当一个人说“我得去找份工作”，这就很可能就是他的感情代替他在思考。如果害怕没钱花，也先不要去找工作，而要先问问自己：一份工作是最终消除这种恐惧的最佳解决办法吗？ 工作只是试图用暂时的办法来解决长期的问题。 以工资的多少来决定过什么样的生活不是真正的生活，认为工作会给你带来安全感其实是在欺骗自己。 ​ P66 由于没有从小店的工作中获得报酬，我们就不得不发挥想象力去寻找挣钱的机会。通过经营我们自己的连环画阅览室，我们就掌控了自己的财务，而不是依赖雇主。 第3章 第二课：为什么要教授财务知识 P69 生活中重要的不是你挣了多少钱，而是你能留下多少钱，以及能够留住多久。 ​ P76 资产：是能把钱放进你口袋里的东西 负债：是把钱从你口袋里取走的东西 ​ P91 当我和妻子要买房子的时候，我们也很清楚那不是资产，而是负债，因为它把钱从我们口袋中掏走了。 决定买昂贵的房子，而不是早早开始证券投资，将对一个人的生活形成3个方面的冲击： ​ 失去了用其他资产增值的机会 本可以用来投资的资本将用于支付房子高额的维修和保养费用 失去受教育的机会。因为没钱投资，也就不去投资，这就使得无法获得投资经验 ​ 当我想换大一点的房子时，我会先买入一些资产，让它们能够支付这所房子的现金流。 中产阶级发现自己总是在财务问题上挣扎。他们最主要的收入“工资”增加时，税收也增加了，更重要的是，他们的支出也同步增加了。他们把房子作为最主要的“资产”，而没有把钱放在那些会带来收入的资产上。 最重要的规则是弄清楚资产与负债的区别，一旦你明白了，你就会竭尽全力只买入能带来收入的资产，这是你走上致富之路的最好办法。 ​ 作为一个自己有房子的雇员，你努力工作的结果就是： 你为别人工作。你的工作只会使雇主或股东更加富有。 你为政府工作。政府在你还未看到自己的工资时就已经拿走了一部分。 你为银行工作。缴了税之后，你的最大支出是抵押贷款和信用卡账单。 ​ 财富就是支撑一个人生存多长时间的能力。或者说，如果我今天停止工作，我还能活多久？如果我的资产每月产生1000美元，而我要支出2000美元，那我根本没有财富。如果我想增加支出，就必须先增加资产项产生的现金来维持我的财富水平。只要我把支出控制在资产项能够产生的现金之下，我就会越来越富有，也会有越来越多的非劳动收入。 ​ 富人买入资产； 穷人只有支出； 中产阶级购买自以为是资产的负债； 第4章 第三课：关注自己的事业 P101 麦当劳的基本业务是出售麦当劳各个分店。 ​ 从事你所学专业的可怕后果在于，它会让你忘记关注的事业。人们耗尽一生去关注别人的事业并使他人致富。 你的事业的重心是你的资产项，而不是你的收入项。富人关心的焦点是资产而其他人关心的是收入。【如何去理解收入项？】 只有你把额外的收入用来购买可产生收入的资产，你才能获得真正的财务安全。大多数穷人和中产阶级财务保守（这意味着他们无法承担风险）的根本原因在于，他们没有经济基础。他们必须依附于工作，必须安全运作。 ​ 真正的资产分为以下几类： 不需我到场就可以正常运作的业务。我拥有它们，但由别人经营和管理。如果我必须在那工作，那它就不是我的是i也，而是我的职业。 股票 债券 共同基金 能够产生收入的房地产 票据（借据） 版税，如音乐、手稿、专利 其他任何有价值、可产生收入或有增值潜力并且有很好铺路的东西 ​ 一旦把1美元投入了资产项，就不要让它出来，它进了资产项，就成了你的雇员。关于钱，最妙的是让它可以一天24小时不断工作，还能为你的子孙后代服务。【观念很重要】 ​ 当你的现金流增加时，你可以买点奢侈品。穷人与富人的一个重要区别是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如房子、珠宝等奢侈品，因为他们想让自己看上去很富有。但实际上他们已深陷贷款的陷阱之中。那些能长期富有的人，就是先构筑资产项，然后才用哦个资产所产生的收入购买奢侈品。 第5章 第四课：税收的历史和公司的力量 P115 当人们想惩罚富人时，他们不会坐以待毙，而是进行反击。美国的税法允许人们采用合理的方法避税，大多数人都可以运用这些方法，但实际上只有富人才常用它们，因为他们关注自己的事业。 ​ 财商=会计（财务知识）+投资策略（钱生钱的科学）+了解市场（供给与需求的科学）+法律规章 ​ | 拥有公司的富人 | 为公司工作的人 || ——- | ——- || 1.挣钱 | 1.挣钱 || 2.支出 | 2.缴税 || 3.缴税 | 3.支出 | ​ 第6章 第五课：富人的投资 P131 大部分人只知道一种方法：努力工作，储蓄，借贷。每月拿出一笔钱存起来听上去是一个好主意，这是一种大多数人都采取的选择，但问题是：它会蒙蔽人们的双眼，使人们看不到事情的真相，从而错过很多使资金大量增加的机会。【把钱存起来是为了后续能够用这一份钱去购买资产，而不是为了去购买奢侈品】 ​ 金钱不是真实的资产 ​ 哪个问题对你来说更难一些？ 辛苦工作，薪水的50%用于缴税，剩下的钱拿去储蓄，存款利率为5%，而且利息还要再缴税 花些时间来提高你的财商，增强你的动脑能力，从而增加你的资产 ​ P143 真正炙手可热的交易不会留给新手。一般来说，能使富者更富的最好的交易总是为那些精通游戏规则的人准备的。我越是老练，越是会得到更多的机会。提高财商的另一个方面，就是让自己拥有更多的机会。 ​ 常常有这样的情况，对一个人来说是高风险的事情，对另一个人来说则可能是低风险的。这就是我不断鼓励人们多关注财商教育而不只是投资股票、房地产或其他市场的原因。你越精明，就越能应付意外的情况。【去关注财商教育】 ​ 投资者分为两类： 1）一揽子投资的人； 2）自己创造投资机会的人；（这需要以下3点） 寻找他人都忽视的机会 增加资金 把精明的人组织起来 第7章 第六课：学会不为钱工作 P152 当涉及钱的时候，只有一项技能的人不得不努力工作。大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。有关综合技能的典型例子就是那位为报纸撰稿的年轻女记者。如果她能努力学习销售的技能和有关市场的知识，她的收入就会显著增加。（女作家的故事：好的作家≠畅销书作家） ​ ​ ​ ​ P154 在学校和单位，最普遍的观点就是“专业化”，也就是说，为了挣更多的钱或者能升职，你需要更加专业化。我受到良好教育的爸爸也信奉同样的信条。但富爸爸则鼓励我去做相反的事情，“对于许多知识你只需要知道一点就够了”，这是他的建议。 ​ 工人付出最大努力以免被解雇，而雇主提供最低工资以防工人辞职。 ​ P160 我将终生只在这一行里学到一种有价值的技能，如果我被这一行业抛弃，我的技能对其他行业则毫无用处。一位拥有10万小时驾驶大型运输机记录的高级飞行员，一旦下岗就很难找到一份相当的收入。 ​ 我们可能能做出比麦当劳更好吃的汉堡，但麦当劳比我们更赚钱？那是因为麦当劳拥有一套出色的商业体系。许多才华横溢的人之所以贫穷，就是因为他们只专心做好产品，而对商业体系知之甚少。【想起了成功需要努力，更需要格局】这是一个有关只懂怎么做好汉堡，却不懂如何将汉堡卖出去的例子。他们只将注意力放在提高做汉堡的技能上，却不注意提高销售和配送的技能。 ​ 成功所必需的管理技能 对现金流的管理 对系统（包括你本人、时间及家庭）的管理 对人员对管理 最重要的专门技能是销售和对市场营销的理解。销售技能是个人成功的基本技能，它涉及与其他人的交往，包括与顾客、雇员、老板、配偶和孩子。而沟通能力，如书面表达、口头表达及谈判能力等对一个人的成功是至关重要的。我还不知道有比销售和市场营销更重要的技能，但掌握它对大多数人来说是很困难的，因为他们害怕被拒绝。 ​ 精通专业技能既是优势也是弱点。他们非常有天赋，但不善于与其他人交流，结果他们的收入少得可怜。我建议他们用一年时间来学销售，即使挣不到钱，可他们处理人际关系的能力会大大提高，这种能力是无价的。【反思自己，这个是自己亟须改变的地方】 第8章 克服困难 P168 掌握了财务知识还依旧不能积累丰厚的资产项，主要原因有： 对可能亏欠的恐惧心理； 如果你要破产了，那就索性一分不剩；【这是一种生活态度】 大部分人在财务上不成功的原因是他们的做法过于安全。因为太害怕失败，所以才会失败。胜利意味着不害怕失败。【其实，胜利都是由每一个失败积累起来的】 不喜欢不同于害怕失败，这两个有着巨大的差别。很多人财务困难的原因在于，他们是为了避免损失而理财，而不是为了赢利而理财。 如果你的资金很小而又想致富，你必须首先集中于一点，而不是追求平衡。 如果你不愿意失败，那就安全地投资，但要尽早起步，因为以这种方式积累需要大量的时间。 愤世嫉俗的心理； 大部分人之所以贫穷，是因为他们想要投资的时候，周围到处是跑来跑去的“小鸡”，叫嚷着“天要塌下来了”；他们从未投资，却总是劝别人不要这样做。 懒惰 过分忙于工作而不关心自己的财富； 他会问：“你怎么样才能买得起这个？”他希望我们学习的并不是目标本身，而是达到目标的过程。 习惯 有的人总是先支付给其他人，最后才支付给自己，而且这还得看他有无余钱；有的人坚信按时支付账单，但是先付给自己，再付给别人；即使我缺钱，我仍要先支付给自己。因为对我来说，我的资产项比政府重要的多。【思考，先支付给自己，其实就是先将钱财分配给自己的资产项】 在我把仅有的钱先支付给自己后，要支付税款和其他债主的压力就会变得非常大，迫使我去寻找其他形式的收入，支付的压力就会成为我的动力。压力迫使我能力工作，迫使我去思考。如果我最后支付给自己，或根本不支付，我就会变得越来越“虚弱”，那么我一生都会围绕着老板、经理、税务官员和地主们转，这仅仅是因为我没有良好的理财习惯；【不管收入多少，我们必须先保证自己的生活；同时为了捍卫自己的生活，会去主动思考并寻找出路】 傲慢；傲慢是自大和无知的结合体。 第9章 开始行动 P193 我需要一个超现实的力量——精神的力量； 很多人都会想致富或者获得财富自由，可一想到现实，就变得崎岖而漫长； | 不想要 | 想要 || ————————- | ———— || 将一生都耗在工作上 | 以自己喜欢的方式生活 || 我爸爸那样努力工作，但在他去世的时候失去了所有东西 | 自由支配自己的时间和生活 || | 金钱为我工作 | 每天做出自己的选择——选择的力量； 我们每挣到一美元，就得到了一次选择成为富人、穷人还是中产阶级的机会。我们花钱的习惯反映了我们是什么样了的人。事实上，我们所做出的每一个选择，都是利用我们自己的时间、金钱和头脑里学到的东西作出的。 首先投资与教育；实际上，你所拥有的唯一真正的资产就是你的头脑；同时，每个人都要选择学习什么样的知识。在投资方面，大部分人选择的是直接去投资，而不是首先投资于学习如何投资。我喜欢参加研讨会，那种为期至少两天的研讨会，因为这样我能静下心来研究某一专题。1973年我在电视上看到有人做广告，举办一个为期3天的研讨班，讨论如何不支付首付就能购买房地产。这个研讨班只花费了385美元，却帮我挣回至少200万美元。更重要的是，它为我创造了新的生活。 今天我会常常问自己，“这件事彼得·林奇会怎么做？”我得以进入他们深邃思想的唯一途径就是谦虚地阅读或倾听他们说过的话。 慎重地选择朋友——关系的力量； 我承认会特意交一些有钱的朋友，但我的目标不是他们的钱财，而是他们得以致富的知识。他们那些没钱的朋友从不问他们是怎么赚到钱的，而总是向他们要求两样东西：贷款、工作 胆小的投资者总是亦步亦趋跟在众人后面，当欲望驱使他们终于冒险投资时，精明的投资者早已经获利退出了。【真正的机会，是给那些勇于尝试的人；如果想要获利，就必须要有承担风险的决心】 掌握一种模式，然后再学习一种新的模式——快速学习的力量 你学习什么，就会成为什么样的人；你必须注意你要学习的内容，因为你的精神力量非常强大，你学习烹饪，你就会经常做菜，然后成为一名厨师。 首先支付自己——自律的力量 开创事业所必备的最重要的3种管理技能： 现金流管理； 人事管理； 个人时间管理； 首先支付给自己，其实就是先将钱分配给自己的资产项；首先支付自己，就是首先不能陷入债务之中。当你资金短缺时，让压力去发挥作用，而不要动用你的储蓄或资本。【回顾之前提到的，一旦把它方你的资产项，就不要让它在出来】 ​ 一个普遍的坏习惯就是随便动用储蓄。富人知道储蓄只能用于创造更多的收入，而不是用来支付账单。【回顾《巴比伦富翁的理财课》，1/10的收入存储起来，是为了后续的投资或做项目，而不是为了购买奢侈品】 ​ 如果一个人缺乏自律，最好别想着致富。从理论上讲，从一项资产中获得现金流的过程是容易的，但拥有控制金钱的坚强意志却是困难的。 ​ 给你的经纪人以优厚的报酬——好建议的力量 要知道一个出售房子的经理人与一个出售投资项目的经纪人之间有着天壤之别；如果你总是琢磨着要减少他们的佣金，那他们凭什么要尽力为你服务呢？ 人事管理方面真正的技能是在某些技术领域能够管理比你更聪明的人并给他们提供优厚的报酬。 做一个“印第安给予者”——无私的力量 有时我会损失资金，但我投资的项目都是在我能承担的损失范围之内的。 用资产来购买奢侈品——专注的力量 我给他3000美元，但他不能直接用这笔钱买车，他可以用来购买股票，也可以用来聘请经纪人，等他把3000美元增值到6000美元，就可以用挣到的钱去买车了。 ​ 今天，我们关注的是借钱来买我们想要的东西，而不是如何才能创造财富。 对英雄的崇拜——神话的力量 先予后取——给予的力量 每当我觉得有什么需要，或是缺钱，或是需要帮助时，我都会想一想，自己心里要 的到底是什么，然后首先为此付出。一旦我付出了，就总能得到回报。 第10章 还想要更多吗？这里有一些要做的事情 P223 没卖过东西的人，对想卖出东西的迫切心情是不会理解的； 报价本身并不重要，关键是有人感兴趣。 ​ 关注适当的地方：一位邻居以10万美元购买了一套公寓，我则以5万美元购买了与之相邻的相同的一套公寓。他告诉我他在等着价格上涨；他能获得的利润在他购买这套公寓时已经确定了，而不是在他出售时才确定。 ​ 我首先寻找想买进的人，然后才去找想卖出的人。一位朋友想买一处地，他有钱但没时间去找。我发现了一处地产，比我朋友想要的面积大一些，我打电话给他，他说只想要其中一片。于是我买下了土地，然后把那一片卖给他。我一直没有卖掉剩下的土地，它一直为我带来收益。这个故事的核心是：买下馅饼并把它切成小块。大部分人寻找的只是自己能付得起的东西，所以他们只看到较小的东西。他们只买一小块馅饼，却总是付出更高的价格。只盯着小生意的人是不会有大突破的。 ​ 零售商喜欢提供数量折扣，就是因为大部分商人都喜欢大额购买的人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《意志力》读书笔记_罗伊.鲍迈特斯]]></title>
      <url>%2F2015%2F04%2F18%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%2F60_%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%26%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%BF%83%E7%90%86%2F30_%E8%A1%8C%E4%B8%BA%E5%BF%83%E7%90%86%E5%AD%A6%2F%E3%80%8A%E6%84%8F%E5%BF%97%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E7%BD%97%E4%BC%8A%C2%B7%E9%B2%8D%E8%BF%88%E7%89%B9%E6%96%AF%2F</url>
      <content type="text"><![CDATA[​ 意志力：关于专注、自控和效率的心理学（Willpower:Rediscovering the Greatest Human Strength） [美]罗伊·鲍迈特斯/约翰·蒂尔尼 著 丁丹 译 ——阅于2015年4月 ​ 意志力像肌肉一样，过度使用就会疲劳，长期锻炼就会增强。 （实验：成功抵制了巧克力曲奇的诱惑，但是付出了很大努力，没有剩下多少精力做几何题，更容易放弃。） （事例：为什么工作压力最大时婚姻往往出问题。人在工作上用完了所有的意志力，当意志力都耗在了办公室，家庭就会遭殃。所以，要在还剩下些精力的时候就下班。） 自我损耗造成的影响是双重的：（1）意志力减弱了；（2）渴望变强了； 用掉的意志力越多，向下一个诱惑屈服的可能性就越大。（事例1：“按时做作业”与“穿干净袜子”是负相关的；事例2：考试月时，学生专注于学习，但饮食怎么方便怎么来，垃圾食品消费量陡增；） 一次只做一件事情。如果你想让生活同时发生几个变化，那么最终可能一个变化都发生不了。最好是只下一个决心并坚持下去，那就足具挑战性。（事例：舍弃“新年任务”清单。不要下决心说要少吃饭、多运动、少花钱、工作努力、家里弄干净，而且有更多的时间进行约会，这是不可能的。） ——以上摘自《第1章 意志力不只是个传说》 ​ 没有葡萄糖就没有意志力。/葡萄糖能逆转消耗引起的大脑变化。 ——以上摘自《第2章 驱动意志力的能量来自哪里？》 ​ 清单越长，失败率越高。/大胆的好决定容易做出，但难以实施。 相互冲突的目标带来的不是行动而是苦恼。 制定计划：月计划优于日计划；（即确定该月整体要完成什么，比每天完成什么效果更好）（实验：对提高学习技能进行实验；一个小组制定日计划，详细到每天何时何地学习什么内容；另一组制定月计划；第三组为对照组，不做计划；结果月计划组在习惯、学习态度以及成绩上都比日计划组好。） 任务清单应该包含“下步行动”，这很重要。 （示例1：不应该包括“处理税务”，而是“打电话给会计”。） （示例2：联系某某研究院。这个太含糊，其实你没有想好下一步做什么？你有他的邮箱/电话号码？决定了是打电话还是写邮件？这其中的细微区别很重要。） 相比已完成的任务，未完成的任务将会占据更多精力，且这个过程往往是无意识的。 ——以上摘自《第3章 任务清单简史，从上帝到凯里》 ​ 做出决策会损耗大量意志力，但如果只是比对，形成偏好，不做出决策，意志力损害相对较小。 当意志力被损耗时，很难继续认真做决定。此时，人们会偏爱风险较小的选择。/做决策会损耗你的意志力，你的意志力一旦耗尽，做决策的能力会下降。因而你会找接口避免或推迟做决策。你会选取做保险最安全的做法，这往往就是保持现状。（事例：同样4个人做假释申请，法官对最后一位表示批准的可能性往往更小，因为如果做出错误的决策会给自己带来坏名声，而随着意志力耗尽则难以认真做出决策，更多的是选择否决，这样其实是推迟做决策，因为后续还是可以选择假释犯人。） 当你有很多要求要考虑，有很多可供选择，你就开始追求完美，从而损耗你的意志力。（示例：淘宝购物） 折中能力是意志力耗尽之后第一个衰退的能力。/决策疲劳一旦出现，人们就容易接受推荐方案。 ——以上摘自《第4章 决策疲劳》 ​ 当人们受到监控时（自己或他人），意志力往往较高。/公开信息比私人信息更有影响力，相对于自己对自己的了解，人们更在意别人对自己的了解。（示例：人们将自己的运动时间/体重公开给朋友圈，督促自己完成目标） ——以上摘自《第5章 钱花到哪儿了？QS知道》 ​ 设置小目标并设法去实现，有助于你实现原本不怎么可能实现的更大目标。/不仅仅要针对目标练习，而是要将练习难度设定得高于目标难度，绝不要低于目标难度，这样你就有余地，你就知道你总能超过目标。 意志力力量≠意志力耐力 / 集中精力改变一个习惯 生活在某个方面训练自制力似乎能提高生活所有方面的自制力。 （事例1：定期运动的人，身体更健康了。但此外，学习成绩也更好了，花钱也更少了；） （示例2：像刮胡子那样的整洁习惯实际上可以提高自制力） 许可效应：做了好事就表现得好像有了做坏事的权利。（事例：今天做了运动，感觉吃更多食物是应有的权利；今天努力工作，感觉放松一下是应有的权利；） ——以上摘自《第6章 意志力可以培养吗？》 ​ 当我们考虑别人时，自制力就会增强。/自制力特别有助于在学习和工作中好好表现，但在饮食和节食中作用最差。 ——以上摘自《第7章深入黑暗之战胜自己》 ​ ​ ​ 附录： 特斯鲁普（Stroop effect）效应：在心理学中指干扰因素对反应时间的影响。例如当测试者被要求说出某个颜色和其覆盖的文字字面意义不符的词语时，被测者往往会反应速度下降，出错率上升。（例如，屏幕显示红色字体的“XXX”，正确答案就是“红色”。但如果屏幕显示的是红色字体的“Green”，那回答起来就不容易。你必须压抑阅读单词“Green”引起的念头，强迫自己确认字体的颜色“红色”。研究表明，在这种情况下，被试者反应比较慢。） ​ 读完本书后，你做了/计划什么改变 不做过多的计划，一次做一件；等这一件完成/养成习惯时，在去做下一个计划 列计划时，避免计划之间相互冲突 常常补充能量，随身携带糖类。/了解自己的极限，疲惫的时候/准备做重要事情时，提前补充能量]]></content>
    </entry>

    
  
  
</search>
